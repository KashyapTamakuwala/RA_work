File_id,Title,Paper_text,Status
316.pdf.json,SEMI-SUPERVISED KNOWLEDGE TRANSFER FOR DEEP LEARNING FROM PRIVATE TRAINING DATA,"some machine learning applications with great benefits are enabled only through the analysis of sensitive data, such as users’ personal contacts, private photographs or correspondence, or even medical records or genetic sequences (alipanahi , 2015; kannan , 2016; kononenko, 2001; sweeney, 1997). ideally, in those cases, the learning algorithms would protect the privacy of users’ training data, e.g., by guaranteeing that the output model generalizes away from the specifics of any individual user. unfortunately, established machine learning algorithms make no such guarantee; indeed, though state-of-the-art algorithms generalize well to the test set, they continue to overfit on specific training examples in the sense that some of these examples are implicitly memorized.
recent attacks exploiting this implicit memorization in machine learning have demonstrated that private, sensitive training data can be recovered from models. such attacks can proceed directly, by analyzing internal model parameters, but also indirectly, by repeatedly querying opaque models to gather data for the attack’s analysis. for example, fredrikson  (2015) used hill-climbing on the output probabilities of a computer-vision classifier to reveal individual faces from the training data.
∗work done while the author was at google. †work done both at google brain and at openai.
because of those demonstrations—and because privacy guarantees must apply to worst-case outliers, not only the average—any strategy for protecting the privacy of training data should prudently assume that attackers have unfettered access to internal model parameters.
to protect the privacy of training data, this paper improves upon a specific, structured application of the techniques of knowledge aggregation and transfer (breiman, 1994), previously explored by nissim  (2007), pathak  (2010), and particularly hamm  (2016). in this strategy, first, an ensemble (dietterich, 2000) of teacher models is trained on disjoint subsets of the sensitive data. then, using auxiliary, unlabeled non-sensitive data, a student model is trained on the aggregate output of the ensemble, such that the student learns to accurately mimic the ensemble. intuitively, this strategy ensures that the student does not depend on the details of any single sensitive training data point (e.g., of any single user), and, thereby, the privacy of the training data is protected even if attackers can observe the student’s internal model parameters.
this paper shows how this strategy’s privacy guarantees can be strengthened by restricting student training to a limited number of teacher votes, and by revealing only the topmost vote after carefully adding random noise. we call this strengthened strategy pate, for private aggregation of teacher ensembles. furthermore, we introduce an improved privacy analysis that makes the strategy generally applicable to machine learning algorithms with high utility and meaningful privacy guarantees—in particular, when combined with semi-supervised learning.
to establish strong privacy guarantees, it is important to limit the student’s access to its teachers, so that the student’s exposure to teachers’ knowledge can be meaningfully quantified and bounded. fortunately, there are many techniques for speeding up knowledge transfer that can reduce the rate of student/teacher consultation during learning. we describe several techniques in this paper, the most effective of which makes use of generative adversarial networks (gans) (goodfellow , 2014) applied to semi-supervised learning, using the implementation proposed by salimans  (2016). for clarity, we use the term pate-g when our approach is combined with generative, semisupervised methods. like all semi-supervised learning methods, pate-g assumes the student has access to additional, unlabeled data, which, in this context, must be public or non-sensitive. this assumption should not greatly restrict our method’s applicability: even when learning on sensitive data, a non-overlapping, unlabeled set of data often exists, from which semi-supervised methods can extract distribution priors. for instance, public datasets exist for text and images, and for medical data.
it seems intuitive, or even obvious, that a student machine learning model will provide good privacy when trained without access to sensitive training data, apart from a few, noisy votes from a teacher quorum. however, intuition is not sufficient because privacy properties can be surprisingly hard to reason about; for example, even a single data item can greatly impact machine learning models trained on a large corpus (chaudhuri , 2011). therefore, to limit the effect of any single sensitive data item on the student’s learning, precisely and formally, we apply the well-established, rigorous standard of differential privacy (dwork & roth, 2014). like all differentially private algorithms, our learning strategy carefully adds noise, so that the privacy impact of each data item can be analyzed and bounded. in particular, we dynamically analyze the sensitivity of the teachers’ noisy votes; for this purpose, we use the state-of-the-art moments accountant technique from abadi  (2016), which tightens the privacy bound when the topmost vote has a large quorum. as a result, for mnist and similar benchmark learning tasks, our methods allow students to provide excellent utility, while our analysis provides meaningful worst-case guarantees. in particular, we can bound the metric for privacy loss (the differential-privacy ε) to a range similar to that of existing, real-world privacyprotection mechanisms, such as google’s rappor (erlingsson , 2014).
finally, it is an important advantage that our learning strategy and our privacy analysis do not depend on the details of the machine learning techniques used to train either the teachers or their student. therefore, the techniques in this paper apply equally well for deep learning methods, or any such learning methods with large numbers of parameters, as they do for shallow, simple techniques. in comparison, hamm  (2016) guarantee privacy only conditionally, for a restricted class of student classifiers—in effect, limiting applicability to logistic regression with convex loss. also, unlike the methods of abadi  (2016), which represent the state-of-the-art in differentiallyprivate deep learning, our techniques make no assumptions about details such as batch selection, the loss function, or the choice of the optimization algorithm. even so, as we show in experiments on
mnist and svhn, our techniques provide a privacy/utility tradeoff that equals or improves upon bespoke learning methods such as those of abadi  (2016).
section 5 further discusses the related work. building on this related work, our contributions are as follows:
• we demonstrate a general machine learning strategy, the pate approach, that provides differential privacy for training data in a “black-box” manner, i.e., independent of the learning algorithm, as demonstrated by section 4 and appendix c.
• we improve upon the strategy outlined in hamm  (2016) for learning machine models that protect training data privacy. in particular, our student only accesses the teachers’ top vote and the model does not need to be trained with a restricted class of convex losses.
• we explore four different approaches for reducing the student’s dependence on its teachers, and show how the application of gans to semi-supervised learning of salimans  (2016) can greatly reduce the privacy loss by radically reducing the need for supervision.
• we present a new application of the moments accountant technique from abadi  (2016) for improving the differential-privacy analysis of knowledge transfer, which allows the training of students with meaningful privacy bounds.
• we evaluate our framework on mnist and svhn, allowing for a comparison of our results with previous differentially private machine learning methods. our classifiers achieve an (ε, δ) differential-privacy bound of (2.04, 10−5) for mnist and (8.19, 10−6) for svhn, respectively with accuracy of 98.00% and 90.66%. in comparison, for mnist, abadi  (2016) obtain a looser (8, 10−5) privacy bound and 97% accuracy. for svhn, shokri & shmatikov (2015) report approx. 92% accuracy with ε > 2 per each of 300,000 model parameters, naively making the total ε > 600,000, which guarantees no meaningful privacy.
• finally, we show that the pate approach can be successfully applied to other model structures and to datasets with different characteristics. in particular, in appendix c pate protects the privacy of medical data used to train a model based on random forests.
our results are encouraging, and highlight the benefits of combining a learning strategy based on semi-supervised knowledge transfer with a precise, data-dependent privacy analysis. however, the most appealing aspect of this work is probably that its guarantees can be compelling to both an expert and a non-expert audience. in combination, our techniques simultaneously provide both an intuitive and a rigorous guarantee of training data privacy, without sacrificing the utility of the targeted model. this gives hope that users will increasingly be able to confidently and safely benefit from machine learning models built from their sensitive data.in this section, we introduce the specifics of the pate approach, which is illustrated in figure 1. we describe how the data is partitioned to train an ensemble of teachers, and how the predictions made by this ensemble are noisily aggregated. in addition, we discuss how gans can be used in training the student, and distinguish pate-g variants that improve our approach using generative, semi-supervised methods.data partitioning and teachers: instead of training a single model to solve the task associated with dataset (x,y ), where x denotes the set of inputs, and y the set of labels, we partition the data in n disjoint sets (xn, yn) and train a model separately on each set. as evaluated in section 4.1, assuming that n is not too large with respect to the dataset size and task complexity, we obtain n classifiers fi called teachers. we then deploy them as an ensemble making predictions on unseen inputs x by querying each teacher for a prediction fi(x) and aggregating these into a single prediction.
aggregation: the privacy guarantees of this teacher ensemble stems from its aggregation. let m be the number of classes in our task. the label count for a given class j ∈ [m] and an input ~x is the number of teachers that assigned class j to input ~x: nj(~x) = |{i : i ∈ [n], fi(~x) = j}|. if we simply apply plurality—use the label with the largest count—the ensemble’s decision may depend on a single teacher’s vote. indeed, when two labels have a vote count differing by at most one, there is a tie: the aggregated output changes if one teacher makes a different prediction. we add random noise to the vote counts nj to introduce ambiguity:
f(x) = argmax j
{ nj(~x) + lap ( 1
γ
)} (1)
in this equation, γ is a privacy parameter and lap(b) the laplacian distribution with location 0 and scale b. the parameter γ influences the privacy guarantee we can prove. intuitively, a large γ leads to a strong privacy guarantee, but can degrade the accuracy of the labels, as the noisy maximum f above can differ from the true plurality.
while we could use an f such as above to make predictions, the noise required would increase as we make more predictions, making the model useless after a bounded number of queries. furthermore, privacy guarantees do not hold when an adversary has access to the model parameters. indeed, as each teacher fi was trained without taking into account privacy, it is conceivable that they have sufficient capacity to retain details of the training data. to address these limitations, we train another model, the student, using a fixed number of labels predicted by the teacher ensemble.we train a student on nonsensitive and unlabeled data, some of which we label using the aggregation mechanism. this student model is the one deployed, in lieu of the teacher ensemble, so as to fix the privacy loss to a value that does not grow with the number of user queries made to the student model. indeed, the privacy loss is now determined by the number of queries made to the teacher ensemble during student training and does not increase as end-users query the deployed student model. thus, the privacy of users who contributed to the original training dataset is preserved even if the student’s architecture and parameters are public or reverse-engineered by an adversary.
we considered several techniques to trade-off the student model’s quality with the number of labels it needs to access: distillation, active learning, semi-supervised learning (see appendix b). here, we only describe the most successful one, used in pate-g: semi-supervised learning with gans.
training the student with gans: the gan framework involves two machine learning models, a generator and a discriminator. they are trained in a competing fashion, in what can be viewed as a two-player game (goodfellow , 2014). the generator produces samples from the data distribution by transforming vectors sampled from a gaussian distribution. the discriminator is trained to distinguish samples artificially produced by the generator from samples part of the real data distribution. models are trained via simultaneous gradient descent steps on both players’ costs. in practice, these dynamics are often difficult to control when the strategy set is non-convex (e.g., a dnn). in their application of gans to semi-supervised learning, salimans  (2016) made the following modifications. the discriminator is extended from a binary classifier (data vs. generator sample) to a multi-class classifier (one of k classes of data samples, plus a class for generated samples). this classifier is then trained to classify labeled real samples in the correct class, unlabeled real samples in any of the k classes, and the generated samples in the additional class.
although no formal results currently explain why yet, the technique was empirically demonstrated to greatly improve semi-supervised learning of classifiers on several datasets, especially when the classifier is trained with feature matching loss (salimans , 2016).
training the student in a semi-supervised fashion makes better use of the entire data available to the student, while still only labeling a subset of it. unlabeled inputs are used in unsupervised learning to estimate a good prior for the distribution. labeled inputs are then used for supervised learning.we now analyze the differential privacy guarantees of our pate approach. namely, we keep track of the privacy budget throughout the student’s training using the moments accountant (abadi , 2016). when teachers reach a strong quorum, this allows us to bound privacy costs more strictly.differential privacy (dwork , 2006b; dwork, 2011) has established itself as a strong standard. it provides privacy guarantees for algorithms analyzing databases, which in our case is a machine learning training algorithm processing a training dataset. differential privacy is defined using pairs of adjacent databases: in the present work, these are datasets that only differ by one training example. recall the following variant of differential privacy introduced in dwork  (2006a). definition 1. a randomized mechanismm with domain d and ranger satisfies (ε, δ)-differential privacy if for any two adjacent inputs d, d′ ∈ d and for any subset of outputs s ⊆ r it holds that:
pr[m(d) ∈ s] ≤ eε pr[m(d′) ∈ s] + δ. (2)
it will be useful to define the privacy loss and the privacy loss random variable. they capture the differences in the probability distribution resulting from runningm on d and d′. definition 2. letm : d → r be a randomized mechanism and d, d′ a pair of adjacent databases. let aux denote an auxiliary input. for an outcome o ∈ r, the privacy loss at o is defined as:
c(o;m,aux, d, d′) ∆= log pr[m(aux, d) = o] pr[m(aux, d′) = o] . (3)
the privacy loss random variable c(m,aux, d, d′) is defined as c(m(d);m,aux, d, d′), i.e. the random variable defined by evaluating the privacy loss at an outcome sampled fromm(d).
a natural way to bound our approach’s privacy loss is to first bound the privacy cost of each label queried by the student, and then use the strong composition theorem (dwork , 2010) to derive the total cost of training the student. for neighboring databases d, d′, each teacher gets the same training data partition (that is, the same for the teacher with d and with d′, not the same across teachers), with the exception of one teacher whose corresponding training data partition differs. therefore, the label counts nj(~x) for any example ~x, on d and d′ differ by at most 1 in at most two locations. in the next subsection, we show that this yields loose guarantees.to better keep track of the privacy cost, we use recent advances in privacy cost accounting. the moments accountant was introduced by abadi  (2016), building on previous work (bun & steinke, 2016; dwork & rothblum, 2016; mironov, 2016). definition 3. letm : d → r be a randomized mechanism and d, d′ a pair of adjacent databases. let aux denote an auxiliary input. the moments accountant is defined as:
αm(λ) ∆ = max aux,d,d′ αm(λ;aux, d, d′) (4)
where αm(λ;aux, d, d′) ∆ = loge[exp(λc(m,aux, d, d′))] is the moment generating function of the privacy loss random variable.
the following properties of the moments accountant are proved in abadi  (2016).
theorem 1. 1. [composability] suppose that a mechanism m consists of a sequence of adaptive mechanismsm1, . . . ,mk wheremi : ∏i−1 j=1rj × d → ri. then, for any output sequence o1, . . . , ok−1 and any λ
αm(λ; d, d ′) = k∑ i=1 αmi(λ; o1, . . . , oi−1, d, d ′) ,
where αm is conditioned onmi’s output being oi for i < k. 2. [tail bound] for any ε > 0, the mechanismm is (ε, δ)-differentially private for
δ = min λ
exp(αm(λ)− λε) .
we write down two important properties of the aggregation mechanism from section 2. the first property is proved in dwork & roth (2014), and the second follows from bun & steinke (2016).
theorem 2. suppose that on neighboring databases d, d′, the label counts nj differ by at most 1 in each coordinate. let m be the mechanism that reports argmaxj { nj + lap( 1 γ ) }
. then m satisfies (2γ, 0)-differential privacy. moreover, for any l, aux, d and d′,
α(l;aux, d, d′) ≤ 2γ2l(l + 1) (5)
at each step, we use the aggregation mechanism with noise lap( 1γ ) which is (2γ, 0)-dp. thus over t steps, we get (4tγ2 + 2γ √ 2t ln 1δ , δ)-differential privacy. this can be rather large: plugging in values that correspond to our svhn result, γ = 0.05, t = 1000, δ = 1e−6 gives us ε ≈ 26 or alternatively plugging in values that correspond to our mnist result, γ = 0.05, t = 100, δ = 1e−5 gives us ε ≈ 5.80.our data-dependent privacy analysis takes advantage of the fact that when the quorum among the teachers is very strong, the majority outcome has overwhelming likelihood, in which case the privacy cost is small whenever this outcome occurs. the moments accountant allows us analyze the composition of such mechanisms in a unified framework.
the following theorem, proved in appendix a, provides a data-dependent bound on the moments of any differentially private mechanism where some specific outcome is very likely.
theorem 3. letm be (2γ, 0)-differentially private and q ≥ pr[m(d) 6= o∗] for some outcome o∗. let l, γ ≥ 0 and q < e γ−1 e4γ−1 . then for any aux and any neighbor d ′ of d,m satisfies
α(l;aux, d, d′) ≤ log((1− q) ( 1− q 1− e2γq )l + q exp(2γl)).
to upper bound q for our aggregation mechanism, we use the following simple lemma, also proved in appendix a.
lemma 4. let n be the label score vector for a database d with nj∗ ≥ nj for all j. then
pr[m(d) 6= j∗] ≤ ∑ j 6=j∗ 2 + γ(nj∗ − nj) 4 exp(γ(nj∗ − nj))
this allows us to upper bound q for a specific score vector n, and hence bound specific moments. we take the smaller of the bounds we get from theorems 2 and 3. we compute these moments for a few values of λ (integers up to 8). theorem 1 allows us to add these bounds over successive steps, and derive an (ε, δ) guarantee from the final α. interested readers are referred to the script that we used to empirically compute these bounds, which is released along with our code: https://github. com/tensorflow/models/tree/master/differential_privacy/multiple_teachers
since the privacy moments are themselves now data dependent, the final ε is itself data-dependent and should not be revealed. to get around this, we bound the smooth sensitivity (nissim , 2007) of the moments and add noise proportional to it to the moments themselves. this gives us a differentially private estimate of the privacy cost. our evaluation in section 4 ignores this overhead and reports the un-noised values of ε. indeed, in our experiments on mnist and svhn, the scale of the noise one needs to add to the released ε is smaller than 0.5 and 1.0 respectively.
how does the number of teachers affect the privacy cost? recall that the student uses a noisy label computed in (1) which has a parameter γ. to ensure that the noisy label is likely to be the correct one, the noise scale 1γ should be small compared to the the additive gap between the two largest vales of nj . while the exact dependence of γ on the privacy cost in theorem 3 is subtle, as a general principle, a smaller γ leads to a smaller privacy cost. thus, a larger gap translates to a smaller privacy cost. since the gap itself increases with the number of teachers, having more teachers would lower the privacy cost. this is true up to a point. with n teachers, each teacher only trains on a 1n fraction of the training data. for large enough n, each teachers will have too little training data to be accurate.
to conclude, we note that our analysis is rather conservative in that it pessimistically assumes that, even if just one example in the training set for one teacher changes, the classifier produced by that teacher may change arbitrarily. one advantage of our approach, which enables its wide applicability, is that our analysis does not require any assumptions about the workings of the teachers. nevertheless, we expect that stronger privacy guarantees may perhaps be established in specific settings—when assumptions can be made on the learning algorithm used to train the teachers.in our evaluation of pate and its generative variant pate-g, we first train a teacher ensemble for each dataset. the trade-off between the accuracy and privacy of labels predicted by the ensemble is greatly dependent on the number of teachers in the ensemble: being able to train a large set of teachers is essential to support the injection of noise yielding strong privacy guarantees while having a limited impact on accuracy. second, we minimize the privacy budget spent on learning the student by training it with as few queries to the ensemble as possible.
our experiments use mnist and the extended svhn datasets. our mnist model stacks two convolutional layers with max-pooling and one fully connected layer with relus. when trained on the entire dataset, the non-private model has a 99.18% test accuracy. for svhn, we add two hidden layers.1 the non-private model achieves a 92.8% test accuracy, which is shy of the state-of-the-art. however, we are primarily interested in comparing the private student’s accuracy with the one of a non-private model trained on the entire dataset, for different privacy guarantees. the source code for reproducing the results in this section is available on github.2as mentioned above, compensating the noise introduced by the laplacian mechanism presented in equation 1 requires large ensembles. we evaluate the extent to which the two datasets considered can be partitioned with a reasonable impact on the performance of individual teachers. specifically, we show that for mnist and svhn, we are able to train ensembles of 250 teachers. their aggregated predictions are accurate despite the injection of large amounts of random noise to ensure privacy. the aggregation mechanism output has an accuracy of 93.18% for mnist and 87.79% for svhn, when evaluated on their respective test sets, while each query has a low privacy budget of ε = 0.05.
prediction accuracy: all other things being equal, the number n of teachers is limited by a tradeoff between the classification task’s complexity and the available data. we train n teachers by partitioning the training data n-way. larger values of n lead to larger absolute gaps, hence potentially allowing for a larger noise level and stronger privacy guarantees. at the same time, a larger n implies a smaller training dataset for each teacher, potentially reducing the teacher accuracy. we empirically find appropriate values of n for the mnist and svhn datasets by measuring the test the model is adapted from https://www.tensorflow.org/tutorials/deep_cnn 2 https://github.com/tensorflow/models/tree/master/differential_privacy/multiple_teachers
set accuracy of each teacher trained on one of the n partitions of the training data. we find that even for n = 250, the average test accuracy of individual teachers is 83.86% for mnist and 83.18% for svhn. the larger size of svhn compensates its increased task complexity.
prediction confidence: as outlined in section 3, the privacy of predictions made by an ensemble of teachers intuitively requires that a quorum of teachers generalizing well agree on identical labels. this observation is reflected by our data-dependent privacy analysis, which provides stricter privacy bounds when the quorum is strong. we study the disparity of labels assigned by teachers. in other words, we count the number of votes for each possible label, and measure the difference in votes between the most popular label and the second most popular label, i.e., the gap. if the gap is small, introducing noise during aggregation might change the label assigned from the first to the second. figure 3 shows the gap normalized by the total number of teachers n. as n increases, the gap remains larger than 60% of the teachers, allowing for aggregation mechanisms to output the correct label in the presence of noise.
noisy aggregation: for mnist and svhn, we consider three ensembles of teachers with varying number of teachers n ∈ {10, 100, 250}. for each of them, we perturb the vote counts with laplacian noise of inversed scale γ ranging between 0.01 and 1. this choice is justified below in section 4.2. we report in figure 2 the accuracy of test set labels inferred by the noisy aggregation mechanism for these values of ε. notice that the number of teachers needs to be large to compensate for the impact of noise injection on the accuracy.the noisy aggregation mechanism labels the student’s unlabeled training set in a privacy-preserving fashion. to reduce the privacy budget spent on student training, we are interested in making as few label queries to the teachers as possible. we therefore use the semi-supervised training approach described previously. our mnist and svhn students with (ε, δ) differential privacy of (2.04, 10−5) and (8.19, 10−6) achieve accuracies of 98.00% and 90.66%. these results improve the differential privacy state-of-the-art for these datasets. abadi  (2016) previously obtained 97% accuracy with a (8, 10−5) bound on mnist, starting from an inferior baseline model without privacy. shokri & shmatikov (2015) reported about 92% accuracy on svhn with ε > 2 per model parameter and a model with over 300,000 parameters. naively, this corresponds to a total ε > 600,000.
we apply semi-supervised learning with gans to our problem using the following setup for each dataset. in the case of mnist, the student has access to 9,000 samples, among which a subset of either 100, 500, or 1,000 samples are labeled using the noisy aggregation mechanism discussed in section 2.1. its performance is evaluated on the 1,000 remaining samples of the test set. note that this may increase the variance of our test set accuracy measurements, when compared to those computed over the entire test data. for the mnist dataset, we randomly shuffle the test set to ensure that the different classes are balanced when selecting the (small) subset labeled to train the student. for svhn, the student has access to 10,000 training inputs, among which it labels 500 or 1,000 samples using the noisy aggregation mechanism. its performance is evaluated on the remaining 16,032 samples. for both datasets, the ensemble is made up of 250 teachers. we use laplacian scale of 20 to guarantee an individual query privacy bound of ε = 0.05. these parameter choices are motivated by the results from section 4.1.
in figure 4, we report the values of the (ε, δ) differential privacy guarantees provided and the corresponding student accuracy, as well as the number of queries made by each student. the mnist student is able to learn a 98% accurate model, which is shy of 1% when compared to the accuracy of a model learned with the entire training set, with only 100 label queries. this results in a strict differentially private bound of ε = 2.04 for a failure probability fixed at 10−5. the svhn student achieves 90.66% accuracy, which is also comparable to the 92.80% accuracy of one teacher learned with the entire training set. the corresponding privacy bound is ε = 8.19, which is higher than for the mnist dataset, likely because of the larger number of queries made to the aggregation mechanism.
we observe that our private student outperforms the aggregation’s output in terms of accuracy, with or without the injection of laplacian noise. while this shows the power of semi-supervised learning, the student may not learn as well on different kinds of data (e.g., medical data), where categories are not explicitly designed by humans to be salient in the input space. encouragingly, as appendix c illustrates, the pate approach can be successfully applied to at least some examples of such data.several privacy definitions are found in the literature. for instance, k-anonymity requires information about an individual to be indistinguishable from at least k − 1 other individuals in the dataset (l. sweeney, 2002). however, its lack of randomization gives rise to caveats (dwork & roth, 2014), and attackers can infer properties of the dataset (aggarwal, 2005). an alternative definition, differential privacy, established itself as a rigorous standard for providing privacy guarantees (dwork , 2006b). in contrast to k-anonymity, differential privacy is a property of the randomized algorithm and not the dataset itself.
a variety of approaches and mechanisms can guarantee differential privacy. erlingsson  (2014) showed that randomized response, introduced by warner (1965), can protect crowd-sourced data collected from software users to compute statistics about user behaviors. attempts to provide differential privacy for machine learning models led to a series of efforts on shallow machine learning models, including work by bassily  (2014); chaudhuri & monteleoni (2009); pathak  (2011); song  (2013), and wainwright  (2012).
a privacy-preserving distributed sgd algorithm was introduced by shokri & shmatikov (2015). it applies to non-convex models. however, its privacy bounds are given per-parameter, and the large number of parameters prevents the technique from providing a meaningful privacy guarantee. abadi  (2016) provided stricter bounds on the privacy loss induced by a noisy sgd by introducing the moments accountant. in comparison with these efforts, our work increases the accuracy of a private mnist model from 97% to 98% while improving the privacy bound ε from 8 to 1.9. furthermore, the pate approach is independent of the learning algorithm, unlike this previous work. support for a wide range of architecture and training algorithms allows us to obtain good privacy bounds on an accurate and private svhn model. however, this comes at the cost of assuming that nonprivate unlabeled data is available, an assumption that is not shared by (abadi , 2016; shokri & shmatikov, 2015).
pathak  (2010) first discussed secure multi-party aggregation of locally trained classifiers for a global classifier hosted by a trusted third-party. hamm  (2016) proposed the use of knowledge transfer between a collection of models trained on individual devices into a single model guaranteeing differential privacy. their work studied linear student models with convex and continuously differentiable losses, bounded and c-lipschitz derivatives, and bounded features. the pate approach of this paper is not constrained to such applications, but is more generally applicable.
previous work also studied semi-supervised knowledge transfer from private models. for instance, jagannathan  (2013) learned privacy-preserving random forests. a key difference is that their approach is tailored to decision trees. pate works well for the specific case of decision trees, as demonstrated in appendix c, and is also applicable to other machine learning algorithms, including more complex ones. another key difference is that jagannathan  (2013) modified the classic model of a decision tree to include the laplacian mechanism. thus, the privacy guarantee does not come from the disjoint sets of training data analyzed by different decision trees in the random forest, but rather from the modified architecture. in contrast, partitioning is essential to the privacy guarantees of the pate approach.to protect the privacy of sensitive training data, this paper has advanced a learning strategy and a corresponding privacy analysis. the pate approach is based on knowledge aggregation and transfer from “teacher” models, trained on disjoint data, to a “student” model whose attributes may be made public. in combination, the paper’s techniques demonstrably achieve excellent utility on the mnist and svhn benchmark tasks, while simultaneously providing a formal, state-of-the-art bound on users’ privacy loss. while our results are not without limits—e.g., they require disjoint training data for a large number of teachers (whose number is likely to increase for tasks with many output classes)—they are encouraging, and highlight the advantages of combining semi-supervised learning with precise, data-dependent privacy analysis, which will hopefully trigger further work. in particular, such future work may further investigate whether or not our semi-supervised approach will also reduce teacher queries for tasks other than mnist and svhn, for example when the discrete output categories are not as distinctly defined by the salient input space features.
a key advantage is that this paper’s techniques establish a precise guarantee of training data privacy in a manner that is both intuitive and rigorous. therefore, they can be appealing, and easily explained, to both an expert and non-expert audience. however, perhaps equally compelling are the techniques’ wide applicability. both our learning approach and our analysis methods are “blackbox,” i.e., independent of the learning algorithm for either teachers or students, and therefore apply, in general, to non-convex, deep learning, and other learning methods. also, because our techniques do not constrain the selection or partitioning of training data, they apply when training data is naturally and non-randomly partitioned—e.g., because of privacy, regulatory, or competitive concerns— or when each teacher is trained in isolation, with a different method. we look forward to such further applications, for example on rnns and other sequence-based models.nicolas papernot is supported by a google phd fellowship in security. the authors would like to thank ilya mironov and li zhang for insightful discussions about early drafts of this document.we provide missing proofs from section 3. theorem 3. letm be (2γ, 0)-differentially private and q ≥ pr[m(d) 6= o∗] for some outcome o∗. let l, γ ≥ 0 and q < e γ−1 e4γ−1 . then for any aux and any neighbor d ′ of d,m satisfies
α(l;aux, d, d′) ≤ log((1− q) ( 1− q 1− e2γq )l + q exp(2γl)).
proof. since m is 2γ-differentially private, for every outcome o, pr[m(d)=o]pr[m(d′)=o] ≤ exp(2γ). let q′ = pr[m(d) 6= o∗]. then pr[m(d′) 6= o∗] ≤ exp(2γ)q′. thus exp(α(l;aux, d, d′)) = ∑ o pr[m(d) = o] ( pr[m(d) = o] pr[m(d′) = o]
)l = pr[m(d) = o∗] ( pr[m(d) = o∗] pr[m(d′) = o∗] )l + ∑ o6=o∗ pr[m(d) = o] ( pr[m(d) = o] pr[m(d′) = o]
)l ≤ (1− q′) ( 1− q′ 1− e2γq′ )l + ∑ o6=o∗ pr[m(d) = o](e2γ)l
≤ (1− q′) ( 1− q′ 1− e2γq′ )l + q′e2γl.
now consider the function
f(z) = (1− z) ( 1− z 1− e2γz )l + ze2γl.
we next argue that this function is non-decreasing in (0, e 2γ−1 e4γ−1 ) under the conditions of the lemma. towards this goal, define
g(z, w) = (1− z) ( 1− w 1− e2γw )l + ze2γl,
and observe that f(z) = g(z, z). we can easily verify by differentiation that g(z, w) is increasing individually in z and in w in the range of interest. this implies that f(q′) ≤ f(q) completing the proof.
lemma 4. let n be the label score vector for a database d with nj∗ ≥ nj for all j. then
pr[m(d) 6= j∗] ≤ ∑ j 6=j∗ 2 + γ(nj∗ − nj) 4 exp(γ(nj∗ − nj))
proof. the probability that nj∗ + lap( 1γ ) < nj + lap( 1 γ ) is equal to the probability that the sum of two independent lap(1) random variables exceeds γ(nj∗ − nj). the sum of two independent lap(1) variables has the same distribution as the difference of twogamma(2, 1) random variables. recalling that thegamma(2, 1) distribution has pdf xe−x, we can compute the pdf of the difference via convolution as∫ ∞
y=0
(y + |x|)e−y−|x|ye−y dy = 1 e|x| ∫ ∞ y=0 (y2 + y|x|)e−2y dy = 1 + |x| 4e|x| .
the probability mass in the tail can then be computed by integration as 2+γ(nj∗−nj)4 exp(γ(nj∗−nj) . taking a union bound over the various candidate j’s gives the claimed bound.in this appendix, we describe approaches that were considered to reduce the number of queries made to the teacher ensemble by the student during its training. as pointed out in sections 3 and 4, this effort is motivated by the direct impact of querying on the total privacy cost associated with student training. the first approach is based on distillation, a technique used for knowledge transfer and model compression (hinton , 2015). the three other techniques considered were proposed in the context of active learning, with the intent of identifying training examples most useful for learning. in sections 2 and 4, we described semi-supervised learning, which yielded the best results. the student models in this appendix differ from those in sections 2 and 4, which were trained using gans. in contrast, all students in this appendix were learned in a fully supervised fashion from a subset of public, labeled examples. thus, the learning goal was to identify the subset of labels yielding the best learning performance.
b.1 training students using distillation
distillation is a knowledge transfer technique introduced as a means of compressing large models into smaller ones, while retaining their accuracy (bucilua , 2006; hinton , 2015). this is for instance useful to train models in data centers before deploying compressed variants in phones. the transfer is accomplished by training the smaller model on data that is labeled with probability vectors produced by the first model, which encode the knowledge extracted from training data. distillation is parameterized by a temperature parameter t , which controls the smoothness of probabilities output by the larger model: when produced at small temperatures, the vectors are discrete, whereas at high temperature, all classes are assigned non-negligible values. distillation is a natural candidate to compress the knowledge acquired by the ensemble of teachers, acting as the large model, into a student, which is much smaller with n times less trainable parameters compared to the n teachers.
to evaluate the applicability of distillation, we consider the ensemble of n = 50 teachers for svhn. in this experiment, we do not add noise to the vote counts when aggregating the teacher predictions. we compare the accuracy of three student models: the first is a baseline trained with labels obtained by plurality, the second and third are trained with distillation at t ∈ {1, 5}. we use the first 10,000 samples from the test set as unlabeled data. figure 5 reports the accuracy of the student model on the last 16,032 samples from the test set, which were not accessible to the model during training. it is plotted with respect to the number of samples used to train the student (and hence the number of queries made to the teacher ensemble). although applying distillation yields classifiers that perform more accurately, the increase in accuracy is too limited to justify the increased privacy cost of revealing the entire probability vector output by the ensemble instead of simply the class assigned the largest number of votes. thus, we turn to an investigation of active learning.
b.2 active learning of the student
active learning is a class of techniques that aims to identify and prioritize points in the student’s training set that have a high potential to contribute to learning (angluin, 1988; baum, 1991). if the label of an input in the student’s training set can be predicted confidently from what we have learned so far by querying the teachers, it is intuitive that querying it is not worth the privacy budget spent. in our experiments, we made several attempts before converging to a simpler final formulation.
siamese networks: our first attempt was to train a pair of siamese networks, introduced by bromley  (1993) in the context of one-shot learning and later improved by koch (2015). the siamese networks take two images as input and return 1 if the images are equal and 0 otherwise. they are two identical networks trained with shared parameters to force them to produce similar representations of the inputs, which are then compared using a distance metric to determine if the images are identical or not. once the siamese models are trained, we feed them a pair of images where the first is unlabeled and the second labeled. if the unlabeled image is confidently matched with a known labeled image, we can infer the class of the unknown image from the labeled image. in our experiments, the siamese networks were able to say whether two images are identical or not, but did not generalize well: two images of the same class did not receive sufficiently confident matches. we also tried a variant of this approach where we trained the siamese networks to output 1 when the two
images are of the same class and 0 otherwise, but the learning task proved too complicated to be an effective means for reducing the number of queries made to teachers.
collection of binary experts: our second attempt was to train a collection of binary experts, one per class. an expert for class j is trained to output 1 if the sample is in class j and 0 otherwise. we first trained the binary experts by making an initial batch of queries to the teachers. using the experts, we then selected available unlabeled student training points that had a candidate label score below 0.9 and at least 4 other experts assigning a score above 0.1. this gave us about 500 unconfident points for 1700 initial label queries. after labeling these unconfident points using the ensemble of teachers, we trained the student. using binary experts improved the student’s accuracy when compared to the student trained on arbitrary data with the same number of teacher queries. the absolute increases in accuracy were however too limited—between 1.5% and 2.5%.
identifying unconfident points using the student: this last attempt was the simplest yet the most effective. instead of using binary experts to identify student training points that should be labeled by the teachers, we used the student itself. we asked the student to make predictions on each unlabeled training point available. we then sorted these samples by increasing values of the maximum probability assigned to a class for each sample. we queried the teachers to label these unconfident inputs first and trained the student again on this larger labeled training set. this improved the accuracy of the student when compared to the student trained on arbitrary data. for the same number of teacher queries, the absolute increases in accuracy of the student trained on unconfident inputs first when compared to the student trained on arbitrary data were in the order of 4%− 10%.in order to further demonstrate the general applicability of our approach, we performed experiments on two additional datasets. while our experiments on mnist and svhn in section 4 used convolutional neural networks and gans, here we use random forests to train our teacher and student models for both of the datasets. our new results on these datasets show that, despite the differing data types and architectures, we are able to provide meaningful privacy guarantees.
uci adult dataset: the uci adult dataset is made up of census data, and the task is to predict when individuals make over $50k per year. each input consists of 13 features (which include the age, workplace, education, occupation—see the uci website for a full list3). the only pre-processing we apply to these features is to map all categorical features to numerical values by assigning an integer value to each possible category. the model is a random forest provided by the scikit-learn python package. when training both our teachers and student, we keep all the default parameter values, except for the number of estimators, which we set to 100. the data is split between a training set of 32,562 examples, and a test set of 16,282 inputs.
uci diabetes dataset: the uci diabetes dataset includes de-identified records of diabetic patients and corresponding hospital outcomes, which we use to predict whether diabetic patients were readmitted less than 30 days after their hospital release. to the best of our knowledge, no particular classification task is considered to be a standard benchmark for this dataset. even so, it is valuable to consider whether our approach is applicable to the likely classification tasks, such as readmission, since this dataset is collected in a medical environment—a setting where privacy concerns arise frequently. we select a subset of 18 input features from the 55 available in the dataset (to avoid features with missing values) and form a dataset balanced between the two output classes (see the uci website for more details4). in class 0, we include all patients that were readmitted in a 30-day window, while class 1 includes all patients that were readmitted after 30 days or never readmitted at all. our balanced dataset contains 34,104 training samples and 12,702 evaluation samples. we use a random forest model identical to the one described above in the presentation of the adult dataset.
experimental results: we apply our approach described in section 2. for both datasets, we train ensembles of n = 250 random forests on partitions of the training data. we then use the noisy aggregation mechanism, where vote counts are perturbed with laplacian noise of scale 0.05 to privately label the first 500 test set inputs. we train the student random forest on these 500 test set inputs and evaluate it on the last 11,282 test set inputs for the adult dataset, and 6,352 test set inputs for the diabetes dataset. these numbers deliberately leave out some of the test set, which allowed us to observe how the student performance-privacy trade-off was impacted by varying the number of private labels, as well as the laplacian scale used when computing these labels.
for the adult dataset, we find that our student model achieves an 83% accuracy for an (ε, δ) = (2.66, 10−5) differential privacy bound. our non-private model on the dataset achieves 85% accuracy, which is comparable to the state-of-the-art accuracy of 86% on this dataset (poulos & valle, 2016). for the diabetes dataset, we find that our privacy-preserving student model achieves a 93.94% accuracy for a (ε, δ) = (1.44, 10−5) differential privacy bound. our non-private model on the dataset achieves 93.81% accuracy.  https://archive.ics.uci.edu/ml/datasets/adult 4 https://archive.ics.uci.edu/ml/datasets/diabetes+130-us+hospitals+for+years+1999-2008",1
325.pdf.json,,"to go beyond the relatively simpler tasks of classification and regression, advancing our ability to learn good generative models of high-dimensional data appears essential. there are many scenarios where one needs to efficiently produce good high-dimensional outputs where output dimensions have unknown intricate statistical dependencies: from generating realistic images, segmentations, text, speech, keypoint or joint positions, etc..., possibly as an answer to the same, other, or multiple input modalities. these are typically cases where there is not just one right answer but a variety of equally valid ones following a non-trivial and unknown distribution. a fundamental ingredient for such scenarios is thus the ability to learn a good generative model from data, one from which we can subsequently efficiently generate varied samples of high quality.
many approaches for learning to generate high dimensional samples have been and are still actively being investigated. these approaches can be roughly classified under the following broad categories:
• ordered visible dimension sampling (van den oord , 2016; larochelle & murray, 2011). in this type of auto-regressive approach, output dimensions (or groups of conditionally independent dimensions) are given an arbitrary fixed ordering, and each is sampled conditionally on the previous sampled ones. this strategy is often implemented using a recurrent network (lstm or gru). desirable properties of this type of strategy are that the exact log likelihood can usually be computed tractably, and sampling is exact. undesirable properties follow from the forced ordering, whose arbitrariness feels unsatisfactory especially for domains that do not have a natural ordering (e.g. images), and imposes for high-dimensional output a long sequential generation that can be slow. • undirected graphical models with multiple layers of latent variables. these make inference, and thus learning, particularly hard and tend to be costly to sample from (salakhutdinov & hinton, 2009). • directed graphical models trained as variational autoencoders (vae) (kingma & welling, 2014; rezende , 2014)
∗associate fellow, canadian institute for advanced research (cifar)
• adversarially-trained generative networks. (gan)(goodfellow , 2014) • stochastic neural networks, i.e. networks with stochastic neurons, trained by an adapted
form of stochastic backpropagation • generative uses of denoising autoencoders (vincent , 2010) and their generalization
as generative stochastic networks (alain , 2016) • inverting a non-equilibrium thermodynamic slow diffusion process (sohl-dickstein , 5) • continuous transformation of a distribution by invertible functions (dinh  (2014), also
used for variational inference in rezende & mohamed (2015))
several of these approaches are based on maximizing an explicit or implicit model log-likelihood or a lower bound of its log-likelihood, but some successful ones are not e.g. gans. the approach we propose here is based on the notion of “denoising” and thus takes its root in denoising autoencoders and the gsn type of approaches. it is also highly related to the non-equilibrium thermodynamics inverse diffusion approach of sohl-dickstein  (2015). one key aspect that distinguishes these types of methods from others listed above is that sample generation is achieved thanks to a learned stochastic mapping from input space to input space, rather than from a latent-space to input-space.
specifically, in the present work, we propose to learn to generate high quality samples through a process of progressive, stochastic, denoising, starting from a simple initial “noise” sample generated in input space from a simple factorial distribution i.e. one that does not take into account any dependency or structure between dimensions. this, in effect, amounts to learning the transition operator of a markov chain operating on input space. starting from such an initial “noise” input, and repeatedly applying the operator for a small fixed number t of steps, we aim to obtain a high quality resulting sample, effectively modeling the training data distribution. our training procedure uses a novel “target-infusion” technique, designed to slightly bias model sampling to move towards a specific data point during training, and thus provide inputs to denoise which are likely under the model’s sample generation paths. by contrast with sohl-dickstein  (2015) which consists in inverting a slow and fixed diffusion process, our infusion chains make a few large jumps and follow the model distribution as the learning progresses.
the rest of this paper is structured as follows: section 2 formally defines the model and training procedure. section 3 discusses and contrasts our approach with the most related methods from the literature. section 4 presents experiments that validate the approach. section 5 concludes and proposes future work directions.we are given a finite data set d containing n points in rd, supposed drawn i.i.d from an unknown distribution q∗. the data set d is supposed split into training, validation and test subsets dtrain, dvalid, dtest. we will denote q∗train the empirical distribution associated to the training set, and use x to denote observed samples from the data set. we are interested in learning the parameters of a generative model p conceived as a markov chain from which we can efficiently sample. note that we are interested in learning an operator that will display fast “burn-in” from the initial factorial “noise” distribution, but beyond the initial t steps we are not concerned about potential slow mixing or being stuck. we will first describe the sampling procedure used to sample from a trained model, before explaining our training procedure.the generative model p is defined as the following sampling procedure:
• using a simple factorial distribution p(0)(z(0)), draw an initial sample z(0) ∼ p(0), where z(0) ∈ rd. since p(0) is factorial, the d components of z(0) are independent: p0 cannot model any dependency structure. z(0) can be pictured as essentially unstructured random noise. • repeatedly apply t times a stochastic transition operator p(t)(z(t)|z(t−1)), yielding a more “denoised” sample z(t) ∼ p(t)(z(t)|z(t−1)), where all z(t) ∈ rd.
• output z(t ) as the final generated sample. our generative model distribution is thus p(z(t )), the marginal associated to joint p(z(0), . . . , z(t )) = p(0)(z(0)) (∏t t=1 p (t)(z(t)|z(t−1)) ) .
in summary, samples from model p are generated, starting with an initial sample from a simple distribution p(0), by taking the t thsample along markov chain z(0) → z(1) → z(2) → . . . → z(t ) whose transition operator is p(t)(z(t)|z(t−1)). we will call this chain the model sampling chain. figure 1 illustrates this sampling procedure using a model (i.e. transition operator) that was trained on mnist. note that we impose no formal requirement that the chain converges to a stationary distribution, as we simply read-out z(t ) as the samples from our model p. the chain also needs not be time-homogeneous, as highlighted by notation p(t) for the transitions.
the set of parameters θ of model p comprise the parameters of p(0) and the parameters of transition operator p(t)(z(t)|z(t−1)). for tractability, learnability, and efficient sampling, these distributions will be chosen factorial, i.e. p(0)(z(0)) = ∏d i=1 p (0) i (z (0) i ) and p
(t)(z(t)|z(t−1)) =∏d i=1 p (t) i (z (t) i |z(t−1)). note that the conditional distribution of an individual component i, p (t) i (z (t) i |z(t−1)) may however be multimodal, e.g. a mixture in which case p(t)(z(t)|z(t−1)) would be a product of independent mixtures (conditioned on z(t−1)), one per dimension. in our experiments, we will take the p(t)(z(t)|z(t−1)) to be simple diagonal gaussian yielding a deep latent gaussian model (dlgm) as in rezende  (2014).we want to train the parameters of model p such that samples from dtrain are likely of being generated under the model sampling chain. let θ(0) be the parameters of p(0) and let θ(t) be the parameters of p(t)(z(t)|z(t−1)). note that parameters θ(t) for t > 0 can straightforwardly be shared across time steps, which we will be doing in practice. having committed to using (conditionally) factorial distributions for our p(0)(z(0)) and p(t)(z(t)|z(t−1)), that are both easy to learn and cheap to sample from, let us first consider the following greedy stagewise procedure. we can easily learn p(0)i (z
(0)) to model the marginal distribution of each component xi of the input, by training it by gradient descent on a maximum likelihood objective, i.e.
θ(0) = argmax θ ex∼q∗train [ log p(0)(x; θ) ] (1)
this gives us a first, very crude unstructured (factorial) model of q∗.
having learned this p(0), we might be tempted to then greedily learn the next stage p(1) of the chain in a similar fashion, after drawing samples z(0) ∼ p(0) in an attempt to learn to “denoise” the sampled z(0) into x. yet the corresponding following training objective θ(1) = argmaxθ ex∼q∗train,z(0)∼p(0) [ log p(1)(x|z(0); θ) ] makes no sense: x and z(0) are sampled independently of each other so z(0) contains no information about x, hence p(1)(x|z(0)) = p(1)(x). so maximizing this second objective becomes essentially the same as what we did when learning p(0). we would learn nothing more. it is essential, if we hope to learn a useful conditional distribution p(1)(x|z(0)) that it be trained on particular z(0) containing some information about x. in other words, we should not take our training inputs to be samples from p(0) but from a slightly different distribution, biased towards containing some information about x. let us call it q(0)(z(0)|x). a natural choice for it, if it were possible, would be to take q(0)(z(0)|x) = p(z(0)|z(t ) = x) but this is an intractable inference, as all intermediate z(t) between z(0) and z(t ) are effectively latent states that we would need to marginalize over. using a workaround such as a variational or mcmc approach would be a usual fallback. instead, let us focus on our initial intent of guiding a progressive stochastic denoising, and think if we can come up with a different way to construct q(0)(z(0)|x) and similarly for the next steps q(t)i (z̃ (t) i |z̃(t−1),x).
eventually, we expect a sequence of samples from markov chain p to move from initial “noise” towards a specific example x from the training set rather than another one, primarily if a sample along the chain “resembles” x to some degree. this means that the transition operator should learn to pick up a minor resemblance with an x in order to transition to something likely to be even more similar to x. in other words, we expect samples along a chain leading to x to both have high probability under the transition operator of the chain p(t)(z(t)|z(t−1)), and to have some form of at least partial “resemblance” with x likely to increase as we progress along the chain. one highly inefficient way to emulate such a chain of samples would be, for teach step t, to sample many candidate samples from the transition operator (a conditionally factorial distribution) until we generate one that has some minimal “resemblance” to x (e.g. for a discrete space, this resemblance measure could be based on their hamming distance). a qualitatively similar result can be obtained at a negligible cost by sampling from a factorial distribution that is very close to the one given by the transition operator, but very slightly biased towards producing something closer to x. specifically, we can “infuse” a little of x into our sample by choosing for each input dimension, whether we sample it from the distribution given for that dimension by the transition operator, or whether, with a small probability, we take the value of that dimension from x. samples from this biased chain, in which we slightly “infuse” x, will provide us with the inputs of our input-target training pairs for the transition operator. the target part of the training pairs is simply x.formally we define an infusion chain z̃(0) → z̃(1) → . . . → z̃(t−1) whose distribution q(z̃(0), . . . , z̃(t−1)|x) will be “close” to the sampling chain z(0) → z(1) → z(2) → . . . → z(t−1) of model p in the sense that q(t)(z̃(t)|z̃(t−1),x) will be close to p(t)(z(t)|z(t−1)), but will at every step be slightly biased towards generating samples closer to target x, i.e. x gets progressively “infused” into the chain. this is achieved by defining q(0)i (z̃ (0) i |x) as a mixture between p (0) i (with a large mixture weight) and δxi , a concentrated unimodal distribution around xi, such as a gaussian with small variance (with a small mixture weight)1. formally q(0)i (z̃ (0) i |x) = (1 − α(t))p(0)i (z̃ (0) i ) + α (t)δxi(z̃ (0) i ), where 1 − α(t) and α(t) are the mixture weights 2. in other words, when sampling a value for z̃(0)i from q (0) i there will be a small probability α (0) to pick value close to xi (as sampled from δxi ) rather than sampling the value from p (0) i . we call α(t) the infusion rate. we define the transition operator of the infusion chain similarly as: q (t) i (z̃ (t) i |z̃(t−1),x) = (1− α(t))p (t) i (z̃ (t) i |z̃(t−1)) + α(t)δxi(z̃ (t) i ). note that δxi does not denote a dirac-delta but a gaussian with small sigma. 2in all experiments, we use an increasing schedule α(t) = α (t−1) +ω with α (0)
and ω constant. this allows to build our chain such that in the first steps, we give little information about the target and in the last steps we give more informations about the target. this forces the network to have less confidence (greater incertitude) at the beginning of the chain and more confidence on the convergence point at the end of the chain.for all x ∈ dtrain: • sample from the infusion chain z̃ = (z̃(0), . . . , z̃(t−1)) ∼ q(z̃(0), . . . , z̃(t−1)|x).
precisely so: z̃0 ∼ q(0)(z̃(0)|x) . . . z̃(t) ∼ q(t)(z̃(t)|z̃(t−1),x) . . . • perform a gradient step so that p learns to “denoise” every z̃(t) into x.
θ(t) ← θ(t) + η(t) ∂ log p (t)(x|z̃(t−1); θ(t)) ∂θ(t)
where η(t) is a scalar learning rate. 3
as illustrated in figure 2, the distribution of samples from the infusion chain evolves as training progresses, since this chain remains close to the model sampling chain.the exact log-likelihood of the generative model implied by our model p is intractable. the logprobability of an example x can however be expressed using proposal distribution q as:
log p(x) = logeq(z̃|x) [ p(z̃,x)
q(z̃|x)
] (2)
using jensen’s inequality we can thus derive the following lower bound:
log p(x) ≥ eq(z̃|x) [log p(z̃,x)− log q(z̃|x)] (3)
where log p(z̃,x) = log p(0)(z̃(0)) + (∑t−1
t=1 log p (t)(z̃(t)|z̃(t−1))
) + log p(t )(x|z̃(t−1)) and
log q(z̃|x) = log q(0)(z̃(0)|x) + ∑t−1 t=1 log q
(t)(z̃(t)|z̃(t−1),x). 3since we will be sharing parameters between the p(t), in order for the expected larger error gradients on the earlier transitions not to dominate the parameter updates over the later transitions we used an increasing schedule η(t) = η0 tt for t ∈ {1, . . . , t}.
a stochastic estimation can easily be obtained by replacing the expectation by an average using a few samples from q(z̃|x). we can thus compute a lower bound estimate of the average log likelihood over training, validation and test data.
similarly in addition to the lower-bound based on eq.3 we can use the same few samples from q(z̃|x) to get an importance-sampling estimate of the likelihood based on eq. 24.since we have derived a lower bound on the likelihood, we can alternatively choose to optimize this stochastic lower-bound directly during training. this alternative lower-bound based infusion training procedure differs only slightly from the denoising-based infusion training procedure by using z̃(t) as a training target at step t (performing a gradient step to increase log p(t)(z̃(t)|z̃(t−1); θ(t))) whereas denoising training always uses x as its target (performing a gradient step to increase log p(t)(x|z̃(t−1); θ(t))). note that the same reparametrization trick as used in variational autoencoders (kingma & welling, 2014) can be used here to backpropagate through the chain’s gaussian sampling.generating samples as a repeated application of a markov transition operator that operates on input space is at the heart of markov chain monte carlo (mcmc) methods. they allow sampling from an energy-model, where one can efficiently compute the energy or unnormalized negated log probability (or density) at any point. the transition operator is then derived from an explicit energy function such that the markov chain prescribed by a specific mcmc method is guaranteed to converge to the distribution defined by that energy function, as the equilibrium distribution of the chain. mcmc techniques have thus been used to obtain samples from the energy model, in the process of learning to adjust its parameters.
by contrast here we do not learn an explicit energy function, but rather learn directly a parameterized transition operator, and define an implicit model distribution based on the result of running the markov chain.variational auto-encoders (vae) (kingma & welling, 2014; rezende , 2014) also start from an unstructured (independent) noise sample and non-linearly transform this into a distribution that matches the training data. one difference with our approach is that the vae typically maps from a lower-dimensional space to the observation space. by contrast we learn a stochastic transition operator from input space to input space that we repeat for t steps. another key difference, is that the vae learns a complex heavily parameterized approximate posterior proposal q whereas our infusion based q can be understood as a simple heuristic proposal distribution based on p. importantly the specific heuristic we use to infuse x into q makes sense precisely because our operator is a map from input space to input space, and couldn’t be readily applied otherwise. the generative network in rezende  (2014) is a deep latent gaussian model (dlgm) just as ours. but their approximate posterior q is taken to be factorial, including across all layers of the dlgm, whereas our infusion based q involves an ordered sampling of the layers, as we sample from q(t)(z̃(t)|z̃(t−1),x). more recent proposals involve sophisticated approaches to sample from better approximate posteriors, as the work of salimans  (2015) in which hamiltonian monte carlo is combined with variational inference, which looks very promising, though computationally expensive, and rezende & mohamed (2015) that generalizes the use of normalizing flows to obtain a better approximate posterior. specifically, the two estimates (lower-bound and is) start by collecting k samples from q(z̃|x) and computing for each the corresponding ` = log p(z̃,x) − log q(z̃|x). the lower-bound estimate is then obtained by averaging the resulting `1, . . . `k, whereas the is estimate is obtained by taking the log of the averaged e`1 , . . . , e`k (in a numerical stable manner as logsumexp(`1, . . . , `k)− log k).earlier works that propose to directly learn a transition operator resulted from research to turn autoencoder variants that have a stochastic component, in particular denoising autoencoders (vincent , 2010), into generative models that one can sample from. this development is natural, since a stochastic auto-encoder is a stochastic transition operator form input space to input space. generative stochastic networks (gsn) (alain , 2016) generalized insights from earlier stochastic autoencoder sampling heuristics (rifai , 2012) into a more formal and general framework. these previous works on generative uses of autoencoders and gsns attempt to learn a chain whose equilibrium distribution will fit the training data. because autoencoders and the chain are typically started from or very close to training data points, they are concerned with the chain mixing quickly between modes. by contrast our model chain is always restarted from unstructured noise, and is not required to reach or even have an equilibrium distribution. our concern is only what happens during the t “burn-in” initial steps, and to make sure that it transforms the initial factorial noise distribution into something that best fits the training data distribution. there are no mixing concerns beyond those t initial steps.
a related aspect and limitation of previous denoising autoencoder and gsn approaches is that these were mainly “local” around training samples: the stochastic operator explored space starting from and primarily centered around training examples, and learned based on inputs in these parts of space only. spurious modes in the generated samples might result from large unexplored parts of space that one might encounter while running a long chain.the approach of sohl-dickstein  (2015) is probably the closest to the approach we develop here. both share a similar model sampling chain that starts from unstructured factorial noise. neither are concerned about an equilibrium distribution. they are however quite different in several key aspects: sohl-dickstein  (2015) proceed to invert an explicit diffusion process that starts from a training set example and very slowly destroys its structure to become this random noise, they then learn to reverse this process i.e. an inverse diffusion. to maintain the theoretical argument that the exact reverse process has the same distributional form (e.g. p(x(t−1)|x(t)) and p(x(t)|x(t−1)) both factorial gaussians), the diffusion has to be infinitesimal by construction, hence the proposed approaches uses chains with thousands of tiny steps. instead, our aim is to learn an operator that can yield a high quality sample efficiently using only a small number t of larger steps. also our infusion training does not posit a fixed a priori diffusion process that we would learn to reverse. and while the distribution of diffusion chain samples of sohl-dickstein  (2015) is fixed and remains the same all along the training, the distribution of our infusion chain samples closely follow the model chain as our model learns. our proposed infusion sampling technique thus adapts to the changing generative model distribution as the learning progresses.
drawing on both sohl-dickstein  (2015) and the walkback procedure introduced for gsn in alain  (2016), a variational variant of the walkback algorithm was investigated by goyal  (2017) at the same time as our work. it can be understood as a different approach to learning a markov transition operator, in which a “heating” diffusion operator is seen as a variational approximate posterior to the forward “cooling” sampling operator with the exact same form and parameters, except for a different temperature.we trained models on several datasets with real-valued examples. we used as prior distribution p(0) a factorial gaussian whose parameters were set to be the mean and variance for each pixel through the training set. similarly, our models for the transition operators are factorial gaussians. their mean and elementwise variance is produced as the output of a neural network that receives the previous z(t−1) as its input, i.e. p(t)(z(t)i |z(t−1)) = n (µi(z(t−1)), σ2i (z(t−1))) where µ and σ2 are computed as output vectors of a neural network. we trained such a model using our infusion training procedure on mnist (lecun & cortes, 1998), toronto face database (susskind , 2010), cifar-10 (krizhevsky & hinton, 2009), and celeba (liu , 2015). for all datasets, the only preprocessing we did was to scale the integer pixel values down to range [0,1]. the network
trained on mnist and tfd is a mlp composed of two fully connected layers with 1200 units using batch-normalization (ioffe & szegedy, 2015) 5. the network trained on cifar-10 is based on the same generator as the gans of salimans  (2016), i.e. one fully connected layer followed by three transposed convolutions. celeba was trained with the previous network where we added another transposed convolution. we use rectifier linear units (glorot , 2011) on each layer inside the networks. each of those networks have two distinct final layers with a number of units corresponding to the image size. they use sigmoid outputs, one that predict the mean and the second that predict a variance scaled by a scalar β (in our case we chose β = 0.1) and we add an epsilon = 1e − 4 to avoid an excessively small variance. for each experiment, we trained the network on 15 steps of denoising with an increasing infusion rate of 1% (ω = 0.01, α (0)
= 0), except on cifar-10 where we use an increasing infusion rate of 2% (ω = 0.02, α (0) = 0) on 20 steps.since we can’t compute the exact log-likelihood, the evaluation of our model is not straightforward. however we use the lower bound estimator derived in section 2.4 to evaluate our model during training and prevent overfitting (see figure 3). since most previous published results on non-likelihood based models (such as gans) used a parzen-window-based estimator (breuleux , 2011), we use it as our first comparison tool, even if it can be misleading (lucas theis & bethge, 2016). results are shown in table 1, we use 10 000 generated samples and σ = 0.17 . to get a better estimate of the log-likelihood, we then computed both the stochastic lower bound and the importance sampling estimate (is) given in section 2.4. for the is estimate in our mnist-trained model, we used 20 000 intermediates samples. in table 2 we compare our model with the recent annealed importance sampling results (wu , 2016). note that following their procedure we add an uniform noise of 1/256 to the (scaled) test point before evaluation to avoid overevaluating models that might have overfitted on the 8 bit quantization of pixel values. another comparison tool that we used is the inception score as in salimans  (2016) which was developed for natural images and is thus most relevant for cifar-10. since salimans  (2016) used a gan trained in a semi-supervised way with some tricks, the comparison with our unsupervised trained model isn’t straightforward. however, we can see in table 3 that our model outperforms the traditional gan trained without labeled data.another common qualitative way to evaluate generative models is to look at the quality of the samples generated by the model. in figure 4 we show various samples on each of the datasets we used. in order to get sharper images, we use at sampling time more denoising steps than in the training time (in the mnist case we use 30 denoising steps for sampling with a model trained on 15 denoising steps). to make sure that our network didn’t learn to copy the training set, we show in the last column the nearest training-set neighbor to the samples in the next-to last column. we can see that our training method allow to generate very sharp and accurate samples on various dataset. we don’t share batch norm parameters across the network, i.e for each time step we have different parameters and independent batch statistics.another method to evaluate a generative model is inpainting. it consists of providing only a partial image from the test set and letting the model generate the missing part. in one experiment, we provide only the top half of celeba test set images and clamp that top half throughout the sampling chain. we restart sampling from our model several times, to see the variety in the distribution of the bottom part it generates. figure 5 shows that the model is able to generate a varied set of bottom halves, all consistent with the same top half, displaying different type of smiles and expression. we also see that the generated bottom halves transfer some information about the provided top half of the images (such as pose and more or less coherent hair cut).we presented a new training procedure that allows a neural network to learn a transition operator of a markov chain. compared to the previously proposed method of sohl-dickstein  (2015) based on inverting a slow diffusion process, we showed empirically that infusion training requires far fewer denoising steps, and appears to provide more accurate models. currently, many successful generative models, judged on sample quality, are based on gan architectures. however these require to use two different networks, a generator and a discriminator, whose balance is reputed delicate to adjust, which can be source of instability during training. our method avoids this problem by using only a single network and a simpler training objective.
denoising-based infusion training optimizes a heuristic surrogate loss for which we cannot (yet) provide theoretical guarantees, but we empirically verified that it results in increasing log-likelihood estimates. on the other hand the lower-bound-based infusion training procedure does maximize an explicit variational lower-bound on the log-likelihood. while we have run most of our experiments with the former, we obtained similar results on the few problems we tried with lower-bound-based infusion training.
future work shall further investigate the relationship and quantify the compromises achieved with respect to other markov chain methods including sohl-dickstein  (2015); salimans  (2015)
and also to powerful inference methods such as rezende & mohamed (2015). as future work, we also plan to investigate the use of more sophisticated neural net generators, similar to dcgan’s (radford , 2016) and to extend the approach to a conditional generator applicable to structured output problems.we would like to thank the developers of theano (theano development team, 2016) for making this library available to build on, compute canada and nvidia for their computation resources, nserc and ubisoft for their financial support, and three iclr anonymous reviewers for helping us improve our paper.a.1 mnist experiments
we show the impact of the infusion rate α(t) = α (t−1)
+ ω for different numbers of training steps on the lower bound estimate of log-likelihood on the validation set of mnist in figure 6. we also show the quality of generated samples and the lower bound evaluated on the test set in table 4. each experiment in table 4 uses the corresponding models of figure 6 that obtained the best lower bound value on the validation set. we use the same network architecture as described in section 4, i.e two fully connected layers with relu activations composed of 1200 units followed by two distinct fully connected layers composed of 784 units, one that predicts the means, the other one that predicts the variances. each mean and variance is associated with one pixel. all of the the parameters of the model are shared across different steps except for the batch norm parameters. during training, we use the batch statistics of the current mini-batch in order to evaluate our model on the train and validation sets. at test time (table 4), we first compute the batch statistics over the entire train set for each step and then use the computed statistics to evaluate our model on the test test.
we did some experiments to evaluate the impact of α or ω in α(t) = α (t−1)
+ ω. figure 6 shows that as the number of steps increases, the optimal value for infusion rate decreases. therefore, if we want to use many steps, we should have a small infusion rate. these conclusions are valid for both increasing and constant infusion rate. for example, the optimal α for a constant infusion rate, in figure 6e with 10 steps is 0.08 and in figure 6f with 15 steps is 0.06. if the number of steps is not enough or the infusion rate is too small, the network will not be able to learn the target distribution as shown in the first rows of all subsection in table 4.
in order to show the impact of having a constant versus an increasing infusion rate, we show in figure 7 the samples created by infused and sampling chains. we observe that having a small infusion rate over many steps ensures a slow blending of the model distribution into the target distribution.
in table 4, we can see high lower bound values on the test set with few steps even if the model can’t generate samples that are qualitatively satisfying. these results indicate that we can’t rely on the lower bound as the only evaluation metric and this metric alone does not necessarily indicate the suitability of our model to generated good samples. however, it is still a useful tool to prevent overfitting (the networks in figure 6e and 6f overfit when the infusion rate becomes too high). concerning the samples quality, we observe that having a small infusion rate over an adequate number of steps leads to better samples.
a.2 infusion and model sampling chains on natural images datasets
in order to show the behavior of our model trained by infusion on more complex datasets, we show in figure 8 chains on cifar-10 dataset and in figure 9 chains on celeba dataset. in each figure, the first sub-figure shows the chains infused by some test examples and the second subfigure shows the model sampling chains. in the experiment on cifar-10, we use an increasing schedule α(t) = α (t−1) + 0.02 with α(0) = 0 and 20 infusion steps (this corresponds to the training parameters). in the experiment on celeba, we use an increasing schedule α(t) = α (t−1)
+0.01 with α(0) = 0 and 15 infusion steps.",1
328.pdf.json,MULTILAYER RECURRENT NETWORK MODELS OF PRI- MATE RETINAL GANGLION CELL RESPONSES,"our understanding of sensory processing in the brain is most straightforwardly reflected in our ability to model the process by which stimuli presented at the sensory periphery are transformed into the spiking activity of populations of neurons. for decades, researchers have interrogated stimulus-response
∗these authors contributed equally.
neural properties using simplified targeted stimuli, such as bars, spots, or gratings. while these types of stimuli uncovered many interesting aspects of visual computation, they have several limitations (barlow & levick, 1965). these stimuli may not fully drive important components of neural response, and modeling efforts have often assumed a quasi-linear mapping from stimulus to firing rate. subsequent efforts to characterize cells relied on white noise stimulation and building models through reverse correlation (de boer r & kuyper, 1968; marmarelis & naka, 1972; chichilnisky, 2001). a standard model used to relate white noise to spiking responses is the linear-nonlinear-poisson (ln) or generalized linear model (glm) which consists of a spatiotemporal linear filtering of the stimulus followed by a nonlinearity and probabilistic spike generation (chichilnisky, 2001; simoncelli , 2004; schwartz , 2006). although this family of models have advanced our understanding, they do not optimally capture neural responses, especially to natural scenes which can lead to more complex responses than white noise stimuli (david , 2004). even in the retina, early in the visual processing stream, these commonly-used models capture retinal ganglion cell (rgc) responses to natural stimuli less accurately than to white noise (heitman , 2016).
recently, deep neural networks have been used to dramatically improve performance on a diverse array of machine learning tasks (krizhevsky , 2012; lecun , 2015). furthermore, these networks bear a loose resemblance to real neural networks, and provide a sufficiently rich model class that can still be roughly constrained to match the biological architecture (kriegeskorte, 2015). most previous research at this intersection of neuroscience and artificial neural networks has focused on training networks on a certain task, such as object recognition, and then comparing the computations performed in different layers of the artificial network to those performed by real neurons (yamins , 2014). here we take a different approach: we fit multilayer models directly to the spiking responses of neurons, an approach that has not been explored in detail (but see (mcintosh , 2016) for some recent independent parallel developments).we fit a range of models, detailed below, to spiking responses of primate rgcs. our baseline comparisons are the glm architectures that have been widely used to construct previous neural models (pillow , 2008), though here we focus on individual neuronal responses (we leave modeling of correlations between neurons for future work). we focused on rnns as a flexible framework in which to model more complex temporal and spatial nonlinearities. we also explored a number of network architectures involving features or weights shared across observed neurons. given the complexity of the network architectures, we reasoned that sharing statistical strength across neurons by learning a shared feature space might improve predictive performance. this is conceptually a form of multitask learning - we are using a shared representation to achieve better generalization (baxter, 2000). motivated by previous research showing significant differences in the processing properties of the two cell types examined, on and off parasol retinal ganglion cells, we fit separate models for each of these cell types (chichilnisky & kalmar, 2002).we fit spiking responses of off and on parasol retinal ganglion cells to natural scenes. recordings were performed on isolated retina using a large-scale multi-electrode recording system (litke , 2004; frechette , 2005; field , 2007). a standard spike sorting algorithm was used to identify spikes from different cells from the voltage signals on each electrode during visual stimulation (litke , 2004). we focus on two separate experiments (the same experimental procedure in two separate retinas) here; analyses of other datasets yielded similar results. models were fit separately for the two experiments due to animal to animal variability in cell properties, such as receptive field size and firing rate. almost all spike sorted cells were used for training (exp 1 = 118 off cells, 66 on cells; exp 2 = 142 off cells, 103 on cells): two cells were removed due to data quality issues (see sec 3.3). performance metrics in this paper are reported for the same subset of cells used in a previous study (heitman , 2016). these cells passed passed a manual screen for spike sorting accuracy, demonstrated stable light responses, and met a convergence criteria in prior linear-nonlinear modeling (exp 1 = 10 off cells, 18 on cells; exp 2 = 65 off cells, 14 on cells). the naturalistic movie
stimulus consisted of images from the van hateren database shown for one second each, with spatial jitter based on eye movements during fixation by awake macaque monkeys (z.m. hafed and r.j. krauzlis, personal communication), (van hateren & van der schaaf, 1998). an example stimulus can be found at https://youtu.be/sg_18uz_6oe. 59 distinct natural scenes movies of length one minute (the training data) were interleaved with 59 repetitions of a 30 second movie (the test data). interleaving ensured that the test movie repetitions spanned the same period of time as the training data and therefore experienced the same range of experimental conditions (in case of neural response drifts over time). the first 4 movies shown (2 training movies and 2 repetitions of the test movie) were excluded to avoid initial transients. test metrics are reported for the last 29 seconds of the 30 second test movie for the same reason. for further details on the experimental set-up, data preprocessing, and visual stimulation, see heitman  (2016).all models were implemented in theano and trained on a combination of cpus and gpus (theano development team, 2016). training was performed using the adam optimizer on the mean squared error (mse) between predicted firing rate and true spikes (kingma & ba, 2014). we also experimented with optimizing a poisson likelihood; this led to qualitatively similar results but occasionally less stable fits, so we focus on the mse results here. all recurrent dynamics and temporal filters operated on time bins of 8.33 ms (the frame rate of the movie). spike history terms and performance metrics were calculated for 0.833 ms bins. we used the same split of training and validation data for both experiments: 104 thirty-second movies as training data and 10 thirty-second movies as a held-out validation set.
during training, the performance on the held-out validation set is checked after every pass through the training data. after each iteration through the training data, if the model exhibits significantly better validation performance than our previous best, we reset the minimum number of iterations to be twice the current iteration number. if we make it through those iterations without another significant improvement, we stop. we train for a maximum of 150 epochs, where we define one epoch as one pass through all the training data. the model with the best validation performance is saved and used to assess test performance. all models with shared parameters were trained on a combined mse over
all neurons and the parameters picked were those which minimized validation mse for all neurons. for individual lns/glms/rnns, the validation mse was minimized for each neuron separately.in all models used in this paper, we estimate the receptive field (rf) center of each neuron in order to identify the appropriate portion of the image to use as input. we calculate a 250 ms long spike triggered average (sta) using reverse correlation of the neuron’s spikes with a white noise stimulus. we reduce the noise in this sta by using a rank 1 approximation (singular value decomposition followed by reconstruction using the primary temporal and spatial components). we then smooth each frame of the sta via convolution with a gaussian spatial filter. the center location is defined as the pixel location that has the maximum absolute magnitude over time. the center locations were visually assessed to check accuracy of the algorithm. rare cases where the algorithm failed to identify the correct center indicated neurons that responded to very little of the image as their receptive field was more than half-way displaced out of the image. these two neurons (two exp 1 on cells) were removed from further analysis. if the receptive field center is close to the edge of the image, the image patch is padded with the average training stimulus value.to quantitatively evaluate the accuracy of model spike predictions, we used the fraction of explainable variance, which has been described in previous literature (heitman , 2016). average firing rates over time are obtained after generating spikes from the model in 0.833 ms bins and smoothing with a gaussian temporal filter (sd=10ms). the fraction of variance is computed as
f (r, rs) = 1− ∑
t(r(t)− rs(t))2∑ t(r(t)− µ)2
(1)
where r(t) is the smoothed recorded firing rate, rs(t) is the smoothed predicted firing rate, and µ is the average recorded rate. finally, to account for the reproducibility of responses over repeated trials, we normalize by the fraction of variance captured by using the average firing rate on the odd (ro) trials of the repeated test movie to predict responses on the even (re) trials:
fv = f (r, rs)
f (re, ro) . (2)individual lns and glms: the linear-nonlinear model (ln) consists of a spatiotemporal filtering of the 31x31x30 movie patch (xt, width by height by time) surrounding the estimated center of the neuron’s receptive field plus a bias term (b), followed by a sigmoid nonlinearity (f ), and poisson spike generation to produce the responses rt. the generalized linear model (glm), given by
rt ∼ poiss [ f ( ~wts (xt ~wt) + b+ ∑ i hirt−i )] , (3)
has the same architecture with the addition of a post-spike history filter h before the nonlinearity f (pillow , 2008). we used a rank 1 approximation of the full spatiotemporal filter (higher rank models did not significantly improve fits on a subset of examined neurons), resulting in a vectorized 31x31 spatial filter (~ws) and a 30 bin temporal filter (~wt) which spans 250 ms (heitman , 2016). the post-spike history filter consists of a weighted sum of a basis of 20 raised cosines spanning approximately 100 ms (pillow , 2008). the models with spike history were fit by initializing with the model fit without spike history. the filter either operates on the recorded spikes (training and validation) or the spikes generated by the model (testing). the nonlinearity is the logistic sigmoid: f = l/(1 + exp(−x)), which has been shown to improve fitting over an exponential nonlinearity for modeling rgc responses to natural scenes (heitman , 2016).
shared ln: in this model, the architecture is similar to the individual lns but all cells of a given type (off or on) share the same temporal and spatial filters (figure 1a; note that the spatial filters are displaced to the rf center of each individual rgc). all other parameters are individually tuned for each observed neuron. there is an additional gain term that weights the output of the filtering individually for each observed neuron.
two-layer rnn, 50 units: in this architecture, there are two recurrent neural network (rnn) layers between the image patch and poisson neural unit:
~h (1) j,t = max(0, u1~sj,t + v1 ~h (1) j,t−1 + ~c) (4)
~h (2) j,t = max(0, u2 ~h (1) j,t + v2 ~h (2) j,t−1 + ~d) (5) rj,t ∼ poiss [ f(~wtj ~h (2) j,t + bj) ] . (6)
the activity of the 50 units in the first rnn layer at time t is given by ~h(1)j,t in eqn. 4. these units are rectified linear, and receive input from the vectorized 31x31 image patch surrounding the center of neuron j’s receptive field, ~sj,t, with weights u1, along with input from the other units in the layer with weights v1 and a bias ~c. the output of the first rnn is then fed into a second rnn with similar architecture. the firing rate for each observed neuron in the final layer is then given by eqn. 6, and is a weighted sum of the recurrent units plus a bias bj , followed by a softplus nonlinearity f = log(1 + exp(−x)). note that all parameters are shared across neurons except for the weights to the final layer and the final bias terms (~wj and bj).
glm-rnn hybrid: the glm-rnn hybrid model consists of a spatial filter followed by a two-layer rnn. the architecture resembles that of the full two-layer rnn with 50 units, except the input to the first layer is a scalar (post multiplication with the spatial filter) at each time step instead of the full image patch; thus the rnn in this model is responsible for shaping the temporal properties of the output, but does not affect spatial processing after the first linear spatial filtering stage. all weights
are shared across neurons except for weights to the final layer (~wj) and the final bias terms (bj):
yj,t = ~w t s ~sj,t (7)
~h (1) j,t = max(0, ~u1yj,t + v1 ~h (1) j,t−1 + ~c) (8)
~h (2) j,t = max(0, u2h (1) j,t + v2 ~h (2) j,t−1 + ~d) (9) rj,t ∼ poiss [ f(~wtj ~h (2) t + bj) ] . (10)rnns of varying architectures consistently outperformed lns and glms in predicting neural spiking responses to a novel natural scene movie for both off and on parasol retinal ganglion cells in both experiments (figure 2). a shared two-layer recurrent network consistently captures around 80% of the explainable variance across experiments and cell types. other recurrent architectures (1-3 layer rnns and a 2 layer lstm) led to similar levels of performance (supplementary figure 6). the increase in performance according to the fraction of explainable variance metric was not an average effect: almost all neurons were significantly better predicted by the rnn (figure 2b). a 2 layer rnn model with additional trained spike history filters outperformed glms and lns according to a normalized log likelihood metric (supplementary figure 7).
inspection of the mean predicted firing rate traces for lns and rnns in figure 3 reveals that the recurrent network seems to be capturing the timing of firing more precisely. the ln often predicts a general increase in firing rate at the correct times, but the rnn captures the sudden increase in firing rate followed by decay which often occurs when the image changes. on the other hand, the ln models sometimes predict modest increases or decreases in firing rate that the recurrent nets miss.
understanding why the recurrent models improve performance is a challenging task due to the black-box nature of deep networks. the first layer filters (u1, from image patches to recurrent units) have an interpretable structure resembling traditional receptive fields expected in the retina
(supplementary figure 8). however, the computations performed by the recurrent units are difficult to tease apart, because the weights are less interpretable. thus, instead of attempting a mechanistic explanation of the internals of the rnn, we focused on what additional captured information resulted in the improved rnn performance.
one possibility is that capturing nonlinear effects in parts of the image far from the receptive field center improved predictions (mcilwain, 1964; passaglia , 2009). we restricted the size of the image patch surrounding each receptive field center from 31x31 to 15x15 (supplementary figure 9). shared rnns trained on the smaller image patch size did as well, or better, than those trained on the larger patch across almost all combinations of cell type and experiment. (we see a similar small improvement when training the ln models on the small patch.) thus we concluded that long-range nonlinear spatial interactions do not contribute to the increased performance produced by the rnns.
we also investigated whether nonlinear spatial interactions or nonlinear temporal processing primarily contributed to better predictions. to accomplish this, we constructed a glm-rnn hybrid, described previously, in which a single spatial filter precedes a two-layer rnn - effectively allowing only temporal nonlinearities to be captured. this model improved prediction over the lns and glms but did not reach full rnn performance. the amount by which this model closed the gap differed for different experiments and cell types. we quantified this by computing the difference between multitask rnn and multitask ln performance for each neuron and the difference between multitask hybrid and multitask ln performance. we divide the latter by the former (on a cell-by-cell basis) to obtain the ratios summarized in figure 2c. the hybrid model closed greater than half of the gap on average between multitask ln and rnn performance, indicating that the richer temporal dynamics of the rnn model account for a large part of the difference between rnn and ln performance, though spatial nonlinearities play a role too.deep networks can be complex and often require large amounts of data to adequately train: convolutional neural networks used for object recognition are trained on over a million images (krizhevsky , 2012). standard neuroscience experiments yield limited data sets, so it is crucial to assess whether we have enough data to adequately fit our network architectures. we trained the rnn on varying amounts of data, and ran several different iterations of the network to explore variation over random initializations and randomly chosen training sets. these results are shown for both on and off cells in figure 4. surprisingly small amounts of training data resulted in good predictive abilities. for larger amounts of training data, different iterations resulted in very similar mean fraction of variance values, indicating fairly robust fitting in these models. see supplementary figure 10 for further details.we investigated whether the multitask framework with shared parameters across neurons actually helps to improve predictive performance with reasonable amounts of experimental data. first, we quantified the benefits of parameter-sharing in the simple ln model. this is a highly constrained
framework: every cell has the same spatial and temporal filter. the shared ln does not improve performance for most neurons (figure 5a).
we expected the multitask framework to be more helpful applied to the rnn model because in this case we are sharing features but not all parameters across neurons. indeed, the multitask rnn consistently outperformed rnns trained individually on single neurons (figure 5b); individuallytrained rnns also had much more variable losses than did the multitask-trained rnns. in a realistic experimental setting with limited data, the multitask framework is a useful way to leverage all of the data collected for all neurons.using retinal neurons responding to natural scenes as an example, we showed that: using deep networks to model neural spiking responses can significantly improve prediction over current state-ofthe-art models; sharing information across neurons in a multi-task framework leads to better and more stable predictions; and these models work well even given relatively small amounts of experimental data. we believe that the multitask rnn framework presented here will enable new, richer models of complex nonlinear spiking computations in other brain areas.
while one could argue that we have merely exchanged the black box of the brain for another black box, just having a more predictive model is an important tool for research: these predictive models of the primate retina can be used in retinal prosthetics research, to probe decoding, and as a first stage of processing in the modeling of higher visual areas. additionally, the recurrent network is more accessible and available for experimentation and quantitative analysis. for example, the trained neural network models may guide choices for more accurate simpler models by identifying key computational features that are important to include. training smaller models on the denoised compression of spiking data (the predicted firing rate) may help them to learn features they otherwise would not (ba & caruana, 2014). the deep network approach allows one to determine types of information important to the neuron without having to build an exact mechanistic model of how such information is incorporated, as demonstrated by our finding that both spatial and temporal nonlinearities are not fully captured by the standard pseudo-linear models. we hope in future work to gain a more thorough and quantitative understanding of the dynamics captured by the recurrent networks and to extend this approach to higher sensory areas.funding for this research was provided by the national science foundation graduate research fellowship program under grant no. dge-114747 (nb), grant number no. dge-16-44869 (eb), the national science foundation igert training grant no. 0801700 (nb), the national institutes of health grant ey017992 (ejc), nsf crcns iis-1430239 (lp, ejc) and google faculty research awards (lp, ejc); in addition, this work was supported by the intelligence advanced research projects activity (iarpa) via department of interior/ interior business center (doi/ibc) contract number d16pc00003 (lp). the u.s. government is authorized to reproduce and distribute reprints for governmental purposes notwithstanding any copyright annotation thereon. disclaimer: the views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of iarpa, doi/ibc, or the u.s. government.",1
340.pdf.json,,"humans excel in tasks that require making analogies between distinct domains, transferring elements from one domain to another, and using these capabilities in order to blend concepts that originated from multiple source domains. our experience tells us that these remarkable capabilities are developed with very little, if any, supervision that is given in the form of explicit analogies.
recent achievements replicate some of these capabilities to some degree: generative adversarial networks (gans) are able to convincingly generate novel samples that match that of a given training set; style transfer methods are able to alter the visual style of images; domain adaptation methods are able to generalize learned functions to new domains even without labeled samples in the target domain and transfer learning is now commonly used to import existing knowledge and to make learning much more efficient.
these capabilities, however, do not address the general analogy synthesis problem that we tackle in this work. namely, given separated but otherwise unlabeled samples from domains s and t and a perceptual function f , learn a mapping g : s → t such that f(x) ∼ f(g(x)). in order to solve this problem, we make use of deep neural networks of a specific structure in which the function g is a composition of the input function f and a learned function g. a compound loss that integrates multiple terms is used. one term is a generative adversarial network (gan) term that encourages the creation of samples g(x) that are indistinguishable from the training samples of the target domain, regardless of x ∈ s or x ∈ t . the second loss term enforces that for every x in the source domain training set, ||f(x)− f(g(x))|| is small. the third loss term is a regularizer that encourages g to be the identity mapping for all x ∈ t . the type of problems we focus on in our experiments are visual, although our methods are not limited to visual or even to perceptual tasks. typically, f would be a neural network representation that is taken as the activations of a network that was trained, e.g., by using the cross entropy loss, in order to classify or to capture identity.
as a main application challenge, we tackle the problem of emoji generation for a given facial image. despite a growing interest in emoji and the hurdle of creating such personal emoji manually, no system has been proposed, to our knowledge, that can solve this problem. our method is able to
produce face emoji that are visually appealing and capture much more of the facial characteristics than the emoji created by well-trained human annotators who use the conventional tools.as far as we know, the domain transfer problem we formulate is novel despite being ecological (i.e., appearing naturally in the real-world), widely applicable, and related to cognitive reasoning (fauconnier & turner, 2003). in the discussion below, we survey recent gan work, compare our work to the recent image synthesis work and make links to unsupervised domain adaptation.
gan (goodfellow , 2014) methods train a generator network g that synthesizes samples from a target distribution given noise vectors. g is trained jointly with a discriminator network d, which distinguishes between samples generated by g and a training set from the target distribution. the goal of g is to create samples that are classified by d as real samples.
while originally proposed for generating random samples, gans can be used as a general tool to measure equivalence between distributions. specifically, the optimization of d corresponds to taking the most discriminative d achievable, which in turn implies that the indistinguishability is true for every d. formally, ganin  (2016) linked the gan loss to the h-divergence between two distributions of ben-david  (2006).
the generative architecture that we employ is based on the successful architecture of radford  (2015). there has recently been a growing concern about the uneven distribution of the samples generated by g – that they tend to cluster around a set of modes in the target domain (salimans , 2016). in general, we do not observe such an effect in our results, due to the requirement to generate samples that satisfy specific f -constancy criteria.
a few contributions (“conditional gans”) have employed gans in order to generate samples from a specific class (mirza & osindero, 2014), or even based on a textual description (reed , 2016). when performing such conditioning, one can distinguish between samples that were correctly generated but fail to match the conditional constraint and samples that were not correctly generated. this is modeled as a ternary discriminative function d (reed , 2016; brock , 2016).
the recent work by dosovitskiy & brox (2016), has shown promising results for learning to map embeddings to their pre-images, given input-target pairs. like us, they employ a gan as well as additional losses in the feature- and the pixel-space. their method is able to invert the midlevel activations of alexnet and reconstruct the input image. in contrast, we solve the problem of unsupervised domain transfer and apply the loss terms in different domains: pixel loss in the target domain, and feature loss in the source domain.
another class of very promising generative techniques that has recently gained traction is neural style transfer. in these methods, new images are synthesized by minimizing the content loss with respect to one input sample and the style loss with respect to one or more input samples. the content loss is typically the encoding of the image by a network training for an image categorization task, similar to our work. the style loss compares the statistics of the activations in various layers of the neural network. we do not employ style losses in our method. while initially style transfer was obtained by a slow optimization process (gatys , 2016), recently, the emphasis was put on feed-forward methods (ulyanov , 2016; johnson , 2016).
there are many links between style transfer and our work: both are unsupervised and generate a sample under f constancy given an input sample. however, our work is much more general in its scope and does not rely on a predefined family of perceptual losses. our method can be used in order to perform style transfer, but not the other way around. another key difference is that the current style transfer methods are aimed at replicating the style of one or several images, while our work considers a distribution in the target space. in many applications, there is an abundance of unlabeled data in the target domain t , which can be modeled accurately in an unsupervised manner.
given the impressive results of recent style transfer work, in particular for face images, one might get the false impression that emoji are just a different style of drawing faces. by way of analogy, this claim is similar to stating that a siamese cat is a labrador in a different style. emoji differ from facial photographs in both content and style. style transfer can create visually appealing face images; however, the properties of the target domain are compromised.
in the computer vision literature, work has been done to automatically generate sketches from images, see kyprianidis  (2013) for a survey. these systems are able to emphasize image edges and facial features in a convincing way. however, unlike our method, they require matching pairs of samples, and were not shown to work across two distant domains as in our method. due to the lack of supervised training data, we did not try to apply such methods to our problems. however, one can assume that if such methods were appropriate for emoji synthesis, automatic face emoji services would be available.
unsupervised domain adaptation addresses the following problem: given a labeled training set in s × y , for some target space y , and an unlabeled set of samples from domain t , learn a function h : t → y (chen , 2012; ganin , 2016). one can solve the sample transfer problem (our problem) using domain adaptation and vice versa. in both cases, the solution is indirect. in order to solve domain adaptation using domain transfer, one would learn a function from s to y and use it as the input method of the domain transfer algorithm in order to obtain a map from s to t 1. the training samples could then be transferred to t and used to learn a classifier there.
in the other direction, given the function f , one can invert f in the domain t by generating training samples (f(x), x) for x ∈ t and learn from them a function h from f(t ) = {f(x)|x ∈ t} to t . domain adaptation can then be used in order to map f(s) = {f(x)|x ∈ s} to t , thus achieving domain transfer. based on the work by zhmoginov & sandler (2016), we expect that h, even in the target domain of emoji, will be hard to learn, making this solution hypothetical at this point.given a set s of unlabeled samples in a source domain s sampled i.i.d according to some distribution ds , a set of samples in the target domain t ⊂ t sampled i.i.d from distribution dt , a function f from the domain s ∪ t , some metric d, and a weight α, we wish to learn a function g : s → t that minimizes the combined risk r = rgan + αrconst, which is comprised of
rgan = max d ex∼ds log[1−d(g(x))] + ex∼dt log[d(x)], (1)
where d is a binary classification function from t , d(x) the probability of the class 1 it assigns for a sample x ∈ t , and
rconst = ex∼ds d(f(x), f(g(x))) (2)
the first term is the adversarial risk, which requires that for every discriminative function d, the samples from the target domain would be indistinguishable from the samples generated by g for samples in the source domain. an adversarial risk is not the only option. an alternative term that does not employ gans would directly compare the distribution dt to the distribution of g(x) where x ∼ ds , e.g., by using kl-divergence. the second term is the f -constancy term, which requires that f is invariant under g. in practice, we have experimented with multiple forms of d including mean squared error (mse) and cosine distance, as well as other variants including metric learning losses (hinge) and triplet losses. the performance is mostly unchanged, and we report results using the simplest mse solution.
similarly to other gan formulations, one can minimize the loss associated with the risk r over g, while maximizing it over d, where g and d are deep neural networks, and the expectations in r are replaced by summations over the corresponding training sets. however, this baseline solution, as we will show experimentally, does not produce desirable results. the function trained this way would be more accurate on s than on t . this asymmetry is shared with all experiments done in this work.we suggest to employ a more elaborate architecture that contains two high level modifications. first, we employ f(x) as the baseline representation to the function g. second, we consider, during training, the generated samples g(x) for x ∈ t. the first change is stated as g = g ◦ f , for some learned function g. by applying this, we focus the learning effort ofg on the aspects that are most relevant torconst. in addition, in most applications, f is not as accurate on t as it on s. the composed function, which is trained on samples from both s and t , adds layers on top of f , which adapt it.
the second change alters the form of lgan, making it multiclass instead of binary. it also introduces a new term ltid that requires g to be the identity matrix on samples from t . taken together and written in terms of training loss, we now have two losses ld and lg = lgang + αlconst + βltid + γltv, for some weights α, β, γ, where
ld = − ∑ x∈s logd1(g(f(x)))− ∑ x∈t logd2(g(f(x)))− ∑ x∈t logd3(x) (3)
lgang = − ∑ x∈s logd3(g(f(x)))− ∑ x∈t logd3(g(f(x))) (4)
lconst = ∑ x∈s d(f(x), f(g(f(x)))) (5)
ltid = ∑ x∈t d2(x,g(x)) (6)
and where d is a ternary classification function from the domain t to 1, 2, 3, and di(x) is the probability it assigns to class i = 1, 2, 3 for an input sample x, and d2 is a distance function in t . during optimization, lg is minimized over g and ld is minimized over d. see fig. 1 for an illustration of our method.
eq. 3 and 4 make sure that the generated analogy, i.e., the output ofg, is in the target space t . since d is ternary and can therefore confuse classes in more than one way, this role, which is captured by eq. 1 in the baseline formulation, is split into two. however, the two equations do not enforce any similarity between the source sample x and the generated g(x). this is done by eq. 5 and 6: eq. 5 enforces f -constancy for x ∈ s, while eq. 6 enforces that for samples x ∈ t , which are already in the target space, g is the identity mapping. the latter is a desirable behavior, e.g., for the cartooning task, given an input emoji, one would like it to remain constant under the mapping of g. it can also be seen as an autoencoder type of loss, applied only to samples from t . the experiments reported in sec. 5 evaluate the contributions of lconst and ltid and reveal that at least one of these is required, and that when employing only one loss, lconst leads to a better performance than ltid.
the last loss, ltv is an anisotropic total variation loss (rudin , 1992; mahendran & vedaldi, 2015), which is added in order to slightly smooth the resulting image. the loss is defined on the generated image z = [zij ] = g(x) as
ltv (z) = ∑ i,j ( (zi,j+1 − zij)2 + (zi+1,j − zij)2 )b 2 , (7)
where we employ b = 1.
in our work, mse is used for both d and d2. we also experimented with replacing d2, which, in visual domains, compares images, with a second gan. no noticeable improvement was observed. throughout the experiments, the adaptive learning rate method adam by kingma & ba (2016) is used as the optimization algorithm.the domain transfer network (dtn) is evaluated in two application domains: digits and face images. in the first domain, we transfer images from the street view house number (svhn) dataset of netzer  (2011) to the domain of the mnist dataset by lecun & cortes (2010). in
the face domain, we transfer a set of random and unlabeled face images to a space of emoji images. in both cases, the source and target domains differ considerably.for working with digits, we employ the extra training split of svhn, which contains 531,131 images for two purposes: learning the function f and as an unsupervised training set s for the domain transfer method. the evaluation is done on the test split of svhn, comprised of 26,032 images. the architecture of f consists of four convolutional layers with 64, 128, 256, 128 filters respectively, each followed by max pooling and relu non-linearity. the error on the test split is 4.95%. even tough this accuracy is far from the best reported results, it seems to be sufficient for the purpose of domain transfer. within the dtn, f maps a 32 × 32 rgb image to the activations of the last convolutional layer of size 128× 1× 1 (post a 4× 4 max pooling and before the relu). in order to apply f on mnist images, we replicate the grayscale image three times.
the set t contains the test set of the mnist dataset. for supporting quantitative evaluation, we have trained a classifier on the train set of the mnist dataset, consisting of the same architecture as f . the accuracy of this classifier on the test set approaches perfect performance at 99.4% accuracy, and is, therefore, trustworthy as an evaluation metric. in comparison, the network f , achieves 76.08% accuracy on t.
network g, inspired by radford  (2015), maps svhn-trained f ’s 128d representations to 32× 32 grayscale images. g employs four blocks of deconvolution, batch-normalization, and relu, with a hyperbolic tangent terminal. the architecture ofd consists of four batch-normalized convolutional layers and employs relu. see radford  (2015) for more details on the networks architecture. in the digit experiments, the results were obtained with the tradeoff hyperparamemters α = β = 15. we did not observe a need to add a smoothness term and the weight of ltv was set to γ = 0.
despite not being very accurate on both domains (and also considerably worse than the svhn state of the art), we were able to achieve visually appealing domain transfer, as shown in fig. 2(a). in order to evaluate the contribution of each of the method’s components, we have employed the mnist network on the set of samples g(stest ) = {g(x)|x ∈ stest }, using the true svhn labels of the test set.
we first compare to the baseline method of sec. 3, where the generative function, which works directly with samples in s, is composed out of a few additional layers at the bottom of g. the results, shown in tab. 1, demonstrate that dtn has a clear advantage over the baseline method. in addition, the contribution of each one of the terms in the loss function is shown in the table. the regularization term ltid seems less crucial than the constancy term. however, at least one of them is required in order to obtain good performance. the gan constraints are also important. finally, the inclusion of f within the generator function g has a dramatic influence on the results.
as explained in sec. 2, domain transfer can be used in order to perform unsupervised domain adaptation. for this purposes, we transformed the set s to the mnist domain (as above), and using the true labels of s employed a simple nearest neighbor classifier there. the choice of classifier was
to emphasize the simplicity of the approach; however, the constraints of the unsupervised domain transfer problem would be respected for any classifier trained on g(s). the results of this experiment are reported in tab. 2, which shows a clear advantage over the state of the art method of ganin  (2016). this is true both when transferring the samples of the set s and when transferring the test set of svhn, which is much smaller and was not seen during the training of the dtn.another set of experiments was performed in order to study the ability of the domain transfer network to overcome the omission of a class of samples. this type of ablation can occur in the source or the target domain, or during the training of f and can help us understand the importance of each of these inputs. the results are shown visually in fig. 3, and qualitatively in tab. 3, based on the accuracy of the mnist classifier only on the transferred samples from the test set of svhn that belong to class ‘3’.
it is evident that not including the class in the source domain is much less detrimental than eliminating it from the target domain. this is the desirable behavior: never seeing any ‘3’-like shapes in t, the generator should not generate such samples. results are better when not observing ‘3’ in both s, t than when not seeing it only in t since in the latter case, g learns to map source samples of ‘3’ to target images of other classes.for face images, we use a set s of one million random images without identity information. the set t consists of assorted facial avatars (emoji) created by an online service (bitmoji.com). the emoji images were processed by a fully automatic process that localizes, based on a set of heuristics, the center of the irides and the tip of the nose. based on these coordinates, the emoji were centered and scaled into 152× 152 rgb images. as the function f , we employ the representation layer of the deepface network taigman  (2014). this representation is 256-dimensional and was trained on a labeled set of four million images that does not intersect the set s. network d takes 152 × 152 rgb images (either natural or scaled-up emoji) and consists of 6 blocks, each containing a convolution with stride 2, batch normalization, and a leaky relu with a parameter of 0.2. network g maps f ’s 256d representations to 64× 64 rgb images through a network with 5 blocks, each consisting of an upscaling convolution, batch-normalization and relu. adding 1 × 1 convolution to each block resulted in lower lconst training errors, and made g 9-layers deep. we set α = 100, β = 1, γ = 0.05 as the tradeoff hyperparameters within lg via validation. as expected, higher values of α resulted in better f -constancy, however introduced artifacts such as general noise or distortions. the network was trained for 3 epochs, the point where no further reduction of validation error was observed on lconst.
in order to upscale the 64 × 64 output to print quality, we used the method of dong  (2015), which was shown to work well on art. we did not retrain this network for our application, and apply the published one to the final output of our method after its training was finished. results without this upscale are shown, for comparison, in appendix c.
comparison with human annotators for evaluation purposes only, a team of professional annotators manually created an emoji, using a web service, for 118 random images from the celeba dataset (yang , 2015). fig. 4 shows side by side samples of the original image, the human generated emoji and the emoji generated by the learned generator function g. as can be seen, the automatically generated emoji tend to be more informative, albeit less restrictive than the ones created manually.
in order to evaluate the identifiability of the resulting emoji, we have collected a second example for each identity in the set of 118 celeba images and a set s′ of 100,000 random face images, which were not included in s. we then employed the vgg face cnn descriptor of parkhi  (2015) in order to perform retrieval as follows. for each image x in our manually annotated set, we create a gallery s′ ∪ x′, where x′ is the other image of the person in x. we then perform retrieval using the vgg face descriptor using either the manually created emoji or g(x) as probe.
the vgg network is used in order to avoid a bias that might be caused by using f both for training the dtn and for evaluation. the results are reported in tab. 4. as can be seen, the emoji generated by g are much more discriminative than the emoji created manually and obtain a median rank of 16 in cross-domain identification out of 105 distractors.
multiple images per person we evaluate the visual quality that is obtained per person and not just per image, by testing dtn on the facescrub dataset (ng & winkler, 2014). for each person p, we considered the set of their images xp, and selected the emoji that was most similar to their
source image: argmin x∈xp ||f(x)− f(g(x))|| (8)
this simple heuristic seems to work well in practice; the general problem of mapping a set x ⊂ s to a single output in t is left for future work. fig. 2(b) contains several examples from the facescrub dataset. for the complete set of identities, see appendix a.
transferring both identity and expression we also experimented with multiple expressions. as it turns out the face identification network f encodes enough expression information to support a successful transfer of both identity as well as expression, see appendix b.
network visualization the obtained mapping g can serve as a visualization tool for studying the properties of the face representation. this is studied in appendix d by computing the emoji generated for the standard basis of r256. the resulting images present a large amount of variability, indicating that g does not present a significant mode effect.fig. 5(a-c) demonstrates that neural style transfer gatys  (2016) cannot solve the photo to emoji transfer task in a convincing way. the output image is perhaps visually appealing; however, it does not belong to the space t of emoji. our result are given in fig. 5(d) for comparison. note that dtn is able to fix the missing hair in the image.
domain transfer is more general than style transfer in the sense that we can perform style transfer using a dtn. in order to show this, we have transformed, using the method of johnson  (2016), the training images of celeba based on the style of a single image (shown in fig. 5(e)). the original photos were used as the set s, and the transformed images were used as t. applying dtn, using face representation f , we obtained styled face images such as the one shown in the figure 5(f).asymmetry is central to our work. not only does our solution handle the two domains s and t differently, the function f is unlikely to be equally effective in both domains since in most practical cases, f would be trained on samples from one domain. while an explicit domain adaptation step can be added in order to make f more effective on the second domain, we found it to be unnecessary. adaptation of f occurs implicitly due to the application of d downstream.
using the same function f , we can replace the roles of the two domains, s and t . for example, we can synthesize an svhn image that resembles a given mnist image, or synthesize a face that matches an emoji. as expected, this yields less appealing results due to the asymmetric nature of f and the lower information content in these new source domains, see appendix e.
domain transfer, as an unsupervised method, could prove useful across a wide variety of computational tasks. here, we demonstrate the ability to use domain transfer in order to perform unsupervised domain adaptation. while this is currently only shown in a single experiment, the simplicity of performing domain adaptation and the fact that state of the art results were obtained effortlessly with a simple nearest neighbor classifier suggest it to be a promising direction for future research.in fig. 6 we show the full set of identities of the facescrub dataset, and their corresponding generated emoji.f may encode, in addition to identity, other data that is desirable to transfer. in the example of faces, this information might include expression, facial hair, glasses, pose, etc. in order to transfer such information, it is important that the set of samples in the target domain t present variability along the desirable dimensions. otherwise, the gan applied in the target domain (eq. 4) would maintain these dimensions fixed. the set t employed throughout our experiments in sec. 5.2 was constructed by sampling emoji of neutral expression. to support a smiling expression for example, we simply added to set t random smiling emoji and re-trained the dtn. the results, presented in fig. 7, demonstrate that f contains expression information in addition to identity information, and that this information is enough in order to transfer smiling photos to smiling emoji.as mentioned in sec. 5, in order to upscale the 64× 64 output to print quality, the method of dong  (2015) is used. fig. 8 shows the effect of applying this postprocessing step.fig. 9 depicts the face emoji generated by g for the standard basis of the face representation (taigman , 2014), viewed as the vector space r256.for completion, we present, in fig. 10 results obtained by performing domain transfer using dtns in the reverse direction of the one reported in sec. 5.",1
350.pdf.json,,"many of the most successful current deep learning architectures for vision rely on supervised learning from large sets of labeled training images. while the performance of these networks is undoubtedly impressive, reliance on such large numbers of training examples limits the utility of deep learning in many domains where such datasets are not available. furthermore, the need for large numbers of labeled examples stands at odds with human visual learning, where one or a few views of an object is often all that is needed to enable robust recognition of that object across a wide range of different views, lightings and contexts. the development of a representation that facilitates such abilities, especially in an unsupervised way, is a largely unsolved problem.
in addition, while computer vision models are typically trained using static images, in the real world, visual objects are rarely experienced as disjoint snapshots. instead, the visual world is alive with movement, driven both by self-motion of the viewer and the movement of objects within the scene. many have suggested that temporal experience with objects as they move and undergo transformations can serve as an important signal for learning about the structure of objects (földiák, 1991; softky, 1996; wiskott & sejnowski, 2002; george & hawkins, 2005; palm, 2012; o’reilly , 2014; agrawal , 2015; goroshin , 2015a; lotter , 2015; mathieu , 2016; srivastava , 2015; wang & gupta, 2015; whitney , 2016). for instance, wiskott and sejnowski proposed “slow feature analysis” as a framework for exploiting temporal structure in video streams (wiskott & sejnowski, 2002). their approach attempts to build feature representations that extract
code and video examples can be found at: https://coxlab.github.io/prednet/
slowly-varying parameters, such as object identity, from parameters that produce fast changes in the image, such as movement of the object. while approaches that rely on temporal coherence have arguably not yet yielded representations as powerful as those learned by supervised methods, they nonetheless point to the potential of learning useful representations from video (mohabi , 2009; sun , 2014; goroshin , 2015a; maltoni & lomonaco, 2015; wang & gupta, 2015).
here, we explore another potential principle for exploiting video for unsupervised learning: prediction of future image frames (softky, 1996; palm, 2012; o’reilly , 2014; goroshin , 2015b; srivastava , 2015; mathieu , 2016; patraucean , 2015; finn , 2016; vondrick , 2016). a key insight here is that in order to be able to predict how the visual world will change over time, an agent must have at least some implicit model of object structure and the possible transformations objects can undergo. to this end, we have designed a neural network architecture, which we informally call a “prednet,” that attempts to continually predict the appearance of future video frames, using a deep, recurrent convolutional network with both bottom-up and topdown connections. our work here builds on previous work in next-frame video prediction (ranzato , 2014; michalski , 2014; srivastava , 2015; mathieu , 2016; lotter , 2015; patraucean , 2015; oh , 2015; finn , 2016; xue , 2016; vondrick , 2016; brabandere , 2016), but we take particular inspiration from the concept of “predictive coding” from the neuroscience literature (rao & ballard, 1999; rao & sejnowski, 2000; lee & mumford, 2003; friston, 2005; summerfield , 2006; egner , 2010; bastos , 2012; spratling, 2012; chalasani & principe, 2013; clark, 2013; o’reilly , 2014; kanai , 2015). predictive coding posits that the brain is continually making predictions of incoming sensory stimuli (rao & ballard, 1999; friston, 2005). top-down (and perhaps lateral) connections convey these predictions, which are compared against actual observations to generate an error signal. the error signal is then propagated back up the hierarchy, eventually leading to an update of the predictions.
we demonstrate the effectiveness of our model for both synthetic sequences, where we have access to the underlying generative model and can investigate what the model learns, as well as natural videos. consistent with the idea that prediction requires knowledge of object structure, we find that these networks successfully learn internal representations that are well-suited to subsequent recognition and decoding of latent object parameters (e.g. identity, view, rotation speed, etc.). we also find that our architecture can scale effectively to natural image sequences, by training using car-mounted camera videos. the network is able to successfully learn to predict both the movement of the camera and the movement of objects in the camera’s view. again supporting the notion of prediction as an unsupervised learning rule, the model’s learned representation in this setting supports decoding of the current steering angle.the prednet architecture is diagrammed in figure 1. the network consists of a series of repeating stacked modules that attempt to make local predictions of the input to the module, which is then subtracted from the actual input and passed along to the next layer. briefly, each module of the network consists of four basic parts: an input convolutional layer (al), a recurrent representation layer (rl), a prediction layer (âl), and an error representation (el). the representation layer, rl, is a recurrent convolutional network that generates a prediction, âl, of what the layer input, al, will be on the next frame. the network takes the difference between al and âl and outputs an error representation, el, which is split into separate rectified positive and negative error populations. the error, el, is then passed forward through a convolutional layer to become the input to the next layer (al+1). the recurrent prediction layerrl receives a copy of the error signalel, along with top-down input from the representation layer of the next level of the network (rl+1). the organization of the network is such that on the first time step of operation, the “right” side of the network (al’s andel’s) is equivalent to a standard deep convolutional network. meanwhile, the “left” side of the network (the rl’s) is equivalent to a generative deconvolutional network with local recurrence at each stage. the architecture described here is inspired by that originally proposed by (rao & ballard, 1999), but is formulated in a modern deep learning framework and trained end-to-end using gradient descent, with a loss function implicitly embedded in the network as the firing rates of the error neurons. our work also shares motivation with the deep predictive coding networks of chalasani & principe (2013); however, their framework is based upon sparse coding and a linear dynamical system with greedy layer-wise training, whereas ours is rooted in convolutional and recurrent neural networks trained with backprop.
while the architecture is general with respect to the kinds of data it models, here we focus on image sequence (video) data. consider a sequence of images, xt. the target for the lowest layer is set to the the actual sequence itself, i.e. at0 = xt ∀t. the targets for higher layers, atl for l > 0, are computed by a convolution over the error units from the layer below, etl−1, followed by rectified linear unit (relu) activation and max-pooling. for the representation neurons, we specifically use convolutional lstm units (hochreiter & schmidhuber, 1997; shi , 2015). in our setting, the rtl hidden state is updated according to r t−1 l , e t−1 l , as well as r t l+1, which is first spatially upsampled (nearest-neighbor), due to the pooling present in the feedforward path. the predictions, âtl are made through a convolution of the r t l stack followed by a relu non-linearity. for the lowest layer, âtl is also passed through a saturating non-linearity set at the maximum pixel value: satlu(x; pmax) := min(pmax, x). finally, the error response, etl , is calculated from the difference between âtl and a t l and is split into relu-activated positive and negative prediction errors, which are concatenated along the feature dimension. as discussed in (rao & ballard, 1999), although not explicit in their model, the separate error populations are analogous to the existence of on-center, off-surround and off-center, on-surround neurons early in the visual system.
the full set of update rules are listed in equations (1) to (4). the model is trained to minimize the weighted sum of the activity of the error units. explicitly, the training loss is formalized in equation 5 with weighting factors by time, λt, and layer, λl, and where nl is the number of units in the lth layer. with error units consisting of subtraction followed by relu activation, the loss at each layer is equivalent to an l1 error. although not explored here, other error unit implementations, potentially even probabilistic or adversarial (goodfellow , 2014), could also be used.
atl = { xt if l = 0 maxpool(relu(conv(etl−1))) l > 0
(1)
âtl = relu(conv(r t l)) (2)
etl = [relu(a t l − âtl); relu(âtl −atl)] (3) rtl = convlstm(e t−1 l , r t−1 l ,upsample(r t l+1)) (4)
ltrain = ∑ t λt ∑ l λl nl ∑ nl etl (5)
algorithm 1 calculation of prednet states require: xt : at0 ← xt 2: e0l , r 0 l ← 0 3: for t = 1 to t do 4: for l = l to 0 do . update rtl states 5: if l = l then 6: rtl = convlstm(e t−1 l , r t−1 l ) 7: else 8: rtl = convlstm(e t−1 l , r t−1 l ,upsample(r t l+1)) : for l = 0 to l do . update âtl , atl , etl states 10: if l = 0 then 11: ât0 = satlu(relu(conv(r t 0))) 12: else 13: âtl = relu(conv(r t l )) 14: etl = [relu(a t l − âtl); relu(âtl −alt)] 15: if l < l then 16: atl+1 = maxpool(conv(e l t))
the order in which each unit in the model is updated must also be specified, and our implementation is described in algorithm 1. updating of states occurs through two passes: a top-down pass where the rtl states are computed, and then a forward pass to calculate the predictions, errors, and higher level targets. a last detail of note is that rl and el are initialized to zero, which, due to the convolutional nature of the network, means that the initial prediction is spatially uniform.to gain an understanding of the representations learned in the proposed framework, we first trained prednet models using synthetic images, for which we have access to the underlying generative stimulus model and all latent parameters. we created sequences of rendered faces rotating with two degrees of freedom, along the “pan” (out-of-plane) and “roll” (in-plane) axes. the faces start at a random orientation and rotate at a random constant velocity for a total of 10 frames. a different face was sampled for each sequence. the images were processed to be grayscale, with values normalized between 0 and 1, and 64x64 pixels in size. we used 16k sequences for training and 800 for both validation and testing.
predictions generated by a prednet model are shown in figure 2. the model is able to accumulate information over time to make accurate predictions of future frames. since the representation neurons are initialized to zero, the prediction at the first time step is uniform. on the second time step, with no motion information yet, the prediction is a blurry reconstruction of the first time step. after further iterations, the model adapts to the underlying dynamics to generate predictions that closely match the incoming frame.
for choosing the hyperparameters of the model, we performed a random search and chose the model that had the lowest l1 error in frame prediction averaged over time steps 2-10 on a validation set. given this selection criteria, the best performing models tended to have a loss solely concentrated at the lowest layer (i.e. λ0 = 1, λl>0 = 0), which is the case for the model shown. using an equal loss at each layer considerably degraded predictions, but enforcing a moderate loss on upper layers that was one magnitude smaller than the lowest layer (i.e. λ0 = 1, λl>0 = 0.1) led to only slightly worse predictions, as illustrated in figure 9 in the appendix. in all cases, the time loss weight, λt, was set to zero for the first time step and then one for all time steps after. as for the remaining hyperparameters, the model shown has 5 layers with 3x3 filter sizes for all convolutions, max-pooling of stride 2, and number of channels per layer, for bothal andrl units, of (1, 32, 64, 128, 256). model weights were optimized using the adam algorithm (kingma & ba, 2014).
actual
predicted
actual
predicted
actual
predicted
quantitative evaluation of generative models is a difficult, unsolved problem (theis , 2016), but here we report prediction error in terms of meansquared error (mse) and the structural similarity index measure (ssim) (wang , 2004). ssim is designed to be more correlated with perceptual judgments, and ranges from−1 and 1, with a larger score indicating greater similarity. we compare the prednet to the trivial solution of copying the last
frame, as well as a control model that shares the overall architecture and training scheme of the prednet, but that sends forward the layer-wise activations (al) rather than the errors (el). this model thus takes the form of a more traditional encoder-decoder pair, with a cnn encoder that has lateral skip connections to a convolutional lstm decoder. the performance of all models on the rotating faces dataset is summarized in table 1, where the scores were calculated as an average over all predictions after the first frame. we report results for the prednet model trained with loss only on the lowest layer, denoted as prednet l0, as well as the model trained with an 0.1 weight on upper layers, denoted as prednet lall. both prednet models outperformed the baselines on both measures, with the l0 model slightly outperforming lall, as expected for evaluating the pixel-level predictions.
synthetic sequences were chosen as the initial training set in order to better understand what is learned in different layers of the model, specifically with respect to the underlying generative model (kulkarni , 2015). the rotating faces were generated using the facegen software package (singular inversions, inc.), which internally generates 3d face meshes by a principal component analysis in “face space”, derived from a corpus of 3d face scans. thus, the latent parameters of the image sequences used here consist of the initial pan and roll angles, the pan and roll velocities, and the principal component (pc) values, which control the “identity” of the face. to understand the information contained in the trained models, we decoded the latent parameters from the representation neurons (rl) in different layers, using a ridge regression. the rl states were taken at the earliest possible informative time steps, which, in the our notation, are the second and third steps, respectively, for the static and dynamic parameters. the regression was trained using 4k sequences with 500 for validation and 1k for testing. for a baseline comparison of the information implicitly embedded in the network architecture, we compare to the decoding accuracies of an untrained network with random initial weights. note that in this randomly initialized case, we still expect above-chance decoding performance, given past theoretical and empirical work with random networks (pinto , 2009; jarrett , 2009; saxe , 2010).
latent variable decoding accuracies of the pan and roll velocities, pan initial angle, and first pc are shown in the left panel of figure 3. there are several interesting patterns. first, the trained models learn a representation that generally permits a better linear decoding of the underlying latent factors than the randomly initialized model, with the most striking difference in terms of the the pan rotation speed (αpan). second, the most notable difference between the lall and l0 versions occurs with the first principle component, where the model trained with loss on all layers has a higher decoding accuracy than the model trained with loss only on the lowest layer.
the latent variable decoding analysis suggests that the model learns a representation that may generalize well to other tasks for which it was not explicitly trained. to investigate this further, we assessed the models in a classification task from single, static images. we created a dataset of 25 previously unseen facegen faces at 7 pan angles, equally spaced between [−π2 , π 2 ], and 8 roll angles, equally spaced between [0, 2π). there were therefore 7 · 8 = 56 orientations per identity, which were tested in a cross-validated fashion. a linear svm to decode face identity was fit on a model’s representation of a random subset of orientations and then tested on the remaining angles. for each size of the svm training set, ranging from 1-40 orientations per face, 50 different random splits were generated, with results averaged over the splits.
for the static face classification task, we compare the prednets to a standard autoencoder and a variant of the ladder network (valpola, 2015; rasmus , 2015). both models were constructed to have the same number of layers and channel sizes as the prednets, as well as a similar alternating convolution/max-pooling, then upsampling/convolution scheme. as both networks are autoencoders, they were trained with a reconstruction loss, with a dataset consisting of all of the individual frames from the sequences used to train the prednets. for the ladder network, which is a denoising autoencoder with lateral skip connections, one must also choose a noise parameter, as well as the relative weights of each layer in the total cost. we tested noise levels ranging from 0 to 0.5 in increments of 0.1, with loss weights either evenly distributed across layers, solely concentrated at the pixel layer, or 1 at the bottom layer and 0.1 at upper layers (analogous to the prednet lall model). shown is the model that performed best for classification, which consisted of 0.4 noise and only pixel weighting. lastly, as in our architecture, the ladder network has lateral and top-down streams that are combined by a combinator function. inspired by (pezeshki , 2015), where a learnable mlp improved results, and to be consistent in comparing to the prednet, we used a purely convolutional combinator. given the distributed representation in both networks, we decoded from a concatenation of the feature representations at all layers, except the pixel layer. for the prednets, the representation units were used and features were extracted after processing one input frame.
face classification accuracies using the representations learned by the l0 and lall prednets, a standard autoencoder, and a ladder network variant are shown in the right panel of figure 3. both prednets compare favorably to the other models at all sizes of the training set, suggesting they learn a representation that is relatively tolerant to object transformations. similar to the decoding accuracy of the first principle component, the prednet lall model actually outperformed the l0 variant. altogether, these results suggest that predictive training with the prednet can be a viable alternative to other models trained with a more traditional reconstructive or denoising loss, and that the relative layer loss weightings (λl’s) may be important for the particular task at hand.we next sought to test the prednet architecture on complex, real-world sequences. as a testbed, we chose car-mounted camera videos, since these videos span across a wide range of settings and are characterized by rich temporal dynamics, including both self-motion of the vehicle and the motion of other objects in the scene (agrawal , 2015). models were trained using the raw videos from the kitti dataset (geiger , 2013), which were captured by a roof-mounted camera on a car driving around an urban environment in germany. sequences of 10 frames were sampled from the “city”, “residential”, and “road” categories, with 57 recording sessions used for training and 4 used for validation. frames were center-cropped and downsampled to 128x160 pixels. in total, the training set consisted of roughly 41k frames.
a random hyperparameter search, with model selection based on the validation set, resulted in a 4 layer model with 3x3 convolutions and layer channel sizes of (3, 48, 96, 192). models were again trained with adam (kingma & ba, 2014) using a loss either solely computed on the lowest layer (l0) or with a weight of 1 on the lowest layer and 0.1 on the upper layers (lall). adam parameters were initially set to their default values (α = 0.001, β1 = 0.9, β2 = 0.999) with the learning rate, α, decreasing by a factor of 10 halfway through training. to assess that the network had indeed learned a robust representation, we tested on the caltech pedestrian dataset (dollár , 2009), which consists of videos from a dashboard-mounted camera on a vehicle driving around los angeles. testing sequences were made to match the frame rate of the kitti dataset and again cropped to 128x160 pixels. quantitative evaluation was performed on the entire caltech test partition, split into sequences of 10 frames.
sample prednet predictions (for the l0 model) on the caltech pedestrian dataset are shown in figure 4, and example videos can be found at https://coxlab.github.io/prednet/. the model is able to make fairly accurate predictions in a wide range of scenarios. in the top sequence of fig. 4, a car is passing in the opposite direction, and the model, while not perfect, is able to predict its trajectory, as well as fill in the ground it leaves behind. similarly in sequence 3, the model is able to predict the motion of a vehicle completing a left turn. sequences 2 and 5 illustrate that the prednet can judge its own movement, as it predicts the appearance of shadows and a stationary vehicle as they approach. the model makes reasonable predictions even in difficult scenarios, such as when the camera-mounted vehicle is turning. in sequence 4, the model predicts the position of a tree, as the vehicle turns onto a road. the turning sequences also further illustrate the model’s ability to “fill-in”, as it is able to extrapolate sky and tree textures as unseen regions come into view. as an additional control, we show a sequence at the bottom of fig. 4, where the input has been temporally scrambled. in this case, the model generates blurry frames, which mostly just resemble the previous frame. finally, although the prednet shown here was trained to predict one frame ahead, it is also possible to predict multiple frames into the future, by feeding back predictions as the inputs and recursively iterating. we explore this in appendix 5.3.
quantitatively, the prednet models again outperformed the cnn-lstm encoderdecoder. to ensure that the difference in performance was not simply because of the choice of hyperparameters, we trained models with four other sets of hyperparameters, which were sampled from the initial random search over the number of layers, filter sizes, and number of filters per layer. for each of the four additional sets, the prednet l0 had the best performance, with an average error reduction of 14.7% and 14.9% for mse and ssim,
respectively, compared to the cnn-lstm encoder-decoder. more details, as well as a thorough investigation of systematically simplified models on the continuum between the prednet and the cnn-lstm encoder-decoder can be found in appendix 5.1. briefly, the elementwise subtraction operation in the prednet seems to be beneficial, and the nonlinearity of positive.egative splitting also adds modest improvements. finally, while these experiments measure the benefits of each component of our model, we also directly compare against recent work in a similar car-cam setting, by reporting results on a 64x64 pixel, grayscale car-cam dataset released by brabandere  (2016). our prednet model outperforms the model by brabandere  (2016) by 29%. details can be found in appendix 5.2. also in appendix 5.2, we present results for the human3.6m (ionescu , 2014) dataset, as reported by finn  (2016). without re-optimizing hyperparameters, our
model underperforms the concurrently developed dna model by finn  (2016), but outperforms the model by mathieu  (2016).
to test the implicit encoding of latent parameters in the car-cam setting, we used the internal representation in the prednet to estimate the car’s steering angle (bojarski , 2016; biasini , 2016). we used a dataset released by comma.ai (biasini , 2016) consisting of 11 videos totaling about 7 hours of mostly highway driving. we first trained networks for next-frame prediction and then fit a linear fully-connected layer on the learned representation to estimate the steering angle, using a mse loss. we again concatenate the rl representation at all layers, but first spatially average pool lower layers to match the spatial size of the upper layer, in order to reduce dimensionality. steering angle estimation results, using the representation on the 10th time step, are shown in figure 5. given just 1k labeled training examples, a simple linear readout on the prednet l0 representation explains 74% of the variance in the steering angle and outperforms the cnn-lstm enc.-dec. by 35%. with 25k labeled training examples, the prednet l0 has a mse (in degrees2) of 2.14. as a point of reference, a cnn model designed to predict the steering angle (biasini , 2016), albeit from a single frame instead of multiple frames, achieve a mse of ~4 when trained end-to-end using 396k labeled training examples. details of this analysis can be found in appendix 8. interestingly, in this task, the prednet lall model actually underperformed the l0 model and slightly underperformed the cnn-lstm enc.-dec, again suggesting that the λl parameter can affect the representation learned, and different values may be preferable in different end tasks. nonetheless, the readout from the lall model still explained a substantial proportion of the steering angle variance and strongly outperformed the random initial weights. overall, this analysis again demonstrates that a representation learned through prediction, and particularly with the prednet model with appropriate hyperparameters, can contain useful information about underlying latent parameters.above, we have demonstrated a predictive coding inspired architecture that is able to predict future frames in both synthetic and natural image sequences. importantly, we have shown that learning to predict how an object or scene will move in a future frame confers advantages in decoding latent parameters (such as viewing angle) that give rise to an object’s appearance, and can improve recognition performance. more generally, we argue that prediction can serve as a powerful unsupervised learning signal, since accurately predicting future frames requires at least an implicit model of the objects that make up the scene and how they are allowed to move. developing a deeper understanding of the nature of the representations learned by the networks, and extending the architecture, by, for instance, allowing sampling, are important future directions.we would like to thank rasmus berg palm for fruitful discussions and early brainstorming. we would also like to thank the developers of keras (chollet, 2016). this work was supported by iarpa (contract d16pc00002), the national science foundation (nsf iis 1409097), and the center for brains, minds and machines (cbmm, nsf stc award ccf-1231216).table 3 contains results for additional variations of the prednet and cnn-lstm encoder-decoder evaluated on the caltech pedestrian dataset after being trained on kitti. we evaluate the models in terms of pixel prediction, thus using the prednet model trained with loss only on the lowest layer (prednet l0) as the base model. in addition to mean-squared error (mse) and the structural similarity index measure (ssim), we include calculations of the peak signal-to-noise ratio (psnr). for each model, we evaluate it with the original set of hyperparameters (controlling the number of layers, filter sizes, and number of filters per layer), as well as with the four additional sets of hyperparameters that were randomly sampled from the initial random search (see main text for more details). below is an explanation of the additional control models:
mse (x 10−3) psnr ssim prednet 3.13 (3.33) 25.8 (25.5) 0.884 (0.878) prednet (no el split) 3.20 (3.37) 25.6 (25.4) 0.883 (0.878) cnn-lstm enc.-dec. 3.67 (3.91) 25.0 (24.6) 0.865 (0.856) cnn-lstm enc.-dec. (2x al filts) 3.82 (3.97) 24.8 (24.6) 0.857 (0.853) cnn-lstm enc.-dec. (except pass e0) 3.41 (3.61) 25.4 (25.1) 0.873 (0.866) cnn-lstm enc.-dec. (+/- split) 3.71 (3.84) 24.9 (24.7) 0.861 (0.857) copy last frame 7.95 20.0 0.762
equalizing the number of filters in the cnn-lstm encoder-decoder (2x al filts) cannot account for its performance difference with the prednet, and actually leads to overfitting and a decrease in performance. passing the error at the lowest layer (e0) in the cnn-lstm enc.-dec. improves performance, but still does not match the prednet, where errors are passed at all layers. finally, splitting the activationsal into positive and negative populations in the cnn-lstm enc.-dec. does not help, but the prednet with linear error activation (“no el split”) performs slightly worse than the original split version. together, these results suggest that the prednet’s error passing operation can lead to improvements in next-frame prediction performance.while our main comparison in the text was a control model that isolates the effects of the more unique components in the prednet, here we directly compare against other published models. we report results on a 64x64 pixel, grayscale car-cam dataset and the human3.6m dataset (ionescu , 2014) to compare against the two concurrently developed models by brabandere  (2016)
and finn  (2016), respectively. for both comparisons, we use a model with the same hyperparameters (# of layers, # of filters, etc.) of the prednet l0 model trained on kitti, but train from scratch on the new datasets. the only modification we make is to train using an l2 loss instead of the effective l1 loss, since both models train with an l2 loss and report results using l2-based metrics (mse for brabandere  (2016) and psnr for finn  (2016)). that is, we keep the original prednet model intact but directly optimize using mse between actual and predicted frames. we measure next-frame prediction performance after inputting 3 frames and 10 frames, respectively, for the 64x64 car-cam and human3.6m datasets, to be consistent with the published works. we also include the results using a feedforward multi-scale network, similar to the model of mathieu  (2016), on human3.6m, as reported by finn  (2016).
on a dataset similar to kitti, our model outperforms the model proposed by brabandere  (2016). on human3.6m, our model outperforms a model similar to (mathieu , 2016), but underperforms finn  (2016), although we note we did not perform any hyperparameter optimization.while the models presented here were originally trained to predict one frame ahead, they can be made to predict multiple frames by treating predictions as actual input and recursively iterating. examples of this process are shown in figure 6 for the prednet l0 model. although the next frame predictions are reasonably accurate, the model naturally breaks down when extrapolating further into the future. this is not surprising since the predictions will unavoidably have different statistics than the natural images for which the model was trained to handle (bengio , 2015). if we additionally train the model to process its own predictions, the model is better able to extrapolate. the third row for every sequence shows the output of the original prednet fine-tuned for extrapolation. starting from the trained weights, the model was trained with a loss over 15 time steps, where the actual frame was inputted for the first 10 and then the model’s predictions were used as input to the network for the last 5. for the first 10 time steps, the training loss was calculated on the el activations as usual, and for the last 5, it was calculated directly as the mean absolute error with respect to the ground truth frames. despite eventual blurriness (which might be expected to some extent due to uncertainty), the fine-tuned model captures some key structure in its extrapolations after the tenth time step. for instance, in the first sequence, the model estimates the general shape of an upcoming shadow, despite minimal information in the last seen frame. in the second sequence, the model is able to extrapolate the motion of a car moving to the right. the reader is again encouraged to visit https://coxlab.github.io/prednet/ to view the predictions in video form. quantitatively, the mse of the model’s predictions stay well below the trivial solution of copying the last seen frame, as illustrated in fig 7. the mse increases fairly linearly from time steps 2-10, even though the model was only trained for up to t+ 5 prediction.in figure 8, we show the steering angle estimation accuracy on the comma.ai (biasini , 2016) dataset using the representation learned by the prednet l0 model, as a function of the number of frames inputted into the model. the prednet’s representation at all layers was concatenated (after spatially pooling lower layers to a common spatial resolution) and a fully-connected readout was fit using mse. for each level of the number of training examples, we average over 10 cross-validation splits. to serve as points of reference, we include results for two static models. the first model is an autoencoder trained on single frame reconstruction with appropriately matching hyperparameters. a fully-connected layer was fit on the autoencoder’s representation to estimate the steering angle in the same fashion as the prednet. the second model is the default model in the posted comma.ai code (biasini , 2016), which is a five layer cnn. this model is trained end-to-end to estimate
the steering angle given the current frame as input, with a mse loss. in addition to 25k examples, we trained a version using all of the frames in the comma dataset (~396k). for all models, the final weights were chosen at the minimum validation error during training. given the relatively small number of videos in the dataset compared to the average duration of each video, we used 5% of each video for validation and testing, chosen as a random continuous chunk, and discarded the 10 frames before and after the chosen segments from the training set.
as illustrated in figure 8, the prednet’s performance gets better over time, as one might expect, as the model is able to accumulate more information. interestingly, it performs reasonably well after just one time step, in a regime that is orthogonal to the training procedure of the prednet where there are no dynamics. altogether, these results again point to the usefulness of the model in learning underlying latent parameters. .5 prednet lall next-frame predictions
figures 9 and 10 compare next-frame predictions by the prednet lall model, trained with a prediction loss on all layers (λ0 = 1, λl>0 = 0.1), and the prednet l0 model, trained with a loss only on the lowest layer. at first glance, the difference in predictions seem fairly minor, and indeed, in terms of mse, the lall model only underperformed the l0 version by 3% and 6%, respectively, for the rotating faces and caltech pedestrian datasets. upon careful inspection, however, it is apparent that the lall predictions lack some of the finer details of the l0 predictions and are more blurry in regions of high variance. for instance, with the rotating faces, the facial features are less defined and with caltech, details of approaching shadows and cars are less precise.
actual
prednet 𝐿0
prednet 𝐿𝑎𝑙𝑙
error 𝐿𝑎𝑙𝑙 - 𝐿0
actual
prednet 𝐿0
prednet 𝐿𝑎𝑙𝑙
error 𝐿𝑎𝑙𝑙 - 𝐿0
actual
prednet 𝐿0
prednet 𝐿𝑎𝑙𝑙
error 𝐿𝑎𝑙𝑙 - 𝐿0
actual
prednet 𝐿0
prednet 𝐿𝑎𝑙𝑙
error 𝐿𝑎𝑙𝑙 - 𝐿0",1
355.pdf.json,,"deep reinforcement learning has achieved super-human performance in fully observable environments, e.g., in atari games [mnih  (2015)] and computer go [silver  (2016)]. recently, asynchronous advantage actor-critic (a3c) [mnih  (2016)] model shows good performance for 3d environment exploration, e.g. labyrinth exploration. however, in general, to train an agent in a partially observable 3d environment from raw frames remains an open challenge. direct application of a3c to competitive 3d scenarios, e.g. 3d games, is nontrivial, partly due to sparse and long-term rewards in such scenarios.
doom is a 1993 first-person shooter (fps) game in which a player fights against other computercontrolled agents or human players in an adversarial 3d environment. previous works on fps ai [van waveren (2001)] focused on using hand-tuned state machines and privileged information, e.g., the geometry of the map, the precise location of all players, to design playable agents. although state-machine is conceptually simple and computationally efficient, it does not operate like human players, who only rely on visual (and possibly audio) inputs. also, many complicated situations require manually-designed rules which could be time-consuming to tune.
in this paper, we train an ai agent in doom with a framework that based on a3c with convolutional neural networks (cnn). this model uses only the recent 4 frames and game variables from the ai side, to predict the next action of the agent and the value of the current situation. we follow the curriculum learning paradigm [bengio  (2009); jiang  (2015)]: start from simple tasks and then gradually try harder ones. the difficulty of the task is controlled by a variety of parameters in doom environment, including different types of maps, strength of the opponents and the design of the reward function. we also develop adaptive curriculum training that samples from a varying distribution of tasks to train the model, which is more stable and achieves higher score than a3c with the same number of epoch. as a result, our trained agent, named f1, won the champion in track 1 of vizdoom competition 1 by a large margin.
there are many contemporary efforts on training a doom ai based on the vizdoom platform [kempka  (2016)] since its release. arnold [lample & chaplot (2016)] also uses game frames and trains an action network using deep recurrent q-learning [hausknecht & stone (2015)], and a navigation network with dqn [mnih  (2015)]. however, there are several important differences. to predict the next action, they use a hybrid architecture (cnn+lstm) that involves more complicated training procedure. second, in addition to game frames, they require internal http://vizdoom.cs.put.edu.pl/competition-cig-2016/results
game status about the opponents as extra supervision during training, e.g., whether enemy is present in the current frame. intelact [dosovitskiy & koltun (2017)] models the doom ai bot training in a supervised manner by predicting the future values of game variables (e.g., health, amount of ammo, etc) and acting accordingly. in comparison, we use curriculum learning with asynchronized actorcritic models and use stacked frames (4 most recent frames) and resized frames to mimic short-term memory and attention. our approach requires no opponent’s information, and is thus suitable as a general framework to train agents for close-source games.
in vizdoom ai competition 2016 at ieee computational intelligence and games (cig) conference2, our ai won the champion of track1 (limited deathmatch with known map), and intelact won the champion of track2 (full deathmatch with unknown maps). neither of the two teams attends the other track. arnold won the second places of both tracks and clyde [ratcliffe  (2017)] won the third place of track1.the goal of reinforcement learning (rl) is to train an agent so that its behavior maximizes/minimizes expected future rewards/penalties it receives from a given environment [sutton & barto (1998)]. two functions play important roles: a value function v (s) that gives the expected reward of the current state s, and a policy function π(a|s) that gives a probability distribution on the candidate actions a for the current state s. getting the groundtruth value of either function would largely solve rl: the agent just follows π(a|s) to act, or jumps in the best state provided by v (s) when the number of candidate next states is finite and practically enumerable. however, neither is trivial.
actor-critic models [barto  (1983); sutton (1984); konda & tsitsiklis (1999); grondman  (2012)] aim to jointly estimate v (s) and π(a|s): from the current state st, the agent explores the environment by iteratively sampling the policy function π(at|st;wπ) and receives positive.egative reward, until the terminal state or a maximum number of iterations are reached. the exploration gives a trajectory {(st, at, rt), (st+1, at+1, rt+1), · · · }, from which the policy function and value function are updated. specifically, to update the value function, we use the expected reward rt along the trajectory as the ground truth; to update the policy function, we encourage actions that lead to high rewards, and penalize actions that lead to low rewards. to determine whether an action leads to high- or low-rewarding state, a reference point, called baseline [williams (1992)], is usually needed. using zero baseline might increase the estimation variance. [peters & schaal (2008)] gives a way to estimate the best baseline (a weighted sum of cumulative rewards) that minimizes the variance of the gradient estimation, in the scenario of episodic reinforce [williams (1992)].
in actor-critic frameworks, we pick the baseline as the expected cumulative reward v (s) of the current state, which couples the two functions v (s) and π(a|s) together in the training, as shown in fig. 1. here the two functions reinforce each other: a correct π(a|s) gives high-rewarding trajectories which update v (s) towards the right direction; a correct v (s) picks out the correct actions for π(a|s) to reinforce. this mutual reinforcement behavior makes actor-critic model converge faster, but is also prone to converge to bad local minima, in particular for on-policy models that follow the very recent policy to sample trajectory during training. if the experience received by the agent in consecutive batches is highly correlated and biased towards a particular subset of the environment, then both π(a|s) and v (s) will be updated towards a biased direction and the agent may never see http://vizdoom.cs.put.edu.pl/competition-cig-2016
the whole picture. to reduce the correlation of game experience, asynchronous advantage actorcritic model [mnih  (2016)] runs independent multiple threads of the game environment in parallel. these game instances are likely uncorrelated, therefore their experience in combination would be less biased.
for on-policy models, the same mutual reinforcement behavior will also lead to highly-peaked π(a|s) towards a few actions (or a few fixed action sequences), since it is always easy for both actor and critic to over-optimize on a small portion of the environment, and end up “living in their own realities”. to reduce the problem, [mnih  (2016)] added an entropy term to the loss to encourage diversity, which we find to be critical. the final gradient update rules are listed as follows:
wπ ← wπ + α(rt − v (st))∇wπ log π(at|st) + β∇wπh(π(·|st)) (1) wv ← wv − α∇wv (rt − v (st)) 2 (2)
where rt = ∑ t t′=t γt ′ −trt′ is the expected discounted reward at time t and α, β are the learning rate. in this work, we use huber loss instead of the l2 loss in eqn. 2.
architecture. while [mnih  (2016)] keeps a separate model for each asynchronous agent and perform model synchronization once in a while, we use an alternative approach called batcha3c, in which all agents act on the same model and send batches to the main process for gradient descent optimization. the agents’ models are updated after each gradient update. note that the contemporary work ga3c [babaeizadeh  (2017)] also proposes a similar architecture. in their architecture, there is a prediction queue that collects agents’ experience and sends them to multiple predictors, and a training queue that collects experience to feed the optimization.in doom, the player controls the agent to fight against enemies in a 3d environment (e.g., in a maze). the agent can only see the environment from his viewpoint and thus receives partial information upon which it makes decisions. on modern computers, the original doom runs in thousands of frames per second, making it suitable as a platform for training ai agent. vizdoom [kempka  (2016)] is an open-source platform that offers programming interface to communicate with doom engine, zdoom3. from the interface, users can obtain current frames of the game, and control the agent’s action. vizdoom offers much flexibility, including:
rich scenarios. many customized scenarios are made due to the popularity of the game, offering a variety of environments to train from. a scenario consists of many components, including 2d maps for the environment, scripts to control characters and events. open-source tools, such as https://zdoom.org/
slade4, are also widely available to build new scenarios. we built our customized map (fig. 2(b)) for training.
game variables. in addition to image frames, vizdoom environment also offers many games variables revealing the internal state of the game. this includes health, ammo ? (agent’s health and ammunition), frag count (current score) and so on. vizdoom also offers user? variables that are computed on the fly via scenario scripts. these user? variables can provide more information of the agent, e.g., their spatial locations. enemy information could also be obtained by modifying vizdoom [lample & chaplot (2016)]. such information is used to construct a reward function, or as a direct supervision to accelerate training [lample & chaplot (2016)].
built-in bots. built-in bots can be inserted in the battle. they are state machines with privileged information over the map and the player, which results in apparently decent intelligence with minimal computational cost. by competing against built-in bots, the agent learns to improve.
evaluation criterion. in fps games, to evaluate their strength, multiple ais are placed to a scenario for a deathmatch, in which every ai plays for itself against the remaining ais. frags per episode, the number of kills minus the number of suicides for the agent in one round of game, is often used as a metric. an ai is stronger if its frags is ranked higher against others. in this work, we use an episode of 2-minute game time (4200 frames in total) for all our evaluations unless noted otherwise.we use convolutional neural networks to extract features from the game frames and then combine its output representation with game variables. fig. 3 shows the network architecture and tbl. 1 gives the parameters. it takes the frames as the input (i.e., the state s) and outputs two branches, one that outputs the value function v (s) by regression, while the other outputs the policy function π(s|a) by a regular softmax. the parameters of the two functions are shared before the branch.
for input, we use the most recent 4 frames plus the center part of them, scaled to the same size (120 × 120). therefore, these centered “attention frames” have higher resolution than regular game frames, and greatly increase the aiming accuracy. the policy network will give 6 actions, namely move forward, move left, move right, turn left, turn right, and attack. we found other on-off actions (e.g., move backward) offered by vizdoom less important. after feature extraction by convolutional network, game variables are incorporated. this includes the agent’s health (0-100) and ammo (how many bullets left). they are related to ai itself and thus legal in the game environment for training, testing and vizdoom ai competition.our training procedure is implemented with tensorflow [abadi  (2016)] and tensorpack5. we open 255 processes, each running one doom instance, and sending experience (st, at, rt) to the http://slade.mancubus.net/ 5https://github.com/ppwwyyxx/tensorpack
main process which runs the training procedure. the main process collects frames from different game instances to create batches, and optimizes on these batches asynchronously on one or more gpus using eqn. 1 and eqn. 2. the frames from different processes running independent game instances, are likely to be uncorrelated, which stabilizes the training. this procedure is slightly different from the original a3c, where each game instance collects their own experience and updates the parameters asynchronously.
despite the use of entropy term, we still find that π(·|s) is highly peaked. therefore, during trajectory exploration, we encourage exploration by the following changes: a) multiply the policy output of the network by an exploration factor (0.2) before softmax b) uniformly randomize the action for 10% random frames.
as mentioned in [kempka  (2016)], care should be taken for frame skips. small frame skip introduces strong correlation in the training set, while big frame skip reduces effective training samples. we set frame skip to be 3. we choose 640x480 as the input frame resolution and do not use high aspect ratio resolution [lample & chaplot (2016)] to increase the field of view.
we use adam [kingma & ba (2014)] with ǫ = 10−3 for training. batch size is 128, discount factor γ = 0.99, learning rate α = 10−4 and the policy learning rate β = 0.08α. the model is trained from scratch. the training procedure runs on intel xeon cpu e5-2680v2 at 2. 80ghz, and 2 titanx gpus. it takes several days to obtain a decent result. our final model, namely the f1 bot, is trained for around 3 million mini-batches on multiple different scenarios.when the environment only gives very sparse rewards, or adversarial, a3c takes a long time to converge to a satisfying solution. a direct training with a3c on the map cigtrack1 with 8 builtin bots does not yield sensible performance. to address this, we use curriculum learning [bengio  (2009)] that trains an agent with a sequence of progressively more difficult environments. by varying parameters in doom (sec. 3), we could control its difficulty level.
reward shaping. reward shaping has been shown to be an effective technique to apply reinforcement learning in a complicated environment with delayed reward [ng  (1999); devlin  (2011)]. in our case, besides the basic reward for kills (+1) and death (-1), intermediate rewards are used as shown in tbl. 2. we penalize agent with a living state, encouraging it to explore and encounter more enemies. health loss and ammo loss place linear reward for a decrement of health and ammunition. ammo pickup and health pickup place reward for picking up these two items. in addition, there is extra reward for picking up ammunition when in need (e.g. almost out of ammo). dist penalty and dist reward push the agent away from the previous locations, encouraging it to explore. the penalty is applied every action, when the displacement of the bot relative to the last state is less than a threshold dist penalty thres. and dist reward is applied for every unit displacement the agent makes. similar to [lample & chaplot (2016)], the displacement information is computed from the ground truth location variables provided by doom engine, and will not be used in the competition. however, unlike [lample & chaplot (2016)] that uses enemy-in-sight signal for training, locations can be extracted directly from user? variables, or can easily be computed roughly with action history.
curriculum design. we train the bot on flatmap that contains a simple square with a few pillars (fig. 2(a)) with several curricula (tbl. 3), and then proceed to cigtrack1. for each map, we design curricula by varying the strength of built-in bots, i.e., their moving speed, initial health and initial weapon. our agent always uses rocketlauncher as its only weapon. training on flatmap leads to a capable initial model which is quickly adapted to more complicated maps. as shown in tbl. 2, for cigtrack1 we increase dist penalty thres to keep the agent moving, and increase num bots so that the agent encounters more enemies per episode.
adaptive curriculum. in addition to staged curriculum learning, we also design adaptive curriculum learning by assigning a probability distribution on different levels for each thread that runs a doom instance. the probability distribution shifts towards more difficult curriculum when the agent performs well on the current distribution, and shifts towards easier level otherwise. we consider the agent to perform well if its frag count is greater than 10 points.for a better performance in the competition, we also put several rules to process the action given by the trained policy network, called post-training (pt) rules. there are two sets of buttons in vizdoom: on-off buttons and delta buttons. while on-off button maps to the binary states of a keystroke (e.g., pressing the up arrow key will move the agent forward), delta buttons mimic the mouse behavior and could act faster in certain situations. therefore, we setup rules that detect the intention of the agent and accelerate with delta button. for example, when the agent turns by invoking turn left repeatedly, we convert its action to turn left right delta for acceleration. besides, the trained model might get stuck in rare situations, e.g., keep moving forward but blocked by an explosive bucket. we also designed rules to detect and fix them.in this section, we show the training procedure (sec. 5.1), evaluate our ais with ablation analysis (sec. 5.2) and vizdoom ai competition (sec. 5.3). we mainly compare among three ais: (1) f1pre, the bot trained with flatmap only, (2) f1plain, the bot trained on both flatmap and cigtrack1, but without post-training rules, and (3) the final f1 bot that attends competition. .1 curriculum learning on flatmap
fig. 4 shows that the curriculum learning increases the performance of the agents over all levels. when an agent becomes stronger in the higher level of class, it is also stronger in the lower level of class without overfitting. fig. 5 shows comparison between adaptive curriculum learning with pure a3c. we can see that pure a3c can learn on flatmap but is slower. moreover, in cigtrack1, a direct application of a3c does not yield sensible performance.visualization. fig. 6 shows the visualization of the first convolutional layer of the trained ai agent. we could see that the convolutional kernels of the current frame is less noisy than the kernels of previous frames. this means that the agent makes the most use of the current frames.
effect of history frames. interestingly, while the agent focuses on the current frame, it also uses motion information. for this, we use (1) 4 duplicated current frames (2) 4 recent frames in reverse order, as the input. this gives 8.50 and 2.39 mean frags, compared to 10.34 in the normal case, showing that the agent heavily uses the motion information for better decision. in particular, the bot is totally confused with the reversed motion feature. detailed results are shown in tbl. 5.
post-training rules. tbl. 5 shows that the post-training rules improve the performance. as a future work, an end-to-end training involving delta buttons could make the bot better.
internal tournament. we also evaluate our ais with internal tournaments (tbl. 4). all our bots beat the performance of built-in bots by a large margin, even though they use privileged information. f1pre, trained with only flatmap, shows decent performance, but is not as good as the models trained with both flatmap and cigtrack1. the final bot f1 performs the best.
behaviors. visually, the three bots behave differently. f1pre is a bit overtrained in flatmap and does not move too often, but when it sees enemies, even faraway, it will start to shoot. occasionally it will move to the corner and pick medkits. in cigtrack1, f1pre stays in one place and ambushes opponents who pass by. on the other hand, f1plain and f1 always move forwards and turn at the corner. as expected, f1 moves and turns faster.
tactics all bots develop interesting local tactics when exchanging fire with enemy: they slide around when shooting the enemy. this is quite effective for dodging others’ attack. also when they shoot the enemy, they usually take advantage of the splashing effect of rocket to cause additional damage for enemy, e.g., shooting the wall when the enemy is moving. they do not pick ammunition too often, even if they can no longer shoot. however, such disadvantage is mitigated by the nature of deathmatch: when a player dies, it will respawn with ammunition. we also check states with highest/lowest estimated future value v (s) over a 10-episode evaluation of f1 bot, from which we can speculate its tactics. the highest value is v = 0.97 when the agent fired, and about to hit the enemy. one low value is v = −0.44, ammo = 0, when the agent encountered an enemy at the corner but is out of ammunition. both cases are reasonable.we attended the vizdoom ai competition hosted by ieee cig. there are 2 tracks in the competition. track 1 (limited deathmatch) uses a known map and fixed weapons, while track 2 (full deathmatch) uses 3 unknown maps and a variety of weapons. each bot fights against all others for 12 rounds of 10 minutes each. due to server capacity, each bot skips one match in the first 9 rounds. all bots are supposed to run in real-time (>35fps) on a gtx960 gpu.
our f1 bot won 10 out of 11 attended games and won the champion for track 1 by a large margin. we have achieved 559 frags, 35.4% higher than 413 frags achieved by arnold [lample & chaplot (2016)], that uses extra game state for model training. on the other hand, intelact [dosovitskiy & koltun (2017)] won track 2. the full videos for the two tracks have been released67, as well as an additional game between human and ais8. our bot behaves reasonable and very human-like in track 1. in the match between human and ais, our bot was even ahead of the human player for a short period (6:30 to 7:00).teaching agents to act properly in complicated and adversarial 3d environment is a very challenging task. in this paper, we propose a new framework to train a strong ai agent in a first-person shooter (fps) game, doom, using a combination of state-of-the-art deep reinforcement learning and curriculum training. via playing against built-in bots in a progressive manner, our bot wins the champion of track1 (known map) in vizdoom ai competition. furthermore, it learns to use motion features and build its own tactics during the game, which is never taught explicitly.
currently, our bot is still an reactive agent that only remembers the last 4 frames to act. ideally, a bot should be able to build a map from an unknown environment and localize itself, is able to have a global plan to act, and visualize its reasoning process. we leave them to future works.",1
356.pdf.json,NEURO-SYMBOLIC PROGRAM SYNTHESIS,"the act of programming, i.e., developing a procedure to accomplish a task, is a remarkable demonstration of the reasoning abilities of the human mind. expectedly, program induction is considered as one of the fundamental problems in machine learning and artificial intelligence. recent progress on deep learning has led to the proposal of a number of promising neural architectures for this problem. many of these models are inspired from computation modules (cpu, ram, gpu) (graves , 2014; kurach , 2015; reed & de freitas, 2015; neelakantan , 2015) or common data structures used in many algorithms (stack) (joulin & mikolov, 2015). a common thread in this line of work is to specify the atomic operations of the network in some differentiable form, allowing efficient end-to-end training of a neural controller, or to use reinforcement learning to make hard choices about which operation to perform. while these results are impressive, these approaches have a number of important limitations: (a) they are computationally expensive and hard to train, (b) a model has to be trained for each task (program) separately, and (c) it is hard to interpret or verify the correctness of the learnt mapping (as it is defined by a neural network). while some recently proposed methods (kurach , 2015; gaunt , 2016; riedel , 2016; bunel , 2016) do learn interpretable programs, they still need to learn a separate neural network model for each individual task.
motivated by the need for model interpretability and scalability to multiple tasks, we address the problem of program synthesis. program synthesis, the problem of automatically constructing programs that are consistent with a given specification, has long been a subject of research in computer science (biermann, 1978; summers, 1977). this interest has been reinvigorated in recent years on
the back of the development of methods for learning programs in various domains, ranging from low-level bit manipulation code (solar-lezama , 2005) to data structure manipulations (singh & solar-lezama, 2011) and regular expression based string transformations (gulwani, 2011).
most of the recently proposed methods for program synthesis operate by searching the space of programs in a domain-specific language (dsl) instead of arbitrary turing-complete languages. this hypothesis space of possible programs is huge (potentially infinite) and searching over it is a challenging problem. several search techniques including enumerative (udupa , 2013), stochastic (schkufza , 2013), constraint-based (solar-lezama, 2008), and version-space algebra based algorithms (gulwani , 2012) have been developed to search over the space of programs in the dsl, which support different kinds of specifications (examples, partial programs, natural language etc.) and domains. these techniques not only require significant engineering and research effort to develop carefully-designed heuristics for efficient search, but also have limited applicability and can only synthesize programs of limited sizes and types.
in this paper, we present a novel technique called neuro-symbolic program synthesis (nsps) that learns to generate a program incrementally without the need for an explicit search. once trained, nsps can automatically construct computer programs that are consistent with any set of input-output examples provided at test time. our method is based on two novel module neural architectures. the first module, called the cross correlation i/o network, produces a continuous representation of any given set of input-output examples. the second module, the recursive-reverse-recursive neural network (r3nn), given the continuous representation of the input-output examples, synthesizes a program by incrementally expanding partial programs. r3nn employs a tree-based neural architecture that sequentially constructs a parse tree by selecting which non-terminal symbol to expand using rules from a context-free grammar (i.e., the dsl).
we demonstrate the efficacy of our method by applying it to the rich and complex domain of regularexpression-based syntactic string transformations, using a dsl based on the one used by flashfill (gulwani, 2011; gulwani , 2012), a programming-by-example (pbe) system in microsoft excel 2013. given a few input-output examples of strings, the task is to synthesize a program built on regular expressions to perform the desired string transformation. an example task that can be expressed in this dsl is shown in figure 1, which also shows the dsl.
our evaluation shows that nsps is not only able to construct programs for known tasks from new input-output examples, but it is also able to construct completely new programs that it had not observed during training. specifically, the proposed system is able to synthesize string transformation programs for 63% of tasks that it had not observed at training time, and for 94% of tasks when 100 program samples are taken from the model. moreover, our system is able to learn 38% of 238 real-world flashfill benchmarks.
to summarize, the key contributions of our work are:
• a novel neuro-symbolic program synthesis technique to encode neural search over the space of programs defined using a domain-specific language (dsl).
• the r3nn model that encodes and expands partial programs in the dsl, where each node has a global representation of the program tree.
• a novel cross-correlation based neural architecture for learning continuous representation of sets of input-output examples.
• evaluation of the nsps approach on the complex domain of regular expression based string transformations.in this section, we formally define the dsl-based program synthesis problem that we consider in this paper. given a dsl l, we want to automatically construct a synthesis algorithm a such that given a set of input-output example, {(i1, o1), · · · , (in, on)}, a returns a program p ∈ l that conforms to the input-output examples, i.e.,
∀j : 1 ≤ j ≤ n p (ij) = oj . (1)
the syntax and semantics of the dsl for string transformations is shown in figure 1(b) and figure 8 respectively. the dsl corresponds to a large subset of flashfill dsl (except conditionals), and allows for a richer class of substring operations than flashfill. a dsl program takes as input a string v and returns an output string o. the top-level string expression e is a concatenation of a finite list of substring expressions f1, · · · , fn. a substring expression f can either be a constant string s or a substring expression, which is defined using two position logics pl (left) and pr (right). a position logic corresponds to a symbolic expression that evaluates to an index in the string. a position logic p can either be a constant position k or a token match expression (r, k,dir), which denotes the start or end of the kth match of token r in input string v. a regex token can either be a constant string s or one of 8 regular expression tokens: p (propercase), c (caps), l (lowercase), d (digits), α (alphabets), αn (alphanumeric), ∧ (startofstring), and $ (endofstring). the semantics of the dsl programs is described in the appendix.
a dsl program for the name transformation task shown in figure 1(a) that is consistent with the examples is: concat(f1,conststr(“, ”), f2,conststr(“.”)), where f1 ≡ substr(v, (“ ”,−1,end),constpos(−1)) and f2 ≡ substr(v,constpos(0),constpos(1)). the program concatenates the following 4 strings: i) substring between the end of last whitespace and end of string, ii) constant string “, ”, iii) first character of input string, and iv) constant string “.”.we now present an overview of our approach. given a dsl l, we learn a generative model of programs in the dsl l that is conditioned on input-output examples to efficiently search for consistent programs. the workflow of our system is shown in figure 2, which is trained end-to-end using a large training set of programs in the dsl together with their corresponding input-output examples. to generate a large training set, we uniformly sample programs from the dsl and then use a rule-based strategy to compute well-formed input strings. given a program p (sampled from the dsl), the rule-based strategy generates input strings for the program p ensuring that the preconditions of p are met (i.e. p doesn’t throw an exception on the input strings). it collects the pre-conditions of all substring expressions present in the sampled program p and then generates inputs conforming to them. for example, let’s assume the sampled program is substr(v,(caps, 2, start), (“ ”, 3, start)), which extracts the substring between the start of 2nd capital letter and start of 3rd whitespace. the rule-based strategy would ensure that all the generated input strings consist of at least 2 capital letters and 3 whitespaces in addition to other randomly generated characters. the corresponding output strings are obtained by running the programs on the input strings.
a dsl can be considered as a context-free grammar with a start symbol s and a set of non-terminals with corresponding expansion rules. the (partial) grammar derivations or trees correspond to (partial) programs. a naı̈ve way to perform a search over the programs in a dsl is to start from the start symbol s and then randomly choose non-terminals to expand with randomly chosen expansion rules until reaching a derivation with only terminals. we, instead, learn a generative model over partial derivations in the dsl that assigns probabilities to different non-terminals in a partial derivation and corresponding expansions to guide the search for complete derivations.
our generative model uses a recursive-reverse-recursive neural network (r3nn) to encode partial trees (derivations) in l, where each node in the partial tree encodes global information about every other node in the tree. the model assigns a vector representation for every symbol and every expansion rule in the grammar. given a partial tree, the model first assigns a vector representation to each leaf node, and then performs a recursive pass going up in the tree to assign a global tree representation to the root. it then performs a reverse-recursive pass starting from the root to assign a global tree representation to each node in the tree.
the generative process is conditioned on a set of input-output examples to learn a program that is consistent with this set of examples. we experiment with multiple input-output encoders including an lstm encoder that concatenates the hidden vectors of two deep bidirectional lstm networks for input and output strings in the examples, and a cross correlation encoder that computes the cross correlation between the lstm tensor representations of input and output strings in the examples. this vector is then used as an additional input in the r3nn model to condition the generative model.we define a program t-steps into construction as a partial program tree (ppt) (see figure 3 for a visual depiction). a ppt has two types of nodes: leaf (symbol) nodes and inner non-leaf (rule) nodes. a leaf node represents a symbol, whether non-terminal or terminal. an inner non-leaf node represents a particular production rule of the dsl, where the number of children of the non-leaf node is equivalent to the arity of the rhs of the rule it represents. a ppt is called a program tree (pt) whenever all the leaves of the tree are terminal symbols. such a tree represents a completed program under the dsl and can be executed. we define an expansion as the valid application of a specific production rule (e → e op2 e) to a specific non-terminal leaf node within a ppt (leaf with symbol e). we refer to the specific production rule that an expansion is derived from as the expansion type. it can be seen that if there exist two leaf nodes (l1 and l2) with the same symbol then for every expansion specific to l1 there exists an expansion specific to l2 with the same type.in order to define a generation model over ppts, we need an efficient way of assigning probabilities to every valid expansion in the current ppt. a valid expansion has two components: first the production rule used, and second the position of the expanded leaf node relative to every other node in the tree. to account for the first component, a separate distributed representation for each production rule is maintained. the second component is handled using an architecture where the forward propagation resembles belief propagation on trees, allowing a notion of global tree state at every node within the tree. a given expansion probability is then calculated as being proportional to the inner product between the production rule representation and the global-tree representation of the leaf-level non-terminal node. we now describe the design of this architecture in more detail.
the r3nn has the following parameters for the grammar described by a dsl (see figure 3): . for every symbol s ∈ s, an m−dimensional representation φ(s) ∈ rm . 2. for every production rule r ∈ r, an m−dimensional representation ω(r) ∈ rm . . for every production rule r ∈ r, a deep neural network fr which takes as input a vector x ∈ rq·m , with q being the number of symbols on the rhs of the production rule r, and outputs a vector y ∈ rm . therefore, the production-rule network fr takes as input a concatenation of the distributed representations of each of its rhs symbols and produces a distributed representation for the lhs symbol. . for every production rule r ∈ r, an additional deep neural network gr which takes as input a vector x′ ∈ rm and outputs a vector y′ ∈ rq·m . we can think of gr as a reverse production-rule network that takes as input a vector representation of the lhs and produces a concatenation of the distributed representations of each of the rule’s rhs symbols.
let e be the set of all valid expansions in a ppt t , let l be the current leaf nodes of t and n be the current non-leaf (rule) nodes of t . let s(l) be the symbol of leaf l ∈ l and r(n) represent the production rule of non-leaf node n ∈ n .to compute the probability distribution over the set e, the r3nn first computes a distributed representation for each leaf node that contains global tree information. to accomplish this, for every leaf node l ∈ l in the tree we retrieve its distributed representation φ(s(l)) . we now do a standard recursive bottom-to-top, rhs→lhs pass on the network, by going up the tree and applying fr(n) for every non-leaf node n ∈ n on its rhs node representations (see figure 3(a)). these networks fr(n) produce a node representation which is input into the parent’s rule network and so on until we reach the root node.
once at the root node, we effectively have a fixed-dimensionality global tree representation φ(root) for the start symbol. the problem is that this representation has lost any notion of tree position. to solve this problem r3nn now does what is effectively a reverse-recursive pass which starts at the root node with φ(root) as input and moves towards the leaf nodes (see figure 3(b)).
more concretely, we start with the root node representation φ(root) and use that as input into the rule network gr(root) where r(root) is the production rule that is applied to the start symbol in t . this produces a representation φ′(c) for each rhs node c of r(root). if c is a non-leaf node, we iteratively apply this procedure to c, i.e., process φ′(c) using gr(c) to get representations φ′(cc) for every rhs node cc of r(c), etc. if c is a leaf node, we now have a leaf representation φ′(c) which has an information path to φ(root) and thus to every other leaf node in the tree. once the reverse-recursive process is complete, we now have a distributed representation φ′(l) for every leaf node l which contains global tree information. while φ(l1) and φ(l2) could be equal for leaf nodes which have the same symbol type, φ′(l1) and φ′(l2) will not be equal even if they have the same symbol type because they are at different positions in the tree.given the global leaf representations φ′(l), we can now straightforwardly acquire scores for each e ∈ e. for expansion e, let e.r be the expansion type (production rule r ∈ r that e applies) and let e.l be the leaf node l that e.r is applied to. ze = φ′(e.l) · ω(e.r) the score of an expansion is calculated using ze = φ′(e.l) · ω(e.r). the probability of expansion e is simply the exponentiated normalized sum over all scores: π(e) = e
ze∑ e′∈e e z e′ .
an additional improvement that was found to help was to add a bidirectional lstm (blstm) to process the global leaf representations right before calculating the scores. to do this, we first order the global leaf representations sequentially from left-most leaf node to right-mode leaf node. we then treat each leaf node as a time step for a blstm to process. this provides a sort of skip connection between leaf nodes, which potentially reduces the path length that information needs to travel between leaf nodes in the tree. the blstm hidden states are then used in the score calculation rather than the leaves themselves.
the r3nn can be seen as an extension and combination of several previous tree-based models, which were mainly developed in the context of natural language processing (le & zuidema, 2014; paulus , 2014; irsoy & cardie, 2013).now that we have defined a generation process over tree-structured programs, we need a way of conditioning this generation process on a set of input/output examples. the set of input/output examples provide a nearly complete specification for the desired output program, and so a good encoding of the examples is crucial to the success of our program generator. for the most part, this example encoding needs to be domain-specific, since different dsls have different inputs (some may operate over integers, some over strings, etc.). therefore, in our case, we use an encoding adapted to the input-output strings that our dsl operates over. we also investigate different ways of conditioning program search on the learnt example input-output encodings.there are two types of information that string manipulation programs need to extract from inputoutput examples: 1) constant strings, such as “@domain.com” or “.”, which appear in all output examples; 2) substring indices in input where the index might be further defined by a regular expression. these indices determine which parts of the input are also present in the output. to simplify the dsl, we assume that there is a fixed finite universe of possible constant strings that could appear in programs. therefore we focus on extracting the second type of information, the substring indices.
in earlier hand-engineered systems such as flashfill, this information was extracted from the inputoutput strings by running the longest common substring algorithm, a dynamic programming algorithm that efficiently finds matching substrings in string pairs. to extract substrings, flashfill runs lcs on every input-output string pair in the i/o set to get a set of substring candidates. it then takes the entire set of substring candidates and simply tries every possible regex and constant index that can be used at substring boundaries, exhaustively searching for the one which is the most “general”, where generality is specified by hand-engineered heuristics.
in contrast to these previous methods, instead of hand-designing a complicated algorithm to extract regex-based substrings, we develop neural network based architectures that are capable of learning to extract and produce continuous representations of the likely regular expressions given i/o examples.our first i/o encoding network involves running two separate deep bidirectional lstm networks for processing the input and the output string in each example pair. for each pair, it then concatenates the topmost hidden representation at every time step to produce a 4ht -dimensional feature vector per i/o pair, where t is the maximum string length for any input or output string, and h is the topmost lstm hidden dimension.
we then concatenate the encoding vectors across all i/o pairs to get a vector representation of the entire i/o set. this encoding is conceptually straightforward and has very little prior knowledge about what operations are being performed over the strings, i.e., substring, constant, etc., which might make it difficult to discover substring indices, especially the ones based on regular expressions.to help the model discover input substrings that are copied to the output, we designed an novel i/o example encoder to compute the cross correlation between each input and output example representation. we used the two output tensors of the lstm encoder (discussed above) as inputs to this encoder. for each example pair, we first slide the output feature block over the input feature block and compute the dot product between the respective position representation. then, we sum over all overlapping time steps. features of all pairs are then concatenated to form a 2∗ (t −1)-dimensional vector encoding for all example pairs. there are 2 ∗ (t − 1) possible alignments in total between input and output feature blocks. an illustration of the cross-correlation encoder is shown in figure 9. we also designed the following variants of this encoder.
diffused cross correlation encoder: this encoder is identical to the cross correlation encoder except that instead of summing over overlapping time steps after the element-wise dot product, we simply concatenate the vectors corresponding to all time steps, resulting in a final representation that contains 2 ∗ (t − 1) ∗ t features for each example pair. lstm-sum cross correlation encoder: in this variant of the cross correlation encoder, instead of doing an element-wise dot product, we run a bidirectional lstm over the concatenated feature blocks of each alignment. we represent each alignment by the lstm hidden representation of the final time step leading to a total of 2 ∗h ∗ 2 ∗ (t − 1) features for each example pair. augmented diffused cross correlation encoder: for this encoder, the output of each character position of the diffused cross correlation encoder is combined with the character embedding at this position, then a basic lstm encoder is run over the combined features to extract a 4∗h-dimensional vector for both the input and the output streams. the lstm encoder output is then concatenated with the output of the diffused cross correlation encoder forming a (4∗h+t ∗(t−1))-dimensional feature vector for each example pair.once the i/o example encodings have been computed, we can use them to perform conditional generation of the program tree using the r3nn model. there are a number of ways in which the ppt generation model can be conditioned using the i/o example encodings depending on where the i/o example information is inserted in the r3nn model. we investigated three locations to inject example encodings: ) pre-conditioning: where example encodings are concatenated to the encoding of each tree leaf, and then passed to a conditioning network before the bottom-up recursive pass over the program tree. the conditioning network can be either a multi-layer feedforward network, or a bidirectional lstm network running over tree leaves. running an lstm over tree leaves allows the model to learn more about the relative position of each leaf node in the tree. ) post-conditioning: after the reverse-recursive pass, example encodings are concatenated to the updated representation of each tree leaf and then fed to a conditioning network before computing the expansion scores. ) root-conditioning: after the recursive pass over the tree, the root encoding is concatenated to the example encodings and passed to a conditioning network. the updated root representation is then used to drive the reverse-recursive pass.
empirically, pre-conditioning worked better than either root- or post- conditioning. in addition, conditioning at all 3 places simultaneously did not cause a significant improvement over just pre-conditioning. therefore, for the experimental section, we report models which only use preconditioning.in order to evaluate and compare variants of the previously described models, we generate a dataset randomly from the dsl. to do so, we first enumerate all possible programs under the dsl up to a specific number of instructions, which are then partitioned into training, validation and test sets. in order to have a tractable number of programs, we limited the maximum number of instructions for programs to be 13. length 13 programs are important for this specific dsl because all larger programs can be written as compositions of sub-programs of length at most 13. the semantics of length 13 programs therefore constitute the “atoms” of this particular dsl.
in testing our model, there are two different categories of generalization. the first is input/output generalization, where we are given a new set of input/output examples as well as a program with a specific tree that we have seen during training. this represents the model’s capacity to be applied on new data. the second category is program generalization, where we are given both a previously unseen program tree in addition to unseen input/output examples. therefore the model needs to have a sufficient enough understanding of the semantics of the dsl that it can construct novel combinations of operations. for all reported results, training sets correspond to the first type of generalization since we have seen the program tree but not the input/output pairs. test sets represent the second type of generalization, as they are trees which have not been seen before on input/output pairs that have also not been seen before.
in this section, we compare several different variants of our model. we first evaluate the effect of each of the previously described input/output encoders. we then evaluate the r3nn model against a simple recurrent model called io2seq, which is basically an lstm that takes as input the input/output conditioning vector and outputs a sequence of dsl symbols that represents a linearized program tree. finally, we report the results of the best model on the length 13 training and testing sets, as well as on a set of 238 benchmark functions.for training the r3nn, two hyperparameters that were crucial for stabilizing training were the use of hyperbolic tangent activation functions in both r3nn (other activations such as relu more consistently diverged during our initial experiments) and cross-correlation i/o encoders and the use of minibatches of length 8. additionally, for all results, the program tree generation is conditioned on a set of 10 input/output string pairs. we used adam (kingma & ba, 2014) to optimize the networks with a learning rate of 0.001. network weights used the default torch initializations.
due to the difficulty of batching tree-based neural networks since each sample in a batch has a potentially different tree structure, we needed to do batching sequentially. therefore for each minibatch of size n , we accumulated the gradients for each sample. after all n sample gradients were accumulated, we updated the parameters and reset the accumulated gradients. due to this sequential processing, in order to train models in a reasonable time, we limited our batch sizes to between 8-12. despite the computational inefficiency, batching was critical to successfully train an r3nn, as online learning often caused the network to diverge.
for each latent function and set of input/output examples that we test on, we report whether we had a success after sampling 100 functions from the model and testing all 100 to see if one of these functions is equivalent to the latent function. here we consider two functions to be equivalent with respect to a specific input/output example set if the functions output the same strings when run on the inputs. under this definition, two functions can have a different set of operations but still be equivalent with respect to a specific input-output set.
we restricted the maximum size of training programs to be 13 because of two computational considerations. as described earlier, one difficulty was in batching tree-based neural networks of different structure and the computational cost of batching increases with the increase in size of the program trees. the second issue is that valid i/o strings for programs often grow with the program length, in the sense that for programs of length 40 a minimal valid i/o string will typically be much longer than a minimal valid i/o string for length 20 programs. for example, for a program such as (concat (conststr “longstring”) (concat (conststr “longstring”) (concat (conststr “longstring”) ...))), the valid output string would be “longstringlongstringlongstring...” which could be many
hundreds of characters long. because of limited gpu memory, the i/o encoder models can quickly run out of memory.in this section, we evaluate the effect of several different input/output example encoders. to control for the effect of the tree model, all results here used an r3nn with fixed hyperparameters to generate the program tree. table 1 shows the performance of several of these input/output example encoders. we can see that the summed cross-correlation encoder did not perform well, which can be due to the fact that the sum destroys positional information that might be useful for determining specific substring indices. the lstm-sum and the augmented diffused cross-correlation models did the best. surprisingly, the lstm encoder was capable of finding nearly 88% of all programs without having any prior knowledge explicitly built into the architecture. we use 100 samples for evaluating the train and test sets. the training performance is sometimes slightly lower because there are close to 5 million training programs but we only look at less than 2 million of these programs during training. we sample a subset of only 1000 training programs from the 5 million program set to report the training results in the tables. the test sets also consist of 1000 programs.in this section, we motivate the use of the r3nn by testing whether a simpler model can also be used to generate programs. the io2seq model is an lstm whose initial hidden and cell states are a function of the input/output encoding vector. the io2seq model then generates a linearized tree of a program symbol-by-symbol. an example of what a linearized program tree looks like is (s(e(f (conststr“@”)conststr)f )e)s , which represents the program tree that returns the constant string “@”. predicting a linearized tree using an lstm was also done in the context of parsing (vinyals , 2015). for the io2seq model, we used the lstm-sum cross-correlation i/o conditioning model.
the results in table 2 show that the performance of the io2seq model at 100 samples per latent test function is far worse than the r3nn, at around 42% versus 91%, respectively. the reasons for that could be that the io2seq model needs to perform far more decisions than the r3nn, since the io2seq model has to predict the parentheses symbols that determine at which level of the tree a particular symbol is at. for example, the io2seq model requires on the order of 100 decisions for length 13 programs, while the r3nn requires no more than 13.for the best r3nn model that we trained, we also evaluated the effect that a different number of samples per latent function had on performance. the results are shown in table 3. the increase of the model’s performance as the sample size increases hints that the model has a notion of what type of program satisfies a given i/o pair, but it might not be that certain about the details such as which regex to use, etc. by 300 samples, the model is nearing perfect accuracy on the test sets.we evaluate the effect of varying the number of input-output examples used to train the input-output encoders. the 1-best accuracy for train and test data for models trained for 74 epochs is shown in figure 4. as expected, the accuracy increases with increase in number of input-output examples, since more examples add more information to the encoder and constrain the space of consistent programs in the dsl.we also evaluate our learnt models on 238 real-world flashfill benchmarks obtained from the microsoft excel team and online help-forums. these benchmarks involve string manipulation tasks described using input-output examples. we evaluate two models – one with a cross correlation encoder trained on 5 input-output examples and another trained on 10 input-output examples. both the models were trained on randomly sampled programs from the dsl upto size 13 with randomly generated input-output examples.
the distribution of the size of smallest dsl programs needed to solve the benchmark tasks is shown in figure 5(a), which varies from 4 to 63. the figure also shows the number of benchmarks for which our model was able to learn the program using 5 input-output examples using samples of top-2000 learnt programs. in total, the model is able to learn programs for 91 tasks (38.2%). since the model was trained for programs upto size 13, it is not surprising that it is not able to solve tasks that need larger program size. there are 110 flashfill benchmarks that require programs upto size 13, out of which the model is able to solve 82.7% of them.
the effect of sampling multiple learnt programs instead of only top program is shown in figure 5(b). with only 10 samples, the model can already learn about 13% of the benchmarks. we observe a steady increase in performance upto about 2000 samples, after which we do not observe any significant improvement. since there are more than 2 million programs in the dsl of length 11 itself, the enumerative techniques with uniform search do not scale well (alur , 2015).
we also evaluate a model that is learnt with 10 input-output examples per benchmark. this model can only learn programs for about 29% of the flashfill benchmarks. since the flashfill benchmarks contained only 5 input-output examples for each task, to run the model that took 10 examples as input, we duplicated the i/o examples. our models are trained on the synthetic training dataset
that is generated uniformly from the dsl. because of the discrepancy between the training data distribution (uniform) and auxiliary task data distribution, the model with 10 input/output examples might not perform the best on the flashfill benchmark distribution, even though it performs better on the synthetic data distribution (on which it is trained) as shown in figure 4.
our model is able to solve majority of flashfill benchmarks that require learning programs with upto 3 concat operations. we now describe a few of these benchmarks, also shown in figure 6. an excel user wanted to clean a set of medical billing records by adding a missing “]” to medical codes as shown in figure 6(a). our system learns the following program given these 5 input-output examples: concat(substr(v,constpos(0),(d,-1,end)), conststr(“]”)). the program concatenates the substring between the start of the input string and the position of the last digit regular expression with the constant string “]”. another task that required user to transform some numbers into a hex format is shown in figure 6(b). our system learns the following program: concat(conststr(“0x”),substr(v,constpos(0),constpos(2))). for some benchmarks with long input strings, it is still able to learn regular expressions to extract the desired substring, e.g. it learns a program to extract “nancyf” from the string “123456789,freehafer ,drew ,nancy,19700101,11/1/2007,nancyf@north.com,1230102,123 1st avenue,seattle,wa,09999”.
our system is currently not able to learn programs for benchmarks that require 4 or more concat operations. two such benchmarks are shown in figure 7. the task of combining names in figure 7(a) requires 6 concat arguments, whereas the phone number transformation task in figure 7(b) requires 5 concat arguments. this is mainly because of the scalability issues in training with programs of larger size. there are also a few interesting benchmarks where the r3nn models gets very close to learning the desired program. for example, for the task “bill gates” → “mr. bill gates”, it learns a program that generates “mr.bill gates” (without the whitespace), and for the task “617-444-5454” → “(617) 444-5454”, it learns a program that generates the string “(617 444-5454”.we have seen a renewed interest in recent years in the area of program induction and synthesis.
in the machine learning community, a number of promising neural architectures have been proposed to perform program induction. these methods have employed architectures inspired from computation modules (turing machines, ram) (graves , 2014; kurach , 2015; reed & de freitas, 2015; neelakantan , 2015) or common data structures such as stacks used in many algorithms (joulin & mikolov, 2015). these approaches represent the atomic operations of the network in a differentiable form, which allows for efficient end-to-end training of a neural controller. however, unlike our approach that learns comprehensible complete programs, many of these approaches learn only the program behavior (i.e., they produce desired outputs on new input data). some recently proposed methods (kurach , 2015; gaunt , 2016; riedel , 2016; bunel , 2016) do learn interpretable programs but these techniques require learning a separate neural network model for each individual task, which is undesirable in many synthesis settings where we would like to learn programs in real-time for a large number of tasks. liang  (2010) restrict the problem space with a probabilistic context-free grammar and introduce a new representation of programs based on combinatory logic, which allows for sharing sub-programs across multiple tasks. they then take a hierarchical bayesian approach to learn frequently occurring substructures of programs. our approach, instead, uses neural architectures to condition the search space of programs, and does not require additional step of representing program space using combinatory logic for allowing sharing.
the dsl-based program synthesis approach has also seen a renewed interest recently (alur , 2015). it has been used for many applications including synthesizing low-level bitvector implementations (solar-lezama , 2005), excel macros for data manipulation (gulwani, 2011; gulwani , 2012), superoptimization by finding smaller equivalent loop bodies (schkufza , 2013), protocol synthesis from scenarios (udupa , 2013), synthesis of loop-free programs (gulwani , 2011), and automated feedback generation for programming assignments (singh , 2013). the synthesis techniques proposed in the literature generally employ various search techniques including enumeration with pruning, symbolic constraint solving, and stochastic search, while supporting different forms of specifications including input-output examples, partial programs, program invariants, and reference implementation.
in this paper, we consider input-output example based specification over the hypothesis space defined by a dsl of string transformations, similar to that of flashfill (without conditionals) (gulwani, 2011). the key difference between our approach over previous techniques is that our system is trained completely in an end-to-end fashion, while previous techniques require significant manual effort to design heuristics for efficient search. there is some work on guiding the program search using learnt clues that suggest likely dsl expansions, but the clues are learnt over hand-coded textual features of examples (menon , 2013). moreover, their dsl consists of composition of about 100 high-level text transformation functions such as count and dedup, whereas our dsl consists of tree structured programs over richer regular expression based substring constructs.
there is also a recent line of work on learning probabilistic models of code from a large number of code repositories (big code) (raychev , 2015; bielik , 2016; hindle , 2016), which are then used for applications such as auto-completion of partial programs, inference of variable and method names, program repair, etc. these language models typically capture only the syntactic
properties of code, unlike our approach that also tries to capture the semantics to learn the desired program. the work by maddison & tarlow (2014) addresses the problem of learning structured generative models of source code but both their model and application domain are different from ours. piech  (2015) use an npm-rnn model to embed program asts, where a subtree of the ast rooted at a node n is represented by a matrix obtained by combining representations of the children of node n and the embedding matrix of the node n itself (which corresponds to its functional behavior). the forward pass in our r3nn architecture from leaf nodes to the root node is, at a high-level, similar, but we use a distributed representation for each grammar symbol that leads to a different root representation. moreover, r3nn also performs a reverse-recursive pass to ensure all nodes in the tree encode global information about other nodes in the tree. finally, the r3nn network is then used to incrementally build a tree to synthesize a program.
the r3nn model employed in our work is related to several tree and graph structured neural networks present in the nlp literature (le & zuidema, 2014; paulus , 2014; irsoy & cardie, 2013). the inside-outside recursive neural network (le & zuidema, 2014) in particular is most similar to the r3nn, where they generate a parse tree incrementally by using global leaf-level representations to determine which expansions in the parse tree to take next.we have proposed a novel technique called neuro-symbolic program synthesis that is able to construct a program incrementally based on given input-output examples. to do so, a new neural architecture called recursive-reverse-recursive neural network is used to encode and expand a partial program tree into a full program tree. its effectiveness at example-based program synthesis is demonstrated, even when the program has not been seen during training.
these promising results open up a number of interesting directions for future research. for example, we took a supervised-learning approach here, assuming availability of target programs during training. in some scenarios, we may only have access to an oracle that returns the desired output given an input. in this case, reinforcement learning is a promising framework for program synthesis.the semantics of the dsl programs is shown in figure 8. the semantics of a concat expression is to concatenate the results of recursively evaluating the constituent substring expressions fi. the semantics of conststr(s) is to simply return the constant string s. the semantics of a substring expression is to first evaluate the two position logics pl and pr to p1 and p2 respectively, and then return the substring corresponding to v[p1..p2]. we denote s[i..j] to denote the substring of string s starting at index i (inclusive) and ending at index j (exclusive), and len(s) denotes its length. the semantics of constpos(k) expression is to return k if k > 0 or return len + k (if k < 0). the semantics of position logic (r, k, start) is to return the start of kth match of r in v from the beginning (if k > 0) or from the end (if k < 0).",1
366.pdf.json,AUTOENCODING VARIATIONAL INFERENCE FOR TOPIC MODELS,"topic models (blei, 2012) are among the most widely used models for learning unsupervised representations of text, with hundreds of different model variants in the literature, and have have found applications ranging from the exploration of the scientific literature (blei & lafferty, 2007) to computer vision (fei-fei & perona, 2005), bioinformatics (rogers , 2005), and archaeology (mimno, 2009). a major challenge in applying topic models and developing new models is the computational cost of computing the posterior distribution. therefore a large body of work has considered approximate inference methods, the most popular methods being variational methods, especially mean field methods, and markov chain monte carlo, particularly methods based on collapsed gibbs sampling.
both mean-field and collapsed gibbs have the drawback that applying them to new topic models, even if there is only a small change to the modeling assumptions, requires re-deriving the inference methods, which can be mathematically arduous and time consuming, and limits the ability of practitioners to freely explore the space of different modeling assumptions. this has motivated the development of black-box inference methods (ranganath , 2014; mnih & gregor, 2014; kucukelbir , 2016; kingma & welling, 2014) which require only very limited and easy to compute information from the model, and hence can be applied automatically to new models given a simple declarative specification of the generative process.
autoencoding variational bayes (aevb) (kingma & welling, 2014; rezende , 2014) is a particularly natural choice for topic models, because it trains an inference network (dayan , 1995), a neural network that directly maps a document to an approximate posterior distribution,
∗additional affiliation: alan turing institute, british library, 96 euston road, london nw1 2db
without the need to run further variational updates. this is intuitively appealing because in topic models, we expect the mapping from documents to posterior distributions to be well behaved, that is, that a small change in the document will produce only a small change in topics. this is exactly the type of mapping that a universal function approximator like a neural network should be good at representing. essentially, the inference network learns to mimic the effect of probabilistic inference, so that on test data, we can enjoy the benefits of probabilistic modeling without paying a further cost for inference.
however, despite some notable successes for latent gaussian models, black box inference methods are significantly more challenging to apply to topic models. for example, in initial experiments, we tried to apply advi (kucukelbir , 2016), a recent black-box variational method, but it was difficult to obtain any meaningful topics. two main challenges are: first, the dirichlet prior is not a location scale family, which hinders reparameterisation, and second, the well known problem of component collapsing (dinh & dumoulin, 2016), in which the inference network becomes stuck in a bad local optimum in which all topics are identical.
in this paper, we present what is, to our knowledge, the first effective aevb inference method for topic models, which we call autoencoded variational inference for topic models or avitm1. on several data sets, we find that avitm yields topics of equivalent quality to standard mean-field inference, with a large decrease in training time. we also find that the inference network learns to mimic the process of approximate inference highly accurately, so that it is not necessary to run variational optimization at all on test data.
but perhaps more important is that avitm is a black-box method that is easy to apply to new models. to illustrate this, we present a new topic model, called prodlda, in which the distribution over individual words is a product of experts rather than the mixture model used in lda. we find that prodlda consistently produces better topics than standard lda, whether measured by automatically determined topic coherence or qualitative examination. furthermore, because we perform probabilistic inference using a neural network, we can fit a topic model on roughly a one million documents in under 80 minutes on a single gpu, and because we are using a black box inference method, implementing prodlda requires a change of only one line of code from our implementation of standard lda.
to summarize, the main advantages of our methods are: . topic coherence: prodlda returns consistently better topics than lda, even when lda is trained using gibbs sampling. . computational efficiency: training avitm is fast and efficient like standard mean-field. on new data, avitm is much faster than standard mean field, because it requires only one forward pass through a neural network. . black box: avitm does not require rigorous mathematical derivations to handle changes in the model, and can be easily applied to a wide range of topic models.
overall, our results suggest that avitm is ready to take its place alongside mean field and collapsed gibbs as one of the workhorse inference methods for topic models.to fix notation, we begin by describing topic modelling and avitm.we describe the most popular topic model, latent dirichlocation (lda). in lda, each document of the collection is represented as a mixture of topics, where each topic βk is a probability distribution over the vocabulary. we also use β to denote the matrix β = (β1 . . . βk). the generative process is then as described in algorithm 1. under this generative model, the marginal likelihood of code available at https://github.com/akashgit/autoencoding_vi_for_topic_models
for each document w do draw topic distribution θ ∼ dirichlet(α); for each word at position n do
sample topic zn ∼ multinomial(1, θ); sample word wn ∼ multinomial(1, βzn);
end end
algorithm 1: lda as a generative model.
a document w is
(1)p(w|α, β) = ∫ θ ( n∏ n=1 k∑ zn=1 p(wn|zn, β)p(zn|θ) ) p(θ|α)dθ.
posterior inference over the hidden variables θ and z is intractable due to the coupling between the θ and β under the multinomial assumption (dickey, 1983).a popular approximation for efficient inference in topic models is mean field variational inference, which breaks the coupling between θ and z by introducing free variational parameters γ over θ and φ over z and dropping the edges between them. this results in an approximate variational posterior q(θ, z|γ, φ) = qγ(θ) ∏ n qφ(zn), which is optimized to best approximate the true posterior p(θ, z|w, α, β). the optimization problem is to minimize
(2)l(γ, φ | α, β) = dkl [q(θ, z|γ, φ)||p(θ, z|w, α, β)]− log p(w|α, β).
in fact the above equation is a lower bound to the marginal log likelihood, sometimes called an evidence lower bound (elbo), a fact which can be easily verified by multiplying and dividing (1) by the variational posterior and then applying jensen’s inequality on its logarithm. note that the mean field method optimizes over an independent set of variational parameters for each document. to emphasize this, we will refer to this standard method by the non-standard name of decoupled mean-field variational inference (dmfvi).
for lda, this optimization has closed form coordinate descent equations due to the conjugacy between the dirichlet and multinomial distributions. although this is a computationally convenient aspect of dmfvi, it also limits its flexibility. applying dmfvi to new models relies on the practitioner’s ability to derive the closed form updates, which can be impractical and sometimes impossible.
aevb (kingma & welling, 2014; rezende , 2014) is one of several recent methods that aims at “black box” inference methods to sidestep this issue. first, rewrite the elbo as
(3)l(γ, φ | α, β) = −dkl [q(θ, z|γ, φ)||p(θ, z|α)] + eq(θ,z|γ,φ)[log p(w|z, θ, α, β)]
this form is intuitive. the first term attempts to match the variational posterior over latent variables to the prior on the latent variables, while the second term ensures that the variational posterior favors values of the latent variables that are good at explaining the data. by analogy to autoencoders, this second term is referred to as a reconstruction term.
what makes this method “autoencoding,” and in fact the main difference from dmfvi, is the parameterization of the variational distribution. in aevb, the variational parameters are computed by using a neural network called an inference network that takes the observed data as input. for example, if the model prior p(θ) were gaussian, we might define the inference network as a feedforward neural network (µ(w),v(w)) = f(w, γ), where µ(w) and v(w) are both vectors of length k, and γ are the network’s parameters. then we might choose a gaussian variational distribution qγ(θ) = n(θ;µ(w), diag(v(w))), where diag(· · ·) produces a diagonal matrix from a column vector. the variational parameters γ can then be chosen by optimizing the elbo (3). note that we have
now, unlike dmfvi, coupled the variational parameters for different documents because they are all computed from the same neural network. to compute the expectations with respect to q in (3), kingma & welling (2014); rezende  (2014) use a monte carlo estimator which they call the “reparameterization trick” (rt; appears also in williams (1992)). in the rt, we define a variate u with a simple distribution that is independent of all variational parameters, like a uniform or standard normal, and a reparameterization function f such that f (u, γ) has distribution qγ . this is always possible, as we could choose f to be the inverse cumulative distribution function of qγ , although we will additionally want f to be easy to compute and differentiable. if we can determine a suitable f , then we can approximate (3) by taking monte carlo samples of u , and optimize γ using stochastic gradient descent.although simple conceptually, applying aevb to topic models raises several practical challenges. the first is the need to determine a reparameterization function for q(θ) and q(zn) to use the rt. the zn are easily dealt with, but θ is more difficult; if we choose q(θ) to be dirichlet, it is difficult to apply the rt, whereas if we choose q to be gaussian or logistic normal, then the kl divergence in (3) becomes more problematic. the second issue is the well known problem of component collapsing (dinh & dumoulin, 2016), which a type of bad local optimum that is particularly endemic to aevb and similar methods. we describe our solutions to each of those problems in the next few subsections. .1 collapsing z’s
dealing with discrete variables like z using reparameterization can be problematic, but fortunately in lda the variable z can be conveniently summed out. by collapsing z we are left with having to sample from θ only, reducing (1) to
(4)p(w|α, β) = ∫ θ ( n∏ n=1 p(wn|β, θ) ) p(θ|α)dθ.
where the distribution of wn|β, θ is multinomial(1, βθ), recalling that β denotes the matrix of all topic-word probability vectors.lda gets its name from the dirichlet prior on the topic proportions θ, and the choice of dirichlet prior is important to obtaining interpretable topics (wallach , 2009). but it is difficult to handle the dirichlet within aevb because it is difficult to develop an effective reparameterization function for the rt. fortunately, a rt does exist for the gaussian distribution and has been shown to perform quite well in the context of variational autoencoder (vae) (kingma & welling, 2014).
we resolve this issue by constructing a laplace approximation to the dirichlet prior. following mackay (1998), we do so in the softmax basis instead of the simplex. there are two benefits of this choice. first, dirichlet distributions are unimodal in the softmax basis with their modes coinciding with the means of the transformed densities. second, the softmax basis also allows for carrying out unconstrained optimization of the cost function without the simplex constraints. the dirichlet probability density function in this basis over the softmax variable h is given by
(5)p (θ(h)|α) = γ( ∑ k αk)∏
k γ(αk) ∏ k θαkk g(1 th).
here θ = σ(h), where σ(.) represents the softmax function. recall that the jacobian of σ is proportional to ∏ k θk and g(·) is an arbitrary density that ensures integrability by constraining the redundant degree of freedom. we use the laplace approximation of hennig  (2012), which
has the property that the covariance matrix becomes diagonal for large k (number of topics). this approximation to the dirichlet prior p(θ|α) is results in the distribution over the softmax variables h as a multivariate normal with mean µ1 and covariance matrix σ1 where
µ1k = logαk − 1
k ∑ i logαi
σ1kk = 1
αk
( 1− 2
k
) + 1
k2 ∑ i 1 αk . (6)
finally, we approximate p(θ|α) in the simplex basis with p̂(θ|µ1,σ1) = ln (θ|µ1,σ1) where ln is a logistic normal distribution with parameters µ1,σ1. although we approximate the dirichlet prior in lda with a logistic normal, this is not the same idea as a correlated topic model (blei & lafferty, 2006), because we use a diagonal covariance matrix. rather, it is an approximation to standard lda.now we can write the modified variational objective function. we use a logistic normal variational distribution over θ with diagonal covariance. more precisely, we define two inference networks as feed forward neural networks fµ and fς with parameters δ; the output of each network is a vector in rk . then for a document w, we define q(θ) to be logistic normal with mean µ0 = fµ(w, δ) and diagonal covariance σ0 = diag(fς(w, δ)), where diag converts a column vector to a diagonal matrix. note that we can generate samples from q(θ) by sampling ∼ n (0, i) and computing θ = σ(µ0 + σ 1/2 0 ).
we can now write the elbo as
l(θ) = d∑ d=1
[ − ( 1 
{ tr(σ−11 σ0) + (µ1 −µ0)tς −1 1 (µ1 −µ0)−k + log
|σ1| |σ0|
}) (7)
+e ∼n (0,i) [ w>d log ( σ(β)σ(µ0 + σ 1/2 0 ) )]] ,
where θ represents the set of all the model and variational parameters and w1 . . .wd are the documents in the corpus. the first line in this equation arises from the kl divergence between the two logistic normal distributions q and p̂, while the second line is the reconstruction error.
in order to impose the simplex constraint on the β matrix during the optimization, we apply the softmax transformation. that is, each topic βk ∈ rv is unconstrained, and the notation σ(β) means to apply the softmax function separately to each column of the matrix β. note that the mixture of multinomials for each word wn can then be written as p(wn|β, θ) = [σ(β)θ]wn , which explains the dot product in (7). to optimize (7), we use stochastic gradient descent using monte carlo samples from , following the law of the unconscious statistician.aevb is prone to component collapsing (dinh & dumoulin, 2016), which is a particular type of local optimum very close to the prior belief, early on in the training. as the latent dimensionality of the model is increased, the kl regularization in the variational objective dominates, so that the outgoing decoder weights collapse for the components of the latent variable that reach close to the prior and do not show any posterior divergence. in our case, the collapsing specifically occurs because of the inclusion of the softmax transformation to produce θ. the result is that the k inferred topics are identical as shown in table 7.
we were able to resolve this issue by tweaking the optimization. specifically, we train the network with the adam optimizer (kingma & ba, 2015) using high moment weight (β1) and learning rate (η). through training at higher rates, early peaks in the functional space can be easily avoided. the
problem is that momentum based training coupled with higher learning rate causes the optimizer to diverge. while explicit gradient clipping helps to a certain extent, we found that batch normalization (ioffe & szegedy, 2015) does even better by smoothing out the functional space and hence curbing sudden divergence.
finally, we also found an increase in performance with dropout units when applied to θ to force the network to use more of its capacity.
while more prominent in the aevb framework, the collapsing can also occurs in dmfvi if the learning offset (referred to as the τ parameter (hofmann, 1999)) is not set properly. interestingly, a similar learning offset or annealing based approach can also be used to down-weight the kl term in early iterations of the training to avoid local optima.in lda, the distribution p(w|θ, β) is a mixture of multinomials. a problem with this assumption is that it can never make any predictions that are sharper than the components that are being mixed (hinton & salakhutdinov, 2009). this can result in some topics appearing that are poor quality and do not correspond well with human judgment. one way to resolve this issue is to replace this word-level mixture with a weighted product of experts which by definition is capable of making sharper predictions than any of the constituent experts (hinton, 2002). in this section we present a novel topic model prodlda that replaces the mixture assumption at the word-level in lda with a weighted product of experts, resulting in a drastic improvement in topic coherence. this is a good illustration of the benefits of a black box inference method, like avitm, to allow exploration of new models.the prodlda model can be simply described as latent dirichlocation where the word-level mixture over topics is carried out in natural parameter space, i.e. the topic matrix is not constrained to exist in a multinomial simplex prior to mixing. in other words, the only changes from lda are that β is unnormalized, and that the conditional distribution of wn is defined as wn|β, θ ∼ multinomial(1, σ(βθ)).
the connection to a product of experts is straightforward, as for the multinomial, a mixture of natural parameters corresponds to a weighted geometric average of the mean parameters. that is, consider two n dimensional multinomials parametrized by mean vectors p and q. define the corresponding natural parameters as p = σ(r) and q = σ(s), and let δ ∈ [0, 1]. it is then easy to show that
p ( x|δr + (1− δ)s ) ∝ n∏ i=1 σ(δri + (1− δ)si)xi ∝ n∏ i=1 [rδi · s (1−δ) i ] xi .
so the prodlda model can be simply described as a product of experts, that is, p(wn|θ, β) ∝∏ k p(wn|zn = k, β)θk . prodlda is an instance of the exponential-family pca (collins , 2001) class, and relates to the exponential-family harmoniums (welling , 2004) but with nongaussian priors.for an overview of topic modeling, see blei (2012). there are several examples of topic models based on neural networks and neural variational inference (hinton & salakhutdinov, 2009; larochelle & lauly, 2012; mnih & gregor, 2014; miao , 2016) but we are unaware of methods that apply aevb generically to a topic model specified by an analyst, or even of a successful application of aevb to the most widely used topic model, latent dirichlocation.
recently, miao  (2016) introduced a closely related model called the neural variational document model (nvdm). this method uses a latent gaussian distribution over topics, like probabilistic latent semantic indexing, and averages over topic-word distributions in the logit space. however,
they do not use either of the two key aspects of our work: explicitly approximating the dirichlet prior using a gaussian, or high-momentum training. in the experiments we show that these aspects lead to much improved training and much better topics.qualitative evaluation of topic models is a challenging task and consequently a large body of work has developed automatic evaluation metrics that attempt to match human judgment of topic quality. traditionally, perplexity has been used to measure the goodness-of-fit of the model but it has been repeatedly shown that perplexity is not a good metric for qualitative evaluation of topics (newman , 2010). several new metrics of topic coherence evaluation have thus been proposed; see lau  (2014) for a comparative review. lau  (2014) showed that among all the competing metrics, normalized pointwise mutual information (npmi) between all the pairs of words in a set of topics matches human judgment most closely, so we adopt it in this work. we also report perplexity, primarily as a way of evaluating the capability of different optimizers. following standard practice (blei , 2003), for variational methods we use the elbo to calculate perplexity. for aevb methods, we calculate the elbo using the same monte carlo approximation as for training.
we run experiments on both the 20 newsgroups (11,000 training instances with 2000 word vocabulary) and rcv1 volume 2 ( 800k training instances with 10000 word vocabulary) datasets. our preprocessing involves tokenization, removal of some non utf-8 characters for 20 newsgroups and english stop word removal. we first compare our avitm inference method with the standard online mean-field variational inference (hoffman , 2010) and collapsed gibbs sampling (griffiths & steyvers, 2004) on the lda model. we use standard implementations of both methods, scikit-learn for dmfvi and mallet (mccallum, 2002) for collapsed gibbs. then we compare two autoencoding inference methods on three different topic models: standard lda, prodlda using our inference method and the neural variational document model (nvdm) (miao , 2016), using the inference described in the paper.2
tables 1 and 2 show the average topic coherence values for all the models for two different settings of k, the number of topics. comparing the different inference methods for lda, we find that, consistent with previous work, collapsed gibbs sampling yields better topics than mean-field methods. among the variational methods, we find that vae-lda model (avitm) 3 yields similar topic coherence and perplexity to the standard dmfvi (although in some cases, vae-lda yields significantly better topics). however, avitm is significantly faster to train than dmfvi. it takes 46 seconds on 20 newsgroup compared to 18 minutes for dmfvi. whereas for a million document corpus of rcv1 it only under 1.5 hours while scikit-learn’s implementation of dmfvi failed to return any results even after running for 24 hours.4
comparing the new topic models than lda, it is clear that prodlda finds significantly better topics than lda, even when trained by collapsed gibbs sampling. to verify this qualitatively, we display examples of topics from all the models in table 6. the topics from prodlda appear visually more coherent than nvdm or lda. unfortunately, nvdm does not perform comparatively to lda we have used both https://github.com/carpedm20/variational-text-tensorflow and the nvdm author’s (miao , 2016) implementation. we recently found that ’whitening’ the topic matrix significantly improves the topic coherence for vaelda. manuscript in preparation. therefore, we were not able to report topic coherence for dmfvi on rcv1
for any value of k. to avoid any training dissimilarities we train all the competing models until we reach the perplexities that were reported in previous work. these are reported in table 35.
a major benefit of avitm inference is that it does not require running variational optimization, which can be costly, for new data. rather, the inference network can be used to obtain topic proportions for new documents for new data points without running any optimization. we evaluate whether this approximation is accurate, i.e. whether the neural network effectively learns to mimic probabilistic inference. we verify this by training the model on the training set, then on the test set, holding the topics (β matrix) fixed, and comparing the test perplexity if we obtain topic proportions by running the inference neural network directly, or by the standard method of variational optimization of the inference network on the test set. as shown in table 4, the perplexity remains practically un-changed. the computational benefits of this are remarkable. on both the datasets, computing perplexity using the neural network takes well under a minute, while running the standard variational approximation takes ∼ 3 minutes even on the smaller 20 newsgroups data. finally, we investigate the reasons behind the improved topic coherence in prodlda. first, table 5 explores the effects of each of our two main ideas separately. in this table, “dirichlet” means that the prior is the laplace approximation to dirichlet(α = 0.02), while “gaussian” indicates that we use a standard gaussian as prior. ‘high learning rate” training means we use β1 > 0.8 and 0.1 > η > 0.0016 with batch normalization, whereas “low learning rate” means β1 > 0.8 and 0.0009 > η > 0.00009 without batch normalization. (for both parameters, the precise value was chosen by bayesian optimization. we found that these values in the ”with bn” cases were close to the default settings in the adam optimizer.) we find that the high topic coherence that we achieve in this work is only possible if we use both tricks together. in fact the high learning rates with momentum is required to avoid local minima in the beginning of the training and batch-normalization is required to be able to train the network at these values without diverging. if trained at a lower momentum value or at a lower learning rate prodlda shows component collapsing. interestingly, if we choose a gaussian prior, rather than the logistic normal approximation used in prodlda or nvlda, the model is easier to train even with low learning rate without any momentum or batch normalization.
the main advantage of avitm topic models as opposed to nvdm is that the laplace approximation allows us to match a specific dirichlet prior of interest. as pointed out by wallach  (2009), the choice of dirichlet hyperparameter is important to the topic quality of lda. following this reasoning, we hypothesize that avitm topics are higher quality than those of nvdm because they are much more focused, i.e., apply to a more specific subset of documents of interest. we provide support for this hypothesis in figure 1, by evaluating the sparsity of the posterior proportions over topics, that is, how many of the model’s topics are typically used to explain each document. in order to estimate the sparsity in topic proportions, we project samples from the gaussian latent spaces of prodlda and nvdm in the simplex and average them across documents. we compare the topic we note that much recent work follows hinton & salakhutdinov (2009) in reporting perplexity for the lda gibbs sampler on only a small subset of the test data. our results are different because we use the entire test dataset. β1 is the weight on the average of the gradients from the previous time step and η refers to the learning rate.
sparsity for the standard gaussian prior used by nvdm to the laplace approximation of dirichlet priors with different hyperparameters. clearly the laplace approximation to the dirichlet prior significantly promotes sparsity, providing support for our hypothesis that preserving the dirichlet prior explains the the increased topic coherence in our method.
the inference network architecture can be found in figure 2 in the appendix.we present what is to our knowledge the first effective aevb inference algorithm for latent dirichlocation. although this combination may seem simple in principle, in practice this method is difficult to train because of the dirichlet prior and because of the component collapsing problem. by addressing both of these problems, we presented a black-box inference method for topic models with the notable advantage that the neural network allows computing topic proportions for new documents without the need to run any variational optimization. as an illustration of the advantages ofblack box inference techniques, we presented a new topic model, prodlda, which achieves significantly better topics than lda, while requiring a change of only one line of code from avitm for lda. our results suggest that avitm inference is ready to take its place alongside mean field and collapsed gibbs as one of the workhorse inference methods for topic models. future work could include extending our inference methods to handle dynamic and correlated topic models.we thank andriy mnih, chris dyer, chris russell, david blei, hannah wallach, max welling, mirella lapata and yishu miao for helpful comments, discussions and feedback.",1
375.pdf.json,,"word embeddings computed using diverse methods are basic building blocks for natural language processing (nlp) and information retrieval (ir). they capture the similarities between words (e.g., (bengio , 2003; collobert & weston, 2008; mikolov , 2013a; pennington , 2014)). recent work has tried to compute embeddings that capture the semantics of word sequences (phrases, sentences, and paragraphs), with methods ranging from simple additional composition of the word vectors to sophisticated architectures such as convolutional neural networks and recurrent neural networks (e.g., (iyyer , 2015; le & mikolov, 2014; kiros , 2015; socher , 2011; blunsom , 2014; tai , 2015; wang , 2016)). recently, (wieting , 2016) learned general-purpose, paraphrastic sentence embeddings by starting with standard word embeddings and modifying them based on supervision from the paraphrase pairs dataset (ppdb), and constructing sentence embeddings by training a simple word averaging model. this simple method leads to better performance on textual similarity tasks than a wide variety of methods and serves as a good initialization for textual classification tasks. however, supervision from the paraphrase dataset seems crucial, since they report that simple average of the initial word embeddings does not work very well.
here we give a new sentence embedding method that is embarrassingly simple: just compute the weighted average of the word vectors in the sentence and then remove the projections of the average vectors on their first principal component (“common component removal”). here the weight of a word w is a/(a+ p(w)) with a being a parameter and p(w) the (estimated) word frequency; we call
this smooth inverse frequency (sif). this method achieves significantly better performance than the unweighted average on a variety of textual similarity tasks, and on most of these tasks even beats some sophisticated supervised methods tested in (wieting , 2016), including some rnn and lstm models. the method is well-suited for domain adaptation settings, i.e., word vectors trained on various kinds of corpora are used for computing the sentence embeddings in different testbeds. it is also fairly robust to the weighting scheme: using the word frequencies estimated from different corpora does not harm the performance; a wide range of the parameters a can achieve close-to-best results, and an even wider range can achieve significant improvement over unweighted average.
of course, this sif reweighting is highly reminiscent of tf-idf reweighting from information retrieval (sparck jones, 1972; robertson, 2004) if one treats a “sentence” as a “document” and make the reasonable assumption that the sentence doesn’t typically contain repeated words. such reweightings (or related ideas like removing frequent words from the vocabulary) are a good rule of thumb but has not had theoretical justification in a word embedding setting.
the current paper provides a theoretical justification for the reweighting using a generative model for sentences, which is a simple modification for the random walk on discourses model for generating text in (arora , 2016). in that paper, it was noted that the model theoretically implies a sentence embedding, namely, simple average of embeddings of all the words in it.
we modify this theoretical model, motivated by the empirical observation that most word embedding methods, since they seek to capture word cooccurence probabilities using vector inner product, end up giving large vectors to frequent words, as well as giving unnecessarily large inner products to word pairs, simply to fit the empirical observation that words sometimes occur out of context in documents. these anomalies cause the average of word vectors to have huge components along semantically meaningless directions. our modification to the generative model of (arora , 2016) allows “smoothing” terms, and then a max likelihood calculation leads to our sif reweighting.
interestingly, this theoretically derived sif does better (by a few percent points) than traditional tfidf in our setting. the method also improves the sentence embeddings of wieting , as seen in table 1. finally, we discovered that —contrary to widespread belief—word2vec(cbow) also does not use simple average of word vectors in the model, as misleadingly suggested by the usual expression pr[w|w1, w2, . . . , w5] ∝ exp(vw · ( 15 ∑ i vwi)). a dig into the implementation shows it implicitly uses a weighted average of word vectors —again, different from tf-idf— and this weighting turns out to be quite similar in effect to ours. (see section 3.1.)word embeddings. word embedding methods represent words as continuous vectors in a low dimensional space which capture lexical and semantic properties of words. they can be obtained from the internal representations from neural network models of text (bengio , 2003; collobert & weston, 2008; mikolov , 2013a) or by low rank approximation of co-occurrence statistics (deerwester , 1990; pennington , 2014). the two approaches are known to be closely related (levy & goldberg, 2014; hashimoto , 2016; arora , 2016).
our work is most directly related work to (arora , 2016), which proposed a random walk model for generating words in the documents. our sentence vector can be seen as approximate inference of the latent variables in their generative model.
phrase/sentence/paragraph embeddings. previous works have computed phrase or sentence embeddings by composing word embeddings using operations on vectors and matrices e.g., (mitchell & lapata, 2008; 2010; blacoe & lapata, 2012). they found that coordinate-wise multiplication of the vectors performed very well among the binary operations studied. unweighted averaging is also found to do well in representing short phrases (mikolov , 2013a). another approach is recursive neural networks (rnns) defined on the parse tree, trained with supervision (socher , 2011) or without (socher , 2014). simple rnns can be viewed as a special case where the parse tree is replaced by a simple linear chain. for example, the skip-gram model (mikolov , 2013b) is extended to incorporate a latent vector for the sequence, or to treat the sequences rather than the word as basic units. in (le & mikolov, 2014) each paragraph was assumed to have a latent paragraph vector, which influences the distribution of the words in the paragraph. skip-thought
of (kiros , 2015) tries to reconstruct the surrounding sentences from surrounded one and treats the hidden parameters as their vector representations. rnns using long short-term memory (lstm) capture long-distance dependency and have also been used for modeling sentences (tai , 2015). other neural network structures include convolution neural networks, such as (blunsom , 2014) that uses a dynamic pooling to handle input sentences of varying length and do well in sentiment prediction and classification tasks.
the directed inspiration for our work is (wieting , 2016) which learned paraphrastic sentence embeddings by using simple word averaging and also updating standard word embeddings based on supervision from paraphrase pairs; the supervision being used for both initialization and training.we briefly recall the latent variable generative model for text in (arora , 2016). the model treats corpus generation as a dynamic process, where the t-th word is produced at step t. the process is driven by the random walk of a discourse vector ct ∈ <d. each word w in the vocabulary has a vector in <d as well; these are latent variables of the model. the discourse vector represents “what is being talked about.” the inner product between the discourse vector ct and the (time-invariant) word vector vw for word w captures the correlations between the discourse and the word. the probability of observing a word w at time t is given by a log-linear word production model from mnih and hinton:
pr[w emitted at time t | ct] ∝ exp (〈ct, vw〉) . (1)
the discourse vector ct does a slow random walk (meaning that ct+1 is obtained from ct by adding a small random displacement vector), so that nearby words are generated under similar discourses. it was shown in (arora , 2016) that under some reasonable assumptions this model generates behavior –in terms of word-word cooccurence probabilities—that fits empirical works like word2vec and glove. the random walk model can be relaxed to allow occasional big jumps in ct, since a simple calculation shows that they have negligible effect on cooccurrence probabilities of words. the word vectors computed using this model are reported to be similar to those from glove and word2vec(cbow).
our improved random walk model. clearly, it is tempting to define the sentence embedding as follows: given a sentence s, do a map estimate of the discourse vectors that govern this sentence. we note that we assume the discourse vector ct doesn’t change much while the words in the sentence were emitted, and thus we can replace for simplicity all the ct’s in the sentence s by a single discourse vector cs. in the paper (arora , 2016), it was shown that the map estimate of cs is —up to multiplication by scalar—the average of the embeddings of the words in the sentence.
in this paper, towards more realistic modeling, we change the model (1) as follows. this model has two types of “smoothing term”, which are meant to account for the fact that some words occur out of context, and that some frequent words (presumably “the”, “and ” etc.) appear often regardless of the discourse. we first introduce an additive term αp(w) in the log-linear model, where p(w) is the unigram probability (in the entire corpus) of word and α is a scalar. this allows words to occur even if their vectors have very low inner products with cs. secondly, we introduce a common discourse vector c0 ∈ <d which serves as a correction term for the most frequent discourse that is often related to syntax. (other possible correction is left to future work.) it boosts the co-occurrence probability of words that have a high component along c0.
concretely, given the discourse vector cs, the probability of a word w is emitted in the sentence s is modeled by,
pr[w emitted in sentence s | cs] = αp(w) + (1− α) exp (〈c̃s, vw〉)
zc̃s , (2)
where c̃s = βc0 + (1− β)cs, c0 ⊥ cs where α and β are scalar hyperparameters, and zc̃s = ∑ w∈v exp (〈c̃s, vw〉) is the normalizing constant (the partition function). we see that the model allows a word w unrelated to the discourse cs to be omitted for two reasons: a) by chance from the term αp(w); b) if w is correlated with the common discourse vector c0.
algorithm 1 sentence embedding input: word embeddings {vw : w ∈ v}, a set of sentences s, parameter a and estimated probabilities {p(w) : w ∈ v} of the words. output: sentence embeddings {vs : s ∈ s} : for all sentence s in s do 2: vs ← 1|s| ∑ w∈s a a+p(w)vw 3: end for 4: compute the first principal component u of {vs : s ∈ s} 5: for all sentence s in s do 6: vs ← vs − uu>vs 7: end for
computing the sentence embedding. the word embeddings yielded by our model are actually the same 1 the sentence embedding will be defined as the max likelihood estimate for the vector cs that generated it. ( in this case mle is the same as map since the prior is uniform.) we borrow the key modeling assumption of (arora , 2016), namely that the word vw’s are roughly uniformly dispersed, which implies that the partition function zc is roughly the same in all directions. so assume that zc̃s is roughly the same, say z for all c̃s. by the model (2) the likelihood for the sentence is
p[s | cs] = ∏ w∈s p(w | cs) = ∏ w∈s [ αp(w) + (1− α)exp (〈vw, c̃s〉) z ] .
let
fw(c̃s) = log
[ αp(w) + (1− α)exp (〈vw, c̃s〉)
z ] denote the log likelihood of sentence s. then, by simple calculus we have,
∇fw(c̃s) = 1 αp(w) + (1− α) exp (〈vw, c̃s〉) /z 1− α z exp (〈vw, c̃s〉) vw.
then by taylor expansion, we have,
fw(c̃s) ≈ fw(0) +∇fw(0)>c̃s
= constant + (1− α)/(αz)
p(w) + (1− α)/(αz) 〈vw, c̃s〉 .
therefore, the maximum likelihood estimator for c̃s on the unit sphere (ignoring normalization) is approximately,2
arg max ∑ w∈s fw(c̃s) ∝ ∑ w∈s
a
p(w) + a vw, where a = 1− α αz . (3)
that is, the mle is approximately a weighted average of the vectors of the words in the sentence. note that for more frequent words w, the weight a/(p(w) + a) is smaller, so this naturally leads to a down weighting of the frequent words.
to estimate cs, we estimate the direction c0 by computing the first principal component of c̃s’s for a set of sentences. in other words, the final sentence embedding is obtained by subtracting the projection of c̃s’s to their first principal component. this is summarized in algorithm 1.word2vec (mikolov , 2013b) uses a sub-sampling technique which downsamples word w with probability proportional to 1/ √ p(w) where p(w) is the marginal probability of the word w. this we empirically discovered the significant common component c0 in word vectors built by existing methods, which inspired us to propose our theoretical model of this paper. note that maxc:‖c‖=1 c + 〈c, g〉 = g/‖g‖ for any constant c.
heuristic not only speeds up the training but also learns more regular word representations. here we explain that this corresponds to an implicit reweighting of the word vectors in the model and therefore the statistical benefit should be of no surprise.
recall the vanilla cbow model of word2vec:
pr[wt | wt−1, . . . , wt−5] ∝ exp (〈v̄t, vw〉) , where v̄t = 1  5∑ i=1 vwt−i . (4)
it can be shown that the loss (mle) for the single word vector vw (from this occurrence) can be abstractly written in the form,
g(vw) = γ(〈v̄t, vw〉) + negative sampling terms ,
where γ(x) = log(1/(1 + e−x)) is the logistic function. therefore, the gradient of g(vw) is
∇g(vw) = γ′(〈v̄t, vw〉)v̄t = α(vwt−5 + vwt−4 + vwt−3 + vwt−2 + vwt−1) , (5)
where α is a scalar. that is, without the sub-sampling trick, the update direction is the average of the word vectors in the window.
the sub-sampling trick in (mikolov , 2013b) randomly selects the summands in equation (5) to “estimate” the gradient. specifically, the sampled update direction is
∇̃g(vw) = α(j5vwt−5 + j4vwt−4 + j3vwt−3 + j2vwt−2 + j1vwt−1) (6)
where jk’s are bernoulli random variables with pr [jk = 1] = q(wt−k) , min { 1, √ 10−5
p(wt−k)
} .
however, we note that ∇̃g(vw) is (very) biased estimator! we have that the expectation of ∇̃g(vw) is a weighted sum of the word vectors,
e [ ∇̃g(vw) ] = α(q(wt−5)vwt−5 + q(wt−4)vwt−4 + q(wt−3)vwt−3 + q(wt−2)vwt−2 + q(wt−1)vwt−1) .
in fact, the expectation e[∇̃g(vw)] corresponds to the gradient of a modified word2vec model with the average v̄t (in equation (4)) being replaced by the weighted average ∑5 k=1 q(wt−k)vwt−k . such a weighted model can also share the same form of what we derive from our random walk model as in equation (3). moreover, the weighting q(wi) closely tracks our weighting scheme a/(a + p(w)) when using parameter a = 10−4; see figure 1 for an illustration. therefore, the expected gradient here is approximately the estimated discourse vector in our model! thus, word2vec with sub-sampling gradient heuristic corresponds to a stochastic gradient update method for using our weighting scheme.datasets. we test our methods on the 22 textual similarity datasets including all the datasets from semeval semantic textual similarity (sts) tasks (2012-2015) (agirre , 2012; 2013; 2014; agirrea , 2015), and the semeval 2015 twitter task (xu , 2015) and the semeval 2014 semantic relatedness task (marelli , 2014). the objective of these tasks is to predict the similarity between two given sentences. the evaluation criterion is the pearson’s coefficient between the predicted scores and the ground-truth scores.
experimental settings. we will compare our method with the following: . unsupervised: st, avg-glove, tfidf-glove. st denotes the skip-thought vectors (kiros , 2015), avg-glove denotes the unweighted average of the glove vectors (pennington , 2014),3 and tfidf-glove denotes the weighted average of glove vectors using tf-idf weights. . semi-supervised: avg-psl. this method uses the unweighted average of the paragramsl999 (psl) word vectors from (wieting , 2015). the word vectors are trained using labeled data, but the sentence embedding are computed by unweighted average without training. . supervised: pp, pp-proj., dan, rnn, irnn, lstm (o.g.), lstm (no). all these methods are initialized with psl word vectors and then trained on the ppdb dataset. pp and ppproj. are proposed in (wieting , 2016). the first is an average of the word vectors, and the second additionally adds a linear projection. the word vectors are updated during the training. dan denotes the deep averaging network of (iyyer , 2015). rnn denotes the classical recurrent neural network, and irnn denotes a variant with the activation being the identity, and the weight matrices initialized to identity. the lstm is the version from (gers , 2002), either with output gates (denoted as lstm(o.g.)) or without (denoted as lstm (no)).
our method can be applied to any types of word embeddings. so we denote the sentence embeddings obtained by applying our method to word embeddings method “xxx” as “xxx+wr”.4 to get a completely unsupervised method, we apply it to the glove vectors, denoted as glove+wr. the weighting parameter a is fixed to 10−3, and the word frequencies p(w) are estimated from the we used the vectors that are publicly available at http:/.lp.stanford.edu/projects/glove/. they are 300- dimensional vectors that were trained on the 840 billion token common crawl corpus. “w” stands for the smooth inverse frequency weighting scheme, and “r” stands for removing the common components.
commoncrawl dataset.5 this is denoted by glove+wr in table 1. we also apply our method on the psl vectors, denoted as psl+wr, which is a semi-supervised method.
results. the results are reported in table 1. each year there are 4 to 6 sts tasks. for clarity, we only report the average result for the sts tasks each year; the detailed results are in the appendix.
the unsupervised method glove+wr improves upon avg-glove significantly by 10% to 30%, and beats the baselines by large margins. it achieves better performance than lstm and rnn and is comparable to dan, even though the later three use supervision. this demonstrates the power of this simple method: it can be even stronger than highly-tuned supervisedly trained sophisticated models. using tf-idf weighting scheme also improves over the unweighted average, but not as much as our method.
the semi-supervised method psl+wr achieves the best results for four out of the six tasks and is comparable to the best in the rest of two tasks. overall, it outperforms the avg-psl baseline and all the supervised models initialized with the same psl vectors. this demonstrates the advantage of our method over the training for those models.
we also note that the top singular vectors c0 of the datasets seem to roughly correspond to the syntactic information or common words. for example, closest words (by cosine similarity) to c0 in the sick dataset are “just”, “when”, “even”, “one”, “up”, “little”, “way”, “there”, “while”, and “but.”
finally, in the appendix, we showed that our two ideas all contribute to the improvement: for glove vectors, using smooth inverse frequency weighting alone improves over unweighted average by about 5%, using common component removal alone improves by 10%, and using both improves by 13%.we study the sensitivity of our method to the weighting parameter a, the method for computing word vectors, and the estimated word probabilities p(w). first, we test the performance of three it is possible to tune the parameter a to get better results. the effect of a and the corpus for estimating word frequencies are studied in section 4.1.1.
types of word vectors (psl, glove, and sn) on the sts 2012 tasks. sn vectors are trained on the enwiki dataset (wikimedia, 2012) using the method in (arora , 2016), while psl and glove vectors are those used in table 1. we enumerate a ∈ {10−i, 3 × 10−i : 1 ≤ i ≤ 5} and use the p(w) estimated on the enwiki dataset. figure 2a shows that for all three kinds of word vectors, a wide range of a leads to significantly improved performance over the unweighted average. best performance occurs from a = 10−3 to a = 10−4.
next, we fix a = 10−3 and use four very different datasets to estimate p(w): enwiki (wikipedia, 3 billion tokens), poliblogs (yano , 2009) (political blogs, 5 million), commoncrawl (buck , 2014) (internet crawl, 800 billion), text8 (mahoney, 2008) (wiki subset, 1 million). figure 2b shows performance is almost the same for all four settings.
the fact that our method can be applied on different types of word vectors trained on different corpora also suggests it should be useful across different domains. this is especially important for unsupervised methods, since the unlabeled data available may be collected in a different domain from the target application.the sentence embeddings obtained by our method can be used as features for downstream supervised tasks. we consider three tasks: the sick similarity task, the sick entailment task, and the stanford sentiment treebank (sst) binary classification task (socher , 2013). to highlight the representation power of the sentence embeddings learned unsupervisedly, we fix the embeddings and only learn the classifier. setup of supervised tasks mostly follow (wieting , 2016) to allow fair comparison, i.e., the classifier a linear projection followed by the classifier in (kiros , 2015). the linear projection maps the sentence embeddings into 2400 dimension (the same as the skip-thought vectors), and is learned during the training. we compare our method to pp, dan, rnn, and lstm, which are the methods used in section 4.1. we also compare to the skip-thought vectors (with improved training in (lei ba , 2016)).
results. our method gets better or comparable performance compared to the competitors. it gets the best results for two of the tasks. this demonstrates the power of our simple method. we emphasize that our embeddings are unsupervisedly learned, while dan, rnn, lstm are trained with supervision. furthermore, skip-thought vectors are much higher dimensional than ours (though projected into higher dimension, the original 300 dimensional embeddings contain all the information).
the advantage is not as significant as in the textual similarity tasks. this is possibly because similarity tasks rely directly upon cosine similarity, which favors our method’s approach of removing the common components (which can be viewed as a form of denoising), while in supervised tasks, with the cost of some label information, the classifier can pick out the useful components and ignore the common ones.
finally, we speculate that our method doesn’t outperform rnn’s and lstm’s for sentiment tasks because (a) the word vectors —and more generally the distributional hypothesis of meaning —has known limitations for capturing sentiment due to the “antonym problem”, (b) also in our weighted average scheme, words like “not” that may be important for sentiment analysis are downweighted a lot. to address (a), there is existing work on learning better word embeddings for sentiment analysis (e.g., (maas , 2011)). to address (b), it is possible to design weighting scheme (or learn weights) for this specific task.a interesting feature of our method is that it ignores the word order. this is in contrast to that rnn’s and lstm’s can potentially take advantage of the word order. the fact that our method achieves better or comparable performance on these benchmarks raise the following question: is word order not important in these benchmarks? we conducted an experiment suggesting that word order does play some role.
we trained and tested rnn/lstm on the supervised tasks where the words in each sentence are randomly shuffled, and the results are reported in table 3.6 it can be observed that the performance drops noticeably. thus our method —which ignores word order—must be much better at exploiting the semantics than rnn’s and lstm’s. an interesting future direction is to explore if some ensemble idea can combine the advantages of both approaches.this work provided a simple approach to sentence embedding, based on the discourse vectors in the random walk model for generating text (arora , 2016). it is simple and unsupervised, but achieves significantly better performance than baselines on various textual similarity tasks, and can even beat sophisticated supervised methods such as some rnn and lstm models. the sentence embeddings obtained can be used as features in downstream supervised tasks, which also leads to better or comparable results compared to the sophisticated methods.we thank the reviewers for insightful comments. we also thank the authors of (wieting , 2016; bowman , 2015) for sharing their code or the preprocessed datasets.
this work was supported in part by nsf grants ccf-1527371, dms-1317308, simons investigator award, simons collaboration grant, and onrn00014- 16-1-2329. tengyu ma was supported in addition by simons award in theoretical computer science and ibm phd fellowship.a.1 unsupervised task: textual similarity
the competitors. we give a brief overview of the competitors. rnn is the classical recurrent neural network:
ht = f(wxw xt w +whht−1 + b)
where f is the activation, wx,wh and b are parameters, and xt is the t-th token in the sentence. the sentence embedding of rnn is just the hidden vector of the last token. irnn is a special rnn with the activation being the identity, the weight matrices initialized to identity, and b initialized to zero. lstm (hochreiter & schmidhuber, 1997) is a recurrent neural network architecture designed to capture long-distance dependencies. here, the version from (gers , 2002) is used.
the supervised methods are initialized with paragram-sl999 (psl) vectors, and trained using the approach of (wieting , 2016) on the xl section of the ppdb data (pavlick , 2015) which contains about 3 million unique phrase pairs. after training, the final models can be used to generate sentence embeddings on the test data. for hyperparameter tuning they used 100k examples sampled from ppdb xxl and trained for 5 epochs. then after finding the hyperparameters that maximize spearmans coefficients on the pavlick  ppdb task, they are trained on the entire xl section of ppdb for 10 epochs. see (wieting , 2016) and related papers for more details about these methods.
the tfidf-glove method is a weighted average of the glove vectors, where the weights are defined by the tf-idf scheme. more precisely, the embedding of a sentence s is
vs = 1 |s| ∑ w∈s idfwvw (7)
where idfw is the inverse document frequency of w, and |s| denotes the number of words in the sentence. here, the tf part of the tf-idf scheme is taken into account by the sum over w ∈ s. furthermore, when computing idfw, each sentence is viewed as a “document”:
idfw := log 1 +n  +nw
where n is the total number of sentences and nw is the number of sentences containing w, and 1 is added to avoid division by 0. in the experiments, we use all the textual similarity datasets to compute idfw.
detailed experimental results. in the main body we present the average results for sts tasks by year. each year there are actually 4 to 6 sts tasks, as shown in table 4. note that tasks with the same name in different years are actually different tasks. here we provide the results for each tasks in table 5. psl+wr achieves the best results on 12 out of 22 tasks, pp and pp-proj. achieves on 3, tfidf-glove achieves on 2, and dan, irnn, and glove+wr achieves on 1. in general, our method improves the performance significantly compared to the unweighted average, though on rare cases such as msrpar it can decrease the performance.
effects of smooth inverse frequency and common component removal. there are two key ideas in our methods: smooth inverse frequency weighting (w) and common component removal (r). it is instructive to see their effects separately. let glove+w denote the embeddings using only smooth inverse frequency, and glove+r denote that using only common component removal. similarly define psl+w and psl+r. the results for these methods are shown in table 6. when using glove vectors, w alone improves the performance of the unweighted average baseline by about 5%, r alone improves by 10%, w and r together improves by 13%. when using psl vectors, w gets 10%, r gets 10%, w and r together gets 13%. in summary, both techniques are important for obtaining significant advantage over the unweighted average.
a.2 supervised tasks
setup of supervised tasks mostly follow (wieting , 2016) to allow fair comparison: the sentence embeddings are fixed and fed into some classifier which are trained. for the sick similarity task, given a pair of sentences with embeddings vl and vr, first do a linear projection:
hl = wpvl, hr = wpvr
where wp is of size 300 × dp and is learned during training. dp = 2400 matches the dimension of the skip-thought vectors. then hl and hr are used in the objective function from (tai , 2015). almost the same approach is used for the entailment task.for the sentiment task, the classifier has a fully-connected layer with a sigmoid activation followed by a softmax layer.
recall that our method has two steps: smooth inverse frequency weighting and common component removal. for the experiments here, we do not perform the common component removal, since it can be absorbed into the projection step. for the weighted average, the hyperparameter a is enumerated in {10−i, 3 × 10−i : 2 ≤ i ≤ 3}. the other hyperparameters are enumerated as in (wieting , 2016), and the same validation approach is used to select the final values.
a.3 additional supervised tasks
here we report the experimental results on two more datasets, comparing to known results on them.
snli. the first experiment is for the 3-class classification task on the snli dataset (bowman , 2015). to compare to the results in (bowman , 2015), we used their experimental setup. in particular, we applied our method to 300 dimensional glove vectors and used an additional tanh neural network layer to map these 300d embeddings into 300 dimensional space, then used the code provided by the authors of (bowman , 2015), trained the classifier on our 100 dimensional sentence embedding for 120 passes over the data, using their default hyperparameters. the results are shown in table 7. our method indeed gets slightly better performance.
our test accuracy is worse than those using more sophisticated models (e.g., using attention mechanism), which are typically 83% - 88%; see the website of the snli project7 for a summary. an interesting direction is to study whether our idea can be combined with these sophisticated models to get improved performance.
imdb. the second experiment is the sentiment analysis task on the imdb dataset, studied in (wang & manning, 2012). since the intended application is semi-supervised or transfer learning, we also compared performance with fewer labeled examples. http:/.lp.stanford.edu/projects/snli/
our method gets worse performance on the full dataset, but its decrease in performance is better with less labeled examples, showing the benefit of using word embeddings. note that our sentence embeddings are unsupervised, while that in the nb-svm method takes advantage of the labels. another comment is that sentiment analysis appears to be the best case for bag-of-word methods, whereas it may be the worst case for word embedding methods (see table 2) due to the well-known antonymy problem —distributional hypothesis fails for distinguishing “good” from “bad.”",1
377.pdf.json,DEEP REINFORCEMENT LEARNING,"our work is inspired by empirical findings and theories in psychology indicating that infant learning and thinking is similar to that of adult scientists (gopnik, 2012). one important view in developmental science is that babies are endowed with a small number of separable systems of core knowledge for reasoning about objects, actions, number, space, and possibly social interactions (spelke & kinzler, 2007). the object core system covering aspects such as cohesion, continuity, and contact, enables babies and other animals to solve object related tasks such as reasoning about oclusion and predicting how objects behave.
core knowledge research has motivated the development of methods that endow agents with physics priors and perception modules so as to infer intrinsic physical properties rapidly from data (battaglia , 2013; wu , 2015; 2016; stewart & ermon, 2016). for instance, using physics engines and mental simulation, it becomes possible to infer quantities such as mass from visual input (hamrick , 2016; wu , 2015).
in early stages of life, infants spend a lot of time interacting with objects in a seemingly random manner (smith & gasser, 2005). they interact with objects in multiple ways, including throwing, pushing, pulling, breaking, and biting. it is quite possible that this process of actively engaging with objects and watching the consequences of their actions helps infants understand different physical properties of the object which cannot be observed directly using their sensory systems. it seems infants run a series of “physical” experiments to enhance their knowledge about the world (gopnik, 2012). the act of performing an experiment is useful both for quickly adapting an agent’s policy to a new environment and for understanding object properties in a holistic manner. despite impressive advances in artificial intelligence that have led to superhuman performance in go, atari and natural language processing, it is still unclear if these systems behind these advances can rival the scientific intuition of even a small child.
while we draw inspiration from child development, it must be emphasized that our purpose is not to provide an account of learning and thinking in humans, but rather to explore how similar types of understanding might be learned by artificial agents in a grounded way. to this end we show that we can build agents that can learn to experiment so as to learn representations that are informative about physical properties of objects, using deep reinforcement learning. the act of conducting an experiment involves the agent having a belief about the world, which it then updates by observing the consequences of actions it performs.
we investigate the ability of agents to learn to perform experiments to infer object properties through two environments—which is heavier and towers. in the which is heavier environment, the agent is able to apply forces to blocks and it must infer which of the blocks is the heaviest. in the towers environment the agent’s task is to infer how many rigid bodies a tower is composed of by knocking it down. unlike wu  (2015), we assume that the agent has no prior knowledge about physical properties of objects, or the laws of physics, and hence must interact with the objects in order to learn to answer questions about these properties.
our results indicate that in the case which is heavier environment our agents learn experimentation strategies that are similar to those we would expect from an algorithm designed with knowledge of the underlying structure of the environment. in the towers environment we show that our agents learn a closed loop policy that can adapt to a varying time scale. in both environments we show that when using the learned interaction policies agents are more accurate and often take less time to produce correct answers than when following randomized interaction policies.this is an unusual paper in that it does not present a new model or propose a new algorithm. there is a reinforcement learning task at the core of each of our experiments, but the algorithm and models we use to solve it are not new, and many other existing approaches should be expected to perform equally well if they were to be substituted in the same setting.
this paper is a step towards agents that understand objects and intuitive reasoning in physical worlds. our best ai agents currently fail on simple control tasks and simple games, such as montezuma’s revenge, because when they look at a screen that has a ladder, a key and a skull they don’t immediately know that keys open doors, that skulls are probably hazardous and best avoided, that ladders allow us to defy gravity, etc. the understanding of physics, relations and objects enables children to solve seemingly simple problems that our best existing ai agents do not come close to begin to solve.
endowing our agents with knowledge of objects would help enormously with planning, reasoning and exploration, and yet, doing so is far from trivial. what is an object? it turns out this question does not have a straightforward answer, and this paper is based around the idea that staring at a thing is not enough to understand what it is.
children understand their world by engaging with it. poking something to find that it is soft, tasting it to discover it is delicious, or hitting it to see if it falls down. much of the knowledge people have of the world is the result of interaction. vision or open loop perception alone is not enough.
this paper introduces tasks where we can evaluate the ability of agents to learn about these “hidden” properties of objects. this requires environments where the tasks depend on these properties (otherwise the agents have no incentive to learn about them) and also that we have a way to probe for this understanding in agents that complete the tasks.
previous approaches to this problem have relied on either explicit knowledge of the underlying structure of the environment (e.g. hard-wired physical laws) or on exploiting correlations between material appearance and physical properties (see section 7 for much more detail). one of the contributions of this paper is to show that our agents can still learn about properties of objects, even when the connection between material appearance and physical properties is broken. this setting allows us to show that our agents are not merely learning that blocks are heavy; they are learning how to check if blocks are heavy.
none of the previous approaches give a complete account of how agents could come to understand the physical properties of the world around them. specifying a model manually is difficult to scale,
generalize and to ground in perception. making predictions from only visual properties will fail to distinguish between objects that look similar, and it will certainly be unable to distinguish between a sack full of rocks and a sack full of tennis balls.we pose the problem of experimentation as that of answering questions about non-visual properties of objects present in the environment. we design environments that ask questions about these properties by providing rewards when the agent is able to infer them correctly, and we train agents to answer these questions using reinforcement learning.
we design environments that follow a three phase structure:
interaction initially there is an exploration phase, where the agent is free to interact with the environment and gather information.
labeling the interaction phase ends when the agent produces a labeling action through which it communicates its answer to the implicit question posed by the environment.
reward when the agent produces as labeling action, the environment responds with a reward, positive for a correct answer and negative for incorrect, and the episode terminates. the episode terminates automatically with a negative reward if the agent does not produce a labeling action before a maximum time limit is reached.
crucially, the transition between interaction and labeling does not happen at a fixed time, but is initiated by the agent. this is achieved by providing the agent with the ability to produce either an interaction action or a labeling action at every time step. this allows the agent to decide when enough information has been gathered, and forces it to balance the trade-off between answering now given its current knowledge, or delaying its answer to gather more information.
the optimal trade-off between information gathering and risk of answering incorrectly depends on two factors. the first factor is the difficulty of the question and the second is the cost of information. the difficulty is environment specific and is addressed later when we describe the environments. the cost of information can be generically controlled by varying the discount factor during learning. a small discount factor places less emphasis on future rewards and encourages the agent to answer as quickly as possible. on the other hand, a large discount factor encourages the agent to spend more time gathering information in order to increase the likelihood of choosing the correct answer.
our use of “questions” and “answers” differs from how these terms are used elsewhere in the literature. sutton  (2011) talk about a value function as a question, and the agent provides an answer in the form of an approximation of the value. the answer incorporates the agent’s knowledge, and the match between the actual value and the agent’s approximation grounds what it means for this knowledge to be accurate.
in our usage the environment (or episode) itself is the question, and answers come in the form of labeling actions. in each episode there is a correct answer whose semantics is grounded in the sign of the reward function, and the accuracy of an agents knowledge is assessed by the frequency with which it is able to choose the correct answer.
using reward (rather than value) to ground our semantics means that we have a straightforward way to ask questions that do not depend on the agent’s behavior. for example, we can easily ask the question “which block is heaviest?” without making the question contingent on a particular information acquisition strategy.we use the same basic agent architecture and training procedure for all of our experiments, making only minimal modifications in order to adapt the agents to different observation spaces and actuators. for all experiments we train recurrent agents using an lstm with 100 hidden units. when working from features we feed the observations into the lstm directly. when training from pixels we first scale the observations to 84x84 pixels and feed them through a three convolution layers, each
followed by a relu non-linearity. the three layers have 32, 64, 64 square filters with sizes 8, 4, 3, which are applied at strides of 4, 2, 1 respectively. we train the agents using asynchronous advantage actor critic (mnih , 2016), but ensure that the unroll length is always greater than the timeout length so the agent network is unrolled over the entirety of each episode.the which is heavier environment is designed to ask a question about the relative masses of different objects in a scene. we assign masses to objects in a way that is uncorrelated with their appearance in order to ensure that the task is not solvable without interaction.the environment is diagrammed in the left panel of figure 1. it consists of four blocks, which are constrained to only move vertically. the blocks are always the same size, but vary in mass between episodes. the agent’s strength (i.e. magnitude of force it can apply) remains constant between episodes.
the question to answer in this environment is which of the four blocks is the heaviest. since the mass of each block is randomly assigned in each episode, the agent must poke the blocks and observe how they respond in order to make this determination. assigning masses randomly ensures it is not possible to solve this task from vision (or features) alone, since the appearance and identity of each block imparts no information about its mass in the current episode. the only way to obtain information about the masses of the blocks is to interact with them and watch how they respond.
the which is heavier environment is designed to encode a latent bandit problem through a “physical” lens. each block corresponds to an arm of the bandit, and the reward obtained by pulling each arm is proportional to the mass of the block. identifying the heaviest block can then be seen as a best arm identification problem (audibert & bubeck, 2010). best arm identification is a well studied problem in experimental design, and understanding of how an optimal solution to the latent bandit should behave is used to guide our analysis of the agents we train on this task.
it is important to emphasize that we cannot simply apply standard bandit algorithms here, because we impose a much higher level of prior ignorance on our algorithms than that setting allows. bandit algorithms assume that rewards are observed directly, whereas our agents observe mass through its role in dynamics (and in the case of learning from pixels, through the lens of vision as well). to maintain a bandit setting one could imagine parameterizing this transformation from reward to observation, and perhaps even learning the mapping as well; however, doing so requires explicitly acknowledging the mapping in the design of the learning algorithm, which we avoid doing. moreover, acknowledging this mapping in any way requires the a-priori recognition of the existence of the latent bandit structure. from the perspective of our learning algorithm the mere existence of such a structure also lies beyond the veil of ignorance.
controlling the distribution of masses allows us to control the difficulty of this task. in particular, by controlling the size of the mass gap between the two heaviest blocks we can make the task more
or less difficult. we generate masses in the range [0, 1] and scale them to an appropriate range for the agent’s strength.
we use the following scheme for controlling the difficulty of the which is heavier environment. first we select one of the blocks uniformly at random to be the “heavy” block and designate the remaining three as “light” blocks. we sample the mass of the heavy block from beta(β, 1) and the mass of the light blocks from beta(1, β). the single parameter β effectively controls the distribution of mass gaps (and thus controls the difficulty), with large values of β leading to easier problems. figure 1 shows the distribution of mass gaps for three values of β that we use in our experiments.
we distinguish between problem level and instance level difficulty for this domain. instance level difficulty refers to the size of the mass gap in a single episode. if the mass gap is small it is harder to determine which block is heaviest, and we say that one episode is more difficult than another by comparing their mass gaps. problem level difficulty refers to the shape of the generating distribution of mass gaps (e.g. as shown in the right panel of figure 1). a distribution that puts more mass on configurations that have a small mass gap will tend to generate more episodes that are difficult at the instance level, and we say that one distribution is more difficult than another if it is more likely to generate instances with small mass gaps. we control the problem level difficulty through β, but we incorporate both problem and instance level difficulty in our analysis.
we set the episode length limit to 100 steps in this environment, which is sufficient time to be much longer than a typical episode by a successfully trained agent.the obvious choice for actuation in physical domains is some kind of arm or hand based manipulator. however, controlling an arm or hand is quite challenging on its own, requiring a fair amount of dexterity on the part of the agent. the manipulation problem, while very interesting in its own right, is orthogonal to our goals in this work. therefore we avoid the problem of learning dexterous manipulation by providing the agent with a much simpler form of actuation.
we call the actuation strategy for this environment direct actuation, which allows the agent to affect forces on the different blocks directly. at every time step the agent can output one out of eight possible actions. the first four actions result in an application of a vertical force of fixed magnitude to center of mass of each of the four blocks respectively. the remaining actions are labeling actions and correspond to agent’s selection of which is the heaviest block.our first experiment is a sanity check to show that we can train agents successfully on the which is heavier environment using both features and pixels. this experiment is designed simply to show that our task is solvable, and to illustrate that by changing the problem difficulty we can make the task very hard.
we present two additional experiments showing how varying difficulty leads to differentiated behavior both at the problem level and at the instance level. in both cases knowledge of the latent bandit problem allows us to make predictions about how an experimenting agent should behave, and our experiments are designed to show that qualitatively correct behavior is obtained by our agents in spite of their a-priori ignorance of the underlying bandit problem.
we show that as we increase the problem difficulty the learned policies transition from guessing immediately when a heavy block is found to strongly preferring to poke all blocks before making a decision. this corresponds to the observation that if it is unlikely for more than one arm to give high reward then any high reward arm is likely to be best.
we also observe that our agents can adapt their behavior to the difficulty of individual problem instances. we show that a single agent will tend to spend longer gathering information when the particular problem instance is more difficult. this corresponds to the observation that when the two best arms have similar reward then more information is required to accurately distinguish them.
finally, we conduct an experiment comparing our learned information gathering policies to a randomized baseline method. this experiment shows that agents more reliably produce the correct label by following their learned interaction policies than by observing the environment being driven by random actions.
success in learning for this experiment we trained several agents at three different difficulties corresponding to β ∈ {3, 5, 10}. for each problem difficulty we trained agents on both feature observations, which includes the z coordinate of each of the four blocks; and also using raw pixels, providing 84 × 84 pixel rgb rendering of the scene to the agent. representative learning curves for each condition are shown in figure 2. the curves are smoothed over time and show a running estimate of the probability of success, rather than showing the reward directly.
the agents do not reach perfect performance on this task, with more difficult problems plateauing at progressively lower performance. this can be explained by looking at the distributions of instance level difficulties generated by different settings of β, which is shown in the right panel of figure 1. for higher difficulties (lower values of β) there is a substantial probability of generating problem instances where the mass gap is near 0, which makes distinguishing between the two heaviest blocks very difficult.
population strategy differentiation for this experiment we trained agents at three different difficulties corresponding to β ∈ {3, 5, 10} all using a discount factor of γ = 0.95 which corresponds a relatively high cost of gathering information. we trained three agents for each difficulty and show results aggregated across the different replicas.
after training, each agent was run for 10,000 steps under the same conditions they were exposed to during training. we record the number and length of episodes executed during the testing period as well as the outcome of each episode. episodes are terminated by timeout after 100 steps, but the vast majority of episodes are terminated in < 30 steps by the agent producing a label. since episodes vary in length not all agents complete the same number of episodes during testing.
the left plot in figure 3 shows histograms of the episode lengths broken down by task difficulty. the dashed vertical line indicates an episode length of four interaction steps, which is the minimum number of actions required for the agents to interact with every block. at a task difficulty of β = 10 the agents appear to learn simply to search for a single heavy block (which can be found with an average of two interactions). however, at a task difficulty of β = 3 we see a strong bias away from terminating the episode before taking at least four exploratory actions.
individual strategy differentiation for this experiment we trained agents using the same three task difficulties as in the previous experiment, but with an increased discount factor of γ = 0.99.
this decreases the cost of exploration and encourages the agents to gather more information before producing a label, leading to longer episodes.
after training, each agent was run for 100,000 steps under the same conditions they were exposed to during training. we record the length of each episode, as well as the mass gap between the two heaviest blocks in each episode. in the same way that we use the distribution of mass gaps as a measure of task difficulty, we can use the mass gap in a single episode as a measure of the difficulty of that specific problem instance. we again exclude from analysis the very small proportion of episodes that terminate by timeout.
the right plots in figure 3 show the relationship between the mass gap and episode length across the testing runs of two different agents. from these plots we can see how a single agent has learned to adapt its behavior based on the difficulty of a single problem instance. although the variance is high, there is a clear correlation between the mass gap and the length of the episodes. this behavior reflects what we would expect from a solution to the latent bandit problem; more information is required to identify the best arm when the second best arm is nearly as good.
randomized interaction for this experiment we trained several agents using both feature and pixel observations at the same three task difficulties with a discount of γ = 0.95. in total we trained six sets of agents for this experiment.
after training, each agent was run for 10,000 steps under the same conditions used during training. we record the outcome of each episode, as well as the number of steps taken by each agent before it chooses a label. for each agent we repeat the experiment using both the agent’s learned interaction policy as well as a randomized interaction policy.
the randomized interaction policy is obtained as follows: at each step the agent chooses a candidate action using its learned policy. if the candidate action is a labeling action then it is passed to the environment unchanged (and the episode terminates). however, if the candidate action is an interaction action then we replace the agent action with a new interaction action chosen uniformly at random from the available action set. when following the randomized interaction policy the agent has no control over the information gathering process, but still controls when each episode ends, and what label is chosen.
figure 4 compares the learned interaction policies to the randomized interaction baselines. the results show that the effect on episode length is small, with no consistent bias towards longer or shorter episodes across difficulties and observation types. however, the learned interaction policies produce more accurate labels across all permutations.the towers environment is designed to ask agents to count the number of cohesive rigid bodies in a scene. the environment is designed so that in its initial configuration it is not possible to determine the number of rigid bodies from vision or features alone.the environment is diagrammed in the left panel of figure 5. it consists of a tower of five blocks which can move freely in three dimensions. the initial block tower is always in the same configuration but in each episode we bolt together different subsets of the blocks to form larger rigid bodies as shown in the figure.
the question to answer in this environment is how many rigid bodies are formed from the primitive blocks. since which blocks are bound together is randomly assigned in each episode, and binding forces are invisible, the agent must poke the tower and observe how it falls down in order to determine how many rigid bodies it is composed of. we parameterize the environment in such a way that the distribution over the number of separate blocks in the tower is uniform. this ensures that there is no single action strategy that achieves high reward.in the towers environment, we used two actuators: direct actuation, which is similar to the which is heavier environment; and the fist actuator, described below. in case of the direct actuation, the agent can output one out of 25 actions. at every time step, the agent can apply a force of fixed magnitude in either of +x, -x, +y or -y direction to one out of the five blocks. if two blocks are glued together, both blocks move under the effect of force. we use towers of five blocks, which results in 20 different possible actions. the remaining actions are labeling actions that are used by the agent to indicate the number of distinct blocks in the tower.
the fist is a large spherical object that the agent can actuate by setting velocities in a 2d horizontal plane. unlike direct actuation, the agent cannot apply any direct forces to the objects that constitute the tower, but only manipulate them by pushing or hitting them with the fist. at every time step agent can output one of nine actions. the first four actions corresponds to setting the velocity of the fist to a constant amount in (+x, -x, +y, -y) directions respectively. the remaining actions are labeling actions, that are used by the agent to indicate the number of distinct blocks in the tower.
in order to investigate if the agent learns a strategy of stopping after a fixed number of time steps or whether it integrates sensory information in a non-trivial manner we used a notion of “control time step”. the idea of control time step is similar to that of action repeats and if the physics simulation time step is 0.025s and control time step is 0.1s, it means that the same action is repeated 4 times. for the direct actuators we use an episode timeout of 26 steps and for both actuator types.our first experiment is again intended to show that we can train agents in this environment. we show simply that the task is solvable by our agents using both types of actuation.
the second experiment shows that the agents learn to wait for an observation where they can identify the number of rigid bodies before producing an answer. this is designed to show that the agents find a closed loop strategy for counting the number of rigid bodies. an alternative hypothesis would be that agents learn to wait for (approximately) the same number of steps each time and then take their best guess.
our third experiment compares the learned policy to a randomized interaction policy and shows that agents are able to determine the correct number of blocks in the tower more quickly and more reliably when using their learned policy to gather information.
success in learning for this experiment we trained several agents on the towers environment using different pairings of actuators and perception. the features observations include the 3d position of each primitive block, and when training using raw pixels we provide an 84× 84 pixel rgb rendering of the scene as the agent observation. figure 6 shows learning curves for each combination of actuator and observation type.
in all cases we obtain agents that solve the task nearly perfectly, although when training from pixels we find that the range of hyperparameters which train successfully is narrower than when training from features. interestingly, the fist actuators lead to the fastest learning, in spite of the fact that the agent must manipulate the blocks indirectly through the fist. one possible explanation is that the fist can affect multiple blocks in one action step, whereas in the direct actuation only one block can be affected per time step.
waiting for information for this experiment we trained an agent with pixel observations and the fist actuator on the towers task with an control time step of 0.1 seconds and examine its behavior at test time with a smaller delay between actions. reducing the control time step means that from the agent perspective time has been slowed down. moving the fist a fixed amount of distance takes longer, as does waiting for the block tower to collapse once it has been hit.
after training the agent was run for 10000 steps for a range of different control time steps. we record the outcome of each episode, as well as the number of steps taken by the agent before it chooses a label. none of the test episodes terminate by timeout, so we include all of them in the analysis.
the plot in figure 5 shows the probability of answering correctly, as well as the median length of each episode measured in seconds. in terms of absolute performance we see a small drop compared to the training setting, where the agent is essentially perfect, but the agent performance remains good even for substantially smaller control timesteps than were used during training.
we also observe that the episodes with different time steps take approximate the same amount of real time across the majority of the tested range. this corresponds to a large change in episode length as measured by number of agent actions, since with an control time step of 0.01 the agent must execute 10x as many actions to cover the same amount of real time as compared to the control time step used during training. from this we can infer that the agent has learned to wait for an informative observation before producing a label, as opposed to a simpler degenerate strategy of waiting a fixed amount of steps before answering.
randomized interaction for this experiment we trained several agents for each combination of actuator and observation type, and examine their behavior when observing an environment driven by a random interaction policy. the randomized interaction policy is identical to the randomized baseline used in the which is heavier environment.
after training, each agent was run for 10,000 steps. we record the outcome of each episode, as well as the number of steps taken by the agent before it chooses a label. for each agent we repeat the experiment using both the agent’s learned interaction policy as well as the randomized interaction policy.
figure 7 compares the learned interaction policies to the randomized interaction baselines. the results show that the agents tend to produce labels more quickly when following their learned interaction policies, and also that the labels they produce in this way are much more accurate.deep learning techniques in conjunction with vast labeled datasets have yielded powerful models for image classification (krizhevsky , 2012; he , 2016) and speech recognition (hinton , 2012). in recent years, as we have approached human level performance on these tasks, there has been a strong interest in the computer vision field in moving beyond semantic classification, to tasks that require a deeper and more nuanced understanding of the world.
inspired by developmental studies (smith & gasser, 2005), some recent works have focused on learning representations by predicting physical embodiment quantities such as ego-motion (agrawal , 2015; jayaraman & grauman, 2015), instead of symbolic labels. extending the realm of things-to-be-predicted to include quantities beyond class labels, such as viewer centric parameters (doersch , 2015) or the poses of humans within a scene (delaitre , 2012; fouhey , 2014), has been shown to improve the quality of feature learning and scene understanding. researchers have looked at cross modal learning, for example synthesizing sounds from visual images (owens , 2015), using summary statistics of audio to learn features for object recognition (owens , 2016) or image colorization (zhang , 2016).
inverting the prediction tower, another line of work has focused on learning about the visual world by synthesizing, rather than analyzing, images. major cornerstones of recent work in this area include the variational autoencoders of kingma & welling (2014), the generative adversarial networks
of (goodfellow , 2014), and more recently autoregressive models have been very successful (van den oord , 2016).
building on models of single image synthesis there have been many works on predicting the evolution of video frames over time (ranzato , 2014; srivastava , 2015; van den oord , 2016). xue  (2016) have approached this problem by designing a variational autoencoder architecture that uses the latent stochastic units of the vae to make choices about the direction of motion of objects, and generates future frames conditioned on these choices.
a different form of uncertainty in video prediction can arise from the effect of actions taken by an agent. in environments with deterministic dynamics (where the possibility of “known unknowns” can, in principle, be eliminated), very accurate action-conditional predictions of future frames can be made (oh , 2015). introducing actions into the prediction process amounts to learning a latent forward dynamics model, which can be exploited to plan actions to achieve novel goals (watter , 2015; assael , 2015; fragkiadaki , 2016). in these works, frame synthesis plays the role of a regularizer, preventing collapse of the feature space where the dynamics model lives.
agrawal  (2016) break the dependency between frame synthesis and dynamics learning by replacing frame synthesis with an inverse dynamics model. the forward model plays the same role as in the earlier works, but here feature space collapse is prevented by ensuring that the model can decode actions from pairs of time-adjacent images. several works, including agrawal  (2016) and assael  (2015) mentioned above but also pinto  (2016); pinto & gupta (2016); levine  (2016), have gone further in coupling feature learning and dynamics. the learned dynamics models can be used for control not only after learning but also during the learning process in order to collect data in a more targeted way, which has been shown to improve the speed and quality of learning in robot manipulation tasks.
a key challenge of learning from dynamics is collecting the appropriate data. an ingenious solution to this is to import real world data into a physics engine and simulate the application of forces in order to generate ground truth data. this is the approach taken by mottaghi  (2016), who generate an “interactable” data set of scenes, which they use to generate a static data set of image and force pairs, along with the ground truth trajectory of a target object in response to the application of the indicated force.
when the purpose is learning an intuitive understanding of dynamics it is possible to do interesting work with entirely synthetic data (fragkiadaki , 2016; lerer , 2016). lerer  (2016) show that convolutional networks can learn to make judgments about the stability of synthetic block towers based on a single image of the tower. they also show that their model trained on synthetic data is able to generalize to make accurate judgments about photographs of similar block towers built in the real world.
making intuitive judgments about block towers has been extensively studied in the psychophysics literature. there is substantial evidence connecting the behavior of human judgments to inference over an explicit latent physics model (hegarty, 2004; hamrick , 2011; battaglia , 2013). humans can infer mass by watching movies of complex rigid body dynamics (hamrick , 2016).
a major component of the above line of work is analysis by synthesis, in which understanding of a physical process is obtained by learning to invert it. observations are assumed to be generated from an explicitly parameterized generative model of the true physical process, and provide constraints to an inference process run over the parameters of this model. the analysis by synthesis approach has been extremely influential due to its power to explain human judgments and generalization patterns in a variety of situations (lake , 2015).
galileo (wu , 2015) is a particularly relevant instance of tying together analysis by synthesis and deep learning for understanding dynamics. this system first infers the physical parameters (mass and friction coefficient) of a variety of blocks by watching videos of them sliding down slopes and colliding with other blocks. this stage of the system uses an off-the-shelf object tracker to ground inference over the parameters of a physical simulator, and the inference is achieved by matching simulated and observed block trajectories. the inferred physical parameters are used to train a deep network to predict the physical parameters from the initial frame of video. at test time the system is evaluated by using the deep network to infer physical parameters of new blocks, which can be fed into the physics engine and used to answer questions about behaviors not observed at training time.
physics 101 (wu , 2016) is an extension of galileo that more fully embraces deep learning. instead of using a first pass of analysis by synthesis to infer physical parameters based on observations, a deep network is trained to regress the output of an object tracker directly, and the relevant physical laws are encoded directly into the architecture of the model. the authors show that they can use latent intrinsic physical properties inferred in this way to make novel predictions. the approach of encoding physical models as architecture constraints has also been proposed by stewart & ermon (2016).
many of the works discussed thus far, including galileo and physics 101, are restricted to passive sensing. pinto  (2016); pinto & gupta (2016); agrawal  (2016); levine  (2016) are exceptions to this because they learn their models using a sequential greedy data collection bootstrapping strategy. active sensing, it appears, is an important aspect of visual object learning in toddlers as argued by bambach  (2016), providing motivation for the approach presented here.
in computer vision, it is well known that recognition performance can be improved by moving so as to acquire new views of an object or scene. jayaraman & grauman (2016), for example, apply deep reinforcement learning to construct an agent that chooses how to acquire new views of an object so as to classify it into a semantic category, and their related work section surveys many other efforts in active vision.
while jayaraman & grauman (2016) and others share deep reinforcement learning and active sensing in common with our work, their goal is to learn a policy that can be applied to images to make decisions based on vision. in contrast, the goal in this paper is to study how agents learn to experiment continually so as to learn representations to answer questions about intrinsic properties of objects. in particular, our focus is on tasks that can only be solved by interaction and not by vision alone.despite recent advances in artificial intelligence, machines still lack a common sense understanding of our physical world. there has been impressive progress in recognizing objects, segmenting object boundaries and even describing visual scenes with natural language. however, these tasks are not enough for machines to infer physical properties of objects such as mass, friction or deformability.
we introduce a deep reinforcement learning agent that actively interacts with physical objects to infer their hidden properties. our approach is inspired by findings from the developmental psychology literature indicating that infants spend a lot of their early time experimenting with objects through random exploration (smith & gasser, 2005; gopnik, 2012; spelke & kinzler, 2007). by letting our agents conduct physical experiments in an interactive simulated environment, they learn to manipulate objects and observe the consequences to infer hidden object properties. we demonstrate the efficacy of our approach on two important physical understanding tasks—inferring mass and counting the number of objects under strong visual ambiguities. our empirical findings suggest that our agents learn different strategies for these tasks that balance the cost of gathering information against the cost of making mistakes in different situations.
scientists and children are able not only to probe the environment to discover things about it, but they can also leverage their findings to answer new questions. in this paper we have shown that agents can be trained to gather knowledge to answer questions about hidden properties, but we have not addressed the larger issue of theory building, or transfer of this information. given agents that can make judgments about mass and numerosity, how can they be enticed to leverage this knowledge to solve new tasks?
another important aspect of understanding through interaction is that that the shape of the interactions influences behavior. we touched on this in the towers environment where we looked at two different actuation styles, but there is much more to be done here. thinking along these lines leads naturally to exploring tool use. we showed that agents can make judgments about object mass by hitting them, but could we train an agent to make similar judgments using a scale?
finally, we have made no attempt in this work to optimize data efficiency, but learning physical properties from fewer samples is an important direction to pursue.we would like to thank matt hoffman for several enlightening discussions about bandits. we would also like to thank the iclr reviewers, whose helpful feedback allowed us to greatly improve the paper.",1
378.pdf.json,EXPLORING UNDER-APPRECIATED REWARDS,"humans can reason about symbolic objects and solve algorithmic problems. after learning to count and then manipulate numbers via simple arithmetic, people eventually learn to invent new algorithms and even reason about their correctness and efficiency. the ability to invent new algorithms is fundamental to artificial intelligence (ai). although symbolic reasoning has a long history in ai (russell , 2003), only recently have statistical machine learning and neural network approaches begun to make headway in automated algorithm discovery (reed & de freitas, 2016; kaiser & sutskever, 2016; neelakantan , 2016), which would constitute an important milestone on the path to ai. nevertheless, most of the recent successes depend on the use of strong supervision to learn a mapping from a set of training inputs to outputs by maximizing a conditional log-likelihood, very much like neural machine translation systems (sutskever , 2014; bahdanau , 2015). such a dependence on strong supervision is a significant limitation that does not match the ability of people to invent new algorithmic procedures based solely on trial and error.
by contrast, reinforcement learning (rl) methods (sutton & barto, 1998) hold the promise of searching over discrete objects such as symbolic representations of algorithms by considering much weaker feedback in the form of a simple verifier that tests the correctness of a program execution on a given problem instance. despite the recent excitement around the use of rl to tackle atari games (mnih , 2015) and go (silver , 2016), standard rl methods are not yet able to consistently and reliably solve algorithmic tasks in all but the simplest cases (zaremba & sutskever, 2014). a key property of algorithmic problems that makes them challenging for rl is reward sparsity, i.e., a policy usually has to get a long action sequence exactly right to obtain a non-zero reward.
∗work done as a member of the google brain residency program (g.co/brainresidency) †also at the department of computing science, university of alberta, daes@ualberta.ca
we believe one of the key factors limiting the effectiveness of current rl methods in a sparse reward setting is the use of undirected exploration strategies (thrun, 1992), such as -greedy and entropy regularization (williams & peng, 1991). for long action sequences with delayed sparse reward, it is hopeless to explore the space uniformly and blindly. instead, we propose a formulation to encourage exploration of action sequences that are under-appreciated by the current policy. our formulation considers an action sequence to be under-appreciated if the model’s log-probability assigned to an action sequence under-estimates the resulting reward from the action sequence. exploring underappreciated states and actions encourages the policy to have a better calibration between its logprobabilities and observed reward values, even for action sequences with negligible rewards. this effectively increases exploration around neglected action sequences.
we term our proposed technique under-appreciated reward exploration (urex). we show that the objective given by urex is a combination of a mode seeking objective (standard reinforce) and a mean seeking term, which provides a well motivated trade-off between exploitation and exploration. to empirically evaluate our method, we take a set of algorithmic tasks such as sequence reversal, multi-digit addition, and binary search. we choose to focus on these tasks because, although simple, they present a difficult sparse reward setting which has limited the success of standard rl approaches. the experiments demonstrate that urex significantly outperforms baseline rl methods, such as entropy regularized reinforce and one-step q-learning, especially on the more difficult tasks, such as multi-digit addition. moreover, urex is shown to be more robust to changes of hyper-parameters, which makes hyper-parameter tuning less tedious in practice. in addition to introducing a new variant of policy gradient with improved performance, our paper is the first to demonstrate strong results for an rl method on algorithmic tasks. to our knowledge, the addition task has not been solved by any model-free reinforcement learning approach. we observe that some of the policies learned by urex can successfully generalize to long sequences; e.g., in 2 out of 5 random restarts, the policy learned by urex for the addition task correctly generalizes to addition of numbers with 2000 digits with no mistakes, even though training sequences are at most 33 digits long.although research on using neural networks to learn algorithms has witnessed a surge of recent interest, the problem of program induction from examples has a long history in many fields, including program induction, inductive logic programming (lavrac & dzeroski, 1994), relational learning (kemp , 2007) and regular language learning (angulin, 1987). rather than presenting a comprehensive survey of program induction here, we focus on neural network approaches to algorithmic tasks and highlight the relative simplicity of our neural network architecture.
most successful applications of neural networks to algorithmic tasks rely on strong supervision, where the inputs and target outputs are completely known a priori. given a dataset of examples, one learns the network parameters by maximizing the conditional likelihood of the outputs via backpropagation (e.g., reed & de freitas (2016); kaiser & sutskever (2016); vinyals  (2015)). however, target outputs may not be available for novel tasks, for which no prior algorithm is known to be available. a more desirable approach to inducing algorithms, followed in this paper, advocates using self-driven learning strategies that only receive reinforcement based on the outputs produced. hence, just by having access to a verifier for an algorithmic problem, one can aim to learn an algorithm. for example, if one does not know how to sort an array, but can check the extent to which an array is sorted, then one can provide the reward signal necessary for learning sorting algorithms.
we formulate learning algorithms as an rl problem and make use of model-free policy gradient methods to optimize a set parameters associated with the algorithm. in this setting, the goal is to learn a policy πθ that given an observed state st at step t, estimates a distribution over the next action at, denoted πθ(at | st). actions represent the commands within the algorithm and states represent the joint state of the algorithm and the environment. previous work in this area has focused on augmenting a neural network with additional structure and increased capabilities (zaremba & sutskever, 2015; graves , 2016). in contrast, we utilize a simple architecture based on a standard recurrent neural network (rnn) with lstm cells (hochreiter & schmidhuber, 1997) as depicted in figure 1. at each episode, the environment is initialized with a latent state h, unknown to the agent, which determines s1 and the subsequent state transition and reward functions. once the agent observes s1
as the input to the rnn, the network outputs a distribution πθ(a1 | s1), from which an action a1 is sampled. this action is applied to the environment, and the agent receives a new state observation s2. the state s2 and the previous action a1 are then fed into the rnn and the process repeats until the end of the episode. upon termination, a reward signal is received.we start by discussing the most common form of policy gradient, reinforce (williams, 1992), and its entropy regularized variant (williams & peng, 1991). reinforce has been applied to model-free policy-based learning with neural networks and algorithmic domains (zaremba & sutskever, 2015; graves , 2016).
the goal is to learn a policy πθ that, given an observed state st at step t, estimates a distribution over the next action at, denoted πθ(at |st). the environment is initialized with a latent vector, h, which determines the initial observed state s1 = g(h), and the transition function st+1 = f(st,at | h). note that the use of nondeterministic transitions f as in markov decision processes (mdp) may be recovered by assuming that h includes the random seed for the any nondeterministic functions. given a latent state h, and s1:t ≡ (s1, . . . , st ), the model probability of an action sequence a1:t ≡ (a1, . . . ,at ) is expressed as,
πθ(a1:t | h) = t∏ t=1 πθ(at | st) , where s1 = g(h), st+1 = f(st,at | h) for 1 ≤ t < t .
the environment provides a reward at the end of the episode, denoted r(a1:t | h). for ease of readability we drop the subscript from a1:t and simply write πθ(a | h) and r(a | h). the objective used to optimize the policy parameters, θ, consists of maximizing expected reward under actions drawn from the policy, plus an optional maximum entropy regularizer. given a distribution over initial latent environment states p(h), we express the regularized expected reward as,
orl(θ; τ) = eh∼p(h) {∑
a∈a πθ(a | h)
[ r(a | h)− τ log πθ(a | h) ]} . (1)
when πθ is a non-linear function defined by a neural network, finding the global optimum of θ is challenging, and one often resorts to gradient-based methods to find a local optimum of orl(θ; τ). given that ddθπθ(a) = πθ(a) d dθ log πθ(a) for any a such that πθ(a) > 0, one can verify that,
d
dθ orl(θ; τ | h) = ∑ a∈a πθ(a | h) d dθ log πθ(a | h) [ r(a | h)− τ log πθ(a | h)− τ ] . (2)
because the space of possible actionsa is large, enumerating over all of the actions to compute this gradient is infeasible. williams (1992) proposed to compute the stochastic gradient of the expected
reward by using monte carlo samples. using monte carlo samples, one first drawsn i.i.d. samples from the latent environment states {h(n)}nn=1, and then draws k i.i.d. samples {a(k)}kk=1 from πθ(a | h(n)) to approximate the gradient of (1) by using (2) as,
d
dθ orl(θ; τ) ≈ 
nk n∑ n=1 k∑ k=1 d dθ log πθ(a (k) | h(n)) [ r(a(k) | h(n))− τ log πθ(a(k) | h(n))− τ ] .
(3) this reparametrization of the gradients is the key to the reinforce algorithm. to reduce the variance of (3), one uses rewards r̂ that are shifted by some offset values,
r̂ (a(k) | h) = r(a(k) | h)− b(h) , (4) where b is known as a baseline or sometimes called a critic. note that subtracting any offset from the rewards in (1) simply results in shifting the objective orl by a constant. unfortunately, directly maximizing expected reward (i.e., when τ = 0) is prone to getting trapped in a local optimum. to combat this tendency, williams & peng (1991) augmented the expected reward objective by including a maximum entropy regularizer (τ > 0) to promote greater exploration. we will refer to this variant of reinforce as ment (maximum entropy exploration).to explain our novel form of policy gradient, we first note that the optimal policy π∗τ , which globally maximizes orl(θ; τ | h) in (1) for any τ > 0, can be expressed as,
π∗τ (a | h) = 1
z(h) exp {1 τ r(a | h) } , (5)
where z(h) is a normalization constant making π∗τ a distribution over the space of action sequences a. one can verify this by first acknowledging that,
orl(θ; τ | h) = −τ dkl (πθ(· | h) ‖ π∗τ (· | h)) . (6) since dkl (p ‖ q) is non-negative and zero iff p = q, then π∗τ defined in (5) maximizes orl. that said, given a particular form of πθ, finding θ that exactly characterizes π∗τ may not be feasible.
the kl divergence dkl (πθ ‖ π∗τ ) is known to be mode seeking (murphy, 2012, section 21.2.2) even with entropy regularization (τ > 0). learning a policy by optimizing this direction of the kl is prone to falling into a local optimum resulting in a sub-optimal policy that omits some of the modes of π∗τ . although entropy regularization helps mitigate the issues as confirmed in our experiments, it is not an effective exploration strategy as it is undirected and requires a small regularization coefficient τ to avoid too much random exploration. instead, we propose a directed exploration strategy that improves the mean seeking behavior of policy gradient in a principled way.
we start by considering the alternate mean seeking direction of the kl divergence, dkl (π∗τ ‖ πθ). norouzi  (2016) considered this direction of the kl to directly learn a policy by optimizing
oraml(θ; τ) = eh∼p(h) { τ ∑ a∈a π∗τ (a | h) log πθ(a | h) } , (7)
for structured prediction. this objective has the same optimal solution π∗τ as orl since, oraml(θ; τ | h) = −τ dkl (π∗τ (· | h) ‖ πθ(· | h)) + const . (8)
norouzi  (2016) argue that in some structured prediction problems when one can draw samples from π∗τ , optimizing (7) is more effective than (1), since no sampling from a non-stationary policy πθ is required. if πθ is a log-linear model of a set of features,oraml is convex in θ whereasorl is not, even in the log-linear case. unfortunately, in scenarios that the reward landscape is unknown or computing the normalization constant z(h) is intractable, sampling from π∗τ is not straightforward.
in rl problems, the reward landscape is completely unknown, hence sampling from π∗τ is intractable. this paper proposes to approximate the expectation with respect to π∗τ by using selfnormalized importance sampling (owen, 2013), where the proposal distribution is πθ and the reference distribution is π∗τ . for importance sampling, one draws k i.i.d. samples {a(k)}kk=1 from
πθ(a | h) and computes a set of normalized importance weights to approximate oraml(θ; τ | h) as,
oraml(θ; τ | h) ≈ τ k∑ k=1 wτ (a (k) | h)∑k m=1 wτ (a (m) | h) log πθ(a (k) | h) , (9)
where wτ (a(k) | h) ∝ π∗τ/πθ denotes an importance weight defined by,
wτ (a (k) | h) = exp {1 τ r(a(k) | h)− log πθ(a(k) | h) } . (10)
one can view these importance weights as evaluating the discrepancy between scaled rewards r/τ and the policy’s log-probabilities log πθ. among the k samples, a sample that is least appreciated by the model, i.e., has the largest r/τ − log πθ, receives the largest positive feedback in (9). in practice, we have found that just using the importance sampling raml objective in (9) does not always yield promising solutions. particularly, at the beginning of training, when πθ is still far away from π∗τ , the variance of importance weights is too large, and the self-normalized importance sampling procedure results in poor approximations. to stabilize early phases of training and ensure that the model distribution πθ achieves large expected reward scores, we combine the expected reward and raml objectives to benefit from the best of their mode and mean seeking behaviors. accordingly, we propose the following objective that we call under-appreciated reward exploration (urex),
ourex(θ; τ) = eh∼p(h) {∑
a∈a
[ πθ(a | h) r(a | h) + τ π∗τ (a | h) log πθ(a | h) ]} , (11)
which is the sum of the expected reward and raml objectives. in our preliminary experiments, we considered a composite objective of orl + oraml, but we found that removing the entropy term is beneficial. hence, theourex objective does not include entropy regularization. accordingly, the optimum policy for ourex is no longer π∗τ , as it was for orl and oraml. appendix a derives the optimal policy for ourex as a function of the optimal policy for orl. we find that the optimal policy of urex is more sharply concentrated on the high reward regions of the action space, which may be an advantage for urex, but we leave more analysis of this behavior to future work.
to compute the gradient ofourex(θ; τ), we use the self-normalized importance sampling estimate outlined in (9). we assume that the importance weights are constant and contribute no gradient to d dθourex(θ; τ). to approximate the gradient, one draws n i.i.d. samples from the latent environment states {h(n)}nn=1, and then draws k i.i.d. samples {a(k)}kk=1 from πθ(a |h (n)) to obtain
d
dθ ourex(θ; τ) ≈ 
n n∑ n=1 k∑ k=1 d dθ log πθ(a (k) |h(n)) [ 1 k r̂ (a(k) | h(n))+τ wτ (a (k) |h(n))∑k m=1wτ (a (m) |h(n)) ] .
(12) as with reinforce, the rewards are shifted by an offset b(h). in this gradient, the model logprobability of a sample action sequence a(k) is reinforced if the corresponding reward is large, or the corresponding importance weights are large, meaning that the action sequence is under-appreciated. the normalized importance weights are computed using a softmax operator softmax(r/τ − log πθ).before presenting the experimental results, we briefly review some pieces of previous work that closely relate to the urex approach.
reward-weighted regression. both raml and urex objectives bear some similarity to a method in continuous control known as reward-weighted regression (rwr) (peters & schaal, 2007; wierstra , 2008). using our notation, the rwr objective is expressed as,
orwr(θ; τ | h) = log ∑ a∈a π∗τ (a | h)πθ(a | h) (13)
≥ ∑ a∈a q(a | h) log π ∗ τ (a | h)πθ(a | h) q(a | h) . (14)
to optimize orwr, peters & schaal (2007) propose a technique inspired by the em algorithm to maximize a variational lower bound in (14) based on a variational distribution q(a | h). the rwr objective can be interpreted as a log of the correlation between π∗τ and πθ. by contrast, the raml and urex objectives are both based on a kl divergence between π∗τ and πθ.
to optimize the rwr objective, one formulates the gradient as, d
dθ orwr(θ; τ | h) = ∑ a∈a π∗τ (a | h)πθ(a | h) c d dθ log πθ(a | h), (15)
where c denotes the normalization factor, i.e., c = ∑
a∈a π ∗ τ (a | h)πθ(a | h). the expectation
with respect to π∗τ (a | h)πθ(a | h)/c on the rhs can be approximated by self-normalized importance sampling,1 where the proposal distribution is πθ. accordingly, one draws k monte carlo samples {a(k)}kk=1 i.i.d. from πθ(a |h) and formulates the gradient as,
d
dθ orwr(θ; τ | h) ≈ 
k k∑ k=1 u(a(k) | h)∑k m=1 u(a (m) | h) d dθ log πθ(a (k) | h), (16)
where u(a(k) | h) = exp{ 1τ r(a (k) | h)}. there is some similarity between (16) and (9) in that they both use self-normalized importance sampling, but note the critical difference that (16) and (9) estimate the gradients of two different objectives, and hence the importance weights in (16) do not correct for the sampling distribution πθ(a |h) as opposed to (9). beyond important technical differences, the optimal policy of orwr is a one hot distribution with all probability mass concentrated on an action sequence with maximal reward, whereas the optimal policies for raml and urex are everywhere nonzero, with the probability of different action sequences being assigned proportionally to their exponentiated reward (with urex introducing an additional re-scaling; see appendix a). further, the notion of under-appreciated reward exploration evident in ourex, which is key to urex’s performance, is missing in the rwr formulation. exploration. the rl literature contains many different attempts at incorporating exploration that may be compared with our method. the most common exploration strategy considered in valuebased rl is -greedy q-learning, where at each step the agent either takes the best action according to its current value approximation or with probability takes an action sampled uniformly at random. like entropy regularization, such an approach applies undirected exploration, but it has achieved recent success in game playing environments (mnih , 2013; van hasselt , 2016; mnih , 2016).
prominent approaches to improving exploration beyond -greedy in value-based or model-based rl have focused on reducing uncertainty by prioritizing exploration toward states and actions where the agent knows the least. this basic intuition underlies work on counter and recency methods (thrun, 1992), exploration methods based on uncertainty estimates of values (kaelbling, 1993; tokic, 2010), methods that prioritize learning environment dynamics (kearns & singh, 2002; stadie , 2015), and methods that provide an intrinsic motivation or curiosity bonus for exploring unknown states (schmidhuber, 2006; bellemare , 2016).
in contrast to value-based methods, exploration for policy-based rl methods is often a by-product of the optimization algorithm itself. since algorithms like reinforce and thompson sampling choose actions according to a stochastic policy, sub-optimal actions are chosen with some non-zero probability. the q-learning algorithm may also be modified to sample an action from the softmax of the q values rather than the argmax (sutton & barto, 1998).
asynchronous training has also been reported to have an exploration effect on both value- and policy-based methods. mnih  (2016) report that asynchronous training can stabilize training by reducing the bias experienced by a single trainer. by using multiple separate trainers, an agent is less likely to become trapped at a policy found to be locally optimal only due to local conditions. in the same spirit, osband  (2016) use multiple q value approximators and sample only one to act for each episode as a way to implicitly incorporate exploration.
by relating the concepts of value and policy in rl, the exploration strategy we propose tries to bridge the discrepancy between the two. in particular, urex can be viewed as a hybrid combination of value-based and policy-based exploration strategies that attempts to capture the benefits of each. bornschein & bengio (2014) apply the same trick to optimize the log-likelihood of latent variable models.
per-step reward. finally, while we restrict ourselves to episodic settings where a reward is associated with an entire episode of states and actions, much work has been done to take advantage of environments that provide per-step rewards. these include policy-based methods such as actor-critic (mnih , 2016; schulman , 2016) and value-based approaches based on qlearning (van hasselt , 2016; schaul , 2016). some of these value-based methods have proposed a softening of q-values which can be interpreted as adding a form of maximum-entropy regularizer (asadi & littman, 2016; azar , 2012; fox , 2016; ziebart, 2010). the episodic total-reward setting that we consider is naturally harder since the credit assignment to individual actions within an episode is unclear.we assess the effectiveness of the proposed approach on five algorithmic tasks from the openai gym (brockman , 2016), as well as a new binary search problem. each task is summarized below, with further details available on the gym website2 or in the corresponding open-source code.3 in each case, the environment has a hidden tape and a hidden sequence. the agent observes the sequence via a pointer to a single character, which can be moved by a set of pointer control actions. thus an action at is represented as a tuple (m,w, o) where m denotes how to move, w is a boolean denoting whether to write, and o is the output symbol to write. . copy: the agent should emit a copy of the sequence. the pointer actions are move left and right. 2. duplicatedinput: in the hidden tape, each character is repeated twice. the agent must deduplicate the sequence and emit every other character. the pointer actions are move left and right. . repeatcopy: the agent should emit the hidden sequence once, then emit the sequence in the reverse order, then emit the original sequence again. the pointer actions are move left and right. . reverse: the agent should emit the hidden sequence in the reverse order. as before, the pointer actions are move left and right. . reversedaddition: the hidden tape is a 2×n grid of digits representing two numbers in base 3 in little-endian order. the agent must emit the sum of the two numbers, in little-endian order. the allowed pointer actions are move left, right, up, or down.
the openai gym provides an additional harder task called reversedaddition3, which involves adding three numbers. we omit this task, since none of the methods make much progress on it.
for these tasks, the input sequences encountered during training range from a length of 2 to 33 characters. a reward of 1 is given for each correct emission. on an incorrect emission, a small penalty of−0.5 is incurred and the episode is terminated. the agent is also terminated and penalized with a reward of −1 if the episode exceeds a certain number of steps. for the experiments using urex and ment, we associate an episodic sequence of actions with the total reward, defined as the sum of the per-step rewards. the experiments using q-learning, on the other hand, used the per-step rewards. each of the gym tasks has a success threshold, which determines the required average reward over 100 episodes for the agent to be considered successful.
we also conduct experiments on an additional algorithmic task described below: 6. binarysearch: given an integer n, the environment has a hidden array of n distinct numbers
stored in ascending order. the environment also has a query number x unknown to the agent that is contained somewhere in the array. the goal of the agent is to find the query number in the array in a small number of actions. the environment has three integer registers initialized at (n, 0, 0). at each step, the agent can interact with the environment via the four following actions: • inc(i): increment the value of the register i for i ∈ {1, 2, 3}. • div(i): divide the value of the register i by 2 for i ∈ {1, 2, 3}. • avg(i): replace the value of the register i with the average of the two other registers. • cmp(i): compare the value of the register i with x and receive a signal indicating which
value is greater. the agent succeeds when it calls cmp on an array cell holding the value x. gym.openai.com 3github.com/openai/gym
we set the maximum number of steps to 2n+1 to allow the agent to perform a full linear search. a policy performing full linear search achieves an average reward of 5, because x is chosen uniformly at random from the elements of the array. a policy employing binary search can find the number x in at most 2 log2 n + 1 steps. if n is selected uniformly at random from the range 32 ≤ n ≤ 512, binary search yields an optimal average reward above 9.55. we set the success threshold for this task to an average reward of 9.we compare our policy gradient method using under-appreciated reward exploration (urex) against two main rl baselines: (1) reinforce with entropy regularization termed ment (williams & peng, 1991), where the value of τ determines the degree of regularization. when τ = 0, standard reinforce is obtained. (2) one-step double q-learning based on bootstrapping one step future rewards.hyper-parameter tuning is often tedious for rl algorithms. we found that the proposed urex method significantly improves robustness to changes in hyper-parameters when compared to ment. for our experiments, we perform a careful grid search over a set of hyper-parameters for both ment and urex. for any hyper-parameter setting, we run the ment and urex methods 5 times with different random restarts. we explore the following main hyper-parameters:
• the learning rate denoted η chosen from a set of 3 possible values η ∈ {0.1, 0.01, 0.001}. • the maximum l2 norm of the gradients, beyond which the gradients are clipped. this parameter, denoted c, matters for training rnns. the value of c is selected from c ∈ {1, 10, 40, 100}. • the temperature parameter τ that controls the degree of exploration for both ment and urex.
for ment, we use τ ∈ {0, 0.005, 0.01, 0.1}. for urex, we only consider τ = 0.1, which consistently performs well across the tasks.
in all of the experiments, both ment and urex are treated exactly the same. in fact, the change of implementation is just a few lines of code. given a value of τ , for each task, we run 60 training jobs comprising 3 learning rates, 4 clipping values, and 5 random restarts. we run each algorithm for a maximum number of steps determined based on the difficulty of the task. the training jobs for copy, duplicatedinput, repeatcopy, reverse, reversedaddition, and binarysearch are run for 2k, 500, 50k, 5k, 50k, and 2k stochastic gradient steps, respectively. we find that running a trainer job longer does not result in a better performance. our policy network comprises a single lstm layer with 128 nodes. we use the adam optimizer (kingma & ba, 2015) for the experiments.
table 1 shows the percentage of 60 trials on different hyper-parameters (η, c) and random restarts which successfully solve each of the algorithmic tasks. it is clear that urex is more robust than
ment to changes in hyper-parameters, even though we only report the results of urex for a single temperature. see appendix b for more detailed tables on hyper-parameter robustness.table 2 presents the number of successful attempts (out of 5 random restarts) and the expected reward values (averaged over 5 trials) for each rl algorithm given the best hyper-parameters. onestep q-learning results are also included in the table. we also present the training curves for ment and urex in figure 2. it is clear that urex outperforms the baselines on these tasks. on the more difficult tasks, such as reverse and reverseaddition, urex is able to consistently find an appropriate algorithm, but ment and q-learning fall behind. importantly, for the binarysearch task, which exhibits many local maxima and necessitates smart exploration, urex is the only method that can solve it consistently. the q-learning baseline solves some of the simple tasks, but it makes little headway on the harder tasks. we believe that entropy regularization for policy gradient and - greedy for q-learning are relatively weak exploration strategies in long episodic tasks with delayed rewards. on such tasks, one random exploratory step in the wrong direction can take the agent off the optimal policy, hampering its ability to learn. in contrast, urex provides a form of adaptive and smart exploration. in fact, we observe that the variance of the importance weights decreases as the agent approaches the optimal policy, effectively reducing exploration when it is no longer necessary; see appendix e.to confirm whether our method is able to find the correct algorithm for multi-digit addition, we investigate its generalization to longer input sequences than provided during training. we evaluate the trained models on inputs up to a length of 2000 digits, even though training sequences were at most 33 characters. for each length, we test the model on 100 randomly generated inputs, stopping when the accuracy falls below 100%. out of the 60 models trained on addition with urex, we find that 5 models generalize to numbers up to 2000 digits without any observed mistakes. on the best urex hyper-parameters, 2 out of the 5 random restarts are able to generalize successfully. for more detailed results on the generalization performance on 3 different tasks including copy,
duplicatedinput, and reversedaddition, see appendix c. during these evaluations, we take the action with largest probability from πθ(a | h) at each time step rather than sampling randomly. we also looked into the generalization of the models trained on the binarysearch task. we found that none of the agents perform proper binary search. rather, those that solved the task perform a hybrid of binary and linear search: first actions follow a binary search pattern, but then the agent switches to a linear search procedure once it narrows down the search space; see appendix d for some execution traces for binarysearch and reversedaddition. thus, on longer input sequences, the agent’s running time complexity approaches linear rather than logarithmic. we hope that future work will make more progress on this task. this task is especially interesting because the reward signal should incorporate both correctness and efficiency of the algorithm.in all of the experiments, we make use of curriculum learning. the environment begins by only providing small inputs and moves on to longer sequences once the agent achieves close to maximal reward over a number of steps. for policy gradient methods including ment and urex, we only provide the agent with a reward at the end of the episode, and there is no notion of intermediate reward. for the value-based baseline, we implement one-step q-learning as described in mnih  (2016)-alg. 1, employing double q-learning with -greedy exploration. we use the same rnn in our policy-based approaches to estimate the q values. a grid search over exploration rate, exploration rate decay, learning rate, and sync frequency (between online and target network) is conducted to find the best hyper-parameters. unlike our other methods, the q-learning baseline uses intermediate rewards, as given by the openai gym on a per-step basis. hence, the q-learning baseline has a slight advantage over the policy gradient methods.
in all of the tasks except copy, our stochastic optimizer uses mini-batches comprising 400 policy samples from the model. these 400 samples correspond to 40 different random sequences drawn from the environment, and 10 random policy trajectories per sequence. in other words, we set k = 10 and n = 40 as defined in (3) and (12). for ment, we use the 10 samples to subtract the mean of the coefficient of ddθ log πθ(a | h) which includes the contribution of the reward and entropy regularization. for urex, we use the 10 trajectories to subtract the mean reward and normalize the importance sampling weights. we do not subtract the mean of the normalized importance weights. for the copy task, we use mini-batches with 200 samples using k = 10 and n = 20. experiments are conducted using tensorflow (abadi , 2016).we present a variant of policy gradient, called urex, which promotes the exploration of action sequences that yield rewards larger than what the model expects. this exploration strategy is the result of importance sampling from the optimal policy. our experimental results demonstrate that urex significantly outperforms other value and policy based methods, while being more robust
to changes of hyper-parameters. by using urex, we can solve algorithmic tasks like multi-digit addition from only episodic reward, which other methods cannot reliably solve even given the best hyper-parameters. we introduce a new algorithmic task based on binary search to advocate more research in this area, especially when the computational complexity of the solution is also of interest. solving these tasks is not only important for developing more human-like intelligence in learning algorithms, but also important for generic reinforcement learning, where smart and efficient exploration is the key to successful methods.we thank sergey levine, irwan bello, corey lynch, george tucker, kelvin xu, volodymyr mnih, and the google brain team for insightful comments and discussions.to derive the form of the optimal policy for the urex objective (11), note that for each h one would like to maximize ∑
a∈a
[ πθ(a) r(a) + τ π ∗ τ (a) log πθ(a) ] , (17)
subject to the constraint ∑
a∈a πθ(a) = 1. to enforce the constraint, we introduce a lagrange multiplier α and aim to maximize∑
a∈a
[ πθ(a) r(a) + τ π ∗ τ (a) log πθ(a)− απθ(a) ] + α . (18)
since the gradient of the lagrangian (18) with respect to θ is given by∑ a∈a dπθ(a) dθ [ r(a) + τ π∗τ (a) πθ(a) − α ] , (19)
the optimal choice for πθ is achieved by setting
πθ(a) = τ π∗τ (a)
α− r(a) for all a ∈ a , (20)
forcing the gradient to be zero. the lagrange multiplier α can then be chosen so that ∑
a∈a πθ(a) = 1 while also satisfying α > maxa∈a r(a); see e.g. (golub, 1987).tables 3–8 provide more details on different cells of table 1. each table presents the results of ment using the best temperature τ vs. urex with τ = 0.1 on a variety of learning rates and clipping values. each cell is the number of trials out of 5 random restarts that succeed at solving the task using a specific η and c.table 9 provides a more detailed look into the generalization performance of the trained models on copy, duplicatedinput, and reversedaddition. the tables show how the number of models which can solve the task correctly drops off as the length of the input increases.we provide the traces of two trained agents on the reversedaddition task (figure 3) and the binarysearch task (table 10).
e variance of importance weights",1
383.pdf.json,DESIGNING NEURAL NETWORK ARCHITECTURES,"deep convolutional neural networks (cnns) have seen great success in the past few years on a variety of machine learning problems (lecun , 2015). a typical cnn architecture consists of several convolution, pooling, and fully connected layers. while constructing a cnn, a network designer has to make numerous design choices: the number of layers of each type, the ordering of layers, and the hyperparameters for each type of layer, e.g., the receptive field size, stride, and number of receptive fields for a convolution layer. the number of possible choices makes the design space of cnn architectures extremely large and hence, infeasible for an exhaustive manual search. while there has been some work (pinto , 2009; bergstra , 2013; domhan , 2015) on automated or computer-aided neural network design, new cnn architectures or network design elements are still primarily developed by researchers using new theoretical insights or intuition gained from experimentation.
in this paper, we seek to automate the process of cnn architecture selection through a metamodeling procedure based on reinforcement learning. we construct a novel q-learning agent whose goal is to discover cnn architectures that perform well on a given machine learning task with no human intervention. the learning agent is given the task of sequentially picking layers of a cnn model. by discretizing and limiting the layer parameters to choose from, the agent is left with a finite but large space of model architectures to search from. the agent learns through random exploration and slowly begins to exploit its findings to select higher performing models using the - greedy strategy (mnih , 2015). the agent receives the validation accuracy on the given machine learning task as the reward for selecting an architecture. we expedite the learning process through repeated memory sampling using experience replay (lin, 1993). we refer to this q-learning based meta-modeling method as metaqnn, which is summarized in figure 1.1
we conduct experiments with a space of model architectures consisting of only standard convolution, pooling, and fully connected layers using three standard image classification datasets: cifar-10, for more information, model files, and code, please visit https://bowenbaker.github.io/metaqnn/
svhn, and mnist. the learning agent discovers cnn architectures that beat all existing networks designed only with the same layer types (e.g., springenberg  (2014); srivastava  (2015)). in addition, their performance is competitive against network designs that include complex layer types and training procedures (e.g., clevert  (2015); lee  (2016)). finally, the metaqnn selected models comfortably outperform previous automated network design methods (stanley & miikkulainen, 2002; bergstra , 2013). the top network designs discovered by the agent on one dataset are also competitive when trained on other datasets, indicating that they are suited for transfer learning tasks. moreover, we can generate not just one, but several varied, well-performing network designs, which can be ensembled to further boost the prediction performance.designing neural network architectures: research on automating neural network design goes back to the 1980s when genetic algorithm-based approaches were proposed to find both architectures and weights (schaffer , 1992). however, to the best of our knowledge, networks designed with genetic algorithms, such as those generated with the neat algorithm (stanley & miikkulainen, 2002), have been unable to match the performance of hand-crafted networks on standard benchmarks (verbancsics & harguess, 2013). other biologically inspired ideas have also been explored; motivated by screening methods in genetics, pinto  (2009) proposed a high-throughput network selection approach where they randomly sample thousands of architectures and choose promising ones for further training. in recent work, saxena & verbeek (2016) propose to sidestep the architecture selection process through densely connected networks of layers, which come closer to the performance of hand-crafted networks.
bayesian optimization has also been used (shahriari , 2016) for automatic selection of network architectures (bergstra , 2013; domhan , 2015) and hyperparameters (snoek , 2012; swersky , 2013). notably, bergstra  (2013) proposed a meta-modeling approach based on tree of parzen estimators (tpe) (bergstra , 2011) to choose both the type of layers and hyperparameters of feed-forward networks; however, they fail to match the performance of handcrafted networks.
reinforcement learning: recently there has been much work at the intersection of reinforcement learning and deep learning. for instance, methods using cnns to approximate theq-learning utility function (watkins, 1989) have been successful in game-playing agents (mnih , 2015; silver , 2016) and robotic control (lillicrap , 2015; levine , 2016). these methods rely on phases of exploration, where the agent tries to learn about its environment through sampling, and exploitation, where the agent uses what it learned about the environment to find better paths. in traditional reinforcement learning settings, over-exploration can lead to slow convergence times, yet over-exploitation can lead to convergence to local minima (kaelbling , 1996). however, in the case of large or continuous state spaces, the -greedy strategy of learning has been empirically shown to converge (vermorel & mohri, 2005). finally, when the state space is large or exploration is costly,
the experience replay technique (lin, 1993) has proved useful in experimental settings (adam , 2012; mnih , 2015). we incorporate these techniques—q-learning, the -greedy strategy and experience replay—in our algorithm design.our method relies on q-learning, a type of reinforcement learning. we now summarize the theoretical formulation of q-learning, as adopted to our problem. consider the task of teaching an agent to find optimal paths as a markov decision process (mdp) in a finite-horizon environment. constraining the environment to be finite-horizon ensures that the agent will deterministically terminate in a finite number of time steps. in addition, we restrict the environment to have a discrete and finite state space s as well as action space u . for any state si ∈ s , there is a finite set of actions, u(si) ⊆ u , that the agent can choose from. in an environment with stochastic transitions, an agent in state si taking some action u ∈ u(si) will transition to state sj with probability ps′|s,u(sj |si, u), which may be unknown to the agent. at each time step t, the agent is given a reward rt, dependent on the transition from state s to s′ and action u. rt may also be stochastic according to a distribution pr|s′,s,u. the agent’s goal is to maximize the total expected reward over all possible trajectories, i.e., maxti∈t rti , where the total expected reward for a trajectory ti is
rti = ∑ (s,u,s′)∈ti er|s,u,s′ [r|s, u, s ′]. (1)
though we limit the agent to a finite state and action space, there are still a combinatorially large number of trajectories, which motivates the use of reinforcement learning. we define the maximization problem recursively in terms of subproblems as follows. for any state si ∈ s and subsequent action u ∈ u(si), we define the maximum total expected reward to be q∗(si, u). q∗(·) is known as the action-value function and individual q∗(si, u) are know as q-values. the recursive maximization equation, which is known as bellman’s equation, can be written as
q∗(si, u) = esj |si,u [ er|si,u,sj [r|si, u, sj ] + γmaxu′∈u(sj)q∗(sj , u′) ] . (2)
in many cases, it is impossible to analytically solve bellman’s equation (bertsekas, 2015), but it can be formulated as an iterative update
qt+1(si, u) = (1− α)qt(si, u) + α [ rt + γmaxu′∈u(sj)qt(sj , u ′) ] . (3)
equation 3 is the simplest form of q-learning proposed by watkins (1989). for well formulated problems, limt→∞qt(s, u) = q∗(s, u), as long as each transition is sampled infinitely many times (bertsekas, 2015). the update equation has two parameters: (i) α is a q-learning rate which determines the weight given to new information over old information, and (ii) γ is the discount factor which determines the weight given to short-term rewards over future rewards. the q-learning algorithm is model-free, in that the learning agent can solve the task without ever explicitly constructing an estimate of environmental dynamics. in addition, q-learning is off policy, meaning it can learn about optimal policies while exploring via a non-optimal behavioral distribution, i.e. the distribution by which the agent explores its environment.
we choose the behavior distribution using an -greedy strategy (mnih , 2015). with this strategy, a random action is taken with probability and the greedy action, maxu∈u(si)qt(si, u), is chosen with probability 1− . we anneal from 1→ 0 such that the agent begins in an exploration phase and slowly starts moving towards the exploitation phase. in addition, when the exploration cost is large (which is true for our problem setting), it is beneficial to use the experience replay technique for faster convergence (lin, 1992). in experience replay, the learning agent is provided with a memory of its past explored paths and rewards. at a given interval, the agent samples from the memory and updates its q-values via equation 3.  designing neural network architectures with q-learning
we consider the task of training a learning agent to sequentially choose neural network layers. figure 2 shows feasible state and action spaces (a) and a potential trajectory the agent may take along with the cnn architecture defined by this trajectory (b). we model the layer selection process as a markov decision process with the assumption that a well-performing layer in one network should
also perform well in another network. we make this assumption based on the hierarchical nature of the feature representations learned by neural networks with many hidden layers (lecun , 2015). the agent sequentially selects layers via the -greedy strategy until it reaches a termination state. the cnn architecture defined by the agent’s path is trained on the chosen learning problem, and the agent is given a reward equal to the validation accuracy. the validation accuracy and architecture description are stored in a replay memory, and experiences are sampled periodically from the replay memory to update q-values via equation 3. the agent follows an schedule which determines its shift from exploration to exploitation.
our method requires three main design choices: (i) reducing cnn layer definitions to simple state tuples, (ii) defining a set of actions the agent may take, i.e., the set of layers the agent may pick next given its current state, and (iii) balancing the size of the state-action space—and correspondingly, the model capacity—with the amount of exploration needed by the agent to converge. we now describe the design choices and the learning process in detail.each state is defined as a tuple of all relevant layer parameters. we allow five different types of layers: convolution (c), pooling (p), fully connected (fc), global average pooling (gap), and softmax (sm), though the general method is not limited to this set. table 1 shows the relevant parameters for each layer type and also the discretization we chose for each parameter. each layer has a parameter layer depth (shown as layer 1, 2, ... in figure 2). adding layer depth to the state space allows us to constrict the action space such that the state-action graph is directed and acyclic (dag) and also allows us to specify a maximum number of layers the agent may select before terminating.
each layer type also has a parameter called representation size (r-size). convolutional nets progressively compress the representation of the original signal through pooling and convolution. the presence of these layers in our state space may lead the agent on a trajectory where the intermediate signal representation gets reduced to a size that is too small for further processing. for example, five 2× 2 pooling layers each with stride 2 will reduce an image of initial size 32× 32 to size 1× 1. at this stage, further pooling, or convolution with receptive field size greater than 1, would be meaningless and degenerate. to avoid such scenarios, we add the r-size parameter to the state tuple s, which allows us to restrict actions from states with r-size n to those that have a receptive field size less than or equal to n. to further constrict the state space, we chose to bin the representation sizes into three discrete buckets. however, binning adds uncertainty to the state transitions: depending on the true underlying representation size, a pooling layer may or may not change the r-size bin. as a result, the action of pooling can lead to two different states, which we model as stochasticity in state transitions. please see figure a1 in appendix for an illustrated example.we restrict the agent from taking certain actions to both limit the state-action space and make learning tractable. first, we allow the agent to terminate a path at any point, i.e. it may choose a termination state from any non-termination state. in addition, we only allow transitions for a state with layer depth i to a state with layer depth i + 1, which ensures that there are no loops in the graph. this constraint ensures that the state-action graph is always a dag. any state at the maximum layer depth, as prescribed in table 1, may only transition to a termination layer.
next, we limit the number of fully connected (fc) layers to be at maximum two, because a large number of fc layers can lead to too may learnable parameters. the agent at a state with type fc may transition to another state with type fc if and only if the number of consecutive fc states is less than the maximum allowed. furthermore, a state s of type fc with number of neurons d may only transition to either a termination state or a state s′ of type fc with number of neurons d′ ≤ d. an agent at a state of type convolution (c) may transition to a state with any other layer type. an agent at a state with layer type pooling (p) may transition to a state with any other layer type other than another p state because consecutive pooling layers are equivalent to a single, larger pooling layer which could lie outside of our chosen state space. furthermore, only states with representation size in bins (8, 4] and (4, 1] may transition to an fc layer, which ensures that the number of weights does not become unreasonably huge. note that a majority of these constraints are in place to enable faster convergence on our limited hardware (see section 5) and not a limitation of the method in itself. .3 q-learning training procedure
for the iterativeq-learning updates (equation 3), we set theq-learning rate (α) to 0.01. in addition, we set the discount factor (γ) to 1 to not over-prioritize short-term rewards. we decrease from 1.0 to 0.1 in steps, where the step-size is defined by the number of unique models trained (table 2). at = 1.0, the agent samples cnn architecture with a random walk along a uniformly weighted markov chain. every topology sampled by the agent is trained using the procedure described in section 5, and the prediction performance of this network topology on the validation set is recorded. we train a larger number of models at = 1.0 as compared to other values of to ensure that the agent has adequate time to explore before it begins to exploit. we stop the agent at = 0.1 (and not at = 0) to obtain a stochastic final policy, which generates perturbations of the global minimum.2 ideally, we want to identify several well-performing model topologies, which can then be ensembled to improve prediction performance.
during the entire training process (starting at = 1.0), we maintain a replay dictionary which stores (i) the network topology and (ii) prediction performance on a validation set, for all of the sampled  = 0 indicates a completely deterministic policy. because we would like to generate several good models for ensembling and analysis, we stop at = 0.1, which represents a stochastic final policy.
models. if a model that has already been trained is re-sampled, it is not re-trained, but instead the previously found validation accuracy is presented to the agent. after each model is sampled and trained, the agent randomly samples 100 models from the replay dictionary and applies the q-value update defined in equation 3 for all transitions in each sampled sequence. the q-value update is applied to the transitions in temporally reversed order, which has been shown to speed up q-values convergence (lin, 1993).during the model exploration phase, we trained each network topology with a quick and aggressive training scheme. for each experiment, we created a validation set by randomly taking 5,000 samples from the training set such that the resulting class distributions were unchanged. for every network, a dropout layer was added after every two layers. the ith dropout layer, out of a total n dropout layers, had a dropout probability of i2n . each model was trained for a total of 20 epochs with the adam optimizer (kingma & ba, 2014) with β1 = 0.9, β2 = 0.999, ε = 10−8. the batch size was set to 128, and the initial learning rate was set to 0.001. if the model failed to perform better than a random predictor after the first epoch, we reduced the learning rate by a factor of 0.4 and restarted training, for a maximum of 5 restarts. for models that started learning (i.e., performed better than a random predictor), we reduced the learning rate by a factor of 0.2 every 5 epochs. all weights were initialized with xavier initialization (glorot & bengio, 2010). our experiments using caffe (jia , 2014) took 8-10 days to complete for each dataset with a hardware setup consisting of 10 nvidia gpus.
after the agent completed the schedule (table 2), we selected the top ten models that were found over the course of exploration. these models were then finetuned using a much longer training schedule, and only the top five were used for ensembling. we now provide details of the datasets and the finetuning process.
the street view house numbers (svhn) dataset has 10 classes with a total of 73,257 samples in the original training set, 26,032 samples in the test set, and 531,131 additional samples in the extended training set. during the exploration phase, we only trained with the original training set, using 5,000 random samples as validation. we finetuned the top ten models with the original plus extended training set, by creating preprocessed training and validation sets as described by lee  (2016). our final learning rate schedule after tuning on validation set was 0.025 for 5 epochs, 0.0125 for 5 epochs, 0.0001 for 20 epochs, and 0.00001 for 10 epochs.
cifar-10, the 10 class tiny image dataset, has 50,000 training samples and 10,000 testing samples. during the exploration phase, we took 5,000 random samples from the training set for validation. the maximum layer depth was increased to 18. after the experiment completed, we used the same validation set to tune hyperparameters, resulting in a final training scheme which we ran on the entire training set. in the final training scheme, we set a learning rate of 0.025 for 40 epochs, 0.0125 for 40 epochs, 0.0001 for 160 epochs, and 0.00001 for 60 epochs, with all other parameters unchanged. during this phase, we preprocess using global contrast normalization and use moderate data augmentation, which consists of random mirroring and random translation by up to 5 pixels.
mnist, the 10 class handwritten digits dataset, has 60,000 training samples and 10,000 testing samples. we preprocessed each image with global mean subtraction. in the final training scheme, we trained each model for 40 epochs and decreased learning rate every 5 epochs by a factor of 0.2. for further tuning details please see appendix c.model selection analysis: from q-learning principles, we expect the learning agent to improve in its ability to pick network topologies as reduces and the agent enters the exploitation phase. in
figure 3, we plot the rolling mean of prediction accuracy over 100 models and the mean accuracy of models sampled at different values, for the cifar-10 and svhn experiments. the plots show that, while the prediction accuracy remains flat during the exploration phase ( = 1) as expected, the agent consistently improves in its ability to pick better-performing models as reduces from 1 to 0.1. for example, the mean accuracy of models in the svhn experiment increases from 52.25% at = 1 to 88.02% at = 0.1. furthermore, we demonstrate the stability of the q-learning procedure with 10 independent runs on a subset of the svhn dataset in section d.1 of the appendix. additional analysis of q-learning results can be found in section d.2.
the top models selected by the q-learning agent vary in the number of parameters but all demonstrate high performance (see appendix tables 1-3). for example, the number of parameters for the top five cifar-10 models range from 11.26 million to 1.10 million, with only a 2.32% decrease in test error. we find design motifs common to the top hand-crafted network architectures as well. for example, the agent often chooses a layer of type c(n, 1, 1) as the first layer in the network. these layers generate n learnable linear transformations of the input data, which is similar in spirit to preprocessing of input data from rgb to a different color spaces such as yuv, as found in prior work (sermanet , 2012; 2013).
prediction performance: we compare the prediction performance of the metaqnn networks discovered by theq-learning agent with state-of-the-art methods on three datasets. we report the accuracy of our best model, along with an ensemble of top five models. first, we compare metaqnn with six existing architectures that are designed with standard convolution, pooling, and fully-connected layers alone, similar to our designs. as seen in table 3, our top model alone, as well as the committee ensemble of five models, outperforms all similar models. next, we compare our results with six top networks overall, which contain complex layer types and design ideas, including generalized pooling functions, residual connections, and recurrent modules. our results are competitive with these methods as well (table 4). finally, our method outperforms existing automated network design methods. metaqnn obtains an error of 6.92% as compared to 21.2% reported by bergstra  (2011) on cifar-10; and it obtains an error of 0.32% as compared to 7.9% reported by verbancsics & harguess (2013) on mnist.
the difference in validation error between the top 10 models for mnist was very small, so we also created an ensemble with all 10 models. this ensemble achieved a test error of 0.28%—which beats the current state-of-the-art on mnist without data augmentation.
the best cifar-10 model performs 1-2% better than the four next best models, which is why the ensemble accuracy is lower than the best model’s accuracy. we posit that the cifar-10 metaqnn did not have adequate exploration time given the larger state space compared to that of the svhn experiment, causing it to not find more models with performance similar to the best model. furthermore, the coarse training scheme could have been not as well suited for cifar-10 as it was for svhn, causing some models to under perform.
transfer learning ability: network designs such as vggnet (simonyan & zisserman, 2014) can be adopted to solve a variety of computer vision problems. to check if the metaqnn networks provide similar transfer learning ability, we use the best metaqnn model on the cifar-10 dataset for training other computer vision tasks. the model performs well (table 5) both when training from random initializations, and finetuning from existing weights.neural networks are being used in an increasingly wide variety of domains, which calls for scalable solutions to produce problem-specific model architectures. we take a step towards this goal and show that a meta-modeling approach using reinforcement learning is able to generate tailored cnn designs for different image classification tasks. our metaqnn networks outperform previous metamodeling methods as well as hand-crafted networks which use the same types of layers.
while we report results for image classification problems, our method could be applied to different problem settings, including supervised (e.g., classification, regression) and unsupervised (e.g., autoencoders). the metaqnn method could also aid constraint-based network design, by optimizing parameters such as size, speed, and accuracy. for instance, one could add a threshold in the state-action space barring the agent from creating models larger than the desired limit. in addition,
∗results in this column obtained with the top metaqnn architecture for cifar-10, trained from random initialization with cifar-100 data.
one could modify the reward function to penalize large models for constraining memory or penalize slow forward passes to incentivize quick inference.
there are several future avenues for research in reinforcement learning-driven network design as well. in our current implementation, we use the same set of hyperparameters to train all network topologies during the q-learning phase and further finetune the hyperparameters for top models selected by the metaqnn agent. however, our approach could be combined with hyperparameter optimization methods to further automate the network design process. moreover, we constrict the state-action space using coarse, discrete bins to accelerate convergence. it would be possible to move to larger state-action spaces using methods for q-function approximation (bertsekas, 2015; mnih , 2015).we thank peter downs for creating the project website and contributing to illustrations. we acknowledge center for bits and atoms at mit for their help with computing resources. finally, we thank members of camera culture group at mit media lab for their help and support.we first describe the main components of the metaqnn algorithm. algorithm 1 shows the main loop, where the parameter m would determine how many models to run for a given and the parameter k would determine how many times to sample the replay database to update q-values on each iteration. the function train refers to training the specified network and returns a validation accuracy. algorithm 2 details the method for sampling a new network using the -greedy strategy, where we assume we have a function transition that returns the next state given a state and action. finally, algorithm 3 implements theq-value update detailed in equation 3, with discounting factor set to 1, for an entire state sequence in temporally reversed order.
algorithm 1 q-learning for cnn topologies initialize:
replay memory← [ ] q← {(s, u) ∀s ∈ s, u ∈ u(s) : 0.5}
for episode = 1 to m do s, u ← sample new network( , q) accuracy← train(s) replay memory.append((s, u, accuracy)) for memory = 1 to k do
ssample , usample , accuracysample ← uniform{replay memory} q← update q values(q, ssample , usample , accuracysample)
end for end for
algorithm 2 sample new network( , q) initialize:
state sequence s = [sstart] action sequence u = [ ]
while u [−1] 6= terminate do α ∼ uniform[0, 1) if α > then
u = argmaxu∈u(s[−1])q[(s[−1], u)] s′ = transition(s[−1], u)
else u ∼ uniform{u(s[−1])} s′ = transition(s[−1], u) end if u.append(u) if u != terminate then
s.append(s′) end if
end while return s, u
algorithm 3 update q values(q, s, u , accuracy) q[s[−1], u [−1]] = (1− α)q[s[−1], u [−1]] + α · accuracy for i = length(s)− 2 to 0 do
q[s[i], u [i]] = (1− α)q[s[i], u [i]] + αmaxu∈u(s[i+1])q[s[i+ 1], u] end for return qas mentioned in section 4.1 of the main text, we introduce a parameter called representation size to prohibit the agent from taking actions that can reduce the intermediate signal representation to a size that is too small for further processing. however, this process leads to uncertainties in state transitions, as illustrated in figure a1, which is handled by the standard q-learning formulation.
p(2,2)
r-size: 18 r-size bin: 1
r-size: 9 r-size bin: 1
(a)
p(2,2)
r-size: 7 r-size bin: 2
r-size: 14 r-size bin: 1
(b)
states actions
p 1 2 p
r-size bin: 1
r-size bin: 1 r-size bin: 2
p(2,2)
(c)
figure a1: representation size binning: in this figure, we show three example state transitions. the true representation size (r-size) parameter is included in the figure to show the true underlying state. assuming there are two r-size bins, r-size bin1: [8,∞) and r-size bin2: (0, 7], figure a1a shows the case where the initial state is in r-size bin1 and true representation size is 18. after the agent chooses to pool with a 2×2 filter with stride 2, the true representation size reduces to 9 but the r-size bin does not change. in figure a1b, the same 2 × 2 pooling layer with stride 2 reduces the actual representation size of 14 to 7, but the bin changes to r-size bin2. therefore, in figures a1a and a1b, the agent ends up in different final states, despite originating in the same initial state and choosing the same action. figure a1c shows that in our state-action space, when the agent takes an action that reduces the representation size, it will have uncertainty in which state it will transition to.we noticed that the final mnist models were prone to overfitting, so we increased dropout and did a small grid search for the weight regularization parameter. for both tuning and final training, we warmed the model with the learned weights from after the first epoch of initial training. the final models and solvers can be found on our project website https://bowenbaker.github.io/metaqnn/ . figure a2 shows the q-learning performance for the mnist experiment.
d further analysis of q-learning
figure 3 of the main text and figure a2 show that as the agent begins to exploit, it improves in architecture selection. it is also informative to look at the distribution of models chosen at each . figure a4 gives further insight into the performance achieved at each for both experiments.
d.1 q-learning stability
because the q-learning agent explores via a random or semi-random distribution, it is natural to ask whether the agent can consistently improve architecture performance. while the success of the three independent experiments described in the main text allude to stability, here we present further evidence. we conduct 10 independent runs of the q-learning procedure on 10% of the svhn dataset (which corresponds to ∼7,000 training examples). we use a smaller dataset to reduce the computation time of each independent run to 10gpu-days, as opposed to the 100gpu-days it would take on the full dataset. as can be seen in figure a3, the q-learning procedure with the exploration schedule detailed in table 2 is fairly stable. the standard deviation at = 1 is notably smaller than at other stages, which we attribute to the large difference in number of samples at each stage.  500 1000 1500 2000 2500 3000 3500 iterations .00 .10 .20 .30 .40 .50 .60 .70 .80 .90 .00
a cc
u ra
cy
epsilon = 1.0 .9.8.7 .6 .5 .4 .3 .2 .1
mnist q-learning performance
average accuracy per epsilon rolling mean model accuracy
figure a2: mnist q-learning performance. the blue line shows a rolling mean of model accuracy versus iteration, where in each iteration of the algorithm the agent is sampling a model. each bar (in light blue) marks the average accuracy over all models that were sampled during the exploration phase with the labeled . as decreases, the average accuracy goes up, demonstrating that the agent learns to select better-performing cnn architectures. .10.20.30.40.50.60.70.80.91.0 epsilon .45 .50 .55 .60 .65 .70 .75 .80
m ea
n ac
cu ra
cy
q-learning stability (across 10 runs)
(a) .10.20.30.40.50.60.70.80.91.0 epsilon .45 .50 .55 .60 .65 .70 .75 0.80 m ea n ac cu ra cy
q-learning individual runs
(b)
figure a3: figure a3a shows the mean model accuracy and standard deviation at each over 10 independent runs of the q-learning procedure on 10% of the svhn dataset. figure a3b shows the mean model accuracy at each for each independent experiment. despite some variance due to a randomized exploration strategy, each independent run successfully improves architecture performance.
furthermore, the best model found during each run had remarkably similar performance with a mean accuracy of 88.25% and standard deviation of 0.58%, which shows that each run successfully found at least one very high performing model. note that we did not use an extended training schedule to improve performance in this experiment.
d.2 q-value analysis
we now analyze the actualq-values generated by the agent during the training process. the learning agent iteratively updates the q-values of each path during the -greedy exploration. each q-value is initialized at 0.5. after the -schedule is complete, we can analyze the final q-value associated with each path to gain insights into the layer selection process. in the left column of figure a5, we plot the average q-value for each layer type at different layer depths (for both svhn and cifar10) datasets. roughly speaking, a higher q-value associated with a layer type indicates a higher probability that the agent will pick that layer type. in figure a5, we observe that, while the average q-value is higher for convolution and pooling layers at lower layer depths, the q-values for fullyconnected and termination layers (softmax and global average pooling) increase as we go deeper into the network. this observation matches with traditional network designs.
we can also plot the averageq-values associated with different layer parameters for further analysis. in the right column of figure a5, we plot the averageq-values for convolution layers with receptive
field sizes 1, 3, and 5 at different layer depths. the plots show that layers with receptive field size of 5 have a higher q-value as compared to sizes 1 and 3 as we go deeper into the networks. this indicates that it might be beneficial to use larger receptive field sizes in deeper networks.
in summary, the q-learning method enables us to perform analysis on the relative benefits of different design parameters of our state space, and possibly gain insights for new cnn designs.in tables a1 through a3, we present the top five model architectures selected with q-learning for each dataset, along with their prediction error reported on the test set, and their total number of parameters. to download the caffe solver and prototext files, please visit https://bowenbaker.github.io/metaqnn/ .
model architecture test error (%) # params (106) [c(512,5,1), c(256,3,1), c(256,5,1), c(256,3,1), p(5,3), c(512,3,1), c(512,5,1), p(2,2), sm(10)] 6.92 11.18 [c(128,1,1), c(512,3,1), c(64,1,1), c(128,3,1), p(2,2), c(256,3,1), p(2,2), c(512,3,1), p(3,2), sm(10)] 8.78 2.17 [c(128,3,1), c(128,1,1), c(512,5,1), p(2,2), c(128,3,1), p(2,2), c(64,3,1), c(64,5,1), sm(10)] 8.88 2.42 [c(256,3,1), c(256,3,1), p(5,3), c(256,1,1), c(128,3,1), p(2,2), c(128,3,1), sm(10)] 9.24 1.10 [c(128,5,1), c(512,3,1), p(2,2), c(128,1,1), c(128,5,1), p(3,2), c(512,3,1), sm(10)] 11.63 1.66
table a1: top 5 model architectures: cifar-10.
model architecture test error (%) # params (106) [c(128,3,1), p(2,2), c(64,5,1), c(512,5,1), c(256,3,1), c(512,3,1), p(2,2), c(512,3,1), c(256,5,1), c(256,3,1), c(128,5,1), c(64,3,1), sm(10)] 2.24 9.81 [c(128,1,1), c(256,5,1), c(128,5,1), p(2,2), c(256,5,1), c(256,1,1), c(256,3,1), c(256,3,1), c(256,5,1), c(512,5,1), c(256,3,1), c(128,3,1), sm(10)] 2.28 10.38 [c(128,5,1), c(128,3,1), c(64,5,1), p(5,3), c(128,3,1), c(512,5,1), c(256,5,1), c(128,5,1), c(128,5,1), c(128,3,1), sm(10)] 2.32 6.83 [c(128,1,1), c(256,5,1), c(128,5,1), c(256,3,1), c(256,5,1), p(2,2), c(128,1,1), c(512,3,1), c(256,5,1), p(2,2), c(64,5,1), c(64,1,1), sm(10)] 2.35 6.99 [c(128,1,1), c(256,5,1), c(128,5,1), c(256,5,1), c(256,5,1), c(256,1,1), p(3,2), c(128,1,1), c(256,5,1), c(512,5,1), c(256,3,1), c(128,3,1), sm(10)] 2.36 10.05
table a2: top 5 model architectures: svhn. note that we do not report the best accuracy on test set from the above models in tables 3 and 4 from the main text. this is because the model that achieved 2.28% on the test set performed the best on the validation set.
model architecture test error (%) # params (106) [c(64,1,1), c(256,3,1), p(2,2), c(512,3,1), c(256,1,1), p(5,3), c(256,3,1), c(512,3,1), fc(512), sm(10)] 0.35 5.59 [c(128,3,1), c(64,1,1), c(64,3,1), c(64,5,1), p(2,2), c(128,3,1), p(3,2), c(512,3,1), fc(512), fc(128), sm(10)] 0.38 7.43 [c(512,1,1), c(128,3,1), c(128,5,1), c(64,1,1), c(256,5,1), c(64,1,1), p(5,3), c(512,1,1), c(512,3,1), c(256,3,1), c(256,5,1), c(256,5,1), sm(10)] 0.40 8.28 [c(64,3,1), c(128,3,1), c(512,1,1), c(256,1,1), c(256,5,1), c(128,3,1), p(5,3), c(512,1,1), c(512,3,1), c(128,5,1), sm(10)] 0.41 6.27 [c(64,3,1), c(128,1,1), p(2,2), c(256,3,1), c(128,5,1), c(64,1,1), c(512,5,1), c(128,5,1), c(64,1,1), c(512,5,1), c(256,5,1), c(64,5,1), sm(10)] 0.43 8.10 [c(64,1,1), c(256,5,1), c(256,5,1), c(512,1,1), c(64,3,1), p(5,3), c(256,5,1), c(256,5,1), c(512,5,1), c(64,1,1), c(128,5,1), c(512,5,1), sm(10)] 0.44 9.67 [c(128,3,1), c(512,3,1), p(2,2), c(256,3,1), c(128,5,1), c(64,1,1), c(64,5,1), c(512,5,1), gap(10), sm(10)] 0.44 3.52 [c(256,3,1), c(256,5,1), c(512,3,1), c(256,5,1), c(512,1,1), p(5,3), c(256,3,1), c(64,3,1), c(256,5,1), c(512,3,1), c(128,5,1), c(512,5,1), sm(10)] 0.46 12.42 [c(512,5,1), c(128,5,1), c(128,5,1), c(128,3,1), c(256,3,1), c(512,5,1), c(256,3,1), c(128,3,1), sm(10)] 0.55 7.25 [c(64,5,1), c(512,5,1), p(3,2), c(256,5,1), c(256,3,1), c(256,3,1), c(128,1,1), c(256,3,1), c(256,5,1), c(64,1,1), c(256,3,1), c(64,3,1), sm(10)] 0.56 7.55
table a3: top 10 model architectures: mnist. we report the top 10 models for mnist because we included all 10 in our final ensemble. note that we do not report the best accuracy on test set from the above models in tables 3 and 4 from the main text. this is because the model that achieved 0.44% on the test set performed the best on the validation set. .1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
validation accuracy  0 0 0 0 0 0
% m
o d e ls
model accuracy distribution (svhn)
epsilon .1 0.2 0.3 0.4 0.5 .6 0.7 0.8 0.9 1.0
(a) .1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
validation accuracy  0 0 0 0 0 0
% m
o d e ls
model accuracy distribution (svhn)
epsilon .1 1.0
(b) .1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9
validation accuracy   0 5 0
% m
o d e ls
model accuracy distribution (cifar-10)
epsilon .1 0.2 0.3 0.4 0.5 .6 0.7 0.8 0.9 1.0
(c) .1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9
validation accuracy   0 5 20 % m o d e ls
model accuracy distribution (cifar-10)
epsilon .1 1.0
(d) .1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 validation accuracy  0 0 0 0 
% m
od el
s
model accuracy distribution (mnist)
epsilon 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
(e) .1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 validation accuracy  0 0 0 0 
% m
od el
s
model accuracy distribution (mnist)
epsilon 0.1 1.0
(f)
figure a4: accuracy distribution versus : figures a4a, a4c, and a4e show the accuracy distribution for each for the svhn, cifar-10, and mnist experiments, respectively. figures a4b, a4d, and a4f show the accuracy distributions for the initial = 1 and the final = 0.1. one can see that the accuracy distribution becomes much more peaked in the high accuracy ranges at small for each experiment.  2 4 6 8 10 12 14 layer depth .0 .2 .4 .6 .8 .0
a ve
ra ge
q -v
al ue
average q-value vs. layer depth (svhn)
convolution fully connected pooling global average pooling softmax
(a)  2 4 6 8 10 12 layer depth .5 .6 .7 .8 .9 .0
a ve
ra ge
q -v
al ue
average q-value vs. layer depth for convolution layers (svhn)
receptive field size 1 receptive field size 3 receptive field size 5
(b)  5 10 15 20 layer depth .0 .2 .4 .6 .8 .0
a ve
ra ge
q -v
al ue
average q-value vs. layer depth (cifar10)
convolution fully connected pooling global average pooling softmax
(c)  2 4 6 8 10 12 14 16 18 layer depth .5 .6 .7 .8 .9 1.0 a ve ra ge q -v al ue
average q-value vs. layer depth for convolution layers (cifar10)
receptive field size 1 receptive field size 3 receptive field size 5
(d)  2 4 6 8 10 12 14 layer depth .0 .2 .4 .6 .8 .0
a ve
ra ge
q -v
al ue
average q-value vs. layer depth (mnist)
convolution fully connected pooling global average pooling softmax
(e)  2 4 6 8 10 12 layer depth .5 .6 .7 .8 .9 .0
a ve
ra ge
q -v
al ue
average q-value vs. layer depth for convolution layers (mnist)
receptive field size 1 receptive field size 3 receptive field size 5
(f)
figure a5: average q-value versus layer depth for different layer types are shown in the left column. average q-value versus layer depth for different receptive field sizes of the convolution layer are shown in the right column.",1
419.pdf.json,TOPICRNN: A RECURRENT NEURAL NETWORK WITH LONG-RANGE SEMANTIC DEPENDENCY,"when reading a document, short or long, humans have a mechanism that somehow allows them to remember the gist of what they have read so far. consider the following example:
“the u.s.presidential race isn’t only drawing attention and controversy in the united states – it’s being closely watched across the globe. but what does the rest of the world think about a campaign that has already thrown up one surprise after another? cnn asked 10 journalists for their take on the race so far, and what their country might be hoping for in america’s next —”
the missing word in the text above is easily predicted by any human to be either president or commander in chief or their synonyms. there have been various language models – from simple ngrams to the most recent rnn-based language models – that aim to solve this problem of predicting correctly the subsequent word in an observed sequence of words.
a good language model should capture at least two important properties of natural language. the first one is correct syntax. in order to do prediction that enjoys this property, we often only need to consider a few preceding words. therefore, correct syntax is more of a local property. word order matters in this case. the second property is the semantic coherence of the prediction. to achieve
∗work was done while at microsoft research.
this, we often need to consider many preceding words to understand the global semantic meaning of the sentence or document. the ordering of the words usually matters much less in this case.
because they only consider a fixed-size context window of preceding words, traditional n-gram and neural probabilistic language models (bengio , 2003) have difficulties in capturing global semantic information. to overcome this, rnn-based language models (mikolov , 2010; 2011) use hidden states to “remember” the history of a word sequence. however, none of these approaches explicitly model the two main properties of language mentioned above, correct syntax and semantic coherence. previous work by chelba and jelinek (2000) and gao  (2004) exploit syntactic or semantic parsers to capture long-range dependencies in language.
in this paper, we propose topicrnn, a rnn-based language model that is designed to directly capture long-range semantic dependencies via latent topics. these topics provide context to the rnn. contextual rnns have received a lot of attention (mikolov and zweig, 2012; mikolov , 2014; ji , 2015; lin , 2015; ji , 2016; ghosh , 2016). however, the models closest to ours are the contextual rnn model proposed by mikolov and zweig (2012) and its most recent extension to the long-short term memory (lstm) architecture (ghosh , 2016). these models use pre-trained topic model features as an additional input to the hidden states and/or the output of the rnn. in contrast, topicrnn does not require pre-trained topic model features and can be learned in an end-to-end fashion. we introduce an automatic way for handling stop words that topic models usually have difficulty dealing with. under a comparable model size set up, topicrnn achieves better perplexity scores than the contextual rnn model of mikolov and zweig (2012) on the penn treebank dataset 1. moreover, topicrnn can be used as an unsupervised feature extractor for downstream applications. for example, we derive document features of the imdb movie review dataset using topicrnn for sentiment classification. we reported an error rate of 6.28%. this is close to the state-of-the-art 5.91% (miyato , 2016) despite that we do not use the labels and adversarial training in the feature extraction stage.
the remainder of the paper is organized as follows: section 2 provides background on rnn-based language models and probabilistic topic models. section 3 describes the topicrnn network architecture, its generative process and how to perform inference for it. section 4 presents per-word perplexity results on the penn treebank dataset and the classification error rate on the imdb 100k dataset. finally, we conclude and provide future research directions in section 5.we present the background necessary for building the topicrnn model. we first review rnn-based language modeling, followed by a discussion on the construction of latent topic models.language modeling is fundamental to many applications. examples include speech recognition and machine translation. a language model is a probability distribution over a sequence of words in a predefined vocabulary. more formally, let v be a vocabulary set and y1, ..., yt a sequence of t words with each yt ∈ v . a language model measures the likelihood of a sequence through a joint probability distribution,
p(y1, ..., yt ) = p(y1) t∏ t=2 p(yt|y1:t−1).
traditional n-gram and feed-forward neural network language models (bengio , 2003) typically make markov assumptions about the sequential dependencies between words, where the chain rule shown above limits conditioning to a fixed-size context window.
rnn-based language models (mikolov , 2011) sidestep this markov assumption by defining the conditional probability of each word yt given all the previous words y1:t−1 through a hidden ghosh  (2016) did not publish results on the ptb and we did not find the code online.
state ht (typically via a softmax function):
p(yt|y1:t−1) , p(yt|ht), ht = f(ht−1, xt).
the function f(·) can either be a standard rnn cell or a more complex cell such as gru (cho , 2014) or lstm (hochreiter and schmidhuber, 1997). the input and target words are related via the relation xt ≡ yt−1. these rnn-based language models have been quite successful (mikolov , 2011; chelba , 2013; jozefowicz , 2016).
while in principle rnn-based models can “remember” arbitrarily long histories if provided enough capacity, in practice such large-scale neural networks can easily encounter difficulties during optimization (bengio , 1994; pascanu , 2013; sutskever, 2013) or overfitting issues (srivastava , 2014). finding better ways to model long-range dependencies in language modeling is therefore an open research challenge. as motivated in the introduction, much of the long-range dependency in language comes from semantic coherence, not from syntactic structure which is more of a local phenomenon. therefore, models that can capture long-range semantic dependencies in language are complementary to rnns. in the following section, we describe a family of such models called probabilistic topic models.probabilistic topic models are a family of models that can be used to capture global semantic coherency (blei and lafferty, 2009). they provide a powerful tool for summarizing, organizing, and navigating document collections. one basic goal of such models is to find groups of words that tend to co-occur together in the same document. these groups of words are called topics and represent a probability distribution that puts most of its mass on this subset of the vocabulary. documents are then represented as mixtures over these latent topics. through posterior inference, the learned topics capture the semantic coherence of the words they cluster together (mimno , 2011).
the simplest topic model is latent dirichlocation (lda) (blei , 2003). it assumes k underlying topics β = {β1, . . . , βk} , each of which is a distribution over a fixed vocabulary. the generative process of lda is as follows: first generate the k topics, βk ∼iid dirichlet(τ). then for each document containing words y1:t , independently generate document-level variables and data: . draw a document-specific topic proportion vector θ ∼ dirichlet(α). . for the tth word in the document,
(a) draw topic assignment zt ∼ discrete(θ). (b) draw word yt ∼ discrete(βzt).
marginalizing each zt, we obtain the probability of y1:t via a matrix factorization followed by an integration over the latent variable θ,
p(y1:t |β) = ∫ p(θ) t∏ t=1 ∑ zt p(zt|θ)p(yt|zt, β)dθ = ∫ p(θ) t∏ t=1 (βθ)ytdθ. (1)
in lda the prior distribution on the topic proportions is a dirichlet distribution; it can be replaced by many other distributions. for example, the correlated topic model (blei and lafferty, 2006) uses a log-normal distribution. most topic models are “bag of words” models in that word order is ignored. this makes it easier for topic models to capture global semantic information. however, this is also one of the reasons why topic models do not perform well on general-purpose language modeling applications such as word prediction. while bi-gram topic models have been proposed (wallach, 2006), higher order models quickly become intractable.
another issue encountered by topic models is that they do not model stop words well. this is because stop words usually do not carry semantic meaning; their appearance is mainly to make the sentence more readable according to the grammar of the language. they also appear frequently in
almost every document and can co-occur with almost any word2. in practice, these stop words are chosen using tf-idf (blei and lafferty, 2009).we next describe the proposed topicrnn model. in topicrnn, latent topic models are used to capture global semantic dependencies so that the rnn can focus its modeling capacity on the local dynamics of the sequences. with this joint modeling, we hope to achieve better overall performance on downstream applications.
the model. topicrnn is a generative model. for a document containing the words y1:t , . draw a topic vector3 θ ∼ n(0, i). 2. given word y1:t−1, for the tth word yt in the document,
(a) compute hidden state ht = fw (xt, ht−1), where we let xt , yt−1. (b) draw stop word indicator lt ∼ bernoulli(σ(γ>ht)), with σ the sigmoid function. (c) draw word yt ∼ p(yt|ht, θ, lt, b), where
p(yt = i|ht, θ, lt, b) ∝ exp ( v>i ht + (1− lt)b>i θ ) .
the stop word indicator lt controls how the topic vector θ affects the output. if lt = 1 (indicating yt is a stop word), the topic vector θ has no contribution to the output. otherwise, we add a bias to favor those words that are more likely to appear when mixing with θ, as measured by the dot product between θ and the latent word vector bi for the ith vocabulary word. as we can see, the longrange semantic information captured by θ directly affects the output through an additive procedure. unlike mikolov and zweig (2012), the contextual information is not passed to the hidden layer of the rnn. the main reason behind our choice of using the topic vector as bias instead of passing it into the hidden states of the rnn is because it enables us to have a clear separation of the contributions of global semantics and those of local dynamics. the global semantics come from the topics which are meaningful when stop words are excluded. however these stop words are needed for the local dynamics of the language model. we hence achieve this separation of global vs local via a binary decision model for the stop words. it is unclear how to achieve this if we pass the topics to the wallach  (2009) described using asymmetric priors to alleviate this issue. although it is not clear how to use this idea in topicrnn, we plan to investigate such priors in future work. instead of using the dirichlet distribution, we choose the gaussian distribution. this allows for more flexibility in the sequence prediction problem and also has advantages during inference.
hidden states of the rnn. this is because the hidden states of the rnn will account for all words (including stop words) whereas the topics exclude stop words.
we show the unrolled graphical representation of topicrnn in figure 1(a). we denote all model parameters as θ = {γ, v, b,w,wc} (see appendix a.1 for more details). parameter wc is for the inference network, which we will introduce below. the observations are the word sequences y1:t and stop word indicators l1:t .4 the log marginal likelihood of the sequence y1:t is
log p(y1:t , l1:t |ht) = log ∫ p(θ) t∏ t=1 p(yt|ht, lt, θ)p(lt|ht)dθ. (2)
model inference. direct optimization of equation 2 is intractable so we use variational inference for approximating this marginal (jordan , 1999). let q(θ) be the variational distribution on the marginalized variable θ. we construct the variational objective function, also called the evidence lower bound (elbo), as follows:
l(y1:t , l1:t |q(θ),θ) , eq(θ) [ t∑ t=1 log p(yt|ht, lt, θ) + log p(lt|ht) + log p(θ)− log q(θ) ] ≤ log p(y1:t , l1:t |ht,θ).
following the proposed variational autoencoder technique, we choose the form of q(θ) to be an inference network using a feed-forward neural network (kingma and welling, 2013; miao , 2015). let xc ∈ n |vc|+ be the term-frequency representation of y1:t excluding stop words (with vc the vocabulary size without the stop words). the variational autoencoder inference network q(θ|xc,wc) with parameter wc is a feed-forward neural network with relu activation units that projects xc into a k-dimensional latent space. specifically, we have
q(θ|xc,wc) = n(θ;µ(xc), diag(σ2(xc))), µ(xc) = w1g(xc) + a1,
log σ(xc) = w2g(xc) + a2,
where g(·) denotes the feed-forward neural network. the weight matrices w1, w2 and biases a1, a2 are shared across documents. each document has its own µ(xc) and σ(xc) resulting in a unique distribution q(θ|xc) for each document. the output of the inference network is a distribution on θ, which we regard as the summarization of the semantic information, similar to the topic proportions in latent topic models. we show the role of the inference network in figure 1(b). during training, the parameters of the inference network and the model are jointly learned and updated via truncated backpropagation through time using the adam algorithm (kingma and ba, 2014). we use stochastic samples from q(θ|xc) and the reparameterization trick towards this end (kingma and welling, 2013; rezende , 2014).
generating sequential text and computing perplexity. suppose we are given a word sequence y1:t−1, from which we have an initial estimation of q(θ|xc). to generate the next word yt, we compute the probability distribution of yt given y1:t−1 in an online fashion. we choose θ to be a point estimate θ̂, the mean of its current distribution q(θ|xc). marginalizing over the stop word indicator lt which is unknown prior to observing yt, the approximate distribution of yt is
p(yt|y1:t−1) ≈ ∑ lt p(yt|ht, θ̂, lt)p(lt|ht).
the predicted word yt is a sample from this predictive distribution. we update q(θ|xc) by including yt toxc if yt is not a stop word. however, updating q(θ|xc) after each word prediction is expensive, so we use a sliding window as was done in mikolov and zweig (2012). to compute the perplexity, we use the approximate predictive distribution above.
model complexity. topicrnn has a complexity of o(h × h + h × (c + k) + wc), where h is the size of the hidden layer of the rnn, c is the vocabulary size, k is the dimension of the topic vector, and wc is the number of parameters of the inference network. the contextual rnn of mikolov and zweig (2012) accounts foro(h×h+h×(c+k)), not including the pre-training process, which might require more parameters than the additional wc in our complexity. stop words can be determined using one of the several lists available online. for example, http://www. lextek.com/manuals/onix/stopwords2.htmlwe assess the performance of our proposed topicrnn model on word prediction and sentiment analysis5. for word prediction we use the penn treebank dataset, a standard benchmark for assessing new language models (marcus , 1993). for sentiment analysis we use the imdb 100k dataset (maas , 2011), also a common benchmark dataset for this application6. we use rnn, lstm, and gru cells in our experiments leading to topicrnn, topiclstm, and topicgru.we first tested topicrnn on the word prediction task using the penn treebank (ptb) portion of the wall street journal. we use the standard split, where sections 0-20 (930k tokens) are used for training, sections 21-22 (74k tokens) for validation, and sections 23-24 (82k tokens) for testing (mikolov , 2010). we use a vocabulary of size 10k that includes the special token unk for rare words and eos that indicates the end of a sentence. topicrnn takes documents as inputs. we split the ptb data into blocks of 10 sentences to constitute documents as done by (mikolov and zweig, 2012). the inference network takes as input the bag-of-words representation of the input document. for that reason, the vocabulary size of the inference network is reduced to 9551 after excluding 449 pre-defined stop words.
in order to compare with previous work on contextual rnns we trained topicrnn using different network sizes. we performed word prediction using a recurrent neural network with 10 neurons, our code will be made publicly available for reproducibility. 6these datasets are publicly available at http://www.fit.vutbr.cz/~imikolov/rnnlm/
simple-examples.tgz and http://ai.stanford.edu/~amaas/data/sentiment/.  neurons and 300 neurons. for these experiments, we used a multilayer perceptron with 2 hidden layers and 200 hidden units per layer for the inference network. the number of topics was tuned depending on the size of the rnn. for 10 neurons we used 18 topics. for 100 and 300 neurons we found 50 topics to be optimal. we used the validation set to tune the hyperparameters of the model. we used a maximum of 15 epochs for the experiments and performed early stopping using the validation set. for comparison purposes we did not apply dropout and used 1 layer for the rnn and its counterparts in all the word prediction experiments as reported in table 2. one epoch for 10 neurons takes 2.5 minutes. for 100 neurons, one epoch is completed in less than 4 minutes. finally, for 300 neurons one epoch takes less than 6 minutes. these experiments were ran on microsoft azure nc12 that has 12 cores, 2 tesla k80 gpus, and 112 gb memory. first, we show five randomly drawn topics in table 1. these results correspond to a network with 100 neurons. we also illustrate some inferred topic distributions for several documents from topicgru in figure 2. similar to standard topic models, these distributions are also relatively peaky.
next, we compare the performance of topicrnn to our baseline contextual rnn using perplexity. perplexity can be thought of as a measure of surprise for a language model. it is defined as the exponential of the average negative log likelihood. table 2 summarizes the results for different network sizes. we learn three things from these tables. first, the perplexity is reduced the larger the network size. second, rnns with context features perform better than rnns without context features. third, we see that topicrnn gives lower perplexity than the previous baseline result reported by mikolov and zweig (2012). note that to compute these perplexity scores for word prediction we use a sliding window to compute θ as we move along the sequences. the topic vector θ that is used from the current batch of words is estimated from the previous batch of words. this enables fair comparison to previously reported results (mikolov and zweig, 2012).7
another aspect of the topicrnn model we studied is its capacity to generate coherent text. to do this, we randomly drew a document from the test set and used this document as seed input to the inference network to compute θ. our expectation is that the topics contained in this seed document are reflected in the generated text. table 3 shows generated text from models learned on the ptb and imdb datasets. see appendix a.3 for more examples. we adjusted the scores in table 2 from what was previously reported after correcting a bug in the computation of the elbo.we performed sentiment analysis using topicrnn as a feature extractor on the imdb 100k dataset. this data consists of 100,000 movie reviews from the internet movie database (imdb) website. the data is split into 75% for training and 25% for testing. among the 75k training reviews, 50k are unlabelled and 25k are labelled as carrying either a positive or a negative sentiment. all 25k test reviews are labelled. we trained topicrnn on 65k random training reviews and used the remaining 10k reviews for validation. to learn a classifier, we passed the 25k labelled training reviews through the learned topicrnn model. we then concatenated the output of the inference network and the last state of the rnn for each of these 25k reviews to compute the feature vectors. we then used these feature vectors to train a neural network with one hidden layer, 50 hidden units, and a sigmoid activation function to predict sentiment, exactly as done in le and mikolov (2014).
to train the topicrnn model, we used a vocabulary of size 5,000 and mapped all other words to the unk token. we took out 439 stop words to create the input of the inference network. we used 500 units and 2 layers for the inference network, and used 2 layers and 300 units per-layer for the
rnn. we chose a step size of 5 and defined 200 topics. we did not use any regularization such as dropout. we trained the model for 13 epochs and used the validation set to tune the hyperparameters of the model and track perplexity for early stopping. this experiment took close to 78 hours on a macbook pro quad-core with 16ghz of ram. see appendix a.4 for the visualization of some of the topics learned from this data.
table 4 summarizes sentiment classification results from topicrnn and other methods. our error rate is 6.28%.8 this is close to the state-of-the-art 5.91% (miyato , 2016) despite that we do not use the labels and adversarial training in the feature extraction stage. our approach is most similar to le and mikolov (2014), where the features were extracted in a unsupervised way and then a one-layer neural net was trained for classification.
figure 3 shows the ability of topicrnn to cluster documents using the feature vectors as created during the sentiment analysis task. reviews with positive sentiment are coloured in green while reviews carrying negative sentiment are shown in red. this shows that topicrnn can be used as an unsupervised feature extractor for downstream applications. table 3 shows generated text from models learned on the ptb and imdb datasets. see appendix a.3 for more examples. the overall generated text from imdb encodes a negative sentiment.in this paper we introduced topicrnn, a rnn-based language model that combines rnns and latent topics to capture local (syntactic) and global (semantic) dependencies between words. the global dependencies as captured by the latent topics serve as contextual bias to an rnn-based language model. this contextual information is learned jointly with the rnn parameters by maximizing the evidence lower bound of variational inference. topicrnn yields competitive per-word perplexity on the penn treebank dataset compared to previous contextual rnn models. we have reported a competitive classification error rate for sentiment analysis on the imdb 100k dataset. we have also illustrated the capacity of topicrnn to generate sensible topics and text. in future work, we will study the performance of topicrnn when stop words are dynamically discovered during training. we will also extend topicrnn to other applications where capturing context is important such as in dialog modeling. if successful, this will allow us to have a model that performs well across different natural language processing applications. the experiments were solely based on topicrnn. experiments using topicgru/topiclstm are being carried out and will be added as an extended version of this paper.a.1 dimension of the parameters of the model:
we use the following notation: c is the vocabulary size (including stop words), h is the number of hidden units of the rnn, k is the number of topics, and e is the dimension of the inference network hidden layer. table 5 gives the dimension of each of the parameters of the topicrnn model (ignoring the biases).
a.2 documents used to infer the distributions on figure 2
figure on the left: ’the’, ’market’, ’has’, ’grown’, ’relatively’, ’quiet’, ’since’, ’the’, ’china’, ’crisis’, ’but’, ’if’, ’the’, ’japanese’, ’return’, ’in’, ’force’, ’their’, ’financial’, ’might’, ’could’, ’compensate’, ’to’, ’some’, ’extent’, ’for’, ’local’, ’investors’, ""’"", ’<unk>’, ’commitment’, ’another’, ’and’, ’critical’, ’factor’, ’is’, ’the’, ’u.s.’, ’hong’, ’kong’, ""’s"", ’biggest’, ’export’, ’market’, ’even’, ’before’, ’the’, ’china’, ’crisis’, ’weak’, ’u.s.’, ’demand’, ’was’, ’slowing’, ’local’, ’economic’, ’growth’, ’<unk>’, ’strong’, ’consumer’, ’spending’, ’in’, ’the’, ’u.s.’, ’two’, ’years’, ’ago’, ’helped’, ’<unk>’, ’the’, ’local’, ’economy’, ’at’, ’more’, ’than’, ’twice’, ’its’, ’current’, ’rate’, ’indeed’, ’a’, ’few’, ’economists’, ’maintain’, ’that’, ’global’, ’forces’, ’will’, ’continue’, ’to’, ’govern’, ’hong’, ’kong’, ""’s"", ’economic’, ’<unk>’, ’once’, ’external’, ’conditions’, ’such’, ’as’, ’u.s.’, ’demand’, ’swing’, ’in’, ’the’, ’territory’, ""’s"", ’favor’, ’they’, ’argue’, ’local’, ’businessmen’, ’will’, ’probably’, ’overcome’, ’their’, ’n’, ’worries’, ’and’, ’continue’, ’doing’, ’business’, ’as’, ’usual’, ’but’, ’economic’, ’arguments’, ’however’, ’solid’, ’wo’, ""n’t"", ’necessarily’, ’<unk>’, ’hong’, ’kong’, ""’s"", ’n’, ’million’, ’people’, ’many’, ’are’, ’refugees’, ’having’, ’fled’, ’china’, ""’s"", ’<unk>’, ’cycles’, ’of’, ’political’, ’repression’, ’and’, ’poverty’, ’since’, ’the’, ’communist’, ’party’, ’took’, ’power’, ’in’, ’n’, ’as’, ’a’, ’result’, ’many’, ’of’, ’those’, ’now’, ’planning’, ’to’, ’leave’, ’hong’, ’kong’, ’ca’, ""n’t"", ’easily’, ’be’, ’<unk>’, ’by’, ’<unk>’, ’improvements’, ’in’, ’the’, ’colony’, ""’s"", ’political’, ’and’, ’economic’, ’climate’
figure on the middle: ’it’, ’said’, ’the’, ’man’, ’whom’, ’it’, ’did’, ’not’, ’name’, ’had’, ’been’, ’found’, ’to’, ’have’, ’the’, ’disease’, ’after’, ’hospital’, ’tests’, ’once’, ’the’, ’disease’, ’was’, ’confirmed’, ’all’, ’the’, ’man’, ""’s"", ’associates’, ’and’, ’family’, ’were’, ’tested’, ’but’, ’none’, ’have’, ’so’, ’far’, ’been’, ’found’, ’to’, ’have’, ’aids’, ’the’, ’newspaper’, ’said’, ’the’, ’man’, ’had’, ’for’, ’a’, ’long’, ’time’, ’had’, ’a’, ’chaotic’, ’sex’, ’life’, ’including’, ’relations’, ’with’, ’foreign’, ’men’, ’the’, ’newspaper’, ’said’, ’the’, ’polish’, ’government’, ’increased’, ’home’, ’electricity’, ’charges’, ’by’, ’n’, ’n’, ’and’, ’doubled’, ’gas’, ’prices’, ’the’, ’official’, ’news’, ’agency’, ’<unk>’, ’said’, ’the’, ’increases’, ’were’, ’intended’, ’to’, ’bring’, ’<unk>’, ’low’, ’energy’, ’charges’, ’into’, ’line’, ’with’, ’production’, ’costs’, ’and’, ’compensate’, ’for’, ’a’, ’rise’, ’in’, ’coal’, ’prices’, ’in’, ’<unk>’, ’news’, ’south’, ’korea’, ’in’, ’establishing’, ’diplomatic’, ’ties’, ’with’, ’poland’, ’yesterday’, ’announced’, ’$’, ’n’, ’million’, ’in’, ’loans’, ’to’, ’the’, ’financially’, ’strapped’, ’warsaw’, ’government’, ’in’, ’a’, ’victory’, ’for’, ’environmentalists’, ’hungary’, ""’s"", ’parliament’, ’terminated’, ’a’, ’multibillion-dollar’, ’river’, ’<unk>’, ’dam’, ’being’, ’built’, ’by’, ’<unk>’, ’firms’, ’the’, ’<unk>’, ’dam’, ’was’, ’designed’, ’to’, ’be’, ’<unk>’, ’with’, ’another’, ’dam’, ’now’, ’nearly’, ’complete’, ’n’, ’miles’, ’<unk>’, ’in’, ’czechoslovakia’, ’in’, ’ending’, ’hungary’, ""’s"", ’part’, ’of’, ’the’, ’project’, ’parliament’, ’authorized’, ’prime’, ’minister’, ’<unk>’, ’<unk>’, ’to’, ’modify’, ’a’, ’n’, ’agreement’, ’with’, ’czechoslovakia’, ’which’, ’still’, ’wants’, ’the’, ’dam’, ’to’, ’be’, ’built’, ’mr.’, ’<unk>’, ’said’, ’in’, ’parliament’, ’that’, ’czechoslovakia’, ’and’, ’hungary’, ’would’, ’suffer’, ’environmental’, ’damage’, ’if’, ’the’, ’<unk>’, ’<unk>’, ’were’, ’built’, ’as’, ’planned’
figure on the right: ’in’, ’hartford’, ’conn.’, ’the’, ’charter’, ’oak’, ’bridge’, ’will’, ’soon’, ’be’, ’replaced’, ’the’, ’<unk>’, ’<unk>’, ’from’, ’its’, ’<unk>’, ’<unk>’, ’to’, ’a’, ’park’, ’<unk>’, ’are’, ’possible’, ’citizens’, ’in’, ’peninsula’, ’ohio’, ’upset’, ’over’, ’changes’, ’to’, ’a’, ’bridge’, ’negotiated’, ’a’, ’deal’, ’the’, ’bottom’, ’half’, ’of’, ’the’, ’<unk>’, ’will’, ’be’, ’type’, ’f’, ’while’, ’the’, ’top’, ’half’, ’will’, ’have’, ’the’, ’old’, ’bridge’, ""’s"", ’<unk>’, ’pattern’, ’similarly’, ’highway’, ’engineers’, ’agreed’, ’to’, ’keep’, ’the’, ’old’, ’<unk>’, ’on’, ’the’, ’key’, ’bridge’, ’in’, ’washington’, ’d.c.’, ’as’, ’long’, ’as’, ’they’, ’could’, ’install’, ’a’, ’crash’, ’barrier’, ’between’, ’the’, ’sidewalk’, ’and’, ’the’, ’road’, ’<unk>’, ’<unk>’, ’drink’, ’carrier’, ’competes’, ’with’, ’<unk>’, ’<unk>’, ’<unk>’, ’just’, ’got’, ’easier’, ’or’, ’so’, ’claims’, ’<unk>’, ’corp.’, ’the’, ’maker’, ’of’, ’the’, ’<unk>’, ’the’, ’chicago’, ’company’, ""’s"", ’beverage’, ’carrier’, ’meant’, ’to’, ’replace’, ’<unk>’, ’<unk>’, ’at’, ’<unk>’, ’stands’, ’and’, ’fast-food’, ’outlets’, ’resembles’, ’the’, ’plastic’, ’<unk>’, ’used’, ’on’, ’<unk>’, ’of’, ’beer’, ’only’, ’the’, ’<unk>’, ’hang’, ’from’, ’a’, ’<unk>’, ’of’, ’<unk>’, ’the’, ’new’, ’carrier’, ’can’, ’<unk>’, ’as’, ’many’, ’as’, ’four’, ’<unk>’, ’at’, ’once’, ’inventor’, ’<unk>’, ’marvin’, ’says’, ’his’, ’design’, ’virtually’, ’<unk>’, ’<unk>’
a.3 more generated text from the model:
we illustrate below some generated text resulting from training topicrnn on the ptb dataset. here we used 50 neurons and 100 topics:
text1: but the refcorp bond fund might have been unk and unk of the point rate eos house in national unk wall restraint in the property pension fund sold willing to zenith was guaranteed by $ n million at short-term rates maturities around unk products eos deposit posted yields slightly
text2: it had happened by the treasury ’s clinical fund month were under national disappear institutions but secretary nicholas instruments succeed eos and investors age far compound average new york stock exchange bonds typically sold $ n shares in the n but paying yields further an average rate of long-term funds
we illustrate below some generated text resulting from training topicrnn on the imdb dataset. the settings are the same as for the sentiment analysis experiment:
the film ’s greatest unk unk and it will likely very nice movies to go to unk why various david proves eos the story were always well scary friend high can be a very strange unk unk is in love with it lacks even perfect for unk for some of the worst movies come on a unk gave a rock unk eos whatever let ’s possible eos that kyle can ’t different reasons about the unk and was not what you ’re not a fan of unk unk us rock which unk still in unk ’s music unk one as
a.4 topics from imdb:
below we show some topics resulting from the sentiment analysis on the imdb dataset. the total number of topics is 200. note here all the topics turn around movies which is expected since all reviews are about movies.",1
448.pdf.json,DEEP INFORMATION PROPAGATION,"deep neural network architectures have become ubiquitous in machine learning. the success of deep networks is due to the fact that they are highly expressive (montufar , 2014) while simultaneously being relatively easy to optimize (choromanska , 2015; goodfellow , 2014) with strong generalization properties (recht , 2015). consequently, developments in machine learning often accompany improvements in our ability to train increasingly deep networks. despite this, designing novel network architectures is frequently equal parts art and science. this is, in part, because a general theory for neural networks that might inform design decisions has lagged behind the feverish pace of design.
a pair of recent papers (poole , 2016; raghu , 2016) demonstrated that random neural networks are exponentially expressive in their depth. central to their approach was the consideration of networks after random initialization, whose weights and biases were i.i.d. gaussian distributed. in particular the paper by poole  (2016) developed a “mean field” formalism for treating wide, untrained, neural networks. they showed that these mean field networks exhibit an order-to-chaos transition as a function of the weight and bias variances. notably the mean field formalism is not closely tied to a specific choice of activation function or loss.
in this paper, we demonstrate the existence of several characteristic “depth” scales that emerge naturally and control signal propagation in these random networks. we then show that one of these depth scales, ξc, diverges at the boundary between order and chaos. this result is insensitive to many architectural decisions (such as choice of activation function) and will generically be true at any order-to-chaos transition. we then extend these results to include dropout and we show that even small amounts of dropout destroys the order-to-chaos critical point and consequently removes the divergence in ξc. together these results bound the depth to which signal may propagate through random neural networks.
we then develop a corresponding mean field model for gradients and we show that a duality exists between the forward propagation of signals and the backpropagation of gradients. the ordered and chaotic phases that poole  (2016) identified correspond to regions of vanishing and exploding gradients, respectively. we demonstrate the validity of this mean field theory by computing gradients of random networks on mnist. this provides a formal explanation of the ‘vanishing gradients’
∗work done as a member of the google brain residency program (g.co/brainresidency)
phenomenon that has long been observed in neural networks (bengio , 1993). we continue to show that the covariance between two gradients is controlled by the same depth scale that limits correlated signal propagation in the forward direction.
finally, we hypothesize that a necessary condition for a random neural network to be trainable is that information should be able to pass through it. thus, the depth-scales identified here bound the set of hyperparameters that will lead to successful training. to test this ansatz we train ensembles of deep, fully connected, feed-forward neural networks of varying depth on mnist and cifar10, with and without dropout. our results confirm that neural networks are trainable precisely when their depth is not much larger than ξc. this result is dataset independent and is, therefore, a universal function of network architecture.
a corollary of these result is that asymptotically deep neural networks should be trainable provided they are initialized sufficiently close to the order-to-chaos transition. the notion of “edge of chaos” initialization has been explored previously. such investigations have been both direct as in bertschinger  (2005); glorot & bengio (2010) or indirect, through initialization schemes that favor deep signal propagation such as batch normalization (ioffe & szegedy, 2015), orthogonal matrix initialization (saxe , 2014), random walk initialization (sussillo & abbott, 2014), composition kernels (daniely , 2016), or residual network architectures (he , 2015). the novelty of the work presented here is two-fold. first, our framework predicts the depth at which networks may be trained even far from the order-to-chaos transition. while a skeptic might ask when it would be profitable to initialize a network far from criticality, we respond by noting that there are architectures (such as neural networks with dropout) where no critical point exists and so this more general framework is needed. second, our work provides a formal, as opposed to intuitive, explanation for why very deep networks can only be trained near the edge of chaos.we begin by recapitulating the mean-field formalism developed in poole  (2016). consider a fully-connected, untrained, feed-forward, neural network of depth l with layer width nl and some nonlinearity φ : r → r. since this is an untrained neural network we suppose that its weights and biases are respectively i.i.d. as w lij ∼ n(0, σ2w/nl) and bli ∼ n(0, σ2b ). notationally we set zli to be the pre-activations of the lth layer and yl+1i to be the activations of that layer. finally, we take the input to the network to be y0i = xi. the propagation of a signal through the network is described by the pair of equations,
zli = ∑ j w lijy l j + b l i y l+1 i = φ(z l i). (1)
since the weights and biases are randomly distributed, these equations define a probability distribution on the activations and pre-activations over an ensemble of untrained neural networks. the “mean-field” approximation is then to replace zli by a gaussian whose first two moments match those of zli. for the remainder of the paper we will take the mean field approximation as given.
consider first the evolution of a single input, xi;a, as it evolves through the network (as quantified by yli;a and z l i;a). since the weights and biases are independent with zero mean, the first two moments of the pre-activations in the same layer will be,
e[zli;a] = 0 e[zli;azlj;a] = qlaaδij (2)
where δij is the kronecker delta. here qlaa is the variance of the pre-activations in the lth layer due to an input xi;a and it is described by the recursion relation,
qlaa = σ 2 w
∫ dzφ2 (√ ql−1aa z ) + σ2b (3)
where ∫ dz = 1√ π
∫ dze− 1 2 z 2
is the measure for a standard gaussian distribution. together these equations completely describe the evolution of a single input through a mean field neural network. for any choice of σ2w and σ 2 b with bounded φ, eq. 3 has a fixed point at q ∗ = liml→∞ qlaa.
the propagation of a pair of signals, x0i;a and x 0 i;b, through this network can be understood similarly. here the mean pre-activations are trivially the same as in the single-input case. the independence
of the weights and biases implies that the covariance between different pre-activations in the same layer will be given by, e[zli;azlj;b] = qlabδij . the covariance, qlab, will be given by the recurrence relation,
qlab = σ 2 w ∫ dz1dz2φ(u1)φ(u2) + σ2b (4)
where u1 = √ ql−1aa z1 and u2 = √ ql−1bb ( cl−1ab z1 + √ 1− (cl−1ab )2z2 ) , with clab = q l ab/ √ qlaaq l bb,
are gaussian approximations to the pre-activations in the preceding layer with the correct covariance matrix. moreover clab is the correlation between the two inputs after l layers.
examining eq. 4 it is clear that c∗ = 1 is a fixed point of the recurrence relation. to determine whether or not the c∗ = 1 is an attractive fixed point the quantity,
χ1 = ∂clab ∂cl−1ab = σ2w
∫ dz [ φ′ (√ q∗z )]2
(5)
is introduced. poole  (2016) note that the c∗ = 1 fixed point is stable if χ1 < 1 and is unstable otherwise. thus, χ1 = 1 represents a critical line separating an ordered phase (in which c∗ = 1 and all inputs end up asymptotically correlated) and a chaotic phase (in which c∗ < 1 and all inputs end up asymptotically decorrelated). for the case of φ = tanh, the phase diagram in fig. 1 (a) is observed.our first contribution is to demonstrate the existence of two depth-scales that arise naturally within the framework of mean field neural networks. motivating the existence of these depth-scales, we iterate eq. 3 and 4 until convergence for many values of σ2w between 0.1 and 3.0 and with σ 2 b = 0.05 starting with q0aa = q 0 bb = 0.8 and c 0 ab = 0.6. we see, in fig. 1 (b) and (c), that the manner in which both qlaa approaches q ∗ and clab approaches c
∗ is exponential over many orders of magnitude. we therefore anticipate that asymptotically |qlaa − q∗| ∼ e−l/ξq and |clab − c∗| ∼ e−l/ξc for sufficiently large l. here, ξq and ξc define depth-scales over which information may propagate about the magnitude of a single input and the correlation between two inputs respectively.
we will presently prove that qlaa and c l ab are asymptotically exponential. in both cases we will use the same fundamental strategy wherein we expand one of the recurrence relations (either eq. 3 or eq. 4) about its fixed point to get an approximate “asymptotic” recurrence relation. we find that this asymptotic recurrence relation in turn implies exponential decay towards the fixed point over a depth-scale, ξx.
we first analyze eq. 3 and identify a depth-scale at which information about a single input may propagate. let qlaa = q ∗ + l. by construction so long as liml→∞ qlaa = q ∗ exists it follows that
l → 0 as l→∞. eq. 3 may be expanded to lowest order in l to arrive at an asymptotic recurrence relation (see appendix 7.1),
l+1 = l [ χ1 + σ 2 w ∫ dzφ′′ (√ q∗z ) φ (√ q∗z )] +o ( ( l)2 ) . (6)
notably, the term multiplying l is a constant. it follows that for large l the asymptotic recurrence relation has an exponential solution, l ∼ e−l/ξq , with ξq given by
ξ−1q = − log [ χ1 + σ 2 w ∫ dzφ′′ (√ q∗z ) φ (√ q∗z )] . (7)
this establishes ξq as a depth scale that controls how deep information from a single input may penetrate into a random neural network.
next, we consider eq. 4. using a similar argument (detailed in appendix 7.2) we can expand about clab = c ∗ + l to find an asymptotic recurrence relation,
l+1 = l [ σ2w ∫ dz1dz2φ′(u∗1)φ′(u∗2) ] +o(( l)2). (8)
here u∗1 = √ q∗z1 and u∗2 = √ q∗(c∗z1 + √ 1− (c∗)2z2). thus, once again, we expect that for large l this recurrence will have an exponential solution, l ∼ e−l/ξc , with ξc given by
ξ−1c = − log [ σ2w ∫ dz1dz2φ′(u∗1)φ′(u∗2) ] . (9)
in the ordered phase c∗ = 1 and so ξ−1c = − logχ1. since the transition between order and chaos occurs when χ1 = 1 it follows that ξc diverges at any order-to-chaos transition so long as q∗ and c∗ exist.
these results can be investigated intuitively by plotting cl+1ab vs c l ab in fig. 2 (a). in the ordered phase there is only a single fixed point, clab = 1. in the chaotic regime we see that a second fixed point develops and the clab = 1 point becomes unstable. we see that the linearization about the fixed points becomes significantly closer to the trivial map near the order-to-chaos transition.
to test these claims we measure ξq and ξc directly by iterating the recurrence relations for qlaa and clab as before with q 0 aa = q 0 bb = 0.8 and c 0 ab = 0.6. in this case we consider values of σ 2 w between .1 and 3.0 and σ2b between 0.01 and 0.3. for each hyperparameter settings we fit the resulting residuals, |qlaa − q∗| and |clab − c∗|, to exponential functions and infer the depth-scale. we then compare this measured depth-scale to that predicted by the asymptotic expansion. the result of this measurement is shown in fig. 2. in general we see that the agreement is quite good. as expected we see that ξc diverges at the critical point.
as observed in poole  (2016) we see that the depth scale for the propagation of information in a single input, ξq , is consistently finite and significantly shorter than ξc. to understand why this is the case consider eq. 6 and note that for tanh nonlinearities the second term is always negative. thus, even as χ1 approaches 1 we expect χ1 + σ2w ∫ dzφ′′(√q∗z)φ(√q∗z) to be substantially smaller than 1.the mean field formalism can be extended to include dropout. the main contribution here will be to argue that even infinitesimal amounts of dropout destroys the mean field critical point, and therefore limits the trainable network depth. in the presence of dropout the propagation equation, eq. 1, becomes,
zli = 1
ρ ∑ j w lijp l jy l j + b l i (10)
where pj ∼ bernoulli(ρ) and ρ is the dropout rate. as is typically the case we have re-scaled the sum by ρ−1 so that the mean of the pre-activation is invariant with respect to our choice of dropout rate.
following a similar procedure to the original mean field calculation consider the fate of two inputs, x0i;a and x 0 i;b, as they are propagated through such a random network. we take the dropout masks to be chosen independently for the two inputs mimicking the manner in which dropout is employed in practice. with dropout the diagonal term in the covariance matrix will be (see appendix 7.3),
q̄laa = σ2w ρ
∫ dzφ2 (√ q̄l−1aa z ) + σ2b . (11)
the variance of a single input with dropout will therefore propagate in an identical fashion to the vanilla case with a re-scaling σ2w → σ2w/ρ. intuitively, this result implies that, for the case of a single input, the presence of dropout simply increases the effective variance of the weights.
computing the off-diagonal term of the covariance matrix similarly (see appendix 7.4),
q̄lab = σ 2 w ∫ dz1dz2φ(ū1)φ(ū2) + σ2b (12)
with ū1, ū2, and c̄lab defined by analogy to the mean field equations without dropout. here, unlike in the case of a single input, the recurrence relation is identical to the recurrence relation without dropout. to see that c̄∗ = 1 is no longer a fixed point of these dynamics consider what happens to eq. 12 when we input c̄l = 1. for simplicity, we leverage the short range of ξq to replace q̄laa = q̄ l bb = q̄ ∗. we find (see appendix 7.5),
c̄l+1ab = 1− 1− ρ ρq̄∗ σ2w
∫ dzφ2 (√ q̄∗z ) . (13)
the second term is positive for any ρ < 1. this implies that if c̄lab = 1 for any l then c̄ l+1 ab < 1. thus, c∗ = 1 is not a fixed point of eq. 12 for any ρ < 1. since eq. 12 is identical in form to eq. 4 it follows that the depth scale for signal propagation with dropout will likewise be given by eq. 9 with the substitutions q∗ → q̄∗ and c∗ → c̄∗ computed using eq. 11 and eq. 12 respectively. importantly, since there is no longer a sharp critical point with dropout we do not expect a diverging depth scale.
as in networks without dropout we plot, in fig. 3 (a), the iterative map c̄l+1ab as a function of c̄ l ab. most significantly, we see that the c̄lab = 1 is no longer a fixed point of the dynamics. instead, as the dropout rate increases c̄lab gets mapped to decreasing values and the fixed point monotonically decreases.
to test these results we plot in fig. 3 (b) the asymptotic correlation, c∗, as a function of σ2w for different values of dropout from ρ = 0.8 to ρ = 1.0. as expected, we see that for all ρ < 1 there is no sharp transition between c∗ = 1 and c∗ < 1. moreover as the dropout rate increases the correlation c∗ monotonically decreases. intuitively this makes sense. identical inputs passed through two different dropout masks will become increasingly dissimilar as the dropout rate increases. in fig. 3 (c) we show the depth scale, ξc, as a function of σ2w for the same range of dropout probabilities. we find that, as predicted, the depth of signal propagation with dropout is drastically reduced and, importantly, there is no longer a divergence in ξc. increasing the dropout rate continues to decrease the correlation depth for constant σ2w.there is a duality between the forward propagation of signals and the backpropagation of gradients. to elucidate this connection consider the backpropagation equations given a loss e,
∂e
∂w lij = δliφ(z l−1 j ) δ l i = φ ′(zli) ∑ j δl+1j w l+1 ji (14)
with the identification δli = ∂e/∂z l i. within mean field theory, it is clear that the scale of fluctuations of the gradient of weights in a layer will be proportional to e[(δli)2] (see appendix 7.6). in contrast to the pre-activations in forward propagation (eq. 1), the δli will typically not be gaussian distributed even in the large layer width limit.
nonetheless, we can work out a recurrence relation for the variance of the error, q̃ laa = e[(δli)2], leveraging the gaussian ansatz on the pre-activations. in order to do this, however, we must first make an additional approximation that the weights used during forward propagation are drawn independently from the weights used in backpropagation. this approximation is similar in spirit to the vanilla mean field approximation and is reminiscent of work on feedback alignment (lillicrap , 2014). with this in mind we arrive at the recurrence (see appendix 7.7),
q̃ laa = q̃ l+1 aa nl+1 nl χ1. (15)
the presence of χ1 in the above equation should perhaps not be surprising. in poole  (2016) they show that χ1 is intimately related to the tangent space of a given layer in mean field neural
networks. we note that the backpropagation recurrence features an explicit dependence on the ratio of widths of adjacent layers of the network, nl+1/nl. here we will consider exclusively constant width networks where this factor is unity. for a discussion of the case of unequal layer widths see glorot & bengio (2010).
since χ1 depends only on the asymptotic q∗ it follows that for constant width networks we expect eq. 15 to again have an exponential solution with,
q̃ laa = q̃ l aae −(l−l)/ξ∇ ξ−1 ∇ = − logχ1. (16)
note that here ξ−1 ∇ = − logχ1 both above and below the transition. it follows that ξ∇ can be both positive and negative. we conclude that there should be three distinct regimes for the gradients. . in the ordered phase, χ1 < 1 and so ξ∇ > 0. we therefore expect gradients to vanish over a depth |ξ∇ |. 2. at criticality, χ1 → 1 and so ξ∇ →∞. here gradients should be stable regardless of depth. 3. in the chaotic phase, χ1 > 1 and so ξ∇ < 0. it follows that in this regime gradients should
explode over a depth |ξ∇ |.
intuitively these three regimes make sense. to see this, recall that perturbations to a weight in layer l can alternatively be viewed as perturbations to the pre-activations in the same layer. in the ordered phase both the perturbed signal and the unperturbed signal will be asymptotically mapped to the same point and the derivative will be small. in the chaotic phase the perturbed and unperturbed signals will become asymptotically decorrelated and the gradient will be large.
to investigate these predictions we construct deep random networks of depth l = 240 and layerwidth nl = 300. we then consider the cross-entropy loss of these networks on mnist. in fig. 4 (a) we plot the layer-by-layer 2-norm of the gradient, ||∇w labe|| 2 2, as a function of layer, l, for different values of σ2w. we see that ||∇w labe|| 2 2 behaves exponentially over many orders of magnitude. moreover, we see that the gradient vanishes in the ordered phase and explodes in the chaotic phase. we test the quantitative predictions of eq. 16 in fig. 4 (b) where we compare |ξ∇ | as predicted from theory with the measured depth-scale constructed from exponential fits to the gradient data. here we see good quantitative agreement between the theoretical predictions from mean field random networks and experimentally realized networks. together these results suggest that the approximations on the backpropagation equations were representative of deep, wide, random networks.
finally, we show that the depth scale for correlated signal propagation likewise controls the depth at which information stored in the covariance between gradients can survive. the existence of
consistent gradients across similar samples from a training set ought to be especially important for determining whether or not a given neural network architecture can be trained. to establish this depth-scale first note (see appendix 7.8) that the covariance between gradients of two different inputs, xi;1 and xi;2, will be proportional to (∇w lijea) · (∇w lijeb) ∼ e[δ l i;aδ l i;b] = q̃ l ab where ea is the loss evaluated on xi;a and δi;a = ∂ea/∂zli;a are appropriately defined errors.
it can be shown (see appendix 7.9) that q̃ lab features the recurrence relation,
q̃ lab = q̃ l+1 ab nl+1 nl+2 σ2w
∫ dz1dz2φ′(u1)φ′(u2) (17)
where u1 and u2 are defined similarly as for the forward pass. expanding asymptotically it is clear that to zeroth order in l, q̃lab will have an exponential solution with q̃ l ab = q̃ l abe −(l−l)/ξc with ξc as defined in the forward pass.taken together, the results of this paper lead us to the following hypothesis: a necessary condition for a random network to be trained is that information about the inputs should be able to propagate forward through the network, and information about the gradients should be able to propagate backwards through the network. the preceding analysis shows that networks will have this property precisely when the network depth, l, is not much larger than the depth-scale ξc. this criterion is data independent and therefore offers a “universal” constraint on the hyperparameters that depends on network architecture alone. we now explore this relationship between depth of signal propagation and network trainability empirically.
to investigate this prediction, we consider random networks of depth 10 ≤ l ≤ 300 and 1 ≤ σ2w ≤ 4 with σ2b = 0.05. we train these networks using stochastic gradient descent (sgd) and rmsprop
on mnist and cifar10. we use a learning rate of 10−3 for sgd when l . 200, 10−4 for larger l, and 10−5 for rmsprop. these learning rates were selected by grid search between 10−6 and 10−2 in exponentially spaced steps of size 10. we note that the depth dependence of learning rate was explored in detail in saxe  (2014). in fig. 5 (a)-(d) we color in red the training accuracy that neural networks achieved as a function of σ2w and l for different datasets, training time, and choice of minimizer (see appendix 7.10 for more comparisons). in all cases the neural networks over-fit the data to give a training accuracy of 100% and test accuracies of 98% on mnist and 55% on cifar10. we emphasize that the purpose of this study is to demonstrate trainability as opposed to optimizing test accuracy.
we now make the connection between the depth scale, ξc, and the maximum trainable depth more precise. given the arguments in the preceding sections we note that if l = nξc then signal through the network will be attenuated by a factor of en. to understand how much signal can be lost while still allowing for training, we overlay in fig. 5 (a) curves corresponding to nξc from n = 1 to 6. we find that networks appear to be trainable when l . 6ξc. it would be interesting to understand why this is the case.
motivated by this argument in fig. 5 (b)-(d) in white, dashed, overlay we plot twice the predicted depth scale, 6ξc. there is clearly a relationship between the depth of correlated signal propagation and whether or not these networks are trainable. networks closer to their critical point appear to train more quickly than those further away. moreover, this relationship has no obvious dependence on dataset, duration of training, or minimizer. we therefore conclude that these bounds on trainable hyperparameters are universal. this in turn implies that to train increasingly deep networks, one must generically be ever closer to criticality.
next we consider the effect of dropout. as we showed earlier, even infinitesimal amounts of dropout disrupt the order-to-chaos phase transition and cause the depth scale to become finite. however, since the effect of a single dropout mask is to simply re-scale the weight variance by σ2w → σ2w/ρ, the gradient magnitude will be stable near criticality, while the input and gradient correlations will not be. this therefore offers a unique opportunity to test whether the relevant depth-scale is |1/ logχ1| or ξc.
in fig. 6 we repeat the same experimental setup as above on mnist with dropout rates ρ = 0.99, 0.98, and 0.94. we observe, first and foremost, that even extremely modest amounts of dropout limit the maximum trainable depth to about l = 100. we additionally notice that the depth-scale, ξc, predicts the trainable region accurately for varying amounts of dropout.in this paper we have elucidated the existence of several depth-scales that control signal propagation in random neural networks. furthermore, we have shown that the degree to which a neural network can be trained depends crucially on its ability to propagate information about inputs and gradients
through its full depth. at the transition between order and chaos, information stored in the correlation between inputs can propagate infinitely far through these random networks. this in turn implies that extremely deep neural networks may be trained sufficiently close to criticality. however, our contribution goes beyond advocating for hyperparameter selection that brings random networks to be nearly critical. instead, we offer a general purpose framework that predicts, at the level of mean field theory, which hyperparameters should allow a network to be trained. this is especially relevant when analyzing schemes like dropout where there is no critical point and which therefore imply an upper bound on trainable network depth.
an alternative perspective as to why information stored in the covariance between inputs is crucial for training can be understood by appealing to the correspondence between infinitely wide bayesian neural networks and gaussian processes (neal, 2012). in particular the covariance, qlab, is intimately related to the kernel of the induced gaussian process. it follows that cases in which signal stored in the covariance between inputs may propagate through the network correspond precisely to situations in which the associated gaussian process is well defined.
our work suggests that it may be fruitful to investigate pre-training schemes that attempt to perturb the weights of a neural network to favor information flow through the network. in principle this could be accomplished through a layer-by-layer local criterion for information flow or by selecting the mean and variance in schemes like batch normalization to maximize the covariance depth-scale.
these results suggest that theoretical work on random neural networks can be used to inform practical architectural decisions. however, there is still much work to be done. for instance, the framework developed here does not apply to unbounded activations, such as rectified linear units, where it can be shown that there are phases in which eq. 3 does not have a fixed point. additionally, the analysis here applies directly only to fully connected feed-forward networks, and will need to be extended to architectures with structured weight matrices such as convolutional networks.
we close by noting that in physics it has long been known that, through renormalization, the behavior of systems near critical points can control their behavior even far from the idealized critical case. we therefore make the somewhat bold hypothesis that a broad class of neural network topologies will be controlled by the fully-connected mean field critical point.we thank ben poole, jeffrey pennington, maithra raghu, and george dahl for useful discussions. we are additionally grateful to rocketai for introducing us to temporally recurrent online learning and two-dimensional time.here we present derivations of results from throughout the paper.consider the recurrence relation for the variance of a single input,
qlaa = σ 2 w
∫ dzφ2 (√ ql−1aa z ) + σ2b (18)
and a fixed point of the dynamics, q∗. qlaa can be expanded about the fixed point to yield the asymptotic recurrence relation,
l+1 = l [ χ1 + σ 2 w ∫ dzφ′′ (√ q∗z ) φ (√ q∗z )] +o ( ( l)2 ) . (19)
derivation:
we begin by first expanding to order l,
q∗ + l+1 = σ2w
∫ dz [ φ (√ q∗ + lz )]2
+ σ2b (20)
≈ σ2w ∫ dz [ φ (√ q∗z + 1  lz√ q∗
)]2 + σ2b (21)
≈ σ2w ∫ dz [ φ (√ q∗z ) + 1  lz√ q∗ φ′ (√ q∗z )]2 + σ2b +o(( l)2) (22)
≈ σ2w ∫ dzφ2 (√ q∗z ) + σ2b + l σ  w√ q∗
∫ dzzφ (√ q∗z ) φ′ (√ q∗z ) +o(( l)2) (23)
≈ q∗ + l σ 2 w√ q∗
∫ dzzφ(√q∗z)φ′ (√ q∗z ) +o(( l)2). (24)
we therefore arrive at the approximate reccurence relation,
l+1 = l σ2w√ q∗
∫ dzzφ(√q∗z)φ′ (√ q∗z ) +o(( l)2). (25)
using the identity, ∫ dzzf(z) = ∫ dzf ′(z) we can rewrite this asymptotic recurrence relation as,
l+1 = l [ σ2w ∫ dz [ φ′ (√ q∗z )]2 + σ2w ∫ dzφ′′ (√ q∗z ) φ (√ q∗z )] +o(( l)2) (26)
= l [ χ1 + σ 2 w ∫ dzφ′′ (√ q∗z ) φ (√ q∗z )] +o(( l)2) (27)
as required.consider the recurrence relation for the co-variance of two input,
qlab = σ 2 w ∫ dz1dz2φ(u1)φ(u2) + σ2b , (28)
a correlation between the inputs, clab = q l ab/ √ qlaaq l bb, and a fixed point of the dynamics, c
∗. clab can be expanded about the fixed point to yield the asymptotic recurrence relation,
l+1 = l [ σ2w ∫ dz1dz2φ′(u1)φ′(u2) ] +o ( ( l)2 ) . (29)since the relaxation of qlaa and q l bb to q ∗ occurs much more quickly than the convergence of qlab we approximate qlaa = q l bb = q
∗ as in poole  (2016). we therefore consider the perturbation qlab/q ∗ = clab = c ∗ + l. it follows that we may make the approximation,
ul2 = √ q∗ ( clabz1 + √ 1− (clab)2z2 ) (30)
≈ √q∗ ( c∗z1 + √ 1− (c∗)2 − 2c∗ lz2 ) + √ q∗ lz1 +o( 2) (31)
(32)
we now consider the case where c∗ < 1 and c∗ = 1 separately; we will later show that these two results agree with one another. first we consider the case where c∗ < 1 in which case we may safely expand the above equation to get,
ul2 = √ q∗ ( c∗z1 + √ 1− (c∗)2z2 ) + √ q∗ l ( z1 −
c∗√ 1− (c∗)2 z2
) +o( 2). (33)
this allows us to in turn approximate the recurrence relation,
cl+1ab = σ2w q∗
∫ dz1dz2φ(u∗1)φ(ul2) + σ2b (34)
≈ σ 2 w
q∗
∫ dz1dz2φ(u∗1) [ φ(u∗2) + √ q∗ l ( z1 −
c∗√ 1− (c∗)2 z2
) φ′(u∗2) ] + σ2b +o( 2)
(35) = c∗ + σ2w√ q∗ l ∫ dz1dz2 ( z1 − c∗√ 1− (c∗)2 z2 ) φ(u∗1)φ ′(u∗2) (36)
= c∗ + σ2w√ q∗ l
[∫ dz1dz2z1φ(u∗1)φ′(u∗2)−
c∗√ 1− (c∗)2
∫ dz1dz2z2φ(u∗1)φ′(u∗2) ] (37)
= c∗ + σ2w l [∫ dz1dz2(φ′(u∗1)φ′(u∗2) + c∗φ(u∗1)φ′′(u∗2))− c∗ ∫ dz1dz2φ(u∗1)φ′′(u∗2) ] (38)
= c∗ + σ2w l ∫ dz1dz2φ′(u∗1)φ′(u∗2). (39)
where u∗1 and u ∗ 2 are appropriately defined asymptotic random variables. this leads to the asymptotic recurrence relation,
l+1 = σ2w l ∫ dz1dz2φ′(u∗1)φ′(u∗2) (40)
as required.
we now consider the case where c∗ = 1 and clab = 1 − l. in this case the expansion of ul2 will become,
ul2 = √ q∗z1 + √ 2q∗ lz2 − √ q∗ lz1 +o( 3/2) (41)
and so the lowest order correction is of ordero( √ l) as opposed too( l). as usual we now expand the recurrence relation, noting that u∗2 = u ∗ 1 is independent of z2 when c ∗ = 1 to find,
cl+1ab = σ2w q∗
∫ dz1dz2φ(u∗1)φ(ul2) + σ2b (42)
≈ σ 2 w
q∗
∫ dz1dz2φ(u∗1) [ φ(u∗2) + (√ 2q∗ lz2 − √ q∗ lz1 ) φ′(u∗2) + q ∗ lz22φ ′′(u∗2) ] + σ2b
(43)
= c∗ + σ2w l
∫ dzφ(√q∗z) [ φ′′( √ q∗z)− 1√
q∗ zφ′( √ q∗z)
] (44)
= c∗ + σ2w l
[∫ dzφ(√q∗z)φ′′(√q∗z)− 1√
q∗
∫ dzzφ(√q∗z)φ′(√q∗z) ] (45)
= c∗ − σ2w l ∫ dz [ φ′( √ q∗z) ]2 (46)
it follows that the asymptotic recurrence relation in this case will be, l+1 = − lσ2w ∫ dz [ φ′( √ q∗z) ]2 = − lχ1. (47)
where χ1 is the stability condition for the ordered phase. we note that although the approximations were somewhat different the asymptotic recurrence relation for c∗ < 1 reduces eq. 47 result for c∗ = 1. we may therefore use 4 for all c∗.result:
in the presence of dropout with rate ρ, the variance of a single input as it is passed through the network is described by the recurrence relation,
q̄laa = σ2w ρ
∫ dzφ2 (√ q̄l−1aa z ) + σ2b . (48)recall that the recurrence relation for the pre-activations is given by,
zli = 1
ρ ∑ j w lijp l jy l j + b l i (49)
where plj ∼ bernoulli(ρ). it follows that the variance will be given by,
q̄laa = e[(zli)2] (50)
= 1
ρ2 ∑ j e[(w lij)2]e[(ρlj)2]e[(ylj)2] + e[(bli)2] (51)
= σ2w ρ
∫ dzφ2 (√ q̄l−1aa z ) + σ2b . (52)
where we have used the fact that e[(plj)2] = ρ.the co-variance between two signals, zli;a and z l i;b, with separate i.i.d. dropout masks p l i;a and p l i;b is given by,
q̄lab = σ 2 w ∫ dz1dz2φ(ū1)φ(ū2) + σ2b . (53)
where, in analogy to eq. 4, ū1 = √ q̄laaz1 and ū2 = √ q̄lbb ( c̄labz1 + √ 1− (c̄lab)2z2 ) .proceeding directly we find that,
e[zli;azli;b] = 1
ρ2 ∑ j e[(w lij)2]e[plj;a]e[plj;b]e[ylj;aylj;b] + e[bli] (54)
= σ2w ∫ dz1dz2φ(ū1)φ(ū2) + σ2b (55)
where we have used the fact that e[pli;a] = e[pli;b] = ρ. we have also used the same substitution for e[ylj;aylj;b] used in the original mean field calculation with the appropriate substitution. .5 the lack of a c∗ = 1 fixed point with dropoutif clab = 1 then it follows that,
c̄l+1ab = 1− 1− ρ ρq̄∗ σ2w
∫ dzφ2 (√ q̄∗z )
(56)
subject to the approximation, qlaa ≈ qlbb ≈ q∗. this implies that cl+1ab < 1. derivation:
plugging in clab = 1 with q l aa ≈ qlbb ≈ q∗ we find that ū1 = ū2 = √ q∗z1. it follows that,
cl+1ab = ql+1ab q∗
(57)
= 1
q∗
[ σ2w ∫ dzφ2 (√ q∗z ) + σ2b ] (58)
= 1
q∗
[ σ2w(1− ρ−1 + ρ−1) ∫ dzφ2 (√ q∗z ) + σ2b ] (59)
= 1
q∗ [ σ2w ρ ∫ dzφ2 (√ q∗z ) + σ2b ] + σ2w q∗ (1− ρ−1) ∫ dzφ2 (√ q∗z )
(60)
= 1− 1− ρ ρq̄∗ σ2w
∫ dzφ2 (√ q̄∗z )
(61)
as required. here we have integrated out z2 since nether ū1 nor ū2 depend on it.in mean field theory the expected magnitude of the gradient ||∇w lije|| 2 will be proportional to e[(δli)2].we first note that since the w lij are i.i.d. it follows that,
||∇w lije|| 2 = ∑ ij
( ∂e
∂w lij
)2 (62)
≈ nlnl+1e ( ∂e ∂w lij )2 (63) where we have used the fact that the first line is related to the sample expectation over the different realizations of thew lij to approximate it by the analytic expectation in the second line. in mean field theory since the pre-activations in each layer are assumed to be i.i.d. gaussian it follows that,
e ( ∂e ∂w lij )2 = e[(δli)2]e[φ2(zl−1j )] (64) and the result follows.in mean field theory the recursion relation for the variance of the errors, q̃ l = e[(δli)2] is given by,
q̃ laa = q̃ l+1 aa nl+1 nl+2 χ1(q l aa). (65)
derivation:
computing the variance directly and using mean field approximation, q̃ laa = e[(δli;a)2] = e[(φ′(zli;a))2] ∑ j e[(δl+1j;a ) 2]e[(w l+1ji ) 2] (66)
= e[(φ′(zli;a))2] σ2w nl+1 ∑ j e[(δl+1j;a ) 2] (67)
= e[(φ′(zli;a))2] nl+1 nl+2 σ2w q̃ l+1 aa (68)
= σ2w q̃ l+1 aa nl+1 nl+2
∫ dz [ φ′ (√
qlaaz
)]2 (69)
≈ q̃ l+1aa nl+1 nl+2 χ1 (70)
as required. in the last step we have made the approximation that qlaa ≈ q∗ since the depth scale for the variance is short ranged.in mean field theory we expect the covariance between the gradients of two different inputs to scale as,
(∇w lijea) · (∇w lijeb) ∼ e[δi;aδi;b]. (71)we proceed in a manner analogous to appendix 7.6. note that in mean field theory since the weights are i.i.d. it follows that
(∇w lijea) · (∇w lijeb) = ∑ ij ∂ea ∂w lij ∂eb ∂w lij
(72)
≈ nlnl+1e [ ∂ea ∂w lij ∂eb ∂w lij ] (73)
where, as before, the final term is approximating the sample expectation. since the weights in the forward and backwards passes are chosen independently it follows that we can factor the expectation as,
e [ ∂ea ∂w lij ∂eb ∂w lij ] = e[δli;aδli;b]e[φ(zli;a)φ(zli;b)] (74)
and the result follows.the covariance between the gradients due to two inputs scales as,
q̃ lab = q̃ l+1 ab nl+1 nl+2 σ2w
∫ dz1dz2φ′(u1)φ′(u2) (75)
under backpropagation.as in the analogous derivation for the variance, we compute directly, q̃ lab = e[δli;aδli;b] = e [φ′(zi;a)φ′(zi;b)] ∑ j e[δl+1j;a δ l+1 j;b ]e[(w l+1 ji ) 2] (76)
= q̃ l+1ab nl+1 nl+2 σ2w
∫ dz1dz2φ′(u1)φ′(u2) (77)
as required.here we include some more experimental figures that investigate the effects of training time, minimizer, and dataset more closely.",1
462.pdf.json,ON DETECTING ADVERSARIAL PERTURBATIONS,"in the last years, machine learning and in particular deep learning methods have led to impressive performance on various challenging perceptual tasks, such as image classification (russakovsky , 2015; he , 2016) and speech recognition (amodei , 2016). despite these advances, perceptual systems of humans and machines still differ significantly. as szegedy  (2014) have shown, small but carefully directed perturbations of images can lead to incorrect classification with high confidence on artificial systems. yet, for humans these perturbations are often visually imperceptible and do not stir any doubt about the correct classification. in fact, so called adversarial examples are crucially characterized by requiring minimal perturbations that are quasi-imperceptible to a human observer. for computer vision tasks, multiple techniques to create such adversarial examples have been developed recently. perhaps most strikingly, adversarial examples have been shown to transfer between different network architectures, and networks trained on disjoint subsets of data (szegedy , 2014). adversarial examples have also been shown to translate to the real world (kurakin , 2016), e.g., adversarial images can remain adversarial even after being printed and recaptured with a cell phone camera. moreover, papernot  (2016a) have shown that a potential attacker can construct adversarial examples for a network of unknown architecture by training an auxiliary network on similar data and exploiting the transferability of adversarial inputs.
the vulnerability to adversarial inputs can be problematic and even prevent the application of deep learning methods in safety- and security-critical applications. the problem is particularly severe when human safety is involved, for example in the case of perceptual tasks for autonomous driving. methods to increase robustness against adversarial attacks have been proposed and range from augmenting the training data (goodfellow , 2015) over applying jpeg compression to the input (dziugaite , 2016) to distilling a hardened network from the original classifier network (papernot , 2016b). however, for some recently published attacks (carlini & wagner, 2016), no effective counter-measures are known yet.
in this paper, we propose to train a binary detector network, which obtains inputs from intermediate feature representations of a classifier, to discriminate between samples from the original data set and adversarial examples. being able to detect adversarial perturbations might help in safety- and security-critical semi-autonomous systems as it would allow disabling autonomous operation and
requesting human intervention (along with a warning that someone might be manipulating the system). however, it might intuitively seem very difficult to train such a detector since adversarial inputs are generated by tiny, sometimes visually imperceptible, perturbations of genuine examples. despite this intuition, our results on cifar10 and a 10-class subset of imagenet show that a detector network that achieves high accuracy in detection of adversarial inputs can be trained successfully. moreover, while we train a detector network to detect perturbations of a specific adversary, our experiments show that detectors generalize to similar and weaker adversaries. an obvious attack against our approach would be to develop adversaries that take into account both networks, the classification and the adversarial detection network. we present one such adversary and show that we can harden the detector against such an adversary using a novel training procedure.since their discovery by szegedy  (2014), several methods to generate adversarial examples have been proposed. most of these methods generate adversarial examples by optimizing an image w.r.t. the linearized classification cost function of the classification network by maximizing the probability for all but the true class or minimizing the probability of the true class (e.g., (goodfellow , 2015), (kurakin , 2016)). the method introduced by moosavi-dezfooli  (2016b) estimates a linearization of decision boundaries between classes in image space and iteratively shifts an image towards the closest of these linearized boundaries. for more details about these methods, please refer to section 3.1.
several approaches exist to increase a model’s robustness against adversarial attacks. goodfellow  (2015) propose to augment the training set with adversarial examples. at training time, they minimize the loss for real and adversarial examples, while adversarial examples are chosen to fool the current version of the model. in contrast, zheng  (2016) propose to append a stability term to the objective function, which forces the model to have similar outputs for samples of the training set and their perturbed versions. this differs from data augmentation since it encourages smoothness of the model output between original and distorted samples instead of minimizing the original objective on the adversarial examples directly. another defense-measure against certain adversarial attack methods is defensive distillation (papernot , 2016b), a special form of network distillation, to train a network that becomes almost completely resistant against attacks such as the l-bfgs attack (szegedy , 2014) and the fast gradient sign attack (goodfellow , 2015). however, carlini & wagner (2016) recently introduced a novel method for constructing adversarial examples that manages to (very successfully) break many defense methods, including defensive distillation. in fact, the authors find that previous attacks were very fragile and could easily fail to find adversarial examples even when they existed. an experiment on the cross-model adversarial portability (rozsa , 2016) has shown that models with higher accuracies tend to be more robust against adversarial examples, while examples that fool them are more portable to less accurate models.
even though the existence of adversarial examples has been demonstrated several times on many different classification tasks, the question of why adversarial examples exist in the first place and whether they are sufficiently regular to be detectable, which is studied in this paper, has remained open. szegedy  (2014) speculated that the data-manifold is filled with “pockets” of adversarial inputs that occur with very low probability and thus are almost never observed in the test set. yet, these pockets are dense and so an adversarial example is found virtually near every test case. the authors further speculated that the high non-linearity of deep networks might be the cause for the existence of these low-probability pockets. later, goodfellow  (2015) introduced the linear explanation: given an input and some adversarial noise η (subject to: ||η||∞ < ), the dot product between a weight vector w and an adversarial input xadv = x+ η is given by wtxadv = wtx+ wtη. the adversarial noise η causes a neuron’s activation to grow by wtη. the max-norm constraint on η does not allow for large values in one dimension, but if x and thus η are high-dimensional, many small changes in each dimension of η can accumulate to a large change in a neuron’s activation. the conclusion was that “linear behavior in high-dimensional spaces is sufficient to cause adversarial examples”.
tanay & griffin (2016) challenged the linear-explanation hypothesis by constructing classes of images that do not suffer from adversarial examples under a linear classifier. they also point out that if the change in activation wtη grows linearly with the dimensionality of the problem, so does the activation
wtx. instead of the linear explanation, tanay  provide a different explanation for the existence of adversarial examples, including a strict condition for the non-existence of adversarial inputs, a novel measure for the strength of adversarial examples and a taxonomy of different classes of adversarial inputs. their main argument is that if a learned class boundary lies close to the data manifold, but the boundary is (slightly) tilted with respect to the manifold1, then adversarial examples can be found by perturbing points from the data manifold towards the classification boundary until the perturbed input crosses the boundary. if the boundary is only slightly tilted, the distance required by the perturbation to cross the decision-boundary is very small, leading to strong adversarial examples that are visually almost imperceptibly close to the data. tanay et. al further argue that such situations are particularly likely to occur along directions of low variance in the data and thus speculate that adversarial examples can be considered an effect of an over-fitting phenomenon that could be alleviated by proper regularization, though it is completely unclear how to regularize neural networks accordingly.
recently, moosavi-dezfooli  (2016a) demonstrated that there even exist universal, imageagnostic perturbations which, when added to all data points, fool deep nets on a large fraction of imagenet validation images. moreover, they showed that these universal perturbations are to a certain extent also transferable between different network architectures. while this observation raises interesting questions about geometric properties and correlations of different parts of the decision boundary of deep nets, potential regularities in adversarial perturbations may also help detecting them. however, the existence of universal perturbations does not necessarily imply that the adversarial examples generated by data-dependent adversaries will be regular. actually, moosavi-dezfooli  (2016a) show that universal perturbations are not unique and that there even exist many different universal perturbations which have little in common. this paper studies if data-dependent adversarial perturbations can nevertheless be detected reliably and answers this question affirmatively.in this section, we introduce the adversarial attacks used in the experiments, propose an approach for detecting adversarial perturbations, introduce a novel adversary that aims at fooling both the classification network and the detector, and propose a training method for the detector that aims at counteracting this novel adversary.let x be an input image x ∈ r3×width×height, ytrue(x) be a one-hot encoding of the true class of image x, and jcls(x, y(x)) be the cost function of the classifier (typically cross-entropy). we briefly introduce different adversarial attacks used in the remainder of the paper.
fast method: one simple approach to compute adversarial examples was described by goodfellow  (2015). the applied perturbation is the direction in image space which yields the highest increase of the linearized cost function under `∞-norm. this can be achieved by performing one step in the direction of the gradient’s sign with step-width ε:
xadv = x+ ε sgn(∇xjcls(x, ytrue(x)))
here, ε is a hyper-parameter governing the distance between adversarial and original image. as suggested in kurakin  (2016) we also refer to this as the fast method due to its non-iterative and hence fast computation.
basic iterative method (`∞ and `2): as an extension, kurakin  (2016) introduced an iterative version of the fast method, by applying it several times with a smaller step size α and clipping all pixels after each iteration to ensure results stay in the ε-neighborhood of the original image:
xadv0 = x, x adv n+1 = clip ε x { xadvn + α sgn(∇xjcls(xadvn , ytrue(x))) } 1it is easier to imagine a linear decision-boundary - for neural networks this argument must be translated into
a non-linear equivalent of boundary tilting.
following kurakin  (2016), we refer to this method as the basic iterative method and use α = 1, i.e., we change each pixel maximally by 1. the number of iterations is set to 10. in addition to this method, which is based on the `∞-norm, we propose an analogous method based on the `2-norm: in each step this method moves in the direction of the (normalized) gradient and projects the adversarial examples back on the ε-ball around x (points with `2 distance ε to x) if the `2 distance exceeds ε:
xadv0 = x, x adv n+1 = project ε x { xadvn + α
∇xjcls(xadvn , ytrue(x)) ||∇xjcls(xadvn , ytrue(x))||2 } deepfool method: moosavi-dezfooli  (2016b) introduced the deepfool adversary which iteratively perturbs an image xadv0 . therefore, in each step the classifier is linearized around x adv n and the closest class boundary is determined. the minimal step according to the `p distance from xadvn to traverse this class boundary is determined and the resulting point is used as xadvn+1. the algorithm stops once xadvn+1 changes the class of the actual (not linearized) classifier. arbitrary `p-norms can be used within deepfool, and here we focus on the `2- and `∞-norm. the technical details can be found in (moosavi-dezfooli , 2016b). we would like to note that we use the variant of deepfool presented in the first version of the paper (https://arxiv.org/abs/1511.04599v1) since we found it to be more stable compared to the variant reported in the final version.we augment classification networks by (relatively small) subnetworks, which branch off the main network at some layer and produce an output padv ∈ [0, 1] which is interpreted as the probability of the input being adversarial. we call this subnetwork “adversary detection network” (or “detector” for short) and train it to classify network inputs into being regular examples or examples generated by a specific adversary. for this, we first train the classification networks on the regular (non-adversarial) dataset as usual and subsequently generate adversarial examples for each data point of the train set using one of the methods discussed in section 3.1. we thus obtain a balanced, binary classification dataset of twice the size of the original dataset consisting of the original data (label zero) and the corresponding adversarial examples (label one). thereupon, we freeze the weights of the classification network and train the detector such that it minimizes the cross-entropy of padv and the labels. the details of the adversary detection subnetwork and how it is attached to the classification network are specific for datasets and classification networks. thus, evaluation and discussion of various design choices of the detector network are provided in the respective section of the experimental results.in the worst case, an adversary might not only have access to the classification network and its gradient but also to the adversary detector and its gradient2. in this case, the adversary might potentially generate inputs to the network that fool both the classifier (i.e., get classified wrongly) and fool the detector (i.e., look innocuous). in principle, this can be achieved by replacing the cost jcls(x, ytrue(x)) by (1 − σ)jcls(x, ytrue(x)) + σjdet(x, 1), where σ ∈ [0, 1] is a hyperparameter and jdet(x, 1) is the cost (cross-entropy) of the detector for the generated x and the label one, i.e., being adversarial. an adversary maximizing this cost would thus aim at letting the classifier mis-label the input x and making the detectors output padv as small as possible. the parameter σ allows trading off these two objectives. for generating x, we propose the following extension of the basic iterative (`∞) method:
xadv0 = x; x adv n+1 = clip ε x { xadvn + α [ (1− σ) sgn(∇xjcls(xadvn , ytrue(x))) + σ sgn(∇xjdet(xadvn , 1)) ]} note that we found a smaller α to be essential for this method to work; more specifically, we use α = 0.25. since such an adversary can adapt to the detector, we call it a dynamic adversary. to we would like to emphasize that is a stronger assumption than granting the adversary access to only the original classifier’s predictions and gradients since the classifier’s predictions need often be presented to a user (and thus also to an adversary). the same is typically not true for the predictions of the adversary detector as they will only be used internally.
counteract dynamic adversaries, we propose dynamic adversary training, a method for hardening detectors against dynamic adversaries. based on the approach proposed by goodfellow  (2015), instead of precomputing a dataset of adversarial examples, we compute the adversarial examples on-the-fly for each mini-batch and let the adversary modify each data point with probability 0.5. note that a dynamic adversary will modify a data point differently every time it encounters the data point since it depends on the detector’s gradient and the detector changes over time. we extend this approach to dynamic adversaries by employing a dynamic adversary, whose parameter σ is selected uniform randomly from [0, 1], for generating the adversarial data points during training. by training the detector in this way, we implicitly train it to resist dynamic adversaries for various values of σ. in principle, this approach bears the risk of oscillation and unlearning for σ > 0 since both, the detector and adversary, adapt to each other (i.e., there is no fixed data distribution). in practice, however, we found this approach to converge stably without requiring careful tuning of hyperparameters.in this section, we present results on the detectability of adversarial perturbations on the cifar10 dataset (krizhevsky, 2009), both for static and dynamic adversaries. moreover, we investigate whether adversarial perturbations are also detectable in higher-resolution images based on a subset of the imagenet dataset (russakovsky , 2015).we use a 32-layer residual network (he , 2016, resnet) as classifier. the structure of the network is shown in figure 1. the network has been trained for 100 epochs with stochastic gradient descent and momentum on 45000 data points from the train set. the momentum term was set to 0.9 and the initial learning rate was set to 0.1, reduced to 0.01 after 41 epochs, and further reduced to 0.001 after 61 epochs. after each epoch, the network’s performance on the validation data (the remaining 5000 data points from the train set) was determined. the network with maximal performance on the validation data was used in the subsequent experiments (with all tunable weights being fixed). this network’s accuracy on non-adversarial test data is 91.3%. we attach an adversary detection subnetwork (called “detector” below) to the resnet. the detector is a convolutional neural network using batch normalization (ioffe & szegedy, 2015) and rectified linear units. in the experiments, we investigate different positions where the detector can be attached (see also figure 1).in this subsection, we investigate a static adversary, i.e., an adversary that only has access to the classification network but not to the detector. the detector was trained for 20 epochs on 45000 data points from the train set and their corresponding adversarial examples using the adam optimizer (kingma & ba, 2015) with a learning rate of 0.0001 and β1 = 0.99, β2 = 0.999. the remaining 5000 data points from the cifar10 train set are used as validation data and used for model selection. the detector was attached to position ad(2) (see figure 1) except for the deepfool-based adversaries where the detector was attached to ad(4); see below for a discussion. for the “fast” and “iterative” adversaries, the parameter ε from section 3.1 was chosen from [1, 2, 3, 4] for `∞-based methods and from [20, 40, 60, 80] for `2-based methods; larger values of ε generally result in reduced accuracy of the classifier but increased detectability. for the “iterative” method with `2-norm, we used α = 20, i.e., in each iteration we make a step of `2 distance 20. please note that these values of ε are based on assuming a range of [0, 255] per color channel of the input.
figure 2 (left) compares the detectability3 of different adversaries. in general, points in the lower left of the plot correspond to stronger adversaries because their adversarial examples are harder to detect and at the same time fool the classifier on most of the images. detecting adversarial examples works surprisingly well given that no differences are perceivable to humans for all shown settings: the detectability is above 80% for all adversaries which decrease classification accuracy below 30% and above 90% for adversaries which decrease classification accuracy below 10%. comparing the different adversaries, the “fast” adversary can generally be considered as a weak adversary, the deepfool based methods as relatively strong adversaries, and the “iterative” method being somewhere in-between. moreover, the methods based on the `2-norm are generally slightly stronger than their `∞-norm counter-parts.
figure 2 (right) compares the detectability of different adversaries for detectors attached at different points to the classification network. ε was chosen minimal under the constraint that the classification accuracy is below 30%. for the “fast” and “iterative” adversaries, the attachment position ad(2) works best, i.e., attaching to a middle layer where more abstract features are already extracted but still the full spatial resolution is maintained. for the deepfool methods, the general pattern is similar except for ad(4), which works best for these adversaries.
figure 3 illustrates the generalizability of trained detectors for the same adversary with different choices of ε: while a detector trained for large ε does not generalize well to small ε, the other direction works reasonably well. figure 4 shows the generalizability of detectors trained for one adversary when tested on data from other adversaries (ε was chosen again minimal under the constraint that the detectability refers to the accuracy of the detector. the detectability on the test data is calculated as follows: for every test sample, a corresponding adversarial example is generated. the original and the corresponding adversarial examples form a joint test set (twice the size of the original test set). this test set is shuffled and the detector is evaluated on this dataset. original and corresponding adversarial example are thus processed independently.
classification accuracy is below 30%): we can see that detectors generalize well between `∞- and `2-norm based variants of the same approach. moreover, detectors trained on the stronger “iterative” adversary generalize well to the weaker “fast” adversary but not vice versa. detectors trained for the deepfool-based methods do not generalize well to other adversaries; however, detectors trained for the “iterative” adversaries generalize relatively well to the deepfool adversaries.in this section, we evaluate the robustness of detector networks to dynamic adversaries (see section 3.3). for this, we evaluate the detectability of dynamic adversaries for σ ∈ {0.0, 0.1, . . . , 1.0}. we use the same optimizer and detector network as in section 4.1.1. when evaluating the detectability of dynamic adversaries with σ close to 1, we need to take into account that the adversary might choose to solely focus on fooling the detector, which is trivially achieved by leaving the input unmodified. thus, we ignore adversarial examples that do not cause a misclassification in the evaluation of the detector and evaluate the detector’s accuracy on regular data versus the successful adversarial examples. figure 5 shows the results of a dynamic adversary with ε = 1 against a static detector, which was trained to only detect static adversaries, and a dynamic detector, which was explicitly trained to resist dynamic adversaries. as can be seen, the static detector is not robust to dynamic adversaries since for certain values of σ, namely σ = 0.3 and σ = 0.4, the detectability is close to
chance level while the predictive performance of the classifier is severely reduced to less than 30% accuracy. a dynamic detector is considerably more robust and achieves a detectability of more than 70% for any choice of σ.in this section, we report results for static adversaries on a subset of imagenet consisting of all data from ten randomly selected classes4. the motivation for this section is to investigate whether adversarial perturbations can be detected in higher-resolution images and for other network architectures than residual networks. we limit the experiment to ten classes in order to keep the computational resources required for computing the adversarial examples small and avoid having too similar classes which would oversimplify the task for the adversary. we use a pretrained vgg16 (simonyan & zisserman, 2015) as classification network and add a layer before the softmax which selects only the 10 relevant class entries from the logits vector. based on preliminary experiments, we attach the detector network after the fourth max-pooling layer. the detector network consists of a sequence of five 3x3 convolutions with 196 feature maps each using batch-normalization and rectified linear units, followed by a 1x1 convolution which maps onto the 10 classes, global-average pooling, and a softmax layer. an additional 2x2 max-pooling layer is added after the first convolution. note that we did not tune the specific details of the detector network; other topologies might perform better than the results reported below. when applicable, we vary ε ∈ [2, 4, 6] for `∞-based methods and ε ∈ [400, 800, 1200] for `2. moreover, we limit changes of the deepfool adversaries to an `∞ distance of 6 since the adversary would otherwise sometimes generate distortions which are clearly perceptible. we train the detector for 500 epochs using the adam optimizer with a learning rate of 0.0001 and β1 = 0.99, β2 = 0.999.
figure 6 compares the detectability of different static adversaries. all adversaries fail to decrease predictive accuracy of the classifier below the chance level of 0.1 (note that predictive accuracy refers to the accuracy on the 10-class problem not on the full 1000-class problem) for the given values of ε. nevertheless, detectability is 85% percent or more with the exception of the “iterative” `2-based adversary with ε = 400. for this adversary, the detector only reaches chance level. other choices of the detector’s attachment depth, internal structure, or hyperparameters of the optimizer might achieve the synsets of the selected classes are: palace; joystick; bee; dugong, dugong dugon; cardigan; modem; confectionery, confectionary, candy store; valley, vale; persian cat; stone wall. classes were selected by randomly drawing 10 ilsvrc2012 synset-ids (i.e. integers from [1, 1000]), using the randint function of the python-package numpy after initializing numpy’s random number generator seed with 0. this results in a train set of 10000 images, a validation set of 2848 images, and a test set (from imagenet’s validation data) of 500 images.
better results; however, this failure case emphasizes that the detector has to detect very subtle patterns and the optimizer might get stuck in bad local optima or plateaus.
figure 7 illustrates the transferability of the detector between different values of ε. the results are roughly analogous to the results on cifar10 in section 4.1.1: detectors trained for an adversary for a small value of ε work well for the same adversary with larger ε but not vice versa. note that a detector trained for the “iterative” `2-based adversary with ε = 1200 can detect the changes of the same adversary with ε = 400 with 78% accuracy; this emphasizes that this adversary is not principally undetectable but that rather the optimization of a detector for this setting is difficult. figure 8 shows the transferability between adversaries: transferring the detector works well between similar adversaries such as between the two deepfool adversaries and between the fast and iterative adversary based on the `∞ distance. moreover, detectors trained for deepfool adversaries work well on all other adversaries. in summary, transferability is not symmetric and typically works best between similar adversaries and from stronger to weaker adversary.why can tiny adversarial perturbations be detected that well? adopting the boundary tilting perspective of tanay & griffin (2016), strong adversarial examples occur in situations in which classification boundaries are tilted against the data manifold such that they lie close and nearly parallel to the data manifold. a detector could (potentially) identify adversarial examples by detecting inputs which are slightly off the data manifold’s center in the direction of a nearby class boundary. thus, the detector can focus on detecting inputs which move away from the data manifold in a certain direction, namely one of the directions to a nearby class boundary (the detector does not have explicit
knowledge of class boundaries but it might learn about their direction implicitly from the adversarial training data). however, training a detector which captures these directions in a model with small capacity and generalizes to unseen data requires certain regularities in adversarial perturbations. the results of moosavi-dezfooli  (2016a) suggest that there may exist regularities in the adversarial perturbations since universal perturbations exist. however, these perturbations are not unique and data-dependent adversaries might potentially choose among many different possible perturbations in a non-regular way, which would be hard to detect. our positive results on detectability suggest that this is not the case for the tested adversaries. thus, our results are somewhat complementary to moosavi-dezfooli  (2016a): while they show that universal, image-agnostic perturbations exist, we show that image-dependent perturbations are sufficiently regular to be detectable. whether a detector generalizes over different adversaries depends mainly on whether the adversaries choose among many different possible perturbations in a consistent way.
why is the joint classifier/detector system harder to fool? for a static detector, there might be areas which are adversarial to both classifier and detector; however, this will be a (small) subset of the areas which are adversarial to the classifier alone. nevertheless, results in section 4.1.2 show that such a static detector can be fooled along with the classifier. however, a dynamic detector is considerably harder to fool: on the one hand, it might further reduce the number of areas which are both adversarial to classifier and detector. on the other hand, the areas which are adversarial to the detector might become increasingly non-regular and difficult to find by gradient descent-based adversaries.in this paper, we have shown empirically that adversarial examples can be detected surprisingly well using a detector subnetwork attached to the main classification network. while this does not directly allow classifying adversarial examples correctly, it allows mitigating adversarial attacks against machine learning systems by resorting to fallback solutions, e.g., a face recognition might request human intervention when verifying a person’s identity and detecting a potential adversarial attack. moreover, being able to detect adversarial perturbations may in the future enable a better understanding of adversarial examples by applying network introspection to the detector network. furthermore, the gradient propagated back through the detector may be used as a source of regularization of the classifier against adversarial examples. we leave this to future work. additional future work will be developing stronger adversaries that are harder to detect by adding effective randomization which would make selection of adversarial perturbations less regular. finally, developing methods for training detectors explicitly such that they can detect many different kinds of attacks reliably at the same time would be essential for safety- and security-related applications.we would like to thank michael herman and michael pfeiffer for helpful discussions and their feedback on drafts of this article. moreover, we would like to thank the developers of theano (the theano development team, 2016), keras (https://keras.io), and seaborn (http:// seaborn.pydata.org/).",1
478.pdf.json,LEARNING INVARIANT REPRESENTATIONS OF PLANAR CURVES,"the discussion on invariance is a strong component of the solutions to many classical problems in numerical differential geometry. a typical example is that of planar shape analysis where one desires to have a local function of the contour which is invariant to rotations, translations and reflections like the euclidean curvature. this representation can be used to obtain correspondence between the shapes and also to compare and classify them. however, the numerical construction of such functions from discrete sampled data is non-trivial and requires robust numerical techniques for their stable and efficient computation.
convolutional neural networks have been very successful in recent years in solving problems in image processing, recognition and classification. efficient architectures have been studied and developed to extract semantic features from images invariant to a certain class or category of transformations. coupled with efficient optimization routines and more importantly, a large amount of data, a convolutional neural network can be trained to construct invariant representations and semantically significant features of images as well as other types of data such as speech and language. it is widely acknowledged that such networks have superior representational power compared to more principled methods with more handcrafted features such as wavelets, fourier methods, kernels etc. which are not optimal for more semantic data processing tasks.
in this paper we connect two seemingly different fields: convolutional neural network based metric learning methods and numerical differential geometry. the results we present are the outcome of investigating the question: ”can metric learning methods be used to construct invariant geometric quantities?” by training with a siamese configuration involving only positive and negative examples of euclidean transformations, we show that the network is able to train for an invariant geometric function of the curve which can be contrasted with a theoretical quantity: euclidean curvature. an example of each can be seen figure 1. we compare the learned invariant functions with axiomatic counterparts and provide a discussion on their relationship. analogous to principled constructions like curvature-scale space methods and integral invariants, we develop a multi-scale representation using a data-dependent learning based approach. we show that network models are able to construct geometric invariants that are numerically more stable and robust than these more principled approaches. we contrast the computational work-flow of a typical numerical geometry pipeline with that of the convolutional neural network model and develop a relationship among them highlighting important geometric ideas.
in section 2 we begin by giving a brief summary of the theory and history of invariant curve representations. in section 3 we explain our main contribution of casting the problem into the form which
enables training a convolutional neural network for generating invariant signatures to the euclidean and similarity group transformations. section 4 provides a discussion on developing a multi-scale representation followed by the experiments and discussion in section 5.an invariant representation of a curve is the set of signature functions assigned to every point of the curve which does not change despite the action of a certain type of transformation. a powerful theorem from e. cartan (cartan (1983)) and sophus lie (ackerman (1976)) characterizes the space of these invariant signatures. it begins with the concept of arc-length which is a generalized notion of the length along a curve. given a type of transformation, one can construct an intrinsic arclength that is independent of the parameterization of the curve, and compute the curvature with respect to this arc-length. the fundamental invariants of the curve, known as differential invariants (bruckstein & netravali (1995), calabi  (1998)) are the set of functions comprising of the curvature and its successive derivatives with respect to the invariant arc-length. these differential invariants are unique in a sense that two curves are related by the group transformation if and only if their differential invariant signatures are identical. moreover, every invariant of the curve is a
function of these fundamental differential invariants. consider c(p) = [ x(p) y(p) ] : a planar curve with
coordinates x and y parameterized by some parameter p. the euclidean arc-length, is given by
s(p) = ∫ p 0 |cp| dp = ∫ p 0 √ x2p + y 2 p dp, (1)
where xp = dxdp , and yp = dy dp and the principal invariant signature, that is the euclidean curvature is given by
κ(p) = det(cp, cpp) |cp|3 = xpypp − ypxpp
(x2p + y 2 p)  2
. (2)
thus, we have the euclidean differential invariant signatures given by the set {κ, κs, κss ...} for every point on the curve. cartan’s theorem provides an axiomatic construction of invariant signatures and the uniqueness property of the theorem guarantees their theoretical validity. their importance is highlighted from the fact that any invariant is a function of the fundamental differential invariants.
the difficulty with differential invariants is their stable numerical computation. equations 1 and 2, involve non-linear functions of derivatives of the curve and this poses serious numerical issues for their practical implementation where noise and poor sampling techniques are involved. apart from methods like pajdla & van gool (1995) and weiss (1993), numerical considerations motivated the development of multi-scale representations. these methods used alternative constructions of invariant signatures which were robust to noise. more importantly, they allowed a hierarchical representation, in which the strongest and the most global components of variation in the contour of the curve are encoded in signatures of higher scale, and as we go lower, the more localized and rapid changes get injected into the representation. two principal methods in this category are scale-space methods and integral invariants. in scale-space methods (mokhtarian & mackworth (1992); sapiro & tannenbaum (1995); bruckstein  (1996)), the curve is subjected to an invariant evolution process where it can be evolved to different levels of abstraction. see figure 5. the curvature function
at each evolved time t is then recorded as an invariant. for example, {κ(s, t), κs(s, t), κss(s, t)...} would be the euclidean-invariant representations at scale t.
integral invariants (manay  (2004); fidler  (2008); pottmann  (2009); hong & soatto (2015)) are invariant signatures which compute integral measures along the curve. for example, for each point on the contour, the integral area invariant computes the area of the region obtained from the intersection of a ball of radius r placed at that point and the interior of the contour. the integral nature of the computation gives the signature robustness to noise and by adjusting different radii of the ball r one can associate a scale-space of responses for this invariant. fidler  (2008) and pottmann  (2009) provide a detailed treatise on different types of integral invariants and their properties.
it is easy to observe that differential and integral invariants can be thought of as being obtained from non-linear operations of convolution filters. the construction of differential invariants employ filters for which the action is equivalent to numerical differentiation (high pass filtering) whereas integral invariants use filters which act like numerical integrators (low pass filtering) for stabilizing the invariant. this provides a motivation to adopt a learning based approach and we demonstrate that the process of estimating these filters and functions can be outsourced to a learning framework. we use the siamese configuration for implementing this idea. such configurations have been used in signature verification (bromley  (1993)), face-verification and recognition(sun  (2014); taigman  (2014); hu  (2014)), metric learning (chopra  (2005)), image descriptors (carlevaris-bianco & eustice (2014)), dimensionality reduction (hadsell  (2006)) and also for generating 3d shape descriptors for correspondence and retrieval (masci  (2015); xie  (2015)). in these papers, the goal was to learn the descriptor and hence the similarity metric from data using notions of only positive and negative examples. we use the same framework for estimation of geometric invariants. however, in contrast to these methods, we contribute an analysis of the output descriptor and provide a geometric context to the learning process. the contrastive loss function driving the training ensures that the network chooses filters which push and pull different features of the curve into the invariant by balancing a mix of robustness and fidelity.a planar curve can be represented either explicitly by sampling points on the curve or using an implicit representation such as level sets (kimmel (2012)). we work with an explicit representation of simple curves (open or closed) with random variable sampling of the points along the curve. thus, every curve is a n × 2 array denoting the x and y coordinates of the n points. we build a convolutional neural network which inputs a curve and outputs a representation or signature for every point on the curve. we can interpret this architecture as an algorithmic scheme of representing a function over the curve. however feeding in a single curve is insufficient and instead we run this convolutional architecture in a siamese configuration (figure 2) that accepts a curve and a
transformed version (positive) of the curve or an unrelated curve (negative). by using two identical copies of the same network sharing weights to process these two curves we are able to extract geometric invariance by using a loss function to require that the two arms of the siamese configuration must produce values that are minimally different for curves which are related by euclidean transformations representing positive examples and maximally different for carefully constructed negative examples. to fully enable training of our network we build a large dataset comprising of positive and negative examples of the relevant transformations from a database of curves. we choose to minimize the contrastive loss between the two outputs of the siamese network as this directs the network architecture to model a function over the curve which is invariant to the transformation.we employ the contrastive loss function (chopra  (2005); lecun  (2006)) for training our network. the siamese configuration comprises of two identical networks of figure 3 computing signatures for two separate inputs of data. associated to each input pair is a label which indicates whether or not that pair is a positive (λ = 1) or a negative (λ = 0) example (figure 2). let c1i and c2i be the curves imputed to first and second arm of the configuration for the ith example of the data with label λi. let sθ(c) denote the output of the network for a given set of weights θ for input curve c. the contrastive loss function is given by:
c(θ) = 1 n { i=n∑ i=1 λi || sθ(c1i)−sθ(c2i) || + (1−λi) max( 0, µ − || sθ(c1i)−sθ(c2i) || ) } , (3) where µ is a cross validated hyper-parameter known as margin which defines the metric threshold beyond which negative examples are penalized.the network inputs a n × 2 array representing the coordinates of n points along the curve. the sequential nature of the curves and the mostly 1d-convolution operations can also be looked at from the point of view of temporal signals using recurrent neural network architectures. here however we choose instead to use a multistage cnn pipeline. the network, given by one arm of the siamese configuration, comprises of three stages that use layer units which are typically considered the basic building blocks of modern cnn architectures. each stage contains two sequential batches of convolutions appended with rectified linear units (relu) and ending with a max unit. the convolutional unit comprises of convolutions with 15 filters of width 5 as depicted in figure 3. the max unit computes the maximum of 15 responses per point to yield an intermediate output after each stage. the final stage is followed by a linear layer which linearly combines the responses to yield the final output. since, every iteration of convolution results in a reduction of the sequence length, sufficient padding is provided on both ends of the curve. this ensures that the value of the signature at a point is the result of the response of the computation resulting from the filter centered around that point.in order to train for invariance, we need to build a dataset with two major attributes: first, it needs to contain a large number of examples of the transformation and second, the curves involved in the training need to have sufficient richness in terms of different patterns of sharp edges, corners, smoothness, noise and sampling factors to ensure sufficient generalizability of the model. to sufficiently span the space of euclidean transformations, we generate random two dimensional rotations by uniformly sampling angles from [−π, π]. the curves are normalized by removing the mean and dividing by the standard deviation thereby achieving invariance to translations and uniform scaling. the contours are extracted from the shapes of the mpeg7 database (latecki  (2000)) as shown in first part of figure 4. it comprises a total of 1400 shapes containing 70 different categories of objects. 700 of the total were used for training and 350 each for testing and validation. the positive examples are constructed by taking a curve and randomly transforming it by a rotation, translation and reflection and pairing them together. the negative examples are obtained by pairing curves which are deemed dissimilar as explained in section 4. the contours are extracted and each contour is sub-sampled to 500 points. we build the training dataset of 10, 000 examples with approximately 50% each for the positive and negative examples. the network and training is performed using the torch library collobert  (2002). we trained using adagrad duchi  (2011) at a learning rate of 5 × 10−4 and a batch size of 10. we set the contrastive loss hyperparameter margin µ = 1 and figure 4 shows the error plot for training and the convergence of the loss to a minimum. the rest of this work describes how we can observe and extend the efficacy of the trained network on new data.invariant representations at varying levels of abstraction have a theoretical interest as well as practical importance to them. enumeration at different scales enables a hierarchical method of analysis which is useful when there is noise and hence stability is desired in the invariant. as mentioned in section 2, the invariants constructed from scale-space methods and integral invariants, naturally allow for such a decomposition by construction.
a valuable insight for multi-scale representations is provided in the theorems of gage, hamilton and grayson (gage & hamilton (1986); grayson (1987)). it says that if we evolve any smooth nonintersecting planar curve with mean curvature flow, which is invariant to euclidean transformations, it will ultimately converge into a circle before vanishing into a point. the curvature corresponding to this evolution follows a profile as shown in figure 5, going from a possibly noisy descriptive feature to a constant function. in our framework, we observe an analogous behavior in a data-dependent setting. the positive part of the loss function (λ = 1) forces the network to push the outputs of the positive examples closer, whereas the negative part (λ = 0) forces the weights of network to push the outputs of the negative examples apart, beyond the distance barrier of µ. if the training data does not contain any negative example, it is easy to see that the weights of the network will converge to a point which will yield a constant output that trivially minimizes the loss function in equation 3.
curvature: κ
figure 5: curve evolution and the corresponding curvature profile.  2 3 4 5  2 3 4 5
figure 6: experiments with multi-scale representations. each signature is the output of a network trained on a dataset with training examples formed as per the rows of table 1. index1 indicates low and 5 indicates a higher level of abstraction.
this is analogous to that point in curvature flow which yields a circle and therefore has a constant curvature.
designing the negative examples of the training data provides the means to obtain a multi-scale representation. since we are training for a local descriptor of a curve, that is, a function whose value at a point depends only on its local neighborhood, a negative example must pair curves such that corresponding points on each curve must have different local neighborhoods. one such possibility is to construct negative examples which pair curves with their smoothed or evolved versions as in table 1. minimizing the loss function in equation 3 would lead to an action which pushes apart the signatures of the curve and its evolved or smoothed counterpart, thereby injecting the signature with fidelity and descriptiveness. we construct separate data-sets where the negative examples are drawn as shown in the rows of table1 and train a network model for each of them using the loss function 3. in our experiments we perform smoothing by using a local polynomial regression with weighted linear least squares for obtaining the evolved contour. figure 6 shows the outputs of these different networks which demonstrate a scale-space like behavior.ability to handle low signal to noise ratios and efficiency of computation are typical qualities desired in a geometric invariant. to test the numerical stability and robustness of the invariant signatures
we designed two experiments. in the first experiment, we add increasing levels of zero-mean gaussian noise to the curve and compare the three types of signatures: differential (euclidean curvature), integral (integral area invariant) and the output of our network (henceforth termed as network invariant) as shown in figure 7. apart from adding noise, we also rotate the curve to obtain a better assessment of the euclidean invariance property. in figure 8, we test descriptiveness of the signature under noisy conditions in a shape retrieval task for a set of 30 shapes with 6 different categories. for every curve, we generate 5 signatures at different scales for the integral and the network invariant and use them as a representation for that shape. we use the hausdorff distance as a distance measure (bronstein  (2008)) between the two sets of signatures to rank the shapes for retrieval. figure 7 and 8 demonstrate the robustness of the network especially at high noise levels.
in the second experiment, we decimate a high resolution contour at successive resolutions by randomly sub-sampling and redistributing a set of its points (marked blue in figure 9) and observe the signatures at certain fixed points (marked red in figure 9) on the curve. figure 9 shows that the network is able to handle these changes in sampling and compares well with the integral invariant. figures 7 and figure 9 represent behavior of geometric signatures for two different tests: large noise for a moderate strength of signal and low signal for a moderate level of noise.we have demonstrated a method to learn geometric invariants of planar curves. using just positive and negative examples of euclidean transformations, we showed that a convolutional neural network 0% 50% 30% 0% 10% 5%  10 20 30 40 50 60
is able to effectively discover and encode transform-invariant properties of curves while remaining numerically robust in the face of noise. by using a geometric context to the training process we were able to develop novel multi-scale representations from a learning based approach without explicitly
enforcing such behavior. as compared to a more axiomatic framework of modeling with differential geometry and engineering with numerical analysis, we demonstrated a way of replacing this pipeline with a deep learning framework which combines both these aspects. the non-specific nature of this framework can be seen as providing the groundwork for future deep learning data based problems in differential geometry.this project has received funding from the european research council (erc) under the european unions horizon 2020 research and innovation program (grant agreement no 664800)",1
484.pdf.json,,"a central factor in the application of machine learning to a given task is the inductive bias, i.e. the choice of hypotheses space from which learned functions are taken. the restriction posed by the inductive bias is necessary for practical learning, and reflects prior knowledge regarding the task at hand. perhaps the most successful exemplar of inductive bias to date manifests itself in the use of convolutional networks (lecun and bengio (1995)) for computer vision tasks. these hypotheses spaces are delivering unprecedented visual recognition results (e.g. krizhevsky  (2012); szegedy  (2015); simonyan and zisserman (2014); he  (2015)), largely responsible for the resurgence of deep learning (lecun  (2015)). unfortunately, our formal understanding of the inductive bias behind convolutional networks is limited – the assumptions encoded into these models, which seem to form an excellent prior knowledge for imagery data, are for the most part a mystery.
existing works studying the inductive bias of deep networks (not necessarily convolutional) do so in the context of depth efficiency, essentially arguing that for a given amount of resources, more layers result in higher expressiveness. more precisely, depth efficiency refers to a situation where a function realized by a deep network of polynomial size, requires super-polynomial size in order to be realized (or approximated) by a shallower network. in recent years, a large body of research was devoted to proving existence of depth efficiency under different types of architectures (see for example delalleau and bengio (2011); pascanu  (2013); montufar  (2014); telgarsky (2015); eldan and shamir (2015); poggio  (2015); mhaskar  (2016)). nonetheless, despite the wide attention it is receiving, depth efficiency does not convey the complete story behind the inductive bias of deep networks. while it does suggest that depth brings forth functions that are otherwise unattainable, it does not explain why these functions are useful. loosely speaking, the
hypotheses space of a polynomially sized deep network covers a small fraction of the space of all functions. we would like to understand why this small fraction is so successful in practice.
a specific family of convolutional networks gaining increased attention is that of convolutional arithmetic circuits. these models follow the standard paradigm of locality, weight sharing and pooling, yet differ from the most conventional convolutional networks in that their point-wise activations are linear, with non-linearity originating from product pooling. recently, cohen  (2016b) analyzed the depth efficiency of convolutional arithmetic circuits, showing that besides a negligible (zero measure) set, all functions realizable by a deep network require exponential size in order to be realized (or approximated) by a shallow one. this result, termed complete depth efficiency, stands in contrast to previous depth efficiency results, which merely showed existence of functions efficiently realizable by deep networks but not by shallow ones. besides their analytic advantage, convolutional arithmetic circuits are also showing promising empirical performance. in particular, they are equivalent to simnets – a deep learning architecture that excels in computationally constrained settings (cohen and shashua (2014); cohen  (2016a)), and in addition, have recently been utilized for classification with missing data (sharir  (2016)). motivated by these theoretical and practical merits, we focus our analysis in this paper on convolutional arithmetic circuits, viewing them as representative of the class of convolutional networks. we empirically validate our conclusions with both convolutional arithmetic circuits and convolutional rectifier networks – convolutional networks with rectified linear (relu, nair and hinton (2010)) activation and max or average pooling. adaptation of the formal analysis to networks of the latter type, similarly to the adaptation of the analysis in cohen  (2016b) carried out by cohen and shashua (2016), is left for future work.
our analysis approaches the study of inductive bias from the direction of function inputs. specifically, we study the ability of convolutional arithmetic circuits to model correlation between regions of their input. to analyze the correlations of a function, we consider different partitions of input regions into disjoint sets, and ask how far the function is from being separable w.r.t. these partitions. distance from separability is measured through the notion of separation rank (beylkin and mohlenkamp (2002)), which can be viewed as a surrogate of the l2 distance from the closest separable function. for a given function and partition of its input, high separation rank implies that the function induces strong correlation between sides of the partition, and vice versa.
we show that a deep network supports exponentially high separation ranks for certain input partitions, while being limited to polynomial or linear (in network size) separation ranks for others. the network’s pooling geometry effectively determines which input partitions are favored in terms of separation rank, i.e. which partitions enjoy the possibility of exponentially high separation rank with polynomial network size, and which require network to be exponentially large. the standard choice of square contiguous pooling windows favors interleaved (entangled) partitions over coarse ones that divide the input into large distinct areas. other choices lead to different preferences, for example pooling windows that join together nodes with their spatial reflections lead to favoring partitions that split the input symmetrically. we conclude that in terms of modeled correlations, pooling geometry controls the inductive bias, and the particular design commonly employed in practice orients it towards the statistics of natural images (nearby pixels more correlated than ones that are far apart). moreover, when processing data that departs from the usual domain of natural imagery, prior knowledge regarding its statistics can be used to derive respective pooling schemes, and accordingly tailor the inductive bias.
with regards to depth efficiency, we show that separation ranks under favored input partitions are exponentially high for all but a negligible set of the functions realizable by a deep network. shallow networks on the other hand, treat all partitions equally, and support only linear (in network size) separation ranks. therefore, almost all functions that may be realized by a deep network require a replicating shallow network to have exponential size. by this we return to the complete depth efficiency result of cohen  (2016b), but with an added important insight into the benefit of functions brought forth by depth – they are able to efficiently model strong correlation under favored partitions of the input.
the remainder of the paper is organized as follows. sec. 2 provides a brief presentation of necessary background material from the field of tensor analysis. sec. 3 describes the convolutional arithmetic circuits we analyze, and their relation to tensor decompositions. in sec. 4 we convey the concept of separation rank, on which we base our analyses in sec. 5 and 6. the conclusions from our analyses are empirically validated in sec. 7. finally, sec. 8 concludes.the analyses carried out in this paper rely on concepts and results from the field of tensor analysis. in this section we establish the minimal background required in order to follow our arguments 1 , referring the interested reader to hackbusch (2012) for a broad and comprehensive introduction to the field.
the core concept in tensor analysis is a tensor, which for our purposes may simply be thought of as a multi-dimensional array. the order of a tensor is defined to be the number of indexing entries in the array, which are referred to as modes. the dimension of a tensor in a particular mode is defined as the number of values that may be taken by the index in that mode. for example, a 4-by-3 matrix is a tensor of order 2, i.e. it has two modes, with dimension 4 in mode 1 and dimension 3 in mode 2. if a is a tensor of order n and dimension mi in each mode i ∈ [n ] := {1, . . . , n}, the space of all configurations it can take is denoted, quite naturally, by rm1×···×mn .
a fundamental operator in tensor analysis is the tensor product, which we denote by ⊗. it is an operator that intakes two tensors a ∈ rm1×···×mp and b ∈ rmp+1×···×mp+q (orders p and q respectively), and returns a tensor a ⊗ b ∈ rm1×···×mp+q (order p + q) defined by: (a ⊗ b)d1...dp+q = ad1...dp · bdp+1...dp+q . notice that in the case p = q = 1, the tensor product reduces to the standard outer product between vectors, i.e. if u ∈ rm1 and v ∈ rm2 , then u⊗ v is no other than the rank-1 matrix uv> ∈ rm1×m2 . we now introduce the important concept of matricization, which is essentially the rearrangement of a tensor as a matrix. supposea is a tensor of order n and dimension mi in each mode i ∈ [n ], and let (i, j) be a partition of [n ], i.e. i and j are disjoint subsets of [n ] whose union gives [n ]. we may write i = {i1, . . . , i|i|} where i1 < · · · < i|i|, and similarly j = {j1, . . . , j|j|} where j1 < · · · < j|j|. the matricization of a w.r.t. the partition (i, j), denoted jaki,j , is the
∏|i| t=1mit -by-∏|j|
t=1mjt matrix holding the entries ofa such thatad1...dn is placed in row index 1+ ∑|i| t=1(dit − ) ∏|i| t′=t+1mit′ and column index 1 + ∑|j| t=1(djt − 1) ∏|j| t′=t+1mjt′ . if i = ∅ or j = ∅, then by
definition jaki,j is a row or column (respectively) vector of dimension ∏n t=1mt holding ad1...dn
in entry 1 + ∑n t=1(dt − 1) ∏n t′=t+1mt′ .
a well known matrix operator is the kronecker product, which we denote by . for two matrices a ∈ rm1×m2 and b ∈ rn1×n2 , a b is the matrix in rm1n1×m2n2 holding aijbkl in row index (i − 1)n1 + k and column index (j − 1)n2 + l. let a and b be tensors of orders p and q respectively, and let (i, j) be a partition of [p +q]. the basic relation that binds together the tensor product, the matricization operator, and the kronecker product, is:
ja⊗ bki,j = jaki∩[p ],j∩[p ] jbk(i−p )∩[q],(j−p )∩[q] (1) where i − p and j − p are simply the sets obtained by subtracting p from each of the elements in i and j respectively. in words, eq. 1 implies that the matricization of the tensor product between a and b w.r.t. the partition (i, j) of [p + q], is equal to the kronecker product between two matricizations: that of a w.r.t. the partition of [p ] induced by the lower values of (i, j), and that of b w.r.t. the partition of [q] induced by the higher values of (i, j).the convolutional arithmetic circuit architecture on which we focus in this paper is the one considered in cohen  (2016b), portrayed in fig. 1(a). instances processed by a network are represented as n -tuples of s-dimensional vectors. they are generally thought of as images, with the s-dimensional vectors corresponding to local patches. for example, instances could be 32-by-32 rgb images, with local patches being 5 × 5 regions crossing the three color bands. in this case, assuming a patch is taken around every pixel in an image (boundaries padded), we have n = 1024 and s = 75. throughout the paper, we denote a general instance by x = (x1, . . . ,xn ), with x1 . . .xn ∈ rs standing for its patches.  the definitions we give are actually concrete special cases of more abstract algebraic definitions as given in hackbusch (2012). we limit the discussion to these special cases since they suffice for our needs and are easier to grasp.
the first layer in a network is referred to as representation. it consists of applying m representation functions fθ1 . . .fθm : rs → r to all patches, thereby creating m feature maps. in the case where representation functions are chosen as fθd(x) = σ(w > d x + bd), with parameters θd = (wd, bd) ∈ rs × r and some point-wise activation σ(·), the representation layer reduces to a standard convolutional layer. more elaborate settings are also possible, for example modeling the representation as a cascade of convolutional layers with pooling in-between. following the representation, a network includes l hidden layers indexed by l = 0. . .l− 1. each hidden layer l begins with a 1 × 1 conv operator, which is simply a three-dimensional convolution with rl channels and filters of spatial dimensions 1-by-1. 2 this is followed by spatial pooling, that decimates feature maps by taking products of non-overlapping two-dimensional windows that cover the spatial extent. the last of the l hidden layers (l = l−1) reduces feature maps to singletons (its pooling operator is global), creating a vector of dimension rl−1. this vector is mapped into y network outputs through a final dense linear layer.
altogether, the architectural parameters of a network are the type of representation functions (fθd ), the pooling window shapes and sizes (which in turn determine the number of hidden layers l), and the number of channels in each layer (m for representation, r0. . .rl−1 for hidden layers, y for output). given these architectural parameters, the learnable parameters of a network are the representation weights (θd for channel d), the conv weights (al,γ for channel γ of hidden layer l), and the output weights (al,y for output node y).
for a particular setting of weights, every node (neuron) in a given network realizes a function from (rs)n to r. the receptive field of a node refers to the indexes of input patches on which its function may depend. for example, the receptive field of node j in channel γ of conv oper-  cohen  (2016b) consider two settings for the 1 × 1 conv operator. the first, referred to as weight sharing, is the one described above, and corresponds to standard convolution. the second is more general, allowing filters that slide across the previous layer to have different weights at different spatial locations. it is shown in cohen  (2016b) that without weight sharing, a convolutional arithmetic circuit with one hidden layer (or more) is universal, i.e. can realize any function if its size (width) is unbounded. this property is imperative for the study of depth efficiency, as that requires shallow networks to ultimately be able to replicate any function realized by a deep network. in this paper we limit the presentation to networks with weight sharing, which are not universal. we do so because they are more conventional, and since our entire analysis is oblivious to whether or not weights are shared (applies as is to both settings). the only exception is where we reproduce the depth efficiency result of cohen  (2016b). there, we momentarily consider networks without weight sharing.
ator at hidden layer 0 is {j}, and that of an output node is [n ], corresponding to the entire input. denote by h(l,γ,j) the function realized by node j of channel γ in conv operator at hidden layer l, and let i(l,γ,j) ⊂ [n ] be its receptive field. by the structure of the network it is evident that i(l,γ,j) does not depend on γ, so we may write i(l,j) instead. moreover, assuming pooling windows are uniform across channels (as customary with convolutional networks), and taking into account the fact that they do not overlap, we conclude that i(l,j1) and i(l,j2) are necessarily disjoint if j1 6=j2. a simple induction over l = 0. . .l − 1 then shows that h(l,γ,j) may be expressed as h(l,γ,j)(xi1 , . . . ,xit ) = ∑m d1...dt=1 a(l,γ,j)d1...dt ∏t t=1 fθdt (xit), where {i1, . . . , it } stands for the receptive field i(l,j), and a(l,γ,j) is a tensor of order t = |i(l,j)| and dimension m in each mode, with entries given by polynomials in the network’s conv weights {al,γ}l,γ . taking the induction one step further (from last hidden layer to network output), we obtain the following expression for functions realized by network outputs:
hy (x1, . . . ,xn ) = ∑m
d1...dn=1 ayd1...dn ∏n i=1 fθdi (xi) (2)
y ∈ [y ] here is an output node index, and hy is the function realized by that node. ay is a tensor of order n and dimension m in each mode, with entries given by polynomials in the network’s conv weights {al,γ}l,γ and output weights al,y . hereafter, terms such as function realized by a network or coefficient tensor realized by a network, are to be understood as referring to hy oray respectively. next, we present explicit expressions for ay under two canonical networks – deep and shallow.
deep network. consider a network as in fig. 1(a), with pooling windows set to cover four entries each, resulting in l = log4n hidden layers. the linear weights of such a network are {a0,γ ∈ rm}γ∈[r0] for conv operator in hidden layer 0, {al,γ ∈ rrl−1}γ∈[rl] for conv operator in hidden layer l = 1. . .l − 1, and {al,y ∈ rrl−1}y∈[y ] for dense output operator. they determine the coefficient tensor ay (eq. 2) through the following recursive decomposition:
φ1,γ︸︷︷︸ order 4
= ∑r0
α=1 a1,γα · ⊗4a0,α , γ ∈ [r1]
· · · φl,γ︸︷︷︸
order 4l
= ∑rl−1
α=1 al,γα · ⊗4φl−1,α , l ∈ {2. . .l− 1}, γ ∈ [rl]
· · · ay︸︷︷︸
order 4l n
= ∑rl−1
α=1 al,yα · ⊗4φl−1,α (3)
al,γα and a l,y α here are scalars representing entry α in the vectors a l,γ and al,y respectively, and the symbol⊗with a superscript stands for a repeated tensor product, e.g.⊗4a0,α := a0,α⊗a0,α⊗a0,α⊗ a0,α. to verify that under pooling windows of size four ay is indeed given by eq. 3, simply plug the rows of the decomposition into eq. 2, starting from bottom and continuing upwards. for context, eq. 3 describes what is known as a hierarchical tensor decomposition (see chapter 11 in hackbusch (2012)), with underlying tree over modes being a full quad-tree (corresponding to the fact that the network’s pooling windows cover four entries each).
shallow network. the second network we pay special attention to is shallow, comprising a single hidden layer with global pooling – see illustration in fig. 1(b). the linear weights of such a network are {a0,γ ∈ rm}γ∈[r0] for hidden conv operator and {a1,y ∈ rr0}y∈[y ] for dense output operator. they determine the coefficient tensor ay (eq. 2) as follows:
ay = ∑r0
γ=1 a1,yγ · ⊗na0,γ (4)
where a1,yγ stands for entry γ of a 1,y , and again, the symbol ⊗ with a superscript represents a repeated tensor product. the tensor decomposition in eq. 4 is an instance of the classic cp decomposition, also known as rank-1 decomposition (see kolda and bader (2009) for a historic survey).
to conclude this section, we relate the background material above, as well as our contribution described in the upcoming sections, to the work of cohen  (2016b). the latter shows that with
arbitrary coefficient tensorsay , functions hy as in eq. 2 form a universal hypotheses space. it is then shown that convolutional arithmetic circuits as in fig. 1(a) realize such functions by applying tensor decompositions to ay , with the type of decomposition determined by the structure of a network (number of layers, number of channels in each layer etc.). the deep network (fig. 1(a) with size-4 pooling windows and l = log4n hidden layers) and the shallow network (fig. 1(b)) presented hereinabove are two special cases, whose corresponding tensor decompositions are given in eq. 3 and 4 respectively. the central result in cohen  (2016b) relates to inductive bias through the notion of depth efficiency – it is shown that in the parameter space of a deep network, all weight settings but a set of (lebesgue) measure zero give rise to functions that can only be realized (or approximated) by a shallow network if the latter has exponential size. this result does not relate to the characteristics of instances x = (x1, . . . ,xn ), it only treats the ability of shallow networks to replicate functions realized by deep networks.
in this paper we draw a line connecting the inductive bias to the nature of x , by studying the relation between a network’s architecture and its ability to model correlation among patches xi. specifically, in sec. 4 we consider partitions (i, j) of [n ] (i ·∪j = [n ], where ·∪ stands for disjoint union), and present the notion of separation rank as a measure of the correlation modeled between the patches indexed by i and those indexed by j . in sec. 5.1 the separation rank of a network’s function hy w.r.t. a partition (i, j) is proven to be equal to the rank of jayki,j – the matricization of the coefficient tensor ay w.r.t. (i, j). sec. 5.2 derives lower and upper bounds on this rank for a deep network, showing that it supports exponential separation ranks with polynomial size for certain partitions, whereas for others it is required to be exponentially large. subsequently, sec. 5.3 establishes an upper bound on rankjayki,j for shallow networks, implying that these must be exponentially large in order to model exponential separation rank under any partition, and thus cannot efficiently replicate a deep network’s correlations. our analysis concludes in sec. 6, where we discuss the pooling geometry of a deep network as a means for controlling the inductive bias by determining a correspondence between partitions (i, j) and spatial partitions of the input. finally, we demonstrate experimentally in sec. 7 how different pooling geometries lead to superior performance in different tasks. our experiments include not only convolutional arithmetic circuits, but also convolutional rectifier networks, i.e. convolutional networks with relu activation and max or average pooling.in this section we define the concept of separation rank for functions realized by convolutional arithmetic circuits (sec. 3), i.e. real functions that take as input x = (x1, . . . ,xn ) ∈ (rs)n . the separation rank serves as a measure of the correlations such functions induce between different sets of input patches, i.e. different subsets of the variable set {x1, . . . ,xn}. let (i, j) be a partition of input indexes, i.e. i and j are disjoint subsets of [n ] whose union gives [n ]. we may write i = {i1, . . . , i|i|} where i1 < · · · < i|i|, and similarly j = {j1, . . . , j|j|} where j1 < · · · < j|j|. for a function h : (rs)n → r, the separation rank w.r.t. the partition (i, j) is defined as follows: 3
sep(h; i, j) := min { r ∈ n ∪ {0} : ∃g1. . .gr : (rs)|i| → r, g′1. . .g′r : (rs)|j| → r s.t. (5)
h(x1, . . . ,xn ) = ∑r
ν=1 gν(xi1 , . . . ,xi|i|)g
′ ν(xj1 , . . . ,xj|j|) } in words, it is the minimal number of summands that together give h, where each summand is separable w.r.t. (i, j), i.e. is equal to a product of two functions – one that intakes only patches indexed by i , and another that intakes only patches indexed by j . one may wonder if it is at all possible to express h through such summands, i.e. if the separation rank of h is finite. from the theory of tensor products between l2 spaces (see hackbusch (2012) for a comprehensive coverage), we know that any h∈l2((rs)n ), i.e. any h that is measurable and square-integrable, may be approximated arbitrarily well by summations of the form ∑r ν=1 gν(xi1 , . . . ,xi|i|)g ′ ν(xj1 , . . . ,xj|j|). exact realization however is only guaranteed at the limit r → ∞, thus in general the separation rank of h  if i = ∅ or j = ∅ then by definition sep(h; i, j) = 1 (unless h ≡ 0, in which case sep(h; i, j) = 0).
need not be finite. nonetheless, as we show in sec. 5, for the class of functions we are interested in, namely functions realizable by convolutional arithmetic circuits, separation ranks are always finite.
the concept of separation rank was introduced in beylkin and mohlenkamp (2002) for numerical treatment of high-dimensional functions, and has since been employed for various applications, e.g. quantum chemistry (harrison  (2003)), particle engineering (hackbusch (2006)) and machine learning (beylkin  (2009)). if the separation rank of a function w.r.t. a partition of its input is equal to 1, the function is separable, meaning it does not model any interaction between the sets of variables. specifically, if sep(h; i, j) = 1 then there exist g : (rs)|i| → r and g′ : (rs)|j| → r such that h(x1, . . . ,xn ) = g(xi1 , . . . ,xi|i|)g′(xj1 , . . . ,xj|j|), and the function h cannot take into account consistency between the values of {xi1 , . . . ,xi|i|} and those of {xj1 , . . . ,xj|j|}. in a statistical setting, if h is a probability density function, this would mean that {xi1 , . . . ,xi|i|} and {xj1 , . . . ,xj|j|} are statistically independent. the higher sep(h; i, j) is, the farther h is from this situation, i.e. the more it models dependency between {xi1 , . . . ,xi|i|} and {xj1 , . . . ,xj|j|}, or equivalently, the stronger the correlation it induces between the patches indexed by i and those indexed by j .
the interpretation of separation rank as a measure of deviation from separability is formalized in app. b, where it is shown that sep(h; i, j) is closely related to the l2 distance of h from the set of separable functions w.r.t. (i, j). specifically, we define d(h; i, j) as the latter distance divided by the l2 norm of h 4 , and show that sep(h; i, j) provides an upper bound on d(h; i, j). while it is not possible to lay out a general lower bound ond(h; i, j) in terms of sep(h; i, j), we show that the specific lower bounds on sep(h; i, j) underlying our analyses can be translated into lower bounds on d(h; i, j). this implies that our results, facilitated by upper and lower bounds on separation ranks of convolutional arithmetic circuits, may equivalently be framed in terms of l2 distances from separable functions.in this section we analyze convolutional arithmetic circuits (sec. 3) in terms of the correlations they can model between sides of different input partitions, i.e. in terms of the separation ranks (sec. 4) they support under different partitions (i, j) of [n ]. we begin in sec. 5.1, establishing a correspondence between separation ranks and coefficient tensor matricization ranks. this correspondence is then used in sec. 5.2 and 5.3 to analyze the deep and shallow networks (respectively) presented in sec. 3. we note that we focus on these particular networks merely for simplicity of presentation – the analysis can easily be adapted to account for alternative networks with different depths and pooling schemes.let hy be a function realized by a convolutional arithmetic circuit, with corresponding coefficient tensor ay (eq. 2). denote by (i, j) an arbitrary partition of [n ], i.e. i ·∪j = [n ]. we are interested in studying sep(hy; i, j) – the separation rank of hy w.r.t. (i, j) (eq. 5). as claim 1 below states, assuming representation functions {fθd}d∈[m ] are linearly independent (if they are not, we drop dependent functions and modify ay accordingly 5 ), this separation rank is equal to the rank of jayki,j – the matricization of the coefficient tensor ay w.r.t. the partition (i, j). our problem thus translates to studying ranks of matricized coefficient tensors.
claim 1. let hy be a function realized by a convolutional arithmetic circuit (fig. 1(a)), with corresponding coefficient tensor ay (eq. 2). assume that the network’s representation functions fθd are linearly independent, and that they, as well as the functions gν , g′ν in the definition of separation  the normalization (division by norm) is of critical importance – without it rescaling h would accordingly rescale d(h; i, j), rendering the latter uninformative in terms of deviation from separability. 5 suppose for example that fθm is dependent, i.e. there exist α1 . . . αm−1 ∈ r such that fθm (x) =∑m−1 d=1 αd·fθd(x). we may then plug this into eq. 2, and obtain an expression for hy that has fθ1 . . .fθm−1 as representation functions, and a coefficient tensor with dimension m − 1 in each mode. continuing in this fashion, one arrives at an expression for hy whose representation functions are linearly independent.
rank (eq. 5), are measurable and square-integrable. 6 then, for any partition (i, j) of [n ], it holds that sep(hy; i, j) = rankjayki,j .
proof. see app. a.1.
as the linear weights of a network vary, so do the coefficient tensors (ay) it gives rise to. accordingly, for a particular partition (i, j), a network does not correspond to a single value of rankjayki,j , but rather supports a range of values. we analyze this range by quantifying its maximum, which reflects the strongest correlation that the network can model between the input patches indexed by i and those indexed by j . one may wonder if the maximal value of rankjayki,j is the appropriate statistic to measure, as a-priori, it may be that rankjayki,j is maximal for very few of the network’s weight settings, and much lower for all the rest. apparently, as claim 2 below states, this is not the case, and in fact rankjayki,j is maximal under almost all of the network’s weight settings. claim 2. consider a convolutional arithmetic circuit (fig. 1(a)) with corresponding coefficient tensor ay (eq. 2). ay depends on the network’s linear weights – {al,γ}l,γ and al,y , thus for a given partition (i, j) of [n ], rankjayki,j is a function of these weights. this function obtains its maximum almost everywhere (w.r.t. lebesgue measure).
proof. see app. a.2.in this subsection we study correlations modeled by the deep network presented in sec. 3 (fig. 1(a) with size-4 pooling windows and l = log4n hidden layers). in accordance with sec. 5.1, we do so by characterizing the maximal ranks of coefficient tensor matricizations under different partitions.
recall from eq. 3 the hierarchical decomposition expressing a coefficient tensor ay realized by the deep network. we are interested in matricizations of this tensor under different partitions of [n ]. let (i, j) be an arbitrary partition, i.e. i ·∪j = [n ]. matricizing the last level of eq. 3 w.r.t. (i, j), while applying the relation in eq. 1, gives:
jayki,j = ∑rl−1
α=1 al,yα ·
q φl−1,α ⊗ φl−1,α ⊗ φl−1,α ⊗ φl−1,α y i,j
= ∑rl−1
α=1 al,yα ·
q φl−1,α ⊗ φl−1,α y i∩[2·4l−1],j∩[2·4l−1]
q φl−1,α ⊗ φl−1,α y (i−2·4l−1)∩[2·4l−1],(j−2·4l−1)∩[2·4l−1]
applying eq. 1 again, this time to matricizations of the tensor φl−1,α ⊗ φl−1,α, we obtain: jayki,j = ∑rl−1
α=1 al,yα ·
q φl−1,α y i∩[4l−1],j∩[4l−1]
q φl−1,α y (i−4l−1)∩[4l−1],(j−4l−1)∩[4l−1] q φl−1,α
y (i−2·4l−1)∩[4l−1],(j−2·4l−1)∩[4l−1]
q φl−1,α y (i−3·4l−1)∩[4l−1],(j−3·4l−1)∩[4l−1]
for every k ∈ [4] define il−1,k := (i−(k−1)·4l−1)∩[4l−1] and jl−1,k := (j−(k−1)·4l−1)∩ [4l−1]. in words, (il−1,k, jl−1,k) represents the partition induced by (i, j) on the k’th quadrant of [n ], i.e. on the k’th size-4l−1 group of input patches. we now have the following matricized version of the last level in eq. 3:
jayki,j = ∑rl−1
α=1 al,yα · 4 t=1 jφl−1,αkil−1,t,jl−1,t 6 square-integrability of representation functions fθd may seem as a limitation at first glance, as for example neurons fθd(x) = σ(w > d x + bd), with parameters θd = (wd, bd) ∈ rs × r and sigmoid or relu activation σ(·), do not meet this condition. however, since in practice our inputs are bounded (e.g. they represent image pixels by holding intensity values), we may view functions as having compact support, which, as long as they are continuous (holds in all cases of interest), ensures square-integrability.
where the symbol with a running index stands for an iterative kronecker product. to derive analogous matricized versions for the upper levels of eq. 3, we define for l ∈ {0. . .l − 1}, k ∈ [n/4l]: il,k := (i − (k − 1) · 4l) ∩ [4l] jl,k := (j − (k − 1) · 4l) ∩ [4l] (6) that is to say, (il,k, jl,k) represents the partition induced by (i, j) on the set of indexes {(k − 1) · 4l + 1, . . . , k · 4l}, i.e. on the k’th size-4l group of input patches. with this notation in hand, traversing upwards through the levels of eq. 3, with repeated application of the relation in eq. 1, one arrives at the following matrix decomposition for jayki,j :
jφ1,γki1,k,j1,k︸ ︷︷ ︸ m |i1,k|-by-m |j1,k|
= ∑r0
α=1 a1,γα · 4 t=1 ja0,αki0,4(k−1)+t,j0,4(k−1)+t , γ ∈ [r1]
· · ·
jφl,γkil,k,jl,k︸ ︷︷ ︸ m |il,k|-by-m |jl,k|
= ∑rl−1
α=1 al,γα · 4 t=1 jφl−1,αkil−1,4(k−1)+t,jl−1,4(k−1)+t , l ∈ {2. . .l− 1}, γ ∈ [rl]
· · ·
jayki,j︸ ︷︷ ︸ m |i|-by-m |j|
= ∑rl−1
α=1 al,yα · 4 t=1 jφl−1,αkil−1,t,jl−1,t (7)
eq. 7 expresses jayki,j – the matricization w.r.t. the partition (i, j) of a coefficient tensoray realized by the deep network, in terms of the network’s conv weights {al,γ}l,γ and output weights al,y . as discussed above, our interest lies in the maximal rank that this matricization can take. theorem 1 below provides lower and upper bounds on this maximal rank, by making use of eq. 7, and of the rank-multiplicative property of the kronecker product (rank(a b) = rank(a)·rank(b)). theorem 1. let (i, j) be a partition of [n ], and jayki,j be the matricization w.r.t. (i, j) of a coefficient tensor ay (eq. 2) realized by the deep network (fig. 1(a) with size-4 pooling windows). for every l ∈ {0. . .l− 1} and k ∈ [n/4l], define il,k and jl,k as in eq. 6. then, the maximal rank that jayki,j can take (when network weights vary) is:
• no smaller than min{r0,m}s , where s := |{k ∈ [n/4] : i1,k 6= ∅ ∧ j1,k 6= ∅}|.
• no greater than min{mmin{|i|,|j|}, rl−1 ∏4 t=1 c
l−1,t}, where c0,k := 1 for k ∈ [n ], and cl,k := min{mmin{|il,k|,|jl,k|}, rl−1 ∏4 t=1 c l−1,4(k−1)+t} for l ∈ [l− 1], k ∈ [n/4l].
proof. see app. a.3.
the lower bound in theorem 1 is exponential in s, the latter defined to be the number of size-4 patch groups that are split by the partition (i, j), i.e. whose indexes are divided between i and j . partitions that split many of the size-4 patch groups will thus lead to a large lower bound. for example, consider the partition (iodd, jeven) defined as follows:
iodd = {1, 3, . . . , n − 1} jeven = {2, 4, . . . , n} (8) this partition splits all size-4 patch groups (s = n/4), leading to a lower bound that is exponential in the number of patches (n ).
the upper bound in theorem 1 is expressed via constants cl,k, defined recursively over levels l = 0. . .l − 1, with k ranging over 1. . .n/4l for each level l. what prevents cl,k from growing double-exponentially fast (w.r.t. l) is the minimization with mmin{|il,k|,|jl,k|}. specifically, if min{|il,k| , |jl,k|} is small, i.e. if the partition induced by (i, j) on the k’th size-4l group of patches is unbalanced (most of the patches belong to one side of the partition, and only a few belong to the other), cl,k will be of reasonable size. the higher this takes place in the hierarchy (i.e. the larger l is), the lower our eventual upper bound will be. in other words, if partitions induced by (i, j) on size-4l patch groups are unbalanced for large values of l, the upper bound in theorem 1 will be small. for example, consider the partition (i low, jhigh) defined by:
i low = {1, . . . , n/2} jhigh = {n/2 + 1, . . . , n} (9)
under (i low, jhigh), all partitions induced on size-4l−1 patch groups (quadrants of [n ]) are completely one-sided (min{|il−1,k|, |jl−1,k|} = 0 for all k ∈ [4]), resulting in the upper bound being no greater than rl−1 – linear in network size.
to summarize this discussion, theorem 1 states that with the deep network, the maximal rank of a coefficient tensor matricization w.r.t. (i, j), highly depends on the nature of the partition (i, j) – it will be exponentially high for partitions such as (iodd, jeven), that split many size-4 patch groups, while being only polynomial (or linear) for partitions like (i low, jhigh), under which size-4l patch groups are unevenly divided for large values of l. since the rank of a coefficient tensor matricization w.r.t. (i, j) corresponds to the strength of correlation modeled between input patches indexed by i and those indexed by j (sec. 5.1), we conclude that the ability of a polynomially sized deep network to model correlation between sets of input patches highly depends on the nature of these sets.we now turn to study correlations modeled by the shallow network presented in sec. 3 (fig. 1(b)). in line with sec. 5.1, this is achieved by characterizing the maximal ranks of coefficient tensor matricizations under different partitions.
recall from eq. 4 the cp decomposition expressing a coefficient tensor ay realized by the shallow network. for an arbitrary partition (i, j) of [n ], i.e. i ·∪j = [n ], matricizing this decomposition with repeated application of the relation in eq. 1, gives the following expression for jayki,j – the matricization w.r.t. (i, j) of a coefficient tensor realized by the shallow network:
jayki,j = ∑r0
γ=1 a1,yγ ·
( |i|a0,γ )( |j|a0,γ )> (10)
|i|a0,γ and |j|a0,γ here are column vectors of dimensions m |i| and m |j| respectively, standing for the kronecker products of a0,γ ∈ rm with itself |i| and |j | times (respectively). eq. 10 immediately leads to two observations regarding the ranks that may be taken by jayki,j . first, they depend on the partition (i, j) only through its division size, i.e. through |i| and |j |. second, they are no greater than min{mmin{|i|,|j|}, r0}, meaning that the maximal rank is linear (or less) in network size. in light of sec. 5.1 and 5.2, these findings imply that in contrast to the deep network, which with polynomial size supports exponential separation ranks under favored partitions, the shallow network treats all partitions (of a given division size) equally, and can only give rise to an exponential separation rank if its size is exponential.
suppose now that we would like to use the shallow network to replicate a function realized by a polynomially sized deep network. so long as the deep network’s function admits an exponential separation rank under at least one of the favored partitions (e.g. (iodd, jeven) – eq. 8), the shallow network would have to be exponentially large in order to replicate it, i.e. depth efficiency takes place. 7 since all but a negligible set of the functions realizable by the deep network give rise to maximal separation ranks (sec 5.1), we obtain the complete depth efficiency result of cohen  (2016b). however, unlike cohen  (2016b), which did not provide any explanation for the usefulness of functions brought forth by depth, we obtain an insight into their utility – they are able to efficiently model strong correlation under favored partitions of the input.the deep network presented in sec. 3, whose correlations we analyzed in sec. 5.2, was defined as having size-4 pooling windows, i.e. pooling windows covering four entries each. we have yet  convolutional arithmetic circuits as we have defined them (sec. 3) are not universal. in particular, it may very well be that a function realized by a polynomially sized deep network cannot be replicated by the shallow network, no matter how large (wide) we allow it to be. in such scenarios depth efficiency does not provide insight into the complexity of functions brought forth by depth. to obtain a shallow network that is universal, thus an appropriate gauge for depth efficiency, we may remove the constraint of weight sharing, i.e. allow the filters in the hidden conv operator to hold different weights at different spatial locations (see cohen  (2016b) for proof that this indeed leads to universality). all results we have established for the original shallow network remain valid when weight sharing is removed. in particular, the separation ranks of the network are still linear in its size. this implies that as suggested, depth efficiency indeed holds.
to specify the shapes of these windows, or equivalently, the spatial (two-dimensional) locations of nodes grouped together in the process of pooling. in compliance with standard convolutional network design, we now assume that the network’s (size-4) pooling windows are contiguous square blocks, i.e. have shape 2 × 2. under this configuration, the network’s functional description (eq. 2 with ay given by eq. 3) induces a spatial ordering of input patches 8 , which may be described by the following recursive process:
• set the index of the top-left patch to 1.
• for l = 1, . . ., l = log4n : replicate the already-assigned top-left 2l−1-by-2l−1 block of indexes, and place copies on its right, bottom-right and bottom. then, add a 4l−1 offset to all indexes in the right copy, a 2 · 4l−1 offset to all indexes in the bottom-right copy, and a 3 · 4l−1 offset to all indexes in the bottom copy.
with this spatial ordering (illustrated in fig. 1(c)), partitions (i, j) of [n ] convey a spatial pattern. for example, the partition (iodd, jeven) (eq. 8) corresponds to the pattern illustrated on the left of fig. 1(c), whereas (i low, jhigh) (eq. 9) corresponds to the pattern illustrated on the right. our analysis (sec. 5.2) shows that the deep network is able to model strong correlation under (iodd, jeven), while being inefficient for modeling correlation under (i low, jhigh). more generally, partitions for which s, defined in theorem 1, is high, convey patterns that split many 2 × 2 patch blocks, i.e. are highly entangled. these partitions enjoy the possibility of strong correlation. on the other hand, partitions for which min{|il,k| , |jl,k|} is small for large values of l (see eq. 6 for definition of il,k and jl,k) convey patterns that divide large 2l × 2l patch blocks unevenly, i.e. separate the input to distinct contiguous regions. these partitions, as we have seen, suffer from limited low correlations.
we conclude that with 2× 2 pooling, the deep network is able to model strong correlation between input regions that are highly entangled, at the expense of being inefficient for modeling correlation between input regions that are far apart. had we selected a different pooling regime, the preference of input partition patterns in terms of modeled correlation would change. for example, if pooling windows were set to group nodes with their spatial reflections (horizontal, vertical and horizontalvertical), coarse patterns that divide the input symmetrically, such as the one illustrated on the right of fig. 1(c), would enjoy the possibility of strong correlation, whereas many entangled patterns would now suffer from limited low correlation. the choice of pooling shapes thus serves as a means for controlling the inductive bias in terms of correlations modeled between input regions. square contiguous windows, as commonly employed in practice, lead to a preference that complies with our intuition regarding the statistics of natural images (nearby pixels more correlated than distant ones). other pooling schemes lead to different preferences, and this allows tailoring a network to data that departs from the usual domain of natural imagery. we demonstrate this experimentally in the next section, where it is shown how different pooling geometries lead to superior performance in different tasks.the main conclusion from our analyses (sec. 5 and 6) is that the pooling geometry of a deep convolutional network controls its inductive bias by determining which correlations between input regions can be modeled efficiently. we have also seen that shallow networks cannot model correlations efficiently, regardless of the considered input regions. in this section we validate these assertions empirically, not only with convolutional arithmetic circuits (subject of our analyses), but also with convolutional rectifier networks – convolutional networks with relu activation and max or average pooling. for conciseness, we defer to app. c some details regarding our implementation. the latter is fully available online at https://github.com/huji-deep/inductive-pooling.  the network’s functional description assumes a one-dimensional full quad-tree grouping of input patch indexes. that is to say, it assumes that in the first pooling operation (hidden layer 0), the nodes corresponding to patches x1,x2,x3,x4 are pooled into one group, those corresponding to x5,x6,x7,x8 are pooled into another, and so forth. similar assumptions hold for the deeper layers. for example, in the second pooling operation (hidden layer 1), the node with receptive field {1, 2, 3, 4}, i.e. the one corresponding to the quadruple of patches {x1,x2,x3,x4}, is assumed to be pooled together with the nodes whose receptive fields are {5, 6, 7, 8}, {9, 10, 11, 12} and {13, 14, 15, 16}.
our experiments are based on a synthetic classification benchmark inspired by medical imaging tasks. instances to be classified are 32-by-32 binary images, each displaying a random distorted oval shape (blob) with missing pixels in its interior (holes). for each image, two continuous scores in range [0, 1] are computed. the first, referred to as closedness, reflects how morphologically closed a blob is, and is defined to be the ratio between the number of pixels in the blob, and the number of pixels in its closure (see app. d for exact definition of the latter). the second score, named symmetry, reflects the degree to which a blob is left-right symmetric about its center. it is measured by cropping the bounding box around a blob, applying a left-right flip to the latter, and computing the ratio between the number of pixels in the intersection of the blob and its reflection, and the number of pixels in the blob. to generate labeled sets for classification (train and test), we render multiple images, sort them according to their closedness and symmetry, and for each of the two scores, assign the label “high” to the top 40% and the label “low” to the bottom 40% (the mid 20% are considered ill-defined). this creates two binary (two-class) classification tasks – one for closedness and one for symmetry (see fig. 2 for a sample of images participating in both tasks). given that closedness is a property of a local nature, we expect its classification task to require a predictor to be able to model strong correlations between neighboring pixels. symmetry on the other hand is a property that relates pixels to their reflections, thus we expect its classification task to demand that a predictor be able to model correlations across distances.
we evaluated the deep convolutional arithmetic circuit considered throughout the paper (fig. 1(a) with size-4 pooling windows) under two different pooling geometries. the first, referred to as square, comprises standard 2 × 2 pooling windows. the second, dubbed mirror, pools together nodes with their horizontal, vertical and horizontal-vertical reflections. in both cases, input patches (xi) were set as individual pixels, resulting in n = 1024 patches and l = log4n = 5 hidden layers. m = 2 representation functions (fθd ) were fixed, the first realizing the identity on binary inputs (fθ1(b) = b for b ∈ {0, 1}), and the second realizing negation (fθ2(b) = 1− b for b ∈ {0, 1}). classification was realized through y = 2 network outputs, with prediction following the stronger activation. the number of channels across all hidden layers was uniform, and varied between 8 and 128. fig. 3 shows the results of applying the deep network with both square and mirror pooling, to both closedness and symmetry tasks, where each of the latter has 20000 images for training and 4000 images for testing. as can be seen in the figure, square pooling significantly outperforms mirror pooling in closedness classification, whereas the opposite occurs in symmetry classification. this complies with our discussion in sec. 6, according to which square pooling supports modeling correlations between entangled (neighboring) regions of the input, whereas mirror pooling puts focus on correlations between input regions that are symmetric w.r.t. one another. we thus obtain a demonstration of how prior knowledge regarding a task at hand may be used to tailor the inductive bias of a deep convolutional network by designing an appropriate pooling geometry.
in addition to the deep network, we also evaluated the shallow convolutional arithmetic circuit analyzed in the paper (fig. 1(b)). the architectural choices for this network were the same as those
deep convolutional arithmetic circuit
described above for the deep network besides the number of hidden channels, which in this case applied to the network’s single hidden layer, and varied between 64 and 4096. the highest train and test accuracies delivered by this network (with 4096 hidden channels) were roughly 62% on closedness task, and 77% on symmetry task. the fact that these accuracies are inferior to those of the deep network, even when the latter’s pooling geometry is not optimal for the task at hand, complies with our analysis in sec. 5. namely, it complies with the observation that separation ranks (correlations) are sometimes exponential and sometimes polynomial with the deep network, whereas with the shallow one they are never more than linear in network size.
finally, to assess the validity of our findings for convolutional networks in general, not just convolutional arithmetic circuits, we repeated the above experiments with convolutional rectifier networks. namely, we placed relu activations after every conv operator, switched the pooling operation from product to average, and re-evaluated the deep (square and mirror pooling geometries) and shallow networks. we then reiterated this process once more, with pooling operation set to max instead of average. the results obtained by the deep networks are presented in fig. 4. the shallow network with average pooling reached train/test accuracies of roughly 58% on closedness task, and 55% on symmetry task. with max pooling, performance of the shallow network did not exceed chance. altogether, convolutional rectifier networks exhibit the same phenomena observed with convolutional arithmetic circuits, indicating that the conclusions from our analyses likely apply to such networks as well. formal adaptation of the analyses to convolutional rectifier networks, similarly to the adaptation of cohen  (2016b) carried out in cohen and shashua (2016), is left for future work.through the notion of separation rank, we studied the relation between the architecture of a convolutional network, and its ability to model correlations among input regions. for a given input partition, the separation rank quantifies how far a function is from separability, which in a probabilistic setting, corresponds to statistical independence between sides of the partition.
our analysis shows that a polynomially sized deep convolutional arithmetic circuit supports exponentially high separation ranks for certain input partitions, while being limited to polynomial or linear (in network size) separation ranks for others. the network’s pooling window shapes effectively determine which input partitions are favored in terms of separation rank, i.e. which partitions enjoy the possibility of exponentially high separation ranks with polynomial network size, and which require network to be exponentially large. pooling geometry thus serves as a means for controlling the inductive bias. the particular pooling scheme commonly employed in practice – square contiguous windows, favors interleaved partitions over ones that divide the input to distinct areas, thus orients the inductive bias towards the statistics of natural images (nearby pixels more correlated than distant  20 40 60 80 100 120 140
breadth (# of channels in each hidden layer) 0 5 0 5 0 5 
a cc
u ra
cy [
% ]
closedness task  20 40 60 80 100 120 140
breadth (# of channels in each hidden layer) 0 5 0 5 0 5 
a cc
u ra
cy [
% ]
symmetry task
square pool - train square pool - test mirror pool - train mirror pool - test
deep convolutional rectifier network (average pooling)
deep convolutional rectifier network (max pooling)
ones). other pooling schemes lead to different preferences, and this allows tailoring the network to data that departs from the usual domain of natural imagery.
as opposed to deep convolutional arithmetic circuits, shallow ones support only linear (in network size) separation ranks. therefore, in order to replicate a function realized by a deep network (exponential separation rank), a shallow network must be exponentially large. by this we derive the depth efficiency result of cohen  (2016b), but in addition, provide an insight into the benefit of functions brought forth by depth – they are able to efficiently model strong correlation under favored partitions of the input.
we validated our conclusions empirically, with convolutional arithmetic circuits as well as convolutional rectifier networks – convolutional networks with relu activation and max or average pooling. our experiments demonstrate how different pooling geometries lead to superior performance in different tasks. specifically, we evaluate deep networks in the measurement of shape continuity, a task of a local nature, and show that standard square pooling windows outperform ones that join together nodes with their spatial reflections. in contrast, when measuring shape symmetry, modeling correlations across distances is of vital importance, and the latter pooling geometry is superior to the conventional one. shallow networks are inefficient at modeling correlations of any kind, and indeed lead to poor performance on both tasks.
finally, our analyses and results bring forth the possibility of expanding the coverage of correlations efficiently modeled by a deep convolutional network. specifically, by blending together multiple pooling geometries in the hidden layers of a network, it is possible to facilitate simultaneous support for a wide variety of correlations suiting data of different types. investigation of this direction, from both theoretical and empirical perspectives, is viewed as a promising avenue for future research.this work is supported by intel grant icri-ci #9-2012-6133, by isf center grant 1790/12 and by the european research council (theorydl project). nadav cohen is supported by a google doctoral fellowship in machine learning.a.1 proof of claim 1
we prove the equality in two steps, first showing that sep(hy; i, j)≤rankjayki,j , and then establishing the converse. the first step is elementary, and does not make use of the representation functions’ (fθd ) linear independence, or of measurability/square-integrability. the second step does rely on these assumptions, and employs slightly more advanced mathematical machinery. throughout the proof, we assume without loss of generality that the partition (i, j) of [n ] is such that i takes on lower values, while j takes on higher ones. that is to say, we assume that i = {1, . . . , |i|} and j = {|i|+ 1, . . . , n}. 9
to prove that sep(hy; i, j)≤rankjayki,j , denote by r the rank of jayki,j . the latter is an m |i|-by-m |j| matrix, thus there exist vectors u1. . .ur ∈ rm |i| and v1. . .vr ∈ rm |j| such that jayki,j = ∑r ν=1 uνv > ν . for every ν ∈ [r], let bν be the tensor of order |i| and dimension m in each mode whose arrangement as a column vector gives uν , i.e. whose matricization w.r.t. the partition ([|i|], ∅) is equal to uν . similarly, let cν , ν ∈ [r], be the tensor of order |j | = n − |i| and dimension m in each mode whose matricization w.r.t. the partition (∅, [|j |]) (arrangement as a row vector) is equal to v>ν . it holds that:
jayki,j = ∑r
ν=1 uνv
> ν
= ∑r
ν=1 jbνk[|i|],∅ jcνk∅,[|j|] = ∑r
ν=1 jbνki∩[|i|],j∩[|i|] jcνk(i−|i|)∩[|j|],(j−|i|)∩[|j|] = ∑r
ν=1 jbν ⊗ cνki,j = r∑r
ν=1 bν ⊗ cν z i,j
where the third equality relies on the assumption i = {1, . . . , |i|}, j = {|i|+ 1, . . . , n}, the fourth equality makes use of the relation in eq. 1, and the last equality is based on the linearity of the matricization operator. since matricizations are merely rearrangements of tensors, the fact that jayki,j = j ∑r ν=1 b
ν⊗cνki,j implies ay = ∑r ν=1 b ν ⊗ cν , or equivalently, ayd1...dn = ∑r ν=1 b ν d1...d|i|
· cνd|i|+1...dn for every d1. . .dn ∈ [m ]. plugging this into eq. 2 gives:
hy (x1, . . . ,xn ) = ∑m
d1...dn=1 ayd1...dn ∏n i=1 fθdi (xi)
= ∑m
d1...dn=1
∑r ν=1 bνd1...d|i| · c ν d|i|+1...dn ∏n i=1 fθdi (xi)
= ∑r
ν=1 (∑m d1...d|i|=1 bνd1...d|i| ∏|i| i=1 fθdi (xi) ) · (∑m
d|i|+1...dn=1 cνd|i|+1...dn ∏n i=|i|+1 fθdi (xi) ) (11)
for every ν ∈ [r], define the functions gν : (rs)|i| → r and g′ν : (rs)|j| → r as follows:
gν(x1, . . . ,x|i|) := ∑m
d1...d|i|=1 bνd1...d|i| ∏|i| i=1 fθdi (xi)
g′ν(x1, . . . ,x|j|) := ∑m
d1...d|j|=1 cνd1...d|j| ∏|j| i=1 fθdi (xi)  to see that this does not limit generality, denote i = {i1, . . . , i|i|} and j = {j1, . . . , j|j|}, and define an auxiliary function h′y by permuting the entries of hy such that those indexed by i are on the left and those indexed by j on the right, i.e. h′y(xi1 , . . . ,xi|i| ,xj1 , . . . ,xj|j|) = hy(x1, . . . ,xn ). obviously sep(hy; i, j) = sep(h′y; i ′, j ′), where the partition (i ′, j ′) is defined by i ′ = {1, . . . , |i|} and j ′ = {|i| + 1, . . . , n}. analogously to the definition of h′y , let a′y be the tensor obtained by permuting the modes of ay such that those indexed by i are on the left and those indexed by j on the right, i.e. a′ydi1 ...di|i|dj1 ...dj|j| = a y d1...dn
. it is not difficult to see that matricizing a′y w.r.t. (i ′, j ′) is equivalent to matricizing ay w.r.t. (i, j), i.e. ja′yki′,j′ = jayki,j , and in particular rankja′yki′,j′ = rankjayki,j . moreover, since by definition ay is a coefficient tensor corresponding to hy (eq. 2), a′y will be a coefficient tensor that corresponds to h′y . now, our proof will show that sep(h′y; i ′, j ′) = rankja′yki′,j′ , which, in light of the equalities above, implies sep(hy; i, j) = rankjayki,j , as required.
substituting these into eq. 11 leads to:
hy (x1, . . . ,xn ) = ∑r
ν=1 gν(x1, . . . ,x|i|)g
′ ν(x|i|+1, . . . ,xn )
which by definition of the separation rank (eq. 5), implies sep(hy; i, j)≤r. by this we have shown that sep(hy; i, j)≤rankjayki,j , as required.
for proving the converse inequality, i.e. sep(hy; i, j)≥rankjayki,j , we rely on basic concepts and results from functional analysis, or more specifically, from the topic of l2 spaces. while a full introduction to this topic is beyond our scope (the interested reader is referred to rudin (1991)), we briefly lay out here the minimal background required in order to follow our proof. for any n ∈ n, l2(rn) is formally defined as the hilbert space of lebesgue measurable square-integrable real functions over rn 10 , equipped with standard (pointwise) addition and scalar multiplication, as well as the inner product defined by integration over point-wise multiplication. for our purposes, l2(rn) may simply be thought of as the (infinite-dimensional) vector space of functions g : rn → r satisfying ∫ g2 < ∞, with inner product defined by 〈g1, g2〉 := ∫ g1·g2. our proof will make use of the following basic facts related to l2 spaces:
fact 1. if v is a finite-dimensional subspace of l2(rn), then any g∈l2(rn) may be expressed as g = p+ δ, with p∈v and δ∈v ⊥ (i.e. δ is orthogonal to all elements in v ). moreover, such a representation is unique, so in the case where g∈v , we necessarily have p = g and δ ≡ 0.
fact 2. if g∈l2(rn), g′∈l2(rn′), then the function (x1,x2)7→g(x1)·g′(x2) belongs to l2(rn × rn′).
fact 3. let v and v ′ be finite-dimensional subspaces of l2(rn) and l2(rn′) respectively, and define u⊂l2(rn × rn′) to be the subspace spanned by {(x1,x2) 7→p(x1)·p′(x2) : p∈v, p′∈v ′}. given g∈l2(rn), g′∈l2(rn′), consider the function (x1,x2) 7→g(x1)·g′(x2) in l2(rn × rn′). this function belongs to u⊥ if g∈v ⊥ or g′∈v ′⊥.
fact 4. if g1. . .gm∈l2(rn) are linearly independent, then for any k ∈ n, the set of functions {(x1, . . . ,xk) 7→ ∏k i=1 gdi(xi)}d1...dk∈[m] is linearly independent in l 2((rn)k).
to facilitate application of the theory of l2 spaces, we now make use of the assumption that the network’s representation functions fθd , as well as the functions gν , g ′ ν in the definition of separation rank (eq. 5), are measurable and square-integrable. taking into account the expression given in eq. 2 for hy , as well as fact 2 above, one readily sees that fθ1 . . .fθm∈l (rs) implies hy∈l2((rs)n ). the separation rank sep(hy; i, j) will be the minimal non-negative integer r such that there exist g1. . .gr∈l2((rs)|i|) and g′1. . .g′r∈l2((rs)|j|) for which:
hy(x1, . . . ,xn ) = ∑r
ν=1 gν(x1, . . . ,x|i|)g
′ ν(x|i|+1, . . . ,xn ) (12)
we would like to show that sep(hy; i, j)≥rankjayki,j . our strategy for achieving this will be to start from eq. 12, and derive an expression for jayki,j comprising a sum of r rank-1 matrices. as an initial step along this path, define the following finite-dimensional subspaces:
v := span { (x1, . . . ,x|i|) 7→ ∏|i| i=1 fθdi (xi) } d1...d|i|∈[m ] ⊂ l2 ( (rs)|i| )
(13)
v ′ := span { (x1, . . . ,x|j|) 7→ ∏|j| i=1 fθdi (xi) } d1...d|j|∈[m ] ⊂ l2 ( (rs)|j| )
(14)
u := span { (x1, . . . ,xn ) 7→ ∏n
i=1 fθdi (xi) } d1...dn∈[m ] ⊂ l2 ( (rs)n )
(15)
notice that hy∈u (eq. 2), and that u is the span of products from v and v ′, i.e.:
u = span { (x1, . . . ,xn ) 7→p(x1, . . . ,x|i|)·p′(x|i|+1, . . . ,xn ) : p∈v, p′∈v ′ }
(16)
returning to eq. 12, we apply fact 1 to obtain orthogonal decompositions of g1. . .gr w.r.t. v , and of g′1. . .g′r w.r.t. v ′. this gives p1. . .pr∈v , δ1. . .δr∈v ⊥, p′1. . .p′r∈v ′ and δ′1. . .δ′r∈v ′⊥, such that gν = pν + δν and 0 more precisely, elements of the space are equivalence classes of functions, where two functions are considered equivalent if the set in rn on which they differ has measure zero.
g′ν = p ′ ν + δ ′ ν for every ν ∈ [r]. plug this into eq. 12:
hy(x1, . . . ,xn ) = ∑r
ν=1 gν(x1, . . . ,x|i|)·g′ν(x|i|+1, . . . ,xn )
= ∑r
ν=1
( pν(x1, . . . ,x|i|) + δν(x1, . . . ,x|i|) ) · ( p′ν(x|i|+1, . . . ,xn ) + δ ′ ν(x|i|+1, . . . ,xn )
) = ∑r ν=1 pν(x1, . . . ,x|i|)·p′ν(x|i|+1, . . . ,xn )
+ ∑r
ν=1 pν(x1, . . . ,x|i|)·δ′ν(x|i|+1, . . . ,xn )
+ ∑r
ν=1 δν(x1, . . . ,x|i|)·p′ν(x|i|+1, . . . ,xn )
+ ∑r
ν=1 δν(x1, . . . ,x|i|)·δ′ν(x|i|+1, . . . ,xn )
given that u is the span of products from v and v ′ (eq. 16), and that pν∈v, δν∈v ⊥, p′ν∈v ′, δ′ν∈v ′⊥, one readily sees that the first term in the latter expression belongs to u , while, according to fact 3, the second, third and fourth terms are orthogonal to u . we thus obtained an orthogonal decomposition of hy w.r.t. u . since hy is contained in u , the orthogonal component must vanish (fact 1), and we amount at:
hy(x1, . . . ,xn ) = ∑r
ν=1 pν(x1, . . . ,x|i|)·p′ν(x|i|+1, . . . ,xn ) (17)
for every ν ∈ [r], let bν and cν be coefficient tensors of pν and p′ν w.r.t. the functions that span v and v ′ (eq. 13 and 14), respectively. put formally, bν and cν are tensors of orders |i| and |j | (respectively), with dimension m in each mode, meeting:
pν(x1, . . . ,x|i|) = ∑m
d1...d|i|=1 bνd1...d|i| ∏|i| i=1 fθdi (xi)
p′ν(x1, . . . ,x|j|) = ∑m
d1...d|j|=1 cνd1...d|j| ∏|j| i=1 fθdi (xi)
substitute into eq. 17:
hy (x1, . . . ,xn ) = ∑r
ν=1 (∑m d1...d|i|=1 bνd1...d|i| ∏|i| i=1 fθdi (xi) ) · (∑m
d|i|+1...dn=1 cνd|i|+1...dn ∏n i=|i|+1 fθdi (xi) ) = ∑r ν=1 ∑m d1...dn=1 bνd1...d|i| · c ν d|i|+1...dn ∏n i=1 fθdi (xi)
= ∑m
d1...dn=1
(∑r ν=1 bνd1...d|i| · c ν d|i|+1...dn )∏n i=1 fθdi (xi)
compare this expression for hy to that given in eq. 2:∑m d1...dn=1 (∑r ν=1 bνd1...d|i| · c ν d|i|+1...dn )∏n i=1 fθdi (xi) = ∑m d1...dn=1 ayd1...dn ∏n i=1 fθdi (xi) (18) at this point we utilize the given linear independence of fθ1 . . .fθm∈l (rs), from which it follows (fact 4) that the functions spanning u (eq. 15) are linearly independent in l2((rs)n ). both sides of eq. 18 are linear combinations of these functions, thus their coefficients must coincide:
ayd1...dn = ∑r ν=1 bνd1...d|i| · c ν d|i|+1...dn ,∀d1. . .dn ∈ [m ] ⇐⇒ a y = ∑r ν=1 bν ⊗ cν
matricizing the tensor equation on the right w.r.t. (i, j) gives: jayki,j = r∑r
ν=1 bν ⊗ cν z i,j
= ∑r
ν=1 jbν ⊗ cνki,j = ∑r
ν=1 jbνki∩[|i|],j∩[|i|] jcνk(i−|i|)∩[|j|],(j−|i|)∩[|j|] = ∑r
ν=1 jbνk[|i|],∅ jcνk∅,[|j|]
where the second equality is based on the linearity of the matricization operator, the third equality relies on the relation in eq. 1, and the last equality makes use of the assumption i = {1, . . . , |i|}, j = {|i| + 1, . . . , n}.
for every ν ∈ [r], jbνk[|i|],∅ is a column vector of dimension m |i| and jcνk∅,[|j|] is a row vector of dimension m |j|. denoting these by uν and v>ν respectively, we may write:
jayki,j = ∑r
ν=1 uνv
> ν
this shows that rankjayki,j≤r. since r is a general non-negative integer that admits eq. 12, we may take it to be minimal, i.e. to be equal to sep(hy; i, j) – the separation rank of hy w.r.t. (i, j). by this we obtain rankjayki,j≤sep(hy; i, j), which is what we set out to prove.
a.2 proof of claim 2
the claim is framed in measure theoretical terms, and in accordance, so will its proof be. while a complete introduction to measure theory is beyond our scope (the interested reader is referred to jones (2001)), we briefly convey here the intuition behind the concepts we will be using, as well as facts we rely upon. the lebesgue measure is defined over sets in a euclidean space, and may be interpreted as quantifying their “volume”. for example, the lebesgue measure of a unit hypercube is one, of the entire space is infinity, and of a finite set of points is zero. in this context, when a phenomenon is said to occur almost everywhere, it means that the set of points in which it does not occur has lebesgue measure zero, i.e. is negligible. an important result we will make use of (proven in caron and traynor (2005) for example) is the following. given a polynomial defined over n real variables, the set of points in rn on which it vanishes is either the entire space (when the polynomial in question is the zero polynomial), or it must have lebesgue measure zero. in other words, if a polynomial is not identically zero, it must be different from zero almost everywhere.
heading on to the proof, we recall from sec. 3 that the entries of the coefficient tensor ay (eq. 2) are given by polynomials in the network’s conv weights {al,γ}l,γ and output weights al,y . since jayki,j – the matricization of ay w.r.t. the partition (i, j), is merely a rearrangement of the tensor as a matrix, this matrix too has entries given by polynomials in the network’s linear weights. now, denote by r the maximal rank taken by jayki,j as network weights vary, and consider a specific setting of weights for which this rank is attained. we may assume without loss of generality that under this setting, the top-left r-by-r block of jayki,j is non-singular. the corresponding minor, i.e. the determinant of the sub-matrix (jayki,j)1:r,1:r , is thus a polynomial defined over {al,γ}l,γ and al,y which is not identically zero. in light of the above, this polynomial is different from zero almost everywhere, implying that rank(jayki,j)1:r,1:r = r almost everywhere. since rankjayki,j≥rank(jayki,j)1:r,1:r , and since by definition r is the maximal rank that jayki,j can take, we have that rankjayki,j is maximal almost everywhere.
a.3 proof of theorem 1
the matrix decomposition in eq. 7 expresses jaki,j in terms of the network’s linear weights – {a0,γ ∈ rm}γ∈[r0] for conv operator in hidden layer 0, {a
l,γ ∈ rrl−1}γ∈[rl] for conv operator in hidden layer l = 1. . .l−1, and al,y ∈ rrl−1 for node y of dense output operator. we prove lower and upper bounds on the maximal rank that jaki,j can take as these weights vary. our proof relies on the rank-multiplicative property of the kronecker product (rank(a b) = rank(a)·rank(b) for any real matrices a and b – see bellman (1970) for proof), but is otherwise elementary.
beginning with the lower bound, consider the following weight setting (eγ here stands for a vector holding 1 in entry γ and 0 at all other entries, 0 stands for a vector holding 0 at all entries, and 1 stands for a vector holding 1 at all entries, with the dimension of a vector to be understood by context):
a0,γ = { eγ , γ≤min{r0,m} 0 , otherwise (19)
a1,γ = { 1 , γ = 1 0 , otherwise
al,γ = { e1 , γ = 1 0 , otherwise for l = 2. . .l− 1
al,y = e1
let n ∈ [n/4]. recalling the definition of il,k and jl,k from eq. 6, consider the sets i1,n and j1,n, as well as i0,4(n−1)+t and j0,4(n−1)+t for t ∈ [4]. (i1,n, j1,n) is a partition of [4], i.e. i1,n ·∪j1,n = [4], and for every t ∈ [4] we have i0,4(n−1)+t = {1} and j0,4(n−1)+t = ∅ if t belongs to i1,n, and otherwise i0,4(n−1)+t = ∅
and j0,4(n−1)+t = {1} if t belongs to j1,n. this implies that for an arbitrary vector v, the matricization jvki0,4(n−1)+t,j0,4(n−1)+t is equal to v if t∈i1,n, and to v> if t∈j1,n. accordingly, for any γ ∈ [r0]:  t=1 ja0,γki0,4(n−1)+t,j0,4(n−1)+t =  (a0,γ a0,γ a0,γ a0,γ) , |i1,n| = 4 |j1,n| = 0 (a0,γ a0,γ a0,γ)(a0,γ)> , |i1,n| = 3 |j1,n| = 1 (a0,γ a0,γ)(a0,γ a0,γ)> , |i1,n| = 2 |j1,n| = 2 (a0,γ)(a0,γ a0,γ a0,γ)> , |i1,n| = 1 |j1,n| = 3 (a0,γ a0,γ a0,γ a0,γ)> , |i1,n| = 0 |j1,n| = 4
assume that γ ≤ min{r0,m}. by our setting a0,γ = eγ , so the above matrix holds 1 in a single entry and 0 in all the rest. moreover, if the matrix is not a row or column vector, i.e. if both i1,n and j1,n are non-empty, the column index and row index of the entry holding 1 are both unique w.r.t. γ, i.e. they do not repeat as γ ranges over 1 . . .min{r0,m}. we thus have:
rank (∑min{r0,m} γ=1 4 t=1 ja0,γki0,4(n−1)+t,j0,4(n−1)+t ) = { min{r0,m} , i1,n 6= ∅ ∧ j1,n 6= ∅ 1 , i1,n = ∅ ∨ j1,n = ∅
since we set a1,1 = 1 and a0,γ = 0 for γ > min{r0,m}, we may write:
rank (∑r0 γ=1 a1,1γ · 4 t=1 ja0,γki0,4(n−1)+t,j0,4(n−1)+t ) = { min{r0,m} , i1,n 6= ∅ ∧ j1,n 6= ∅ 1 , i1,n = ∅ ∨ j1,n = ∅
the latter matrix is by definition equal to jφ1,1ki1,n,j1,n (see top row of eq. 7), and so for every n ∈ [n/4]:
rank q φ1,1 y i1,n,j1,n = { min{r0,m} , i1,n 6= ∅ ∧ j1,n 6= ∅ 1 , i1,n = ∅ ∨ j1,n = ∅ (20)
now, the fact that we sy = e1 and al,1 = e1 for l = 2. . .l− 1, implies that the second to last levels of the decomposition in eq. 7 collapse to:
jayki,j = n/4
t=1 jφ1,1ki1,t,j1,t applying the rank-multiplicative property of the kronecker product, and plugging in eq. 20, we obtain:
rankjayki,j = ∏n/4
t=1 rankjφ1,1ki1,t,j1,t = min{r0,m}s
where s := |{t ∈ [n/4] : i1,t 6= ∅ ∧ j1,t 6= ∅}|. this equality holds for the specific weight setting we defined in eq. 19. maximizing over all weight settings gives the sought after lower bound:
max {al,γ}l,γ ,al,y
rankjayki,j ≥ min{r0,m}s
moving on to the upper bound, we show by induction over l = 1. . .l−1 that for any k ∈ [n/4l] and γ ∈ [rl], the rank of jφl,γkil,k,jl,k is no greater than cl,k, regardless of the chosen weight setting. for the base case l = 1 we have:
jφ1,γki1,k,j1,k = ∑r0
α=1 a1,γα · 4 t=1 ja0,αki0,4(k−1)+t,j0,4(k−1)+t the m |i1,k|-by-m |j1,k| matrix jφ1,γki1,k,j1,k is given here as a sum of r0 rank-1 terms, thus obviously its rank is no greater than min{mmin{|i1,k|,|j1,k|}, r0}. since by definition c0,t = 1 for all t ∈ [n ], we may write:
rankjφ1,γki1,k,j1,k ≤ min { mmin{|i1,k|,|j1,k|}, r0 ∏4 t=1 c0,4(k−1)+t }
c1,k is defined by the right hand side of this inequality, so our inductive hypotheses holds for l = 1. for l > 1: jφl,γkil,k,jl,k = ∑rl−1
α=1 al,γα · 4 t=1 jφl−1,αkil−1,4(k−1)+t,jl−1,4(k−1)+t taking ranks:
rankjφl,γkil,k,jl,k = rank (∑rl−1
α=1 al,γα · 4 t=1
jφl−1,αkil−1,4(k−1)+t,jl−1,4(k−1)+t )
≤ ∑rl−1
α=1 rank ( 4 t=1 jφl−1,αkil−1,4(k−1)+t,jl−1,4(k−1)+t )
= ∑rl−1
α=1 ∏4 t=1 rankjφl−1,αkil−1,4(k−1)+t,jl−1,4(k−1)+t
≤ ∑rl−1
α=1 ∏4 t=1 cl−1,4(k−1)+t
= rl−1 ∏4
t=1 cl−1,4(k−1)+t
where we used rank sub-additivity in the second line, the rank-multiplicative property of the kronecker product in the third line, and our inductive hypotheses for l − 1 in the fourth line. since the number rows and columns in jφl,γkil,k,jl,k is m |il,k| and m |jl,k| respectively, we may incorporate these terms into the inequality, obtaining:
rankjφl,γkil,k,jl,k ≤ min { mmin{|il,k|,|jl,k|}, rl−1 ∏4 t=1 cl−1,4(k−1)+t }
the right hand side here is equal to cl,k by definition, so our inductive hypotheses indeed holds for all l = 1. . .l − 1. to establish the sought after upper bound on the rank of jayki,j , we recall that the latter is given by:
jayki,j = ∑rl−1
α=1 al,yα · 4 t=1 jφl−1,αkil−1,t,jl−1,t carry out a series of steps similar to before, while making use of our inductive hypotheses for l = l− 1:
rankjayki,j = rank (∑rl−1
α=1 al,yα · 4 t=1
jφl−1,αkil−1,t,jl−1,t )
≤ ∑rl−1
α=1 rank ( 4 t=1 jφl−1,αkil−1,t,jl−1,t )
= ∑rl−1
α=1 ∏4 t=1 rankjφl−1,αkil−1,t,jl−1,t
≤ ∑rl−1
α=1 ∏4 t=1 cl−1,t
= rl−1 ∏4
t=1 cl−1,t
since jayki,j has m |i| rows and m |j| columns, we may include these terms in the inequality, thus reaching the upper bound we set out to prove.our analysis of correlations modeled by convolutional networks is based on the concept of separation rank, conveyed in sec. 4. when the separation rank of a function w.r.t. a partition of its input is equal to 1, the function is separable, meaning it does not model any interaction between sides of the partition. we argued that the higher the separation rank, the farther the function is from this situation, i.e. the stronger the correlation it induces between sides of the partition. in the current appendix we formalize this argument, by relating separation rank to the l2 distance from the set of separable functions. we begin by defining and characterizing a normalized (scale invariant) version of this distance (app. b.1). it is then shown (app. b.2) that separation rank provides an upper bound on the normalized distance. finally, a lower bound that applies to deep convolutional arithmetic circuits is derived (app. b.3), based on the lower bound for their separation ranks established in sec. 5.2. together, these steps imply that our entire analysis, facilitated by upper and lower bounds on separation ranks of convolutional arithmetic circuits, can be interpreted as based on upper and lower bounds on (normalized) l2 distances from separable functions.
in the text hereafter, we assume familiarity of the reader with the contents of sec. 2, 3, 4, 5 and the proofs given in app. a. we also rely on basic knowledge in the topic of l2 spaces (see discussion in app. a.1 for minimal background required in order to follow our arguments), as well as several results concerning singular values of matrices. in line with sec. 5, an assumption throughout this appendix is that all functions in question are measurable and square-integrable (i.e. belong to l2 over the respective euclidean space), and in app. b.3, we also make use of the fact that representation functions (fθd ) of a convolutional arithmetic circuit can be regarded as linearly independent (see sec. 5.1). finally, for convenience, we now fix (i, j) – an arbitrary partition of [n ]. specifically, i and j are disjoint subsets of [n ] whose union gives [n ], denoted by i = {i1, . . . , i|i|} with i1 < · · · < i|i|, and j = {j1, . . . , j|j|} with j1 < · · · < j|j|.
b.1 normalized l2 distance from separable functions
for a function h∈l2((rs)n ) (which is not identically zero), the normalized l2 distance from the set of separable functions w.r.t. (i, j), is defined as follows:
d(h; i, j) := 1
‖h‖ · infg∈l2((rs)|i|) g′∈l2((rs)|j|) ∥∥∥h(x1, . . . ,xn )− g(xi1 , . . . ,xi|i|)g′(xj1 , . . . ,xj|j|)∥∥∥ (21) where ‖·‖ refers to the norm of l2 space, e.g. ‖h‖ := ( ∫ (rs)n h )1/2. in words, d(h; i, j) is defined as the minimal l2 distance between h and a function that is separable w.r.t. (i, j), divided by the norm of h. the
normalization (division by ‖h‖) admits scale invariance to d(h; i, j), and is of critical importance – without it, rescaling h would accordingly rescale the distance measure, rendering the latter uninformative in terms of deviation from separability.
it is worthwhile noting the resemblance between d(h; i, j) and the concept of mutual information (see cover and thomas (2012) for a comprehensive introduction). both measures quantify the interaction that a normalized function 11 induces between input variables, by measuring distance from separable functions. the difference between the measures is threefold. first, mutual information considers probability density functions (non-negative and in l1), while d(h; i, j) applies to functions in l2. second, the notion of distance in mutual information is quantified through the kullback-leibler divergence, whereas in d(h; i, j) it is simply the l2 metric. third, while mutual information evaluates the distance from a specific separable function – product of marginal distributions, d(h; i, j) evaluates the minimal distance across all separable functions.
we now turn to establish a spectral characterization of d(h; i, j), which will be used in app. b.2 and b.3 for deriving upper and lower bounds (respectively). assume we have the following expression for h:
h(x1, . . . ,xn ) = ∑m
µ=1 ∑m′ µ′=1 aµ,µ′ · φµ(xi1 , . . . ,xi|i|)φ ′ µ′(xj1 , . . . ,xj|j|) (22)
wherem andm′ are positive integers, a is anm-by-m′ real matrix, and {φµ}mµ=1, {φ′µ′}m ′
µ′=1 are orthonormal sets of functions in l2((rs)|i|), l2((rs)|j|) respectively. we refer to such expression as an orthonormal separable decomposition of h, with a being its coefficient matrix. we will show that for any orthonormal separable decomposition, d(h; i, j) is given by the following formula:
d(h; i, j) = √ 1− σ 2 1(a)
σ21(a) + · · ·+ σ2min{m,m′}(a) (23)
where σ1(a) ≥ · · · ≥ σmin{m,m′}(a) ≥ 0 are the singular values of the coefficient matrix a. this implies that if the largest singular value of a accounts for a significant portion of the spectral energy, the normalized l2 distance of h from separable functions is small. on the other hand, if all but a fraction of the spectral energy is attributed to trailing singular values, h is far from being separable (d(h; i, j) is close to 1).
as a first step in deriving eq. 23, we show that ‖h‖2 = σ21(a) + · · ·+ σ2min{m,m′}(a):
‖h‖2 = (1)
∫ h2(x1, . . . ,xn )dx1· · ·dxn
= (2) ∫ (∑m µ=1 ∑m′ µ′=1 aµ,µ′ · φµ(xi1 , . . . ,xi|i|)φ ′ µ′(xj1 , . . . ,xj|j|) )2 dx1· · ·dxn
= (3) ∫ ∑m µ,µ̄=1 ∑m′ µ′,µ̄′=1 aµ,µ′aµ̄,µ̄′ · φµ(xi1 , . . . ,xi|i|)φ ′ µ′(xj1 , . . . ,xj|j|)
·φµ̄(xi1 , . . . ,xi|i|)φ ′ µ̄′(xj1 , . . . ,xj|j|)dx1· · ·dxn
= (4) ∑m µ,µ̄=1 ∑m′ µ′,µ̄′=1 aµ,µ′aµ̄,µ̄′ ∫ φµ(xi1 , . . . ,xi|i|)φ ′ µ′(xj1 , . . . ,xj|j|)
·φµ̄(xi1 , . . . ,xi|i|)φ ′ µ̄′(xj1 , . . . ,xj|j|)dx1· · ·dxn
= (5) ∑m µ,µ̄=1 ∑m′ µ′,µ̄′=1 aµ,µ′aµ̄,µ̄′ ∫ φµ(xi1 , . . . ,xi|i|)φµ̄(xi1 , . . . ,xi|i|)dxi1 · · ·dxi|i|
· ∫ φ′µ′(xj1 , . . . ,xj|j|)φ ′ µ̄′(xj1 , . . . ,xj|j|)dxj1 · · ·dxj|j|
= (6) ∑m µ,µ̄=1 ∑m′ µ′,µ̄′=1 aµ,µ′aµ̄,µ̄′ · { 1 , µ = µ̄ 0 , otherwise } · { 1 , µ′ = µ̄′ 0 , otherwise } = (7) ∑m µ=1 ∑m′ µ′=1 a2µ,µ′
= (8)
σ21(a) + · · ·+ σ2min{m,m′}(a) (24)
equality (1) here originates from the definition of l2 norm. (2) is obtained by plugging in the expression in eq. 22. (3) is merely an arithmetic manipulation. (4) follows from the linearity of integration. (5) makes use 1 an equivalent definition ofd(h; i, j) is the minimall2 distance between h/ ‖h‖ and a function separable w.r.t. (i, j). accordingly, we may view d(h; i, j) as operating on normalized functions.
of fubini’s theorem (see jones (2001)). (6) results from the orthonormality of {φµ}mµ=1 and {φ′µ′}m ′
µ′=1. (7) is a trivial computation. finally, (8) is an outcome of the fact that the squared frobenius norm of a matrix, i.e. the sum of squares over its entries, is equal to the sum of squares over its singular values (see golub and van loan (2013) for proof).
let g∈l2((rs)|i|). by fact 1 in app. a.1, there exist scalars α1 . . . αm ∈ r, and a function δ∈l2((rs)|i|) orthogonal to span{φ1 . . . φm}, such that g = ∑m µ=1 αµ ·φµ+δ. similarly, for any g
′∈l2((rs)|j|) there exist α′1 . . . α ′ m′ ∈ r and δ′∈span{φ′1 . . . φ′m′}⊥ such that g′ = ∑m′ µ′=1 α ′ µ′ ·φ′µ′ + δ′. fact 2 in app. a.1 indicates that the function given by (x1, . . . ,xn ) 7→g(xi1 , . . . ,xi|i|)g ′(xj1 , . . . ,xj|j|) belongs tol ((rs)n ). we may express it as follows:
g(xi1 , . . . ,xi|i|)g ′(xj1 , . . . ,xj|j|) = ∑m µ=1 ∑m′ µ′=1 αµα ′ µ′ · φµ(xi1 , . . . ,xi|i|)φ ′ µ′(xj1 , . . . ,xj|j|)
+ (∑m
µ=1 αµ · φµ(xi1 , . . . ,xi|i|)
) · δ′(xj1 , . . . ,xj|j|)
+δ(xi1 , . . . ,xi|i|) · (∑m′ µ′=1 α′µ′ · φ′µ′(xj1 , . . . ,xj|j|) ) +δ(xi1 , . . . ,xi|i|)δ ′(xj1 , . . . ,xj|j|)
according to fact 3 in app. a.1, the second, third and fourth terms on the right hand side of the above are orthogonal to span{(x1, . . . ,xn ) 7→φµ(xi1 , . . . ,xi|i|)φ ′ µ′(xj1 , . . . ,xj|j|)}µ∈[m],µ′∈[m′]. denote their summation by e(x1, . . . ,xn ), and subtract the overall function from h (given by eq. 22): h(x1, . . . ,xn )− g(xi1 , . . . ,xi|i|)g ′(xj1 , . . . ,xj|j|)
= ∑m
µ=1 ∑m′ µ′=1 aµ,µ′ · φµ(xi1 , . . . ,xi|i|)φ ′ µ′(xj1 , . . . ,xj|j|)
− ∑m
µ=1 ∑m′ µ′=1 αµα ′ µ′ · φµ(xi1 , . . . ,xi|i|)φ ′ µ′(xj1 , . . . ,xj|j|)− e(x1, . . . ,xn )
= ∑m
µ=1 ∑m′ µ′=1 (aµ,µ′ − αµα′µ′) · φµ(xi1 , . . . ,xi|i|)φ ′ µ′(xj1 , . . . ,xj|j|)− e(x1, . . . ,xn )
since the two terms in the latter expression are orthogonal to one another, we have:∥∥∥h(x1, . . . ,xn )− g(xi1 , . . . ,xi|i|)g′(xj1 , . . . ,xj|j|)∥∥∥2 = ∥∥∥∥∑mµ=1∑m′µ′=1(aµ,µ′ − αµα′µ′) · φµ(xi1 , . . . ,xi|i|)φ′µ′(xj1 , . . . ,xj|j|) ∥∥∥∥2 + ‖e(x1, . . . ,xn )‖2
applying a sequence of steps as in eq. 24 to the first term in the second line of the above, we obtain:∥∥∥h(x1, . . . ,xn )− g(xi1 , . . . ,xi|i|)g′(xj1 , . . . ,xj|j|)∥∥∥2 = m∑ µ=1 m′∑ µ′=1 (aµ,µ′−αµα′µ′)2+‖e(x1, . . . ,xn )‖2
e(x1, . . . ,xn ) = 0 if δ and δ′ are the zero functions, implying that:∥∥∥h(x1, . . . ,xn )− g(xi1 , . . . ,xi|i|)g′(xj1 , . . . ,xj|j|)∥∥∥2 ≥∑mµ=1∑m′µ′=1(aµ,µ′ − αµα′µ′)2 with equality holding if g = ∑m µ=1 αµ ·φµ and g ′ = ∑m′ µ′=1 α ′ µ′ ·φ′µ′ . now, ∑m µ=1 ∑m′ µ′=1(aµ,µ′ −αµα ′ µ′) 2 is the squared frobenius distance between the matrix a and the rank-1 matrix αα′>, where α and α′ are column vectors holding α1 . . . αm and α′1 . . . α′m′ respectively. this squared distance is greater than or equal to the sum of squares over the second to last singular values of a, and moreover, the inequality holds with equality for proper choices of α and α′ (eckart and young (1936)). from this we conclude that:∥∥∥h(x1, . . . ,xn )− g(xi1 , . . . ,xi|i|)g′(xj1 , . . . ,xj|j|)∥∥∥2 ≥ σ22(a) + · · ·+ σ2min{m,m′}(a) with equality holding if g and g′ are set to ∑m µ=1 αµ ·φµ and ∑m′ µ′=1 α ′ µ′ ·φ′µ′ (respectively) for proper choices of α1 . . . αm and α′1 . . . α′m′ . we thus have the infimum over all possible g, g ′:
inf g∈l2((rs)|i|) g′∈l2((rs)|j|) ∥∥∥h(x1, . . . ,xn )− g(xi1 , . . . ,xi|i|)g′(xj1 , . . . ,xj|j|)∥∥∥2 = σ22(a) + · · ·+ σ2min{m,m′}(a) (25)
recall that we would like to derive the formula in eq. 23 ford(h; i, j), assuming h is given by the orthonormal separable decomposition in eq. 22. taking square root of the equalities established in eq. 24 and 25, and plugging them into the definition of d(h; i, j) (eq. 21), we obtain the sought after result.
b.2 upper bound through separation rank
we now relate d(h; i, j) – the normalized l2 distance of h∈l2((rs)n ) from the set of separable functions w.r.t. (i, j) (eq. 21), to sep(h; i, j) – the separation rank of h w.r.t. (i, j) (eq. 5). specifically, we make use of the formula in eq. 23 to derive an upper bound on d(h; i, j) in terms of sep(h; i, j).
assuming h has finite separation rank (otherwise the bound we derive is trivial), we may express it as:
h(x1, . . . ,xn ) = ∑r
ν=1 gν(xi1 , . . . ,xi|i|)g
′ ν(xj1 , . . . ,xj|j|) (26)
wherer is some positive integer (necessarily greater than or equal to sep(h; i, j)), and g1. . .gr∈l2((rs)|i|), g′1. . .g ′ r∈l2((rs)|j|). let {φ1, . . . , φm}⊂l2((rs)|i|) and {φ′1, . . . , φ′m′}⊂l2((rs)|j|) be two sets of orthonormal functions spanning span{g1. . .gr} and span{g′1. . .g′r} respectively. by definition, for every ν∈r there exist αν,1 . . . αν,m ∈ r and α′ν,1 . . . α′ν,m′ ∈ r such that gν = ∑m µ=1 αν,µ · φµ and
g′ν = ∑m′ µ′=1 α ′ ν,µ′ · φ′µ′ . plugging this into eq. 26, we obtain:
h(x1, . . . ,xn ) = ∑m
µ=1 ∑m′ µ′=1 (∑r ν=1 αν,µα ′ ν,µ′ ) · φµ(xi1 , . . . ,xi|i|)φ ′ µ′(xj1 , . . . ,xj|j|)
this is an orthonormal separable decomposition of h (eq. 22), with coefficient matrix a = ∑r ν=1 αν(α ′ ν) >, where αν := [αν,1 . . . αν,m]> and α′ν := [α′ν,1 . . . α′ν,m′ ] > for every ν∈r. obviously the rank of a is no greater than r, implying: σ21(a)
σ21(a) + · · ·+ σ2min{m,m′}(a) ≥ 1 r
where as in app. b.1, σ1(a) ≥ · · · ≥ σmin{m,m′}(a) ≥ 0 stand for the singular values of a. introducing this inequality into eq. 23 gives:
d(h; i, j) = √ 1− σ 2 1(a) σ21(a) + · · ·+ σ2min{m,m′}(a) ≤ √ 1− 1 r
the latter holds for any r ∈ n that admits eq. 26, so in particular we may take it to be minimal, i.e. to be equal to sep(h; i, j) 12 , bringing forth the sought after upper bound:
d(h; i, j) ≤ √ 1− 1
sep(h; i, j) (27)
by eq. 27, low separation rank implies proximity (in normalized l2 sense) to a separable function. we may use the inequality to translate the upper bounds on separation ranks established for deep and shallow convolutional arithmetic circuits (sec. 5.2 and 5.3 respectively), into upper bounds on normalized l2 distances from separable functions. to completely frame our analysis in terms of the latter measure, a translation of the lower bound on separation ranks of deep convolutional arithmetic circuits (sec. 5.2) is also required. eq. 27 does not facilitate such translation, and in fact, it is easy to construct functions hwhose separation ranks are high yet are very close (in normalized l2 sense) to separable functions. 13 however, as we show in app. b.3 below, the specific lower bound of interest can indeed be translated, and our analysis may entirely be framed in terms of normalized l2 distance from separable functions.
b.3 lower bound for deep convolutional arithmetic circuits
let hy∈l2((rs)n ) be a function realized by a deep convolutional arithmetic circuit (fig. 1(a) with size-4 pooling windows and l = log4 n hidden layers), i.e. hy is given by eq. 2, where fθ1 . . .fθm∈l (rs) are linearly independent representation functions, and ay is a coefficient tensor of order n and dimension m in each mode, determined by the linear weights of the network ({al,γ}l,γ ,al,y) through the hierarchical decomposition in eq. 3. rearrange eq. 2 by grouping indexes d1. . .dn in accordance with the partition (i, j):
hy (x1, . . . ,xn ) = ∑m
di1 ...di|i|=1 ∑m dj1 ...dj|j|=1 ayd1...dn · (∏|i| t=1 fθdit (xit) )(∏|j| t=1 fθdjt (xjt) ) (28) 2 we disregard the trivial case where sep(h; i, j) = 0 (h is identically zero). 13 this will be the case, for example, if h is given by an orthonormal separable decomposition (eq. 22), with coefficient matrix a that has high rank but whose spectral energy is highly concentrated on one singular value.
let m = m |i|, and define the following mapping:
µ : [m ]|i| → [m] , µ(di1 , . . . , di|i|) = 1 + ∑|i|
t=1 (dit − 1)·m
|i|−t
µ is a one-to-one correspondence between the index sets [m ]|i| and [m]. we slightly abuse notation, and denote by (di1(µ), . . . , di|i|(µ)) the tuple in [m ]
|i| that maps to µ ∈ [m]. additionally, we denote the function∏|i| t=1 fθdit (µ) (xit), which according to fact 2 in app. a.1 belongs to l 2((rs)|i|), by φµ(xi1 , . . . ,xi|i|). in the exact same manner, we let m′ = m |j|, and define the bijective mapping:
µ′ : [m ]|j| → [m′] , µ′(dj1 , . . . , dj|j|) = 1 + ∑|j|
t=1 (djt − 1)·m
|j|−t
as before, (dj1(µ ′), . . . , dj|j|(µ ′)) stands for the tuple in [m ]|j| that maps to µ′ ∈ [m′], and the function∏|j| t=1 fθdjt (µ′)
(xjt)∈l2((rs)|j|) is denoted by φ′µ′(xj1 , . . . ,xj|j|). now, recall the definition of matricization given in sec. 2, and consider jayki,j – the matricization of the coefficient tensoray w.r.t. (i, j). this is a matrix of sizem-by-m′, holdingad1...dn in row index µ(di1 , . . . , di|i|) and column index µ
′(dj1 , . . . , dj|j|). rewriting eq. 28 with the indexes µ and µ′ instead of (di1 , . . . , di|i|) and (dj1 , . . . , dj|j|), we obtain:
hy (x1, . . . ,xn ) = ∑m
µ=1 ∑m′ µ′=1 (jayki,j)µ,µ′ · φµ(xi1 , . . . ,xi|i|)φ ′ µ′(xj1 , . . . ,xj|j|) (29)
this equation has the form of eq. 22. however, for it to qualify as an orthonormal separable decomposition, the sets of functions {φ1, . . . , φm}⊂l2((rs)|i|) and {φ′1, . . . , φ′m′}⊂l2((rs)|j|) must be orthonormal. if the latter holds eq. 23 may be applied, giving an expression for d(hy; i, j) – the normalized l2 distance of hy from the set of separable functions w.r.t. (i, j), in terms of the singular values of jayki,j .
we now direct our attention to the special case where fθ1 . . .fθm∈l 2(rs) – the network’s representation functions, are known to be orthonormal. the general setting, in which only linear independence is known, will be treated thereafter. orthonormality of representation functions implies that φ1 . . . φm∈l2((rs)|i|) are orthonormal as well:
〈φµ, φµ̄〉 = (1)
∫ φµ(xi1 , . . . ,xi|i|)φµ̄(xi1 , . . . ,xi|i|)dxi1 · · ·dxi|i|
= (2) ∫ ∏|i| t=1 fθdit (µ) (xit) ∏|i| t=1 fθdit (µ̄) (xit)dxi1 · · ·dxi|i|
= (3) ∏|i| t=1 ∫ fθdit (µ) (xit)fθdit (µ̄) (xit)dxit
= (4) ∏|i| t=1 〈 fθdit (µ) , fθdit (µ̄) 〉 = (5) ∏|i| t=1 { 1 , dit(µ) = dit(µ̄) 0 , otherwise
} = (6) { 1 , dit(µ) = dit(µ̄) ∀t ∈ [|i|] 0 , otherwise
= (7) { 1 , µ = µ̄ 0 , otherwise
(1) and (4) here follow from the definition of inner product in l2 space, (2) replaces φµ and φµ̄ by their definitions, (3) makes use of fubini’s theorem (see jones (2001)), (5) relies on the (temporary) assumption that representation functions are orthonormal, (6) is a trivial step, and (7) owes to the fact that µ 7→ (di1(µ), . . . , di|i|(µ)) is an injective mapping. a similar sequence of steps (applied to 〈φ ′ µ′ , φ ′ µ̄′〉) shows that in addition to φ1 . . . φm, the functions φ′1 . . . φ′m′∈l2((rs)|j|) will also be orthonormal if fθ1 . . .fθm are. we conclude that if representation functions are orthonormal, eq. 29 indeed provides an orthonormal separable decomposition of hy , and the formula in eq. 23 may be applied:
d(hy; i, j) = √ 1− σ 2 1(jayki,j)
σ21(jayki,j) + · · ·+ σ2min{m,m′}(jayki,j) (30)
where σ1(jayki,j) ≥ · · · ≥ σmin{m,m′}(jayki,j) ≥ 0 are the singular values of the coefficient tensor matricization jayki,j . in sec. 5.2 we showed that the maximal separation rank realizable by a deep network is greater than or equal to min{r0,m}s , wherem, r0 are the number of channels in the representation and first hidden layers (respectively), and s stands for the number of index quadruplets (sets of the form {4k-3, 4k-2, 4k-1, 4k} for some k ∈
[n/4]) that are split by the partition (i, j). to prove this lower bound, we presented in app. a.3 a specific setting for the linear weights of the network ({al,γ}l,γ ,al,y) under which rankjayki,j = min{r0,m}s . careful examination of the proof shows that with this particular weight setting, not only is the rank of jayki,j equal to min{r0,m}s , but also, all of its non-zero singular values are equal to one another. 14 this implies that σ21(jayki,j)/(σ21(jayki,j) + · · · + σ2min{m,m′}(jayki,j)) = min{r0,m}−s , and since we currently assume that fθ1 . . .fθm are orthonormal, eq. 30 applies and we obtain d(hy; i, j) = √ 1−min{r0,m}−s . maximizing over all possible weight settings, we arrive at the following lower bound for the normalized l2 distance from separable functions brought forth by a deep convolutional arithmetic circuit:
sup {al,γ}l,γ , al,y
d ( hy|{al,γ}l,γ ,al,y ; i, j ) ≥ √ 1− 1
min{r0,m}s (31)
turning to the general case, we omit the assumption that representation functions fθ1 . . .fθm∈l 2(rs) are orthonormal, and merely rely on their linear independence. the latter implies that the dimension of span{fθ1 . . .fθm } is m , thus there exist orthonormal functions ϕ1. . .ϕm∈l (rs) that span it. let f ∈ rm×m be a transition matrix between the bases – the matrix defined byϕc = ∑m d=1 fc,d·fθd , ∀c ∈ [m ]. suppose now that we replace the original representation functions fθ1 . . .fθm by the orthonormal ones ϕ1. . .ϕm . using the latter, the lower bound in eq. 31 applies, and there exists a setting for the linear weights of the network – {al,γ}l,γ ,al,y , such that d(hy; i, j)≥ √ 1−min{r0,m}−s . recalling the structure of convolutional arithmetic circuits (fig. 1(a)), one readily sees that if we return to the original representation functions fθ1 . . .fθm , while multiplying conv weights in hidden layer 0 by f
> (i.e. mapping a0,γ 7→f>a0,γ), the overall function hy remains unchanged, and in particular d(hy; i, j)≥ √ 1−min{r0,m}−s still holds. we conclude that the lower bound in eq. 31 applies, even if representation functions are not orthonormal.
to summarize, we translated the lower bound from sec. 5.2 on the maximal separation rank realized by a deep convolutional arithmetic circuit, into a lower bound on the maximal normalized l2 distance from separable functions (eq. 31). this, along with the translation of upper bounds facilitated in app. b.2, implies that the analysis carried out in the paper, which studies correlations modeled by convolutional networks through the notion of separation rank, may equivalently be framed in terms of normalized l2 distance from separable functions. we note however that there is one particular aspect in our original analysis that does not carry through the translation. namely, in sec. 5.1 it was shown that separation ranks realized by convolutional arithmetic circuits are maximal almost always, i.e. for all linear weight settings but a set of (lebesgue) measure zero. put differently, for a given partition (i, j), the maximal separation rank brought forth by a network characterizes almost all functions realized by it. an equivalent statement does not hold with the continuous measure of normalized l2 distance from separable functions. the behavior of this measure across the hypotheses space of a network is non-trivial, and forms a subject for future research.
c implementation details
in this appendix we provide implementation details omitted from the description of our experiments in sec. 7. our implementation, available online at https://github.com/huji-deep/inductive-pooling, is based on the simnets branch (cohen  (2016a)) of caffe toolbox (jia  (2014)). the latter realizes convolutional arithmetic circuits in log-space for numerical stability.
when training convolutional arithmetic circuits, we followed the hyper-parameter choices made by sharir  (2016). in particular, our objective function was the cross-entropy loss with no l2 regularization (i.e. with weight decay set to 0), optimized using adam (kingma and ba (2014)) with step-size α = 0.003 and moment decay rates β1 = β2 = 0.9. 15000 iterations with batch size 64 (48 epochs) were run, with the step-size α decreasing by a factor of 10 after 12000 iterations (38.4 epochs). we did not use dropout (srivastava  (2014)), as the limiting factor in terms of accuracies was the difficulty of fitting training data (as opposed to overfitting) – see fig. 3.
for training the conventional convolutional rectifier networks, we merely switched the hyper-parameters of adam to the recommended settings specified in kingma and ba (2014) (α = 0.001, β1 = 0.9, β2 = 0.999), and set weight decay to the standard value of 0.0001. 4 to see this, note that with the specified weight setting, for every n ∈ [n/4], jφ1,1ki1,n,j1,n has one of two forms: it is either a non-zero (row/column) vector, or it is a matrix holding 1 in several entries and 0 in all the rest, where any two entries holding 1 reside in different rows and different columns. the first of the two forms admits a single non-zero singular value. the second brings forth several singular values equal to 1, possibly accompanied by null singular values. in both cases, all non-zero singular values of jφ1,1ki1,n,j1,n are equal to one another. now, since jayki,j = n/4n=1jφ1,1ki1,n,j1,n , and since the kronecker product multiplies singular values (see bellman (1970)), we have that all non-zero singular values of jayki,j are equal, as required.the synthetic dataset used in our experiments (sec. 7) consists of binary images displaying different shapes (blobs). one of the tasks facilitated by this dataset is the detection of morphologically closed blobs, i.e. of images that are relatively similar to their morphological closure. the procedure we followed for computing the morphological closure of a binary image is: . pad the given image with background (0 value) pixels . morphological dilation: simultaneously turn on (set to 1) all pixels that have a (left, right, top or bottom) neighbor originally active (holding 1) . morphological erosion: simultaneously turn off (set to 0) all pixels that have a (left, right, top or bottom) neighbor currently inactive (holding 0) . remove pixels introduced in padding
it is not difficult to see that any pixel active in the original image is necessarily active in its closure. moreover, pixels that are originally inactive yet are surrounded by active ones will also be turned on in the closure, hence the effect of “gap filling”. finally, we note that the particular sequence of steps described above represents the most basic form of morphological closure. the interested reader is referred to haralick  (1987) for a much more comprehensive introduction.",1
496.pdf.json,HIERARCHICAL MULTISCALE RECURRENT NEURAL NETWORKS,"one of the key principles of learning in deep neural networks as well as in the human brain is to obtain a hierarchical representation with increasing levels of abstraction (bengio, 2009; lecun , 2015; schmidhuber, 2015). a stack of representation layers, learned from the data in a way to optimize the target task, make deep neural networks entertain advantages such as generalization to unseen examples (hoffman , 2013), sharing learned knowledge among multiple tasks, and discovering disentangling factors of variation (kingma & welling, 2013). the remarkable recent successes of the deep convolutional neural networks are particularly based on this ability to learn hierarchical representation for spatial data (krizhevsky , 2012). for modelling temporal data, the recent resurgence of recurrent neural networks (rnn) has led to remarkable advances (mikolov , 2010; graves, 2013; cho , 2014; sutskever , 2014; vinyals , 2015). however, unlike the spatial data, learning both hierarchical and temporal representation has been among the long-standing challenges of rnns in spite of the fact that hierarchical multiscale structures naturally exist in many temporal data (schmidhuber, 1991; mozer, 1993; el hihi & bengio, 1995; lin , 1996; koutník , 2014).
a promising approach to model such hierarchical and temporal representation is the multiscale rnns (schmidhuber, 1992; el hihi & bengio, 1995; koutník , 2014). based on the observation that high-level abstraction changes slowly with temporal coherency while low-level abstraction has quickly changing features sensitive to the precise local timing (el hihi & bengio, 1995), the multiscale rnns group hidden units into multiple modules of different timescales. in addition to the fact that the architecture fits naturally to the latent hierarchical structures in many temporal data, the multiscale approach provides the following advantages that resolve some inherent problems of standard rnns: (a) computational efficiency obtained by updating the high-level layers less frequently, (b) efficiently delivering long-term dependencies with fewer updates at the high-level layers, which mitigates the vanishing gradient problem, (c) flexible resource allocation (e.g., more hidden units to the higher layers that focus on modelling long-term dependencies and less hidden units to the lower layers which are in charge of learning short-term dependencies). in addition, the learned latent hierarchical structures can provide useful information to other downstream tasks such ∗yoshua bengio is cifar senior fellow.
as module structures in computer program learning, sub-task structures in hierarchical reinforcement learning, and story segments in video understanding.
there have been various approaches to implementing the multiscale rnns. the most popular approach is to set the timescales as hyperparameters (el hihi & bengio, 1995; koutník , 2014; bahdanau , 2016) instead of treating them as dynamic variables that can be learned from the data (schmidhuber, 1991; 1992; chung , 2015; 2016). however, considering the fact that non-stationarity is prevalent in temporal data, and that many entities of abstraction such as words and sentences are in variable length, we claim that it is important for an rnn to dynamically adapt its timescales to the particulars of the input entities of various length. while this is trivial if the hierarchical boundary structure is provided (sordoni , 2015), it has been a challenge for an rnn to discover the latent hierarchical structure in temporal data without explicit boundary information.
in this paper, we propose a novel multiscale rnn model, which can learn the hierarchical multiscale structure from temporal data without explicit boundary information. this model, called a hierarchical multiscale recurrent neural network (hm-rnn), does not assign fixed update rates, but adaptively determines proper update times corresponding to different abstraction levels of the layers. we find that this model tends to learn fine timescales for low-level layers and coarse timescales for high-level layers. to do this, we introduce a binary boundary detector at each layer. the boundary detector is turned on only at the time steps where a segment of the corresponding abstraction level is completely processed. otherwise, i.e., during the within segment processing, it stays turned off. using the hierarchical boundary states, we implement three operations, update, copy and flush, and choose one of them at each time step. the update operation is similar to the usual update rule of the long short-term memory (lstm) (hochreiter & schmidhuber, 1997), except that it is executed sparsely according to the detected boundaries. the copy operation simply copies the cell and hidden states of the previous time step. unlike the leaky integration of the lstm or the gated recurrent unit (gru) (cho , 2014), the copy operation retains the whole states without any loss of information. the flush operation is executed when a boundary is detected, where it first ejects the summarized representation of the current segment to the upper layer and then reinitializes the states to start processing the next segment. learning to select a proper operation at each time step and to detect the boundaries, the hm-rnn discovers the latent hierarchical structure of the sequences. we find that the straight-through estimator (hinton, 2012; bengio , 2013; courbariaux , 2016) is efficient for training this model containing discrete variables.
we evaluate our model on two tasks: character-level language modelling and handwriting sequence generation. for the character-level language modelling, the hm-rnn achieves the state-of-the-art results on the text8 dataset, and comparable results to the state-of-the-art on the penn treebank and hutter prize wikipedia datasets. the hm-rnn also outperforms the standard rnn on the handwriting sequence generation using the iam-ondb dataset. in addition, we demonstrate that the hierarchical structure found by the hm-rnn is indeed very similar to the intrinsic structure observed in the data. the contributions of this paper are:
• we propose for the first time an rnn model that can learn a latent hierarchical structure of a sequence without using explicit boundary information. • we show that it is beneficial to utilize the above structure through empirical evaluation. • we show that the straight-through estimator is an efficient way of training a model containing
discrete variables. • we propose the slope annealing trick to improve the training procedure based on the
straight-through estimator.two notable early attempts inspiring our model are schmidhuber (1992) and el hihi & bengio (1995). in these works, it is advocated to stack multiple layers of rnns in a decreasing order of update frequency for computational and learning efficiency. in schmidhuber (1992), the author shows a model that can self-organize a hierarchical multiscale structure. particularly in el hihi & bengio (1995), the advantages of incorporating a priori knowledge, “temporal dependencies are structured hierarchically"", into the rnn architecture is studied. the authors propose an rnn architecture that updates each layer with a fixed but different rate, called a hierarchical rnn.
lstms (hochreiter & schmidhuber, 1997) employ the multiscale update concept, where the hidden units have different forget and update rates and thus can operate with different timescales. however, unlike our model, these timescales are not organized hierarchically. although the lstm has a selfloop for the gradients that helps to capture the long-term dependencies by mitigating the vanishing gradient problem, in practice, it is still limited to a few hundred time steps due to the leaky integration by which the contents to memorize for a long-term is gradually diluted at every time step. also, the model remains computationally expensive because it has to perform the update at every time step for each unit. however, our model is less prone to these problems because it learns a hierarchical structure such that, by design, high-level layers learn to perform less frequent updates than low-level layers. we hypothesize that this property mitigates the vanishing gradient problem more efficiently while also being computationally more efficient.
a more recent model, the clockwork rnn (cw-rnn) (koutník , 2014) extends the hierarchical rnn (el hihi & bengio, 1995) and the narx rnn (lin , 1996)1. the cw-rnn tries to solve the issue of using soft timescales in the lstm, by explicitly assigning hard timescales. in the cw-rnn, hidden units are partitioned into several modules, and different timescales are assigned to the modules such that a module i updates its hidden units at every 2(i−1)-th time step. the cw-rnn is computationally more efficient than the standard rnn including the lstm since hidden units are updated only at the assigned clock rates. however, finding proper timescales in the cw-rnn remains as a challenge whereas our model learns the intrinsic timescales from the data. in the biscale rnns (chung , 2016), the authors proposed to model layer-wise timescales adaptively by having additional gating units, however this approach still relies on the soft gating mechanism like lstms.
other forms of hierarchical rnn (hrnn) architectures have been proposed in the cases where the explicit hierarchical boundary structure is provided. in ling  (2015), after obtaining the word boundary via tokenization, the hrnn architecture is used for neural machine translation by modelling the characters and words using the first and second rnn layers, respectively. a similar hrnn architecture is also adopted in sordoni  (2015) to model dialogue utterances. however, in many cases, hierarchical boundary information is not explicitly observed or expensive to obtain. also, it is unclear how to deploy more layers than the number of boundary levels that is explicitly observed in the data.
while the above models focus on online prediction problems, where a prediction needs to be made by using only the past data, in some cases, predictions are made after observing the whole sequence. in this setting, the input sequence can be regarded as 1-d spatial data, convolutional neural networks with 1-d kernels are proposed in kim (2014) and kim  (2015) for language modelling and sentence classification. also, in chan  (2016) and bahdanau  (2016), the authors proposed to obtain high-level representation of the sequences of reduced length by repeatedly merging or pooling the lower-level representation of the sequences.
hierarchical rnn architectures have also been used to discover the segmentation structure in sequences (fernández , 2007; kong , 2015). it is however different to our model in the sense that they optimize the objective with explicit labels on the hierarchical segments while our model discovers the intrinsic structure only from the sequences without segment label information.
the copy operation used in our model can be related to zoneout (krueger , 2016) which is a recurrent generalization of stochastic depth (huang , 2016). in zoneout, an identity transformation is randomly applied to each hidden unit at each time step according to a bernoulli distribution. this results in occasional copy operations of the previous hidden states. while the focus of zoneout is to propose a regularization technique similar to dropout (srivastava , 2014) (where the regularization strength is controlled by a hyperparameter), our model learns (a) to dynamically determine when to copy from the context inputs and (b) to discover the hierarchical multiscale structure and representation. although the main goal of our proposed model is not regularization, we found that our model also shows very good generalization performance.to begin with, we provide an example of how a stacked rnn can model temporal data in an ideal setting, i.e., when the hierarchy of segments is provided (sordoni , 2015; ling , 2015). in figure 1 (a), we depict a hierarchical rnn (hrnn) for language modelling with two layers: the first layer receives characters as inputs and generates word-level representations (c2w-rnn), and the second layer takes the word-level representations as inputs and yields phrase-level representations (w2p-rnn).
as shown, by means of the provided end-of-word labels, the c2w-rnn obtains word-level representation after processing the last character of each word and passes the word-level representation to the w2p-rnn. then, the w2p-rnn performs an update of the phrase-level representation. note that the hidden states of the w2p-rnn remains unchanged while all the characters of a word are processed by the c2w-rnn. when the c2w-rnn starts to process the next word, its hidden states are reinitialized using the latest hidden states of the w2p-rnn, which contain summarized representation of all the words that have been processed by that time step, in that phrase.
from this simple example, we can see the advantages of having a hierarchical multiscale structure: (1) as the w2p-rnn is updated at a much slower update rate than the c2w-rnn, a considerable amount of computation can be saved, (2) gradients are backpropagated through a much smaller number of time steps, and (3) layer-wise capacity control becomes possible (e.g., use a smaller number of hidden units in the first layer which models short-term dependencies but whose updates are invoked much more often).
can an rnn discover such hierarchical multiscale structure without explicit hierarchical boundary information? considering the fact that the boundary information is difficult to obtain (for example, consider languages where words are not always cleanly separated by spaces or punctuation symbols, and imperfect rules are used to separately perform segmentation) or usually not provided at all, this is a legitimate problem. it gets worse when we consider higher-level concepts which we would like the rnn to discover autonomously. in section 2, we discussed the limitations of the existing rnn models under this setting, which either have to update all units at every time step or use fixed update frequencies (el hihi & bengio, 1995; koutník , 2014). unfortunately, this kind of approach is not well suited to the case where different segments in the hierarchical decomposition have different lengths: for example, different words have different lengths, so a fixed hierarchy would not update its upper-level units in synchrony with the natural boundaries in the data.a key element of our model is the introduction of a parametrized boundary detector, which outputs a binary value, in each layer of a stacked rnn, and learns when a segment should end in such a way to optimize the overall target objective. whenever the boundary detector is turned on at a time step of layer ` (i.e., when the boundary state is 1), the model considers this to be the end of a the acronym narx stands for non-linear auto-regressive model with exogenous inputs.
segment corresponding to the latent abstraction level of that layer (e.g., word or phrase) and feeds the summarized representation of the detected segment into the upper layer (`+ 1). using the boundary states, at each time step, each layer selects one of the following operations: update, copy or flush. the selection is determined by (1) the boundary state of the current time step in the layer below z`−1t and (2) the boundary state of the previous time step in the same layer z ` t−1.
in the following, we describe an hm-rnn based on the lstm update rule. we call this model a hierarchical multiscale lstm (hm-lstm). consider an hm-lstm model of l layers (` = 1, . . . , l) which, at each layer `, performs the following update at time step t:
h`t, c ` t, z ` t = f ` hm-lstm(c ` t−1,h ` t−1,h `−1 t ,h `+1 t−1, z ` t−1, z `−1 t ). (1)
here, h and c denote the hidden and cell states, respectively. the function f `hm-lstm is implemented as follows. first, using the two boundary states z`t−1 and z `−1 t , the cell state is updated by:
c`t =  f `t c`t−1 + i`t g`t if z`t−1 = 0 and z`−1t = 1 (update) c`t−1 if z ` t−1 = 0 and z `−1 t = 0 (copy)
i`t g`t if z`t−1 = 1 (flush), (2)
and then the hidden state is obtained by:
h`t = { h`t−1 if copy, o`t tanh(c`t) otherwise.
(3)
here, (f , i,o) are forget, input, output gates, and g is a cell proposal vector. note that unlike the lstm, it is not necessary to compute these gates and cell proposal values at every time step. for example, in the case of the copy operation, we do not need to compute any of these values and thus can save computations.
the copy operation, which simply performs (c`t,h ` t)← (c`t−1,h`t−1), implements the observation that an upper layer should keep its state unchanged until it receives the summarized input from the lower layer. the update operation is performed to update the summary representation of the layer ` if the boundary z`−1t is detected from the layer below but the boundary z ` t−1 was not found at the previous time step. hence, the update operation is executed sparsely unlike the standard rnns where it is executed at every time step, making it computationally inefficient. if a boundary is detected, the flush operation is executed. the flush operation consists of two sub-operations: (a) eject to pass the current state to the upper layer and then (b) reset to reinitialize the state before starting to read a new segment. this operation implicitly forces the upper layer to absorb the summary information of the lower layer segment, because otherwise it will be lost. note that the flush operation is a hard reset in the sense that it completely erases all the previous states of the same layer, which is different from the soft reset or soft forget operation in the gru or lstm.
whenever needed (depending on the chosen operation), the gate values (f `t , i ` t,o ` t), the cell proposal g`t , and the pre-activation of the boundary detector z̃ ` t  are then obtained by: f `t i`t o`t g`t z̃`t  =  sigm sigm sigm tanh hard sigm  fslice (srecurrent(`)t + stop-down(`)t + sbottom-up(`)t + b(`)) , (4) where
s recurrent(`) t = u ` `h ` t−1, (5)
s top-down(`) t = z ` t−1u ` `+1h `+1 t−1, (6)
s bottom-up(`) t = z `−1 t w ` `−1h `−1 t . (7)
here, we usew ji ∈ r(4dim(h `)+1)×dim(h`−1), u ji ∈ r(4dim(h `)+1)×dim(h`) to denote state transition parameters from layer i to layer j, and b ∈ r4dim(h`)+1 is a bias term. in the last layer l, the z̃`t can also be implemented as a function of h`t , e.g., z̃`t = hard sigm(uh`t).
top-down connection is ignored, and we use h0t = xt. since the input should not be omitted, we set z0t = 1 for all t. also, we do not use the boundary detector for the last layer. the hard sigm is defined by hard sigm(x) = max ( 0,min ( 1, ax+1 
)) with a being the slope variable.
unlike the standard lstm, the hm-lstm has a top-down connection from (`+ 1) to `, which is allowed to be activated only if a boundary is detected at the previous time step of the layer ` (see eq. 6). this makes the layer ` to be initialized with more long-term information after the boundary is detected and execute the flush operation. in addition, the input from the lower layer (` − 1) becomes effective only when a boundary is detected at the current time step in the layer (`− 1) due to the binary gate z`−1t . figure 2 (left) shows the gating mechanism of the hm-lstm at time step t.
finally, the binary boundary state z`t is obtained by:
z`t = fbound(z̃ ` t ). (8)
for the binarization function fbound : r→ {0, 1}, we can either use a deterministic step function:
z`t = { 1 if z̃`t > 0.5 0 otherwise,
(9)
or sample from a bernoulli distribution z`t ∼ bernoulli(z̃`t ). although this binary decision is a key to our model, it is usually difficult to use stochastic gradient descent to train such model with discrete decisions as it is not differentiable.training neural networks with discrete variables requires more efforts since the standard backpropagation is no longer applicable due to the non-differentiability. among a few methods for training a neural network with discrete variables such as the reinforce (williams, 1992; mnih & gregor, 2014) and the straight-through estimator (hinton, 2012; bengio , 2013), we use the straightthrough estimator to train our model. the straight-through estimator is a biased estimator because the non-differentiable function used in the forward pass (i.e., the step function in our case) is replaced by a differentiable function during the backward pass (i.e., the hard sigmoid function in our case). the straight-through estimator, however, is much simpler and often works more efficiently in practice than other unbiased but high-variance estimators such as the reinforce. the straight-through estimator has also been used in courbariaux  (2016) and vezhnevets  (2016).
the slope annealing trick. in our experiment, we use the slope annealing trick to reduce the bias of the straight-through estimator. the idea is to reduce the discrepancy between the two functions used during the forward pass and the backward pass. that is, by gradually increasing the slope a of the hard sigmoid function, we make the hard sigmoid be close to the step function. note that starting with a high slope value from the beginning can make the training difficult while it is more applicable later when the model parameters become more stable. in our experiments, starting from slope a = 1, we slowly increase the slope until it reaches a threshold with an appropriate scheduling.we evaluate the proposed model on two tasks, character-level language modelling and handwriting sequence generation. character-level language modelling is a representative example of discrete
sequence modelling, where the discrete symbols form a distinct hierarchical multiscale structure. the performance on real-valued sequences is tested on the handwriting sequence generation in which a relatively clear hierarchical multiscale structure exists compared to other data such as speech signals.a sequence modelling task aims at learning the probability distribution over sequences by minimizing the negative log-likelihood of the training sequences:
min θ − 1 n n∑ n=1 tn∑ t=1 log p (xnt | xn<t; θ) , (10)
where θ is the model parameter, n is the number of training sequences, and tn is the length of the n-th sequence. a symbol at time t of sequence n is denoted by xnt , and x n <t denotes all previous symbols at time t. we evaluate our model on three benchmark text corpora: (1) penn treebank, (2) text8 and (3) hutter prize wikipedia. we use the bits-per-character (bpc), e[− log2 p(xt+1 | x≤t)], as the evaluation metric.
model we use a model consisting of an input embedding layer, an rnn module and an output module. the input embedding layer maps each input symbol into 128-dimensional continuous vector without using any non-linearity. the rnn module is the hm-lstm, described in section 3, with three layers. the output module is a feedforward neural network with two layers, an output embedding layer and a softmax layer. figure 2 (right) shows a diagram of the output module. at each time step, the output embedding layer receives the hidden states of the three rnn layers as input. in order to adaptively control the importance of each layer at each time step, we also introduce three scalar gating units g`t ∈ r to each of the layer outputs:
g`t = sigm(w `[h1t ; · · · ;hlt ]), (11)
where w` ∈ r ∑l
`=1 dim(h `) is the weight parameter. the output embedding het is computed by:
het = relu ( l∑ `=1 g`tw e `h ` t ) , (12)
where l = 3 and relu(x) = max(0, x) (nair & hinton, 2010). finally, the probability distribution for the next target character is computed by the softmax function, softmax(xj) = e
xj∑k k=1 exk , where
each output class is a character.
penn treebank we process the penn treebank dataset (marcus , 1993) by following the procedure introduced in mikolov  (2012). each update is done by using a mini-batch of 64 examples of length 100 to prevent the memory overflow problem when unfolding the rnn in time for backpropagation. the last hidden state of a sequence is used to initialize the hidden state of the next sequence to approximate the full backpropagation. we train the model using adam (kingma & ba, 2014) with an initial learning rate of 0.002. we divide the learning rate by a factor of 50 when the validation negative log-likelihood stopped decreasing. the norm of the gradient is clipped with a threshold of 1 (mikolov , 2010; pascanu , 2012). we also apply layer normalization (ba , 2016) to our models. for all of the character-level language modelling experiments, we apply the same procedure, but only change the number of hidden units, mini-batch size and the initial learning rate.
for the penn treebank dataset, we use 512 units in each layer of the hm-lstm and for the output embedding layer. in table 1 (left), we compare the test bpcs of four variants of our model to other baseline models. note that the hm-lstm using the step function for the hard boundary decision outperforms the others using either sampling or soft boundary decision (i.e., hard sigmoid). the test bpc is further improved with the slope annealing trick, which reduces the bias of the straight-through estimator. we increased the slope a with the following schedule a = min (5, 1 + 0.04 ·nepoch), where nepoch is the maximum number of epochs. the hm-lstm achieves test bpc score of 1.24. for the remaining tasks, we fixed the hard boundary decision using the step function without slope annealing due to the difficulty of finding a good annealing schedule on large-scale datasets.
text8 the text8 dataset (mahoney, 2009) consists of 100m characters extracted from the wikipedia corpus. text8 contains only alphabets and spaces, and thus we have total 27 symbols. in order to compare with other previous works, we follow the data splits used in mikolov  (2012). we use 1024 units for each hm-lstm layer and 2048 units for the output embedding layer. the mini-batch size and the initial learning rate are set to 128 and 0.001, respectively. the results are shown in table 2. the hm-lstm obtains the state-of-the-art test bpc 1.29.
hutter prize wikipedia the hutter prize wikipedia (enwik8) dataset (hutter, 2012) contains 205 symbols including xml markups and special characters. we follow the data splits used in graves (2013) where the first 90m characters are used to train the model, the next 5m characters for validation, and the remainders for the test set. we use the same model size, mini-batch size and the initial learning rate as in the text8. in table 1 (right), we show the hm-lstm achieving the test bpc 1.32, which is a tie with the state-of-the-art result among the neural models. although the neural models, show remarkable performances, their compression performance is still behind the best models such as paq8hp12 (mahoney, 2005) and decomp8 (mahoney, 2009).
visualizing learned hierarchical multiscale structure in figure 3 and 4, we visualize the boundaries detected by the boundary detectors of the hm-lstm while reading a character sequence of total length 270 taken from the validation set of either the penn treebank or hutter prize wikipedia dataset. due to the page width limit, the figure contains the sequence partitioned into three segments of length 90. the white blocks indicate boundaries z`t = 1 while the black blocks indicate the non-boundaries z`t = 0.
interestingly in both figures, we can observe that the boundary detector of the first layer, z1, tends to be turned on when it sees a space or after it sees a space, which is a reasonable breakpoint to separate between words. this is somewhat surprising because the model self-organizes this structure
without any explicit boundary information. in figure 3, we observe that the z1 tends to detect the boundaries of the words but also fires within the words, where the z2 tends to fire when it sees either an end of a word or 2, 3-grams. in figure 4, we also see flushing in the middle of a word, e.g., “tele-flush-phone”. note that “tele” is a prefix after which a various number of postfixes can follow. from these, it seems that the model uses to some extent the concept of surprise to learn the boundary. although interpretation of the second layer boundaries is not as apparent as the first layer boundaries, it seems to segment at reasonable semantic / syntactic boundaries, e.g., “consumers may” - “want to move their telephones a” - “little closer to the tv set <unk>”, and so on.
another remarkable point is the fact that we do not pose any constraint on the number of boundaries that the model can fire up. the model, however, learns that it is more beneficial to delay the information ejection to some extent. this is somewhat counterintuitive because it might look more beneficial to feed the fresh update to the upper layers at every time step without any delay. we conjecture the reason that the model works in this way is due to the flush operation that poses an implicit constraint on the frequency of boundary detection, because it contains both a reward (feeding fresh information to upper layers) and a penalty (erasing accumulated information). the model finds an optimal balance between the reward and the penalty.
to understand the update mechanism more intuitively, in figure 4, we also depict the heatmap of the `2-norm of the hidden states along with the states of the boundary detectors. as we expect, we can see that there is no change in the norm value within segments due to the copy operation. also, the color of ‖h1‖ changes quickly (at every time step) because there is no copy operation in the first layer. the color of ‖h2‖ changes less frequently based on the states of z1t and z2t−1. the color of ‖h3‖ changes even slowly, i.e., only when z2t = 1. a notable advantage of the proposed architecture is that the internal process of the rnn becomes more interpretable. for example, we can substitute the states of z1t and z 2 t−1 into eq. 2 and infer which operation among the update, copy and flush was applied to the second layer at time step t. we can also inspect the update frequencies of the layers simply by counting how many update and flush operations were made in each layer. for example in figure 4, we see that the first layer updates at every time step (which is 270 update operations), the second layer updates 56 times,
and only 9 updates has made in the third layer. note that, by design, the first layer performs update operation at every time step and then the number of update operations decreases as the layer level increases. in this example, the total number of updates is 335 for the hm-lstm which is 60% of reduction from the 810 updates of the standard rnn architecture.we extend the evaluation of the hm-lstm to a real-valued sequence modelling task using iamondb (liwicki & bunke, 2005) dataset. the iam-ondb dataset consists of 12, 179 handwriting examples, each of which is a sequence of (x, y) coordinate and a binary indicator p for pen-tip location, giving us (x1:tn , y1:tn , p1:tn), where n is an index of a sequence. at each time step, the model receives (xt, yt, pt), and the goal is to predict (xt+1, yt+1, pt+1). the pen-up (pt = 1) indicates an end of a stroke, and the pen-down (pt = 0) indicates that a stroke is in progress. there is usually a large shift in the (x, y) coordinate to start a new stroke after the pen-up happens. we remove all sequences whose length is shorter than 300. this leaves us 10, 465 sequences for training, 581 for validation, 582 for test. the average length of the sequences is 648. we normalize the range of the (x, y) coordinates separately with the mean and standard deviation obtained from the training set. we use the mini-batch size of 32, and the initial learning rate is set to 0.0003.
we use the same model architecture as used in the character-level language model, except that the output layer is modified to predict real-valued outputs. we use the mixture density network as the output layer following graves (2013), and use 400 units for each hm-lstm layer and for the output embedding layer. in table 3, we compare the log-likelihood averaged over the test sequences of the iam-ondb dataset. we observe that the hm-lstm outperforms the standard lstm. the slope annealing trick further improves the test log-likelihood of the hm-lstm into 1167 in our setting. in this experiment, we increased the slope a with the following schedule a = min (3, 1 + 0.004 ·nepoch). in figure 5, we let the hm-lstm to read a randomly picked validation sequence and present the visualization of handwriting examples by segments based on either the states of z2 or the states of pen-tip location3.in this paper, we proposed the hm-rnn that can capture the latent hierarchical structure of the sequences. we introduced three types of operations to the rnn, which are the copy, update and flush operations. in order to implement these operations, we introduced a set of binary variables and a novel update rule that is dependent on the states of these binary variables. each binary variable is learned to find segments at its level, therefore, we call this binary variable, a boundary detector. on the character-level language modelling, the hm-lstm achieved state-of-the-art result on the text8 dataset and comparable results to the state-of-the-art results on the penn treebank and hutter prize wikipedia datasets. also, the hm-lstm outperformed the standard lstm on the handwriting sequence generation. our results and analysis suggest that the proposed hm-rnn can discover the latent hierarchical structure of the sequences and can learn efficient hierarchical multiscale representation that leads to better generalization performance. the plot function could be found at blog.otoro.net/2015/12/12/handwriting-generation-demo-in-tensorflow/.the authors would like to thank alex graves, tom schaul and hado van hasselt for their fruitful comments and discussion. we acknowledge the support of the following agencies for research funding and computing support: ubisoft, samsung, ibm, facebook, google, microsoft, nserc, calcul québec, compute canada, the canada research chairs and cifar. the authors thank the developers of theano (team , 2016). jc would like to thank arnaud bergenon and frédéric bastien for their technical support. jc would also like to thank guillaume alain, kyle kastner and david ha for providing us useful pieces of code.",1
517.pdf.json,LEARNING TO DISCOVER SPARSE GRAPHICAL MODELS,"probabilistic graphical models provide a powerful framework for describing the dependencies between a set of variables. many applications infer the structure of a probabilistic graphical model from data to elucidate the relationships between variables. these relationships are often represented by an undirected graphical model also known as a markov random field (mrf). we focus on a common mrf model, gaussian graphical models (ggms). ggms are used in structure-discovery settings for rich data such as neuroimaging, genetics, or finance (friedman , 2008; ryali  2012; mohan , 2012; belilovsky , 2016). although multivariate gaussian distributions are well-behaved, determining likely structures from few examples is a complex task when the data is high dimensional. it requires strong priors, typically a sparsity assumption, or other restrictions on the structure of the graph, which now make the distribution difficult to express analytically and use.
a standard approach to estimating structure with ggms in high dimensions is based on the classic result that the zeros of a precision matrix correspond to zero partial correlation, a necessary and sufficient condition for conditional independence (lauritzen, 1996). assuming only a few conditional dependencies corresponds to a sparsity constraint on the entries of the precision matrix, leading to a combinatorial problem. many popular approaches to learning ggms can be seen as leveraging the
`1-norm to create convex surrogates to this problem. meinshausen & bühlmann (2006) use nodewise `1 penalized regressions. other estimators penalize the precision matrix directly (cai , 2011; friedman , 2008; ravikumar , 2011). the most popular being the graphical lasso
fglasso(σ̂) = arg min θ 0 − log |θ|+ tr (σ̂θ) + λ‖θ‖1, (1)
which can be seen as a penalized maximum-likelihood estimator. here θ and σ̂ are the precision and sample covariance matrices, respectively. a large variety of alternative regularization penalties extend the priors of the graphical lasso (danaher , 2014; ryali  2012; varoquaux , 2010). however, several problems arise in this approach. constructing novel surrogates for structured-sparsity assumptions on mrf structures is challenging, as a prior needs to be formulated and incorporated into a penalized maximum likelihood objective which then needs an efficient optimization algorithm to be developed, often within a separate research effort. furthermore, model selection in a penalized maximum likelihood setting is difficult as regularization parameters are often unintuitive.
we propose to learn the estimator. rather than manually designing a specific graph-estimation procedure, we frame this estimator-engineering problem as a learning problem, selecting a function from a large flexible function class by risk minimization. this allows us to construct a loss function that explicitly aims to recover the edge structure. indeed, sampling from a distribution of graphs and empirical covariances with desired properties is often possible, even when this distribution is not analytically tractable. as such we can perform empirical risk minimization to select an appropriate function for edge estimation. such a framework gives more easy control on the assumed level of sparsity (as opposed to graph lasso) and can impose structure on the sampling to shape the expected distribution, while optimizing a desired performance metric.
for particular cases we show that the problem of interest can be solved with a polynomial function, which is learnable with a neural network (andoni , 2014). motivated by this fact, as well as theoretical and empricial results on learning smooth functions approximating solutions to combinatorial problems (cohen , 2016; vinyals , 2015), we propose to use a particular convolutional neural network as the function class. we train it by sampling small datasets, generated from graphs with the prescribed properties, with a primary focus on sparse graphical models. we estimate from this data small-sample covariance matrices (n < p), where n is the number of samples and p is the dimensionality of the data. then we use them as training data for the neural network (figure 2) where target labels are indicators of present and absent edges in the underlying ggm. the learned network can then be employed in various real-world structure discovery problems.
in section 1.1 we review the related work. in section 2 we formulate the risk minimization view of graph-structure inference and describe how it applies to sparse ggms. section 2.3 describes and motivates the deep-learning architecture we chose to use for the sparse ggm problem in this work. in section 3 we describe the details of how we train an edge estimator for sparse ggms. we then evaluate its properties extensively on simulation data. finally, we show that this edge estimator trained only on synthetic data can obtain state of the art performance at inference time on real neuroimaging and genetics problems, while being much faster to execute than other methods.lopez-paz  (2015) analyze learning functions to identify the structure of directed graphical models in causal inference using estimates of kernel-mean embeddings. as in our work, they demonstrate the use of simulations for training while testing on real data. unlike our work, they primarily focus on finding the causal direction in two node graphs with many observations.
our learning architecture is motivated by the recent literature on deep networks. vinyals  (2015) have shown that neural networks can learn approximate solutions to np-hard combinatorial problems, and the problem of optimal edge recovery in mrfs can be seen as a combinatorial optimization problem. several recent works have been proposed which show neural architectures for graph input data (henaff , 2015; duvenaud  2015; li , 2016). these are based on multi layer convolutional networks, as in our work, or multi-step recurrent neural networks. the input in our approach can be viewed as a complete graph, while the ouput a sparse graph, thus none of these are directly applicable. a related use of deep networks to approximate a posterior distribution can be found in balan  (2015). finally, gregor & lecun (2010); xin  (2016) use deep networks to approximate steps of a known sparse recovery algorithm.
bayesian approaches to structure learning rely on priors on the graph combined with sampling techniques to estimate the posterior of the graph structure. some approaches make assumptions on the decomposability of the graph (moghaddam , 2009). the g-wishart distribution is a popular distribution which forms part of a framework for structure inference, and advances have been recently made in efficient sampling (mohammadi & wit, 2015). these methods can still be rather slow compared to competing methods, and in the setting of p > n we find they are less powerful.we consider mrf edge estimation as a learnable function. let x ∈ rn×p be a matrix whose n rows are i.i.d. samples x ∼ p (x) of dimension p. let g = (v,e) be an undirected and unweighted graph associated with the set of variables in x. let l = {0, 1} and ne = p(p−1)2 the maximum possible edges in e. let y ∈ lne indicate the presence or absence of edges in the edge set e of g, namely
y ij = { 0 xi ⊥ xj |xv \i,j 1 xi 6⊥ xj |xv \i,j
(2)
we define an approximate structure discovery method gw(x), which produces a prediction of the edge structure, ŷ = gw(x), given a set of data x . we focus on x drawn from a gaussian distribution. in this case, the empirical covariance matrix, σ̂, is a sufficient statistic of the population covariance and therefore of the conditional dependency structure. we thus express our structure-recovery problem as a function of σ̂: gw(x) := fw(σ̂). fw is parametrized by w and belongs to the function class f . we note that the graphical lasso in equation (1) is an fw for an appropriate choice of f . this view on the edge estimator now allows us to bring the selection of fw from the domain of human design to the domain of empirical risk minimization over f . defining a distribution p on rp×p × lne such that (σ̂, y ) ∼ p, we would like our estimator, fw, to minimize the expected risk r(f) = e(σ̂,y )∼p[l(f(σ̂), y )] (3) here l : lne×lne → r+ is the loss function. for graphical model selection the 0/1 loss function is the natural error metric to consider (wang , 2010). the estimator with minimum risk is generally not possible to compute as a closed form expression for most interesting choices of p, such as those arising from sparse graphs. in this setting, eq. (1) achieves the information theoretic optimal recovery rate up to a constant for certain p corresponding to uniformly sparse graphs with a maximum degree, but only when the optimal λ is used and the non-zero precision matrix values are bounded away from zero (wang , 2010; ravikumar , 2011).
the design of the estimator in equation (1) is not explicitly minimizing this risk functional. thus modifying the estimator to fit a different class of graphs (e.g. small-world networks) while minimizing r(f) is not obvious. furthermore, in practical settings the optimal λ is unknown and precision matrix entries can be very small. we would prefer to directly minimize the risk functional. desired structural assumptions on samples from p on the underlying graph, such as sparsity, may imply that the distribution is not tractable for analytic solutions. meanwhile, we can often devise a sampling procedure for p allowing us to select an appropriate function via empirical risk minimization. thus it is sufficient to define a rich enough f over which we can minimize the empirical risk over the samples generated, giving us a learning objective over n samples {yk,σk}nk=1 drawn from p: min w 1 n ∑n k=1 l(fw(σ̂k), yk). to maintain tractability, we use the standard cross-entropy loss as a convex surrogate, l̂ : rne × lne , given by: l̂(fw(σ̂), y ) =
∑ i 6=j ( y ij log(f ijw (σ̂)) + (1− y ij) log(1− f ijw (σ̂)) ) . (4)
we now need to select a sufficiently rich function class for fw and a method to produce appropriate (y, σ̂) which model our desired data priors. this will allow us to learn a fw that explicitly attempts to minimize errors in edge discovery.we discuss how the described approach can be applied to recover sparse gaussian graphical models. a typical assumption in many modalities is that the number of edges is sparse. a convenient property of these ggms is that the precision matrix has a zero value in the (i, j)th entry precisely when variables i and j are independent conditioned on all others. additionally, the precision matrix and partial correlation matrix have the same sparsity pattern, while the partial correlation matrix has normalized entries.
algorithm 1 training a ggm edge estimator for i ∈ {1, .., n} do
sample gi ∼ p(g) sample σi ∼ p(σ|g = gi) xi ← {xj ∼ n(0,σi)}nj=1 construct (yi, σ̂i) pair from (gi,xi)
end for select function class f (e.g. cnn) optimize: min
f∈f 1 n
∑n k=1 l̂(f(σ̂k), yk)) we propose to simulate our a priori assumptions of sparsity and gaussianity to learn fw(σ̂), which can then produce predictions of edges from the input data. we model p (x|g) as arising from a sparse prior on the graph g and correspondingly the entries of the precision matrix θ. to obtain a single sample of x corresponds to n i.i.d. samples from n (0,θ−1). we can now train fw(σ̂) by generating sample pairs (σ̂, y ). at execution time we standardize the input data and compute the covariance matrix before evaluating fw(σ̂). the process of learning fw for the sparse ggm is given in algorithm 1. a weakly-informative sparsity prior is one where each edge is equally likely with small probability, versus structured sparsity where edges have specific configurations. for obtaining the training samples (σ̂, y ) in this case we would like to create a sparse precision matrix, θ, with the desired number of zero entries distributed uniformly. one strategy to do this and assure the precision matrices lie in the positive definite cone is to first construct an upper triangular sparse matrix and then multiply it by its transpose. this process is described in detail in the experimental section. alternatively, an mcmc based g-wishart distribution sampler can be employed if specific structures of the graph are desired (lenkoski, 2013).
the sparsity patterns in real data are often not uniformly distributed. many real world networks have a small-world structure: graphs that are sparse and yet have a comparatively short average distance between nodes. these transport properties often hinge on a small number of high-degree nodes called hubs. normally, such structural patterns require sophisticated adaptation when applying estimators like eq. (1). indeed, high-degree nodes break the small-sample, sparse-recovery properties of `1-penalized estimators (ravikumar , 2011). in our framework such structural assumptions appear as a prior that can be learned offline during training of the prediction function. similarly priors on other distributions such as general exponential families can be more easily integrated. as the structure discovery model can be trained offline, even a slow sampling procedure may suffice.in this work we propose to use a neural network as our function fw. to motivate this let us consider the extreme case when n p. in this case σ̂ ≈ σ and thus entries of σ̂−1 or the partial correlation that are almost equal to zero can give the edge structure. definition 1 (p-consistency). a function class f is p-consistent if ∃f ∈ f such thatproposition 1 (existence of p-consistent neural network graph estimator). there exists a feed forward neural network function class f that is p-consistent. proof. if the data is standardized, each entry of σ corresponds to the correlation ρi,j . the partial correlation of edge (i, j) conditioned on nodes z, is given recursively as
ρi,j|z = (ρi,j|z\zo − ρi,zo|z\zoρj,zo|z\zo) 1
d . (5)
we may ignore the denominator, d, as we are interested in i(ρi,j|z = 0). thus we are left with a recursive formula that yields a high degree polynomial. from andoni  (2014, theorem 3.1) using gradient descent, a neural network with only two layers can learn a polynomial function of degree d to arbitrary precision given sufficient hidden units.
remark 1. naïvely the polynomial from the recursive definition of partial correlation is of degree bounded by 2p−2. in the worst case, this would seem to imply that we would need an exponentially
growing number of hidden nodes to approximate it. however, this problem has a great deal of structure that can allow efficient approximation. firstly, higher order monomials will go to zero quickly with a uniform prior on ρi,j , which takes values between 0 and 1, suggesting that in many cases a concentration bound exists that guarantees non-exponential growth. furthermore, the existence result is shown already for a shallow network, and we expect a logarithmic decrease in the number of parameters to peform function estimation with a deep network (cohen , 2016).
moreover, there are a great deal of redundant computations in eq. (5) and an efficient dynamic programming implementation can yield polynomial computation time and require only low order polynomial computations with appropriate storage of previous computation. similarly we would like to design a network that would have capacity to re-use computations across edges and approximate low order polynomials. we also observe that the conditional independence of nodes i, j given z can be computed equivalently in many ways by considering many paths through the nodes z. thus we can choose any valid ordering for traversing the nodes starting from a given edge.
we propose a series of shared operations at each edge. we consider a feedforward network where each edge i, j is associated with a fixed sized vector, oki,j , of dimensionality d at each layer, k > 0. o0i,j is initialized to the covariance entries at k = 0. for each edge we start with a neighborhood of the 6 adjacent nodes, i, j, i-1, i+1, j-1, j+1 for which we take all corresponding edge values from the covariance matrix illustrated in figure 1. we proceed at each layer to increase the nodes considered for each edge, the output at each layer progressively increasing the receptive field making sure all values associated with the considered nodes are present. the receptive field here refers to the original covariance entries which are accessible by a given, oki,j (luo , 2010). the equations defining the process are shown in figure 1. here a neural network fwk is applied at each edge at each layer and a dilation sequence dk is used. we call a network of this topology a d-net of depth l. we use dilation here to allow the receptive field to grow fast, so the network does not need a great deal of layers. we make the following observations: proposition 2. for general p it is a necessary condition for p-consistency that the receptive field of d-net covers all entries of the covariance, σ̂, at any edge it is applied. proof. consider nodes i and j and a chain graph such that i and j are adjacent to each other in the matrix but are at the terminal nodes of the chain graph. one would need to consider all other variables to be able to explain away the correlation. alternatively we can see this directly from expanding eq. (5).
proposition 3. a p× p matrix σ̂ will be covered by the receptive field for a d-net of depth log2(p) and dk = 2k−1 proof. the receptive field of a d-net with dilation sequence dk = 2k−1 of depth l is o(2l). we can see this as oki,j will receive input from o k−1 a,b at the edge of it’s receptive field, effectively doubling it. it now follows that we need at least log2(p) layers to cover the receptive field.
intuitively adjacent edges have a high overlap in their receptive fields and can easily share information about the non-overlapping components. this is analogous to a parametrized message passing. for example if edge (i, j) is explained by node k, as k enters the receptive field of edge (i, j − 1),
the path through (i, j) can already be discounted. in terms of eq. 5 this can correspond to storing computations that can be used by neighbor edges from lower levels in the recursion.
here fwk is shared amongst all nodes and thus we can implement this as a special kind of convolutional network. we make sure that to have considered all edges relevant to the current set of nodes in the receptive field which requires us to add values from filters applied at the diagonal to all edges. in figure 1 we illustrate the nodes and receptive field considered with respect to the covariance matrix. this also motivates a straightforward implementation using 2d convolutions (adding separate convolutions at i, i and j, j to each i, j at each layer to achieve the specific input pattern described) shown in (figure 2).
ultimately our choice of architecture that has shared computations and multiple layers is highly scalable as compared with a naive fully connected approach and allows leveraging existing optimized 2-d convolutions. in preliminary work we have also considered fully connected layers but this proved to be much less efficient in terms of storage and scalibility than using deep convolutional networks.
considering the general n p case is illustrative. however, the main advantages of making the computations differentiable and learned from data is that we can take advantage of the sparsity and structure assumptions on the target function to obtain more efficient results than naive computation of partial correlation or matrix inversion. as n decreases our estimate of ρ̂i,j becomes inexact and here a data driven model which can take advantage of the assumptions on the underlying distribution can more accurately recover the graph structure.
the convolution structure is dependent on the order of the variables used to build the covariance matrix, which is arbitrary. permuting the input data we can obtain another estimate of the output. in the experiments, we leverage these various estimate in an ensembling approach, averaging the results of several permutations of input. we observe that this generally yields a modest increase in accuracy, but that even a single node ordering can show substantially improved performance over competing methods in the literature.our experimental evaluations focus on the challenging high dimensional settings in which p > n and consider both synthetic data and real data from genetics and neuroimaging. in our experiments we explore how well networks trained on parametric samples generalize, both to unseen synthetic data and to several real world problems. in order to highlight the generality of the learned networks, we apply the same network to multiple domains. we train networks taking in 39, 50, and 500 node graphs. the former sizes are chosen based on the real data we consider in subsequent sections. we refer to these networks as deepgraph-39, 50, and 500. in all cases we have 50 feature maps of 3× 3 kernels. the 39 and 50 node network with 6 convolutional layers and dk = k + 1. for the 500 node network with 8 convolutional layers and dk = 2k+1. we use relu activations. the last layer has 1× 1 convolution and a sigmoid outputing a value of 0 to 1 for each edge. we sample p (x|g) with a sparse prior on p (g) as follows. we first construct a lower diagonal matrix, l, where each entry has α probability of being zero. non-zero entries are set uniformly between −c and c. multiplying llt gives a sparse positive definite precision matrix, θ. this gives us our p (θ|g) with a sparse prior on p (g). we sample from the gaussian n (0,θ−1) to obtain
samples of x . here α corresponds approximately to a specific sparsity level in the final precision matrix, which we set to produce matrices 92− 96% sparse and c chosen so that partial correlations range 0 to 1.
each network is trained continously with new samples generated until the validation error saturates. for a given precision matrix we generate 5 possible x samples to be used as training data, with a total of approximately 100k training samples used for each network. the networks are optimized using adam (kingma & ba, 2015) coupled with cross-entropy loss as the objective function (cf. sec. 2.1). we use batch normalization at each layer. additionally, we found that using the absolute value of the true partial correlations as labels, instead of hard binary labels, improves results.
synthetic data evaluation to understand the properties of our learned networks, we evaluated them on different synthetic data than the ones they were trained on. more specifically, we used a completely different third party sampler so as to avoid any contamination. we use deepgraph-39 on a variety of settings. the same trained network is utilized in the subsequent neuroimaging evaluations as well. deepgraph-500 is also used to evaluate larger graphs.
we used the bdgraph r-package to produce sparse precision matrices based on the g-wishart distribution (mohammadi & wit, 2015) as well as the r-package rags2ridges (peeters , 2015) to generate data from small-world networks corresponding to the watts–strogatz model (watts & strogatz, 1998). we compared our learned estimator against the scikit-learn (pedregosa  2011) implementation of graphical lasso with regularizer chosen by cross-validation as well as the birth-death rate mcmc (bdmcmc) method from mohammadi & wit (2015).
for each scenario we repeat the experiment for 100 different graphs and small sample observations showing the average area under the roc curve (auc), precision@k corresponding to 5% of possible edges, and calibration error (ce) (mohammadi & wit, 2015).
for graphical lasso we use the partial correlations to indicate confidence in edges; bdgraph automatically returns posterior probabilities as does our method. finally to understand the effect of the regularization parameter we additionally report the result of graphical lasso under optimal regularizer setting on the testing data.
our method dominates all other approaches in all cases with p > n (which also corresponds to the training regime). for the case of random gaussian graphs with n=35 (as in our training data), and graph sparsity of 95%, we have superior performance and can further improve on this by averaging permutations. next we apply the method to a less straightforward synthetic data, with distributions typical of many applications. we found that, compared to baseline methods, our network performs particularly well with high-degree nodes and when the distribution becomes non-normal. in particular our method performs well on the relevant metrics with small-world networks, a very common family of graphs in real-world data, obtaining superior precision at the primary levels of interest. figure 3 shows examples of random and watts-strogatz small-world graphs used in these experiments.
training a new network for each number of samples can pose difficulties with our proposed method. thus we evaluted how robust the network deepgraph-39 is to input covariances obtained from fewer or more samples. we find that overall the performance is quite good even when lowering the number of samples to n = 15, we obtain superior performance to the other approaches (table 1). we also applied deepgraph-39 on data from a multivariate generalization of the laplace distribution (gómez , 1998). as in other experiments precision matrices were sampled from the g-wishart at a sparsity of 95%. gómez  (1998, proposition 3.1) was applied to produce samples. we find that deepgraph-39 performs competitively, despite the discrepancy between train and test distributions. experiments with variable sparsity are considered in the supplementary material, which find that for very sparse graphs, the networks remain robust in performance, while for increased density performance degrades but remains competitive.
using the small-world network data generator (peeters , 2015), we demonstrate that we can update the generic sparse prior to a structured one. we re-train deepgraph-39 using only 1000 examples of small-world graphs mixed with 1000 examples from the original uniform sparsity model. we perform just one epoch of training and observe markedly improved performance on this test case as seen in the last row of table 1.
for our final scenario we consider the very challenging setting with 500 nodes and only n = 50 samples. we note that the mcmc based method fails to converge at this scale, while graphical lasso is very slow as seen in the timing performance and barely performs better than chance. our method convincingly outperforms graphical lasso in this scenario. here we additionally report precision at just the first 0.05% of edges since competitors perform nearly at chance at the 5% level.
cancer genome data we perform experiments on a gene expression dataset described in honorio  (2012). the data come from a cancer genome atlas from 2360 subjects for various types of cancer. we used the first 50 genes from honorio  (2012, appendix c.2) of commonly regulated genes in cancer. we evaluated on two groups of subjects, one with breast invasive carcinoma (brca) consisting of 590 subjects and the other colon adenocarcinoma (coda) consisting of 174 subjects.
evaluating edge selection in real-world data is challenging. we use the following methodology: for each method we select the top-k ranked edges, recomputing the maximum likelihood precision matrix with support given by the corresponding edge selection method. we then evaluate the likelihood on a held-out set of data. we repeat this procedure for a range of k. we rely on algorithm 0 in hara & takemura (2010) to compute the maximum likelihood precision given a support. the experiment is repeated for each of coda and brca subject groups 150 times. results are shown in figure 4. in all cases we use 40 samples for edge selection and precision estimation. we compare with graphical lasso as well as the ledoit-wolf shrinkage estimator (ledoit & wolf, 2004). we additionally consider the mcmc based approach described in previous section. for graphical lasso and ledoit-wolf, edge selection is based on thresholding partial correlation (balmand & dalalyan, 2016).
additionally, we evaluate the stability of the solutions provided by the various methods. in several applications a low variance on the estimate of the edge set is important. on table 3, we report
spearman correlations between pairs of solutions, as it is a measure of a monotone link between two variables. deepgraph has far better stability in the genome experiments and is competitive in the fmri data.
resting state functional connectivity we evaluate our graph discovery method to study brain functional connectivity in resting-state fmri data. correlations in brain activity measured via fmri reveal functional interactions between remote brain regions. these are an important measure to study psychiatric diseases that have no known anatomical support. typical connectome analysis describes each subject or group by a ggm measuring functional connectivity between a set of regions (varoquaux & craddock, 2013). we use the abide dataset (di martino  2014), a large scale resting state fmri dataset. it gathers brain scans from 539 individuals suffering from autism spectrum disorder and 573 controls over 16 sites.1 for our experiments we use an atlas with 39 regions of interest derived in varoquaux  (2011).
we use the network deepgraph-39, the same network and parameters from synthetic experiments, using the same evaluation protocol as used in the genomic data. for both control and autism patients we use time series from 35 random subjects to estimate edges and corresponding precision matrices. we find that for both the autism and control group we can obtain edge selection comparable to graph lasso for very few selected edges. when the number of selected edges is in the range above 25 we begin to perform significantly better in edge selection as seen in fig. 4. we evaluated stability of the results as shown in tab. 3. deepgraph outperformed the other methods across the board.
abide has high variability across sites and subjects. as a result, to resolve differences between approaches, we needed to perform 1000 folds to obtain well-separated error bars. we found that the birth-death mcmc method took very long to converge on this data, moreover the need for many folds to obtain significant results amongst the methods made this approach prohibitively slow to evaluate. http://preprocessed-connectomes-project.github.io/abide/
we show the edges returned by graph lasso and deepgraph for a sample from 35 subjects (fig. 5) in the control group. we also show the result of a large-sample result based on 368 subjects from graphical lasso. in visual evaluation of the edges returned by deepgraph we find that they closely align with results from a large-sample estimation procedure. furthermore we can see several edges in the subsample which were particularly strongly activated in both methods.our method was competitive with strong baselines. even in cases that deviate from standard ggm sparsity assumptions (e.g. laplacians, small-world) it performed substantially better. when finetuning on the target distribution performance further improves. most importantly the learned estimator generalizes well to real data finding relevant stable edges. we also observed that the learned estimators generalize to variations not seen at training time (e.g. different n or sparsity), which points to this potentialy learning generic computations. this also shows potential to more easily scale the method to different graph sizes. one could consider transfer learning, where a network for one size of data is used as a starting point to learn a network working on larger dimension data.
penalized maximum likelihood can provide performance guarantees under restrictive assumptions on the form of the distribution and not considering the regularization path. in the proposed method one could obtain empirical bounds under the prescribed data distribution. additionally, at execution time the speed of the approach can allow for re-sampling based uncertainty estimates and efficient model selection (e.g. cross-validation) amongst several trained estimators.
we have introduced the concept of learning an estimator for determining the structure of an undirected graphical model. a network architecture and sampling procedure for learning such an estimator for the case of sparse ggms was proposed. we obtained competitive results on synthetic data with various underlying distributions, as well as on challenging real-world data. empirical results show that our method works particularly well compared to other approaches for small-world networks, an important class of graphs common in real-world domains. we have shown that neural networks can obtain improved results over various statistical methods on real datasets, despite being trained with samples from parametric distributions. our approach enables straightforward specifications of new priors and opens new directions in efficient graphical structure discovery from few examples.this work is partially funded by internal funds ku leuven, fp7-mc-cig 334380, digiteo 2013- 0788d - soprano, and anr-11-binf-0004 niconnect. we thank jean honorio for providing pre-processed cancer genome data.using our framework it is possible to attempt to directly predict an accurate covariance matrix given a noisy one constructed from few observations. this is a more challenging task than predicting the edges. in this section we show preliminay experiments which given an empirical covariance matrix from few observations attempts to predict a more accurate covariance matrix that takes into account underlying sparse data dependency structure.
one challenge is that outputs of our covariance predictor must be on the positive semidefinite cone, thus we choose to instead predict on the cholesky decompositions, which allows us to always produce positive definite covariances. we train a similar structure to deepgraph-39 structure modifying the last layer to be fully connected linear layer that predicts on the cholesky decomposition of the true covariance matrices generated by our model with a squared loss.
we evaluate this network using the abide dataset described in section 3. the abide data has a large number of samples allowing us to obtain a large sample estimate of the covariance and compare it to our estimator as well as graphical lasso and empirical covariance estimators. using the large sample abide empirical covariance matrix. we find that we can obtain competitive `2 and `∞ norm using few samples. we use 403 subjects from the abide control group each with a recording of 150 − 200 samples to construct covariance matrix, totaling 77 330 samples (some correlated). this acts as our very approximate estimate of the population σ. we then evaluate covariance estimation on 35 samples using the empirical covariance estimator, graphical lasso, and deepgraph trained to output covariance matrices. we repeat the experiment for 50 different subsamples of the data. we see in 5 that the prediction approach can obtain competitive results. in terms of `2 graphical lasso performs better, however our estimate is better than empirical covariance estimation and much faster then graphical lasso. in some applications such as robust estimation a fast estimate of the covariance matrix (automatically embedding sparsity assumptions) can be of great use. for `∞ error we see the empirical covariance estimation outperforms graphical lasso and deepgraph for this dataset, while deepgraph performs better in terms of this metric.
we note these results are preliminary, as the covariance predicting networks were not heavily optimized, moreover the abide dataset is very noisy even when pre-processed and thus even the large sample covariance estimate may not be accurate. we believe this is an interesting alternate application of our paper.we investigate the affect of sparsity on deepgraph-39 which has been trained with input that has sparsity 96% − 92% sparse. we find that deepgraph performs well at the 2% sparsity level despite not seeing this at training time. at the same time performance begins to degrade for 15% but is still competitive in several categories. the results are shown in table 6. future investigation can consider how alternate variation of sparsity at training time will affect these results.we perform preliminary investigation of application of a network trained for a larger number of nodes to a smaller set of nodes. specifically, we consider the breast invasive carcinoma groups gene data. we now take all 175 valid genes from appendix c.2 of honorio  (2012). we take the network trained on 500 nodes in the synthetic experiments section. we use the same experimental setup as in the gene experiments. the 175× 175
covariance matrix from 40 samples and padded to the appropriate size. we observe that deepgraph has similar performance to graph lasso while permuting the input and ensembling the result gives substantial improvement.as discussed in section 2.3, permuting the input and averaging several permutations can produce an improved result empirically. we interpret this as a typical ensembling method. this can be an advantage of the proposed architecture as we are able to easily use standard ensemble techniques. we perform an experiment to further verify that indeed the permutation of the input (and subsequent inverse permutation) allows us to produce separate classifiers that have uncorrelated errors.
we use the setup from the synthetic experiments with deepgraph-39 in section 3 with n = 35 and p = 39. we construct 20 permutation matrices as in the experimental section. treating each as a separate classifier we compute the correlation coefficient of the errors on 50 synthetic input examples. we find that the average correlation coefficient of the errors of two classifiers is 0.028± 0.002, suggesting they are uncorrelated. finally we note the individual errors are relatively small, as can already be inferred from our extensive experimental results in section 3. we however compute the average absolute error of all the outputs across each permutation for this set of inputs as 0.03, notably the range of outputs is 0 to 1. thus since prediction error differ at each permutation but are accurate we can average and yield a lower total prediction error.
finally we note that our method is extremely efficient computationally thus averaging the results of several permutations is practical even as the graph becomes large.",0
533.pdf.json,SURPRISE-BASED INTRINSIC MOTIVATION FOR DEEP REINFORCEMENT LEARNING,"a reinforcement learning agent uses experiences obtained from interacting with an unknown environment to learn behavior that maximizes a reward signal. the optimality of the learned behavior is strongly dependent on how the agent approaches the exploration/exploitation trade-off in that environment. if it explores poorly or too little, it may never find rewards from which to learn, and its behavior will always remain suboptimal; if it does find rewards but exploits them too intensely, it may wind up prematurely converging to suboptimal behaviors, and fail to discover more rewarding opportunities. although substantial theoretical work has been done on optimal exploration strategies for environments with finite state and action spaces, we are here concerned with problems that have continuous state and/or action spaces, where algorithms with theoretical guarantees admit no obvious generalization or are prohibitively impractical to implement.
simple heuristic methods of exploring such as -greedy action selection and gaussian control noise have been successful on a wide range of tasks, but are inadequate when rewards are especially sparse. for example, the deep q-network approach of mnih  [13] used -greedy exploration in training deep neural networks to play atari games directly from raw pixels. on many games, the algorithm resulted in superhuman play; however, on games like montezuma’s revenge, where rewards are extremely sparse, dqn (and its variants [25], [26], [15], [12]) with -greedy exploration failed to achieve scores even at the level of a novice human. similarly, in benchmarking deep reinforcement learning for continuous control, duan [5] found that policy optimization algorithms that explored by acting according to the current stochastic policy, including reinforce and trust region policy optimization (trpo), could succeed across a diverse slate of simulated robotics control tasks with well-defined, non-sparse reward signals (like rewards proportional to the forward velocity of the robot). yet, when tested in environments with sparse rewards—where the agent would only be able to attain rewards after first figuring out complex motion primitives without reinforcement—every algorithm failed to attain scores better than random agents. the failure modes in all of these cases pertained to the nature of the exploration: the agents encountered reward signals so infrequently that they were never able to learn reward-seeking behavior.
one approach to encourage better exploration is via intrinsic motivation, where an agent has a task-independent, often information-theoretic intrinsic reward function which it seeks to maximize in addition to the reward from the environment. examples of intrinsic motivation include empowerment, where the agent enjoys the level of control it has about its future; surprise, where the agent is excited to see outcomes that run contrary to its understanding of the world; and novelty, where the agent is excited to see new states (which is tightly connected to surprise, as shown in [2]). for in-depth reviews of the different types of intrinsic motivation, we direct the reader to [1] and [17].
recently, several applications of intrinsic motivation to the deep reinforcement learning setting (such as [2], [7], [22]) have found promising success. in this work, we build on that success by exploring scalable measures of surprise for intrinsic motivation in deep reinforcement learning. we formulate surprise as the kl-divergence of the true transition probability distribution from a transition model which is learned concurrently with the policy, and consider two approximations to this divergence which are easy to compute in practice. one of these approximations results in using the surprisal of a transition as an intrinsic reward; the other results in using a measure of learning progress which is closer to a bayesian concept of surprise. our contributions are as follows: . we investigate surprisal and learning progress as intrinsic rewards across a wide range of environments in the deep reinforcement learning setting, and demonstrate empirically that the incentives (especially surprisal) result in efficient exploration, . we evaluate the difficulty of the slate of sparse reward continuous control tasks introduced by houthooft  [7] to benchmark exploration incentives, and introduce a new task to complement the slate, . and we present an efficient method for learning the dynamics model (transition probabilities) concurrently with a policy.
we distinguish our work from prior work in a number of implementation details: unlike bellemare  [2], we learn a transition model as opposed to a state-action occupancy density; unlike stadie  [22], our formulation naturally encompasses environments with stochastic dynamics; unlike houthooft  [7], we avoid the overhead of maintaining a distribution over possible dynamics models, and learn a single deep dynamics model.
in our empirical evaluations, we compare the performance of our proposed intrinsic rewards with other heuristic intrinsic reward schemes and to recent results from the literature. in particular, we compare to variational information maximizing exploration (vime) [7], a method which approximately maximizes bayesian surprise and currently achieves state-of-the-art performance on continuous control with sparse rewards. we show that our incentives can perform on the level of vime at a lower computational cost.we begin by introducing notation which we will use throughout the paper. a markov decision process (mdp) is a tuple, (s,a,r, p, µ), where s is the set of states, a is the set of actions, r : s × a × s → r is the reward function, p : s × a × s → [0, 1] is the transition probability function (where p (s′|s, a) is the probability of transitioning to state s′ given that the previous state was s and the agent took action a in s), and µ : s → [0, 1] is the starting state distribution. a policy π : s × a → [0, 1] is a distribution over actions per state, with π(a|s) the probability of selecting a in state s. we aim to select a policy π which maximizes a performance measure, l(π), which usually takes the form of expected finite-horizon total return (sum of rewards in a fixed time period), or expected infinite-horizon discounted total return (discounted sum of all rewards forever). in this paper, we use the finite-horizon total return formulation.to train an agent with surprise-based exploration, we alternate between making an update step to a dynamics model (an approximator of the mdp’s transition probability function), and making a policy update step that maximizes a trade-off between policy performance and a surprise measure.
the dynamics model step makes progress on the optimization problem
min φ − 1 |d| ∑ (s,a,s′)∈d logpφ(s ′|s, a) + αf(φ), (1)
where d is is a dataset of transition tuples from the environment, pφ is the model we are learning, f is a regularization function, and α > 0 is a regularization trade-off coefficient. the policy update step makes progress on an approximation to the optimization problem
max π l(π) + η e s,a∼π
[dkl(p ||pφ)[s, a]] , (2)
where η > 0 is an explore-exploit trade-off coefficient. the exploration incentive in (2), which we select to be the on-policy average kl-divergence of pφ from p , is intended to capture the agent’s surprise about its experience. the dynamics model pφ should only be close to p on regions of the transition state space that the agent has already visited (because those transitions will appear in d and thus the model will be fit to them), and as a result, the kl divergence of pφ and p will be higher in unfamiliar places. essentially, this exploits the generalization in the model to encourage the agent to go where it has not gone before. the surprise incentive in (2) gives the net effect of performing a reward shaping of the form
r′(s, a, s′) = r(s, a, s′) + η (logp (s′|s, a)− logpφ(s′|s, a)) , (3) where r(s, a, s′) is the original reward and r′(s, a, s′) is the transformed reward, so ideally we could solve (2) by applying any reinforcement learning algorithm with these reshaped rewards. in practice, we cannot directly implement this reward reshaping because p is unknown. instead, we consider two ways of finding an approximate solution to (2).
in one method, we approximate the kl-divergence by the cross-entropy, which is reasonable when h(p ) is finite (and small) and pφ is sufficiently far from p 1; that is, denoting the cross-entropy by h(p, pφ)[s, a] . = es′∼p (·|s,a)[− logpφ(s′|s, a)], we assume
dkl(p ||pφ)[s, a] = h(p, pφ)[s, a]−h(p )[s, a] ≈ h(p, pφ)[s, a].
(4)
this approximation results in a reward shaping of the form
r′(s, a, s′) = r(s, a, s′)− η logpφ(s′|s, a); (5) here, the intrinsic reward is the surprisal of s′ given the model pφ and the context (s, a).
in the other method, we maximize a lower bound on the objective in (2) by lower bounding the surprise term:
dkl(p ||pφ)[s, a] = dkl(p ||pφ′)[s, a] + e s′∼p
[ log pφ′(s ′|s, a)
pφ(s′|s, a) ] ≥ e s′∼p [ log pφ′(s ′|s, a)
pφ(s′|s, a)
] .
(6)
the bound (6) results in a reward shaping of the form
r′(s, a, s′) = r(s, a, s′) + η (logpφ′(s ′|s, a)− logpφ(s′|s, a)) , (7)
which requires a choice of φ′. from (6), we can see that the bound becomes tighter by minimizing dkl(p ||pφ′). as a result, we choose φ′ to be the parameters of the dynamics model after k updates based on (1), and φ to be the parameters from before the updates. thus, at iteration t, the reshaped rewards are
r′(s, a, s′) = r(s, a, s′) + η ( logpφt(s ′|s, a)− logpφt−k(s′|s, a) ) ; (8)
here, the intrinsic reward is the k-step learning progress at (s, a, s′). it also bears a resemblance to bayesian surprise; we expand on this similarity in the next section.
in our experiments, we investigate both the surprisal bonus (5) and the k-step learning progress bonus (8) (with varying values of k). on the other hand, if h(p )[s, a] is non-finite everywhere—for instance if the mdp has continuous states and deterministic transitions—then as long as it has the same sign everywhere, es,a∼π[h(p )[s, a]] is a constant with respect to π and we can drop it from the optimization problem anyway.ideally, we would like the intrinsic rewards to vanish in the limit as pφ → p , because in this case, the agent should have sufficiently explored the state space, and should primarily learn from extrinsic rewards. for the proposed intrinsic reward in (5), this is not the case, and it may result in poor performance in that limit. the thinking goes that when pφ = p , the agent will be incentivized to seek out states with the noisiest transitions. however, we argue that this may not be an issue, because the intrinsic motivation seems mostly useful long before the dynamics model is fully learned. as long as the agent is able to find the extrinsic rewards before the intrinsic reward is just the entropy in p , the pathological noise-seeking behavior should not happen. on the other hand, the intrinsic reward in (8) should not suffer from this pathology, because in the limit, as the dynamics model converges, we should have pφt ≈ pφt−k . then the intrinsic reward will vanish as desired. next, we relate (8) to bayesian surprise. the bayesian surprise associated with a transition is the reduction in uncertainty over possibly dynamics models from observing it ([1],[8]):
dkl (p (φ|ht, at, st+1)||p (φ|ht)) . here, p (φ|ht) is meant to represent a distribution over possible dynamics models parametrized by φ given the preceding history of observed states and actions ht (so ht includes st), and p (φ|ht, at, st+1) is the posterior distribution over dynamics models after observing (at, st+1). by bayes’ rule, the dynamics prior and posterior are related to the model-based transition probabilities by
p (φ|ht, at, st+1) = p (φ|ht)p (st+1|ht, at, φ)
eφ∼p (·|ht) [p (st+1|ht, at, φ)] ,
so the bayesian surprise can be expressed as e
φ∼pt+1 [logp (st+1|ht, at, φ)]− log e φ∼pt [p (st+1|ht, at, φ)] , (9)
where pt+1 = p (·|ht, at, st+1) is the posterior and pt = p (·|ht) is the prior. in this form, the resemblance between (9) and (8) is clarified. although the update from φt−k to φt is not bayesian— and is performed in batch, instead of per transition sample—we can imagine (8) might contain similar information to (9).our implementation usesl2 regularization in the dynamics model fitting, and we impose an additional constraint to keep model iterates close in the kl-divergence sense. denoting the average divergence as
d̄kl(pφ′ ||pφ) = 1 |d| ∑
(s,a)∈d
dkl(pφ′ ||pφ)[s, a], (10)
our dynamics model update is
φi+1 = arg min φ − 1 |d| ∑ (s,a,s′)∈d logpφ(s ′|s, a) + α‖φ‖22 : d̄kl(pφ||pφi) ≤ κ. (11)
the constraint value κ is a hyper-parameter of the algorithm. we solve this optimization problem approximately using a single second-order step with a line search, as described by [20]; full details are given in supplementary material. d is a fifo replay memory, and at each iteration, instead of using the entirety of d for the update step we sub-sample a batch d ⊂ d. also, similarly to [7], we adjust the bonus coefficient η at each iteration, to keep the average bonus magnitude upper-bounded (and usually fixed). let η0 denote the desired average bonus, and r+(s, a, s′) denote the intrinsic reward; then, at each iteration, we set
η = η0 max ( , 1|b| ∣∣∣∑(s,a,s′)∈b r+(s, a, s′)∣∣∣) , where b is the batch of data used for the policy update step. this normalization improves the stability of the algorithm by keeping the scale of the bonuses fixed with respect to the scale of the extrinsic rewards. also, in environments where the agent can die, we avoid the possibility of the intrinsic rewards becoming a living cost by translating all bonuses so that the mean is nonnegative. the basic outline of the algorithm is given as algorithm 1. in all experiments, we use fully-factored gaussian distributions for the dynamics models, where the means and variances are the outputs of neural networks.
algorithm 1 reinforcement learning with surprise incentive input: initial policy π0, dynamics model pφ0 repeat
collect rollouts on current policy πi add rollout (s, a, s′) tuples to replay memory d compute reshaped rewards using (5) or (8) with dynamics model pφi normalize η by the average intrinsic reward of the current batch of data update policy to πi+1 using any rl algorithm with the reshaped rewards update the dynamics model to pφi+1 according to (11)
until training is completedwe evaluate our proposed surprise incentives on a wide range of benchmarks that are challenging for naive exploration methods, including continuous control and discrete control tasks. our continuous control tasks include the slate of sparse reward tasks introduced by houthooft  [7]: sparse mountaincar, sparse cartpoleswingup, and sparse halfcheetah, as well as a new sparse reward task that we introduce here: sparse swimmer. (we refer to these environments with the prefix ‘sparse’ to differentiate them from other versions which appear in the literature, where agents receive non-sparse reward signals.) additionally, we evaluate performance on a highly-challenging hierarchical sparse reward task introduced by duan [5], swimmergather. the discrete action tasks are several games from the atari ram domain of the openai gym [4]: pong, bankheist, freeway, and venture.
environments with deterministic and stochastic dynamics are represented in our benchmarks: the continuous control domains have deterministic dynamics, while the gym atari ram games have stochastic dynamics. (in the atari games, actions are repeated for a random number of frames.)
we use trust region policy optimization (trpo) [20], a state-of-the-art policy gradient method, as our base reinforcement learning algorithm throughout our experiments, and we use the rllab implementations of trpo and the continuous control tasks [5]. full details for the experimental set-up are included in the appendix.
on all tasks, we compare against trpo without intrinsic rewards, which we refer to as using naive exploration (in contrast to intrinsically motivated exploration). for the continuous control tasks, we also compare against intrinsic motivation using the l2 model prediction error,
r+(s, a, s ′) = ‖s′ − µφ(s, a)‖2, (12)
where µφ is the mean of the learned gaussian distribution pφ. the model prediction error was investigated as intrinsic motivation for deep reinforcement learning by stadie [22], although they used a different method for learning the model µφ. this comparison helps us verify whether or not our proposed form of surprise, as a kl-divergence from the true dynamics model, is useful. additionally, we compare our performance against the performance reported by houthooft  [7] for variational information maximizing exploration (vime), a method where the intrinsic reward associated with a transition approximates its bayesian surprise using variational methods. currently, vime has achieved state-of-the-art results on intrinsic motivation for continuous control.
as a final check for the continuous control tasks, we benchmark the tasks themselves, by measuring the performance of the surprisal bonus without any dynamics learning: r+(s, a, s′) = − logpφ0(s′|s, a), where φ0 are the original random parameters of pφ. this allows us to verify whether our benchmark tasks actually require surprise to solve at all, or if random exploration strategies successfully solve them.median performance curves are shown in figure 1 with interquartile ranges shown in shaded areas. note that trpo without intrinsic motivation failed on all tasks: the median score and upper quartile range for naive exploration were zero everywhere. also note that trpo with random exploration bonuses failed on most tasks, as shown separately in figure 2. we found that surprise was not needed to solve mountaincar, but was necessary to perform well on the other tasks.
the surprisal bonus was especially robust across tasks, achieving good results in all domains and substantially exceeding the other baselines on the more challenging ones. the learning progress bonus for k = 1 was successful on cartpoleswingup and halfcheetah but it faltered in the others. its weak performance in mountaincar was due to premature convergence of the dynamics model, which resulted in the agent receiving intrinsic rewards that were identically zero. (given the simplicity of the environment, it is not surprising that the dynamics model converged so quickly.) in swimmer, however, it seems that the learning progress bonuses did not inspire sufficient exploration. because the swimmer environment is effectively a stepping stone to the harder swimmergather, where the agent has to learn a motion primitive and collect target pellets, on swimmergather, we only evaluated the intrinsic rewards that had been successful on swimmer.
both surprisal and learning progress (with k = 1) exceeded the reported performance of vime on halfcheetah by learning to solve the task more quickly. on cartpoleswingup, however, both were more susceptible to getting stuck in locally optimal policies, resulting in lower median scores than vime. surprisal performed comparably to vime on swimmergather, the hardest task in the slate—in the sense that after 1000 iterations, they both reached approximately the same median score—although with greater variance than vime.
our results suggest that surprisal is a viable alternative to vime in terms of performance, and is highly favorable in terms of computational cost. in vime, a backwards pass through the dynamics model must be computed for every transition tuple separately to compute the intrinsic rewards, whereas our surprisal bonus only requires forward passes through the dynamics model for intrinsic
reward computation. (limitations of current deep learning tool kits make it difficult to efficiently compute separate backwards passes, whereas almost all of them support highly parallel forward computations.) furthermore, our dynamics model is substantially simpler than the bayesian neural network dynamics model of vime. to illustrate this point, in figure 3 we show the results of a speed comparison making use of the open-source vime code [6], with the settings described in the vime paper. in our speed test, our bonus had a per-iteration speedup of a factor of 3 over vime.2 we give a full analysis of the potential speedup in appendix c.median performance curves are shown in figure 4, with tasks arranged from (a) to (d) roughly in order of increasing difficulty.
in pong, naive exploration naturally succeeds, so we are not surprised to see that intrinsic motivation does not improve performance. however, this serves as a sanity check to verify that our intrinsic rewards do not degrade performance. (as an aside, we note that the performance here falls short of the standard score of 20 for this domain because we truncate play at 5000 timesteps.)
in bankheist, we find that intrinsic motivation accelerates the learning significantly. the agents with surprisal incentives reached high levels of performance (scores > 1000) 10% sooner than naive exploration, while agents with learning progress incentives reached high levels almost 20% sooner.
in freeway, the median performance for trpo without intrinsic motivation was adequate, but the lower quartile range was quite poor—only 6 out of 10 runs ever found rewards. with the learning progress incentives, 8 out of 10 runs found rewards; with the surprisal incentive, all 10 did. freeway is a game with very sparse rewards, where the agent effectively has to cross a long hallway before it can score a point, so naive exploration tends to exhibit random walk behavior and only rarely reaches the reward state. the intrinsic motivation helps the agent explore more purposefully. we compute this by comparing the marginal time cost incurred just by the bonus in each case: that is, if tvime, tsurprisal, and tnobonus denote the times to 15 iterations, we obtain the speedup as
tvime − tnobonus tsurprisal − tnobonus .
in venture, we obtain our strongest results in the atari domain. venture is extremely difficult because the agent has to navigate a large map to find very sparse rewards, and the agent can be killed by enemies interspersed throughout. we found that our intrinsic rewards were able to substantially improve performance over naive exploration in this challenging environment. here, the best performance was again obtained by the surprisal incentive, which usually inspired the agent to reach scores greater than 500.among our proposed incentives, we found that surprisal worked the best overall, achieving the most consistent performance across tasks. the learning progress-based incentives worked well on some domains, but generally not as well as surprisal. interestingly, learning progress with k = 10 performed much worse on the continuous control tasks than with k = 1, but we observed virtually no difference in their performance on the atari games; it is unclear why this should be the case.
surprisal strongly outperformed the l2 error based incentive on the harder continuous control tasks, learning to solve them more quickly and without forgetting. because we used fully-factored gaussians for all of our dyanmics models, the surprisal had the form
− logpφ(s′|s, a) = n∑ i=1
( (s′i − µφ,i(s, a))2 σ2φ,i(s, a) + log σφ,i(s, a)
) + k  log 2π,
which essentially includes the l2-squared error norm as a sub-expression. the relative difference in performance suggests that the variance terms confer additional useful information about the novelty of a state-action pair.substantial theoretical work has been done on optimal exploration in finite mdps, resulting in algorithms such as e3 [10], r-max [3], and ucrl [9], which scale polynomially with mdp size. however, these works do not permit obvious generalizations to mdps with continuous state and action spaces. c-pace [18] provides a theoretical foundation for pac-optimal exploration in mdps with continuous state spaces, but it requires a metric on state spaces. lopes  [11] investigated exploration driven by learning progress and proved theoretical guarantees for their approach in the finite mdp case, but they did not address the question of scaling their approach to continuous or high-dimensional mdps. also, although they formulated learning progress in the same way as (8), they formed intrinsic rewards differently. conceptually and mathematically, our work is closest to prior work on curiosity and surprise [8, 19, 23, 24], although these works focus mainly on small finite mdps.
recently, several intrinsic motivation strategies that deal specifically with deep reinforcement learning have been proposed. stadie  [22] learn deterministic dynamics models by minimizing euclidean loss—whereas in our work, we learn stochastic dynamics with cross entropy loss—and use l2 prediction errors for intrinsic motivation. houthooft  [7] train bayesian neural networks to approximate posterior distributions over dynamics models given observed data, by maximizing a variational lower bound; they then use second-order approximations of the bayesian surprise as intrinsic motivation. bellemare  [2] derived pseudo-counts from cts density models over states and used those to form intrinsic rewards, notably resulting in dramatic performance improvement on montezuma’s revenge, one of the hardest games in the atari domain. mohamed and rezende [14] developed a scalable method of approximating empowerment, the mutual information between an agent’s actions and the future state of the environment, using variational methods. oh  [16] estimated state visit frequency using gaussian kernels to compare against a replay memory, and used these estimates for directed exploration.in this work, we formulated surprise for intrinsic motivation as the kl-divergence of the true transition probabilities from learned model probabilities, and derived two approximations—surprisal and k-step
learning progress—that are scalable, computationally inexpensive, and suitable for application to high-dimensional and continuous control tasks. we showed that empirically, motivation by surprisal and 1-step learning progress resulted in efficient exploration on several hard deep reinforcement learning benchmarks. in particular, we found that surprisal was a robust and effective intrinsic motivator, outperforming other heuristics on a wide range of tasks, and competitive with the current state-of-the-art for intrinsic motivation in continuous control.we thank rein houthooft for interesting discussions and for sharing data from the original vime experiments. we also thank rocky duan, carlos florensa, vicenc rubies-royo, dexter scobee, and eric mazumdar for insightful discussions and reviews of the preliminary manuscript.
this work is supported by trust (team for research in ubiquitous secure technology) which receives support from nsf (award number ccf-0424422).in our experiments, we approximately solve several optimization problems by using a single secondorder step with a line search. this section will describe the exact methodology, which was originally given by schulman  [20].
we consider the optimization problem
p∗ = max θ l(θ) : d(θ) ≤ δ, (13)
where θ ∈ rn, and for some θold we have d(θold) = 0,∇θd(θold) = 0, and∇2θd(θold) 0; also, ∀θ,d(θ) ≥ 0. we suppose that δ is small, so the optimal point will be close to θold. we also suppose that the curvature of the constraint is much greater than the curvature of the objective. as a result, we feel justified in approximating the objective to linear order and the constraint to quadratic order:
l(θ) ≈ l(θold) + gt (θ − θold) g . = ∇θl(θold)
d(θ) ≈ 1 2 (θ − θold)ta(θ − θold) a . = ∇2θd(θold).
we now consider the approximate optimization problem,
p∗ ≈ max θ gt (θ − θold) :  2 (θ − θold)ta(θ − θold) ≤ δ.
this optimization problem is convex as long as a 0, which is an assumption that we make. (if this assumption seems to be empirically invalid, then we repair the issue by using the substitution a→ a+ i , where i is the identity matrix, and > 0 is a small constant chosen so that we usually have a+ i 0.) this problem can be solved analytically by applying methods of duality, and its optimal point is
θ∗ = θold +
√ 2δ
gta−1g a−1g. (14)
it is possible that the parameter update step given by (14) may not exactly solve the original optimization problem (13)—in fact, it may not even satisfy the constraint—so we perform a line search between θold and θ∗. our update with the line search included is given by
θ = θold + s k
√ 2δ
gta−1g a−1g, (15)
where s ∈ (0, 1) is a backtracking coefficient, and k is the smallest integer for which l(θ) ≥ l(θold) and d(θ) ≤ δ. we select k by checking each of k = 1, 2, ...,k, where k is the maximum number of backtracks. if there is no value of k in that range which satisfies the conditions, no update is performed.
because the optimization problems we solve with this method tend to involve thousands of parameters, inverting a is prohibitively computationally expensive. thus in the implementation of this algorithm that we use, the search direction x = a−1g is found by using the conjugate gradient method to solve ax = g; this avoids the need to invert a.
when a and g are sample averages meant to stand in for expectations, we employ an additional trick to reduce the total number of computations necessary to solve ax = g. the computation of a is more expensive than g, and so we use a smaller fraction of the population to estimate it quickly. concretely, suppose that the original optimization problem’s objective is ez∼p [l(θ, z)], and the constraint is ez∼p [d(θ, z)] ≤ δ, where z is some random variable and p is its distribution; furthermore, suppose that we have a dataset of samples d = {zi}i=1,...,n drawn on p , and we form an approximate optimization problem using these samples. defining g(z) .= ∇θl(θold, z) and a(z)
. = ∇2θd(θold, z), we would need to solve(  |d| ∑ z∈d a(z)
) x = 1
|d| ∑ z∈d g(z)
to obtain the search direction x. however, because the computation of the average hessian is expensive, we sub-sample a batch b ⊂ d to form it. as long as b is a large enough set, then the approximation  |b| ∑ z∈b a(z) ≈ 1 |d| ∑ z∈d a(z) ≈ e z∼p [a(z)]
is good, and the search direction we obtain by solving( 1
|b| ∑ z∈b a(z)
) x = 1
|d| ∑ z∈d g(z)
is reasonable. the sub-sample ratio |b|/|d| is a hyperparameter of the algorithm.b.1 environments
the environments have the following state and action spaces: for the sparse mountaincar environment, s ⊆ r2, a ⊆ r1; for the sparse cartpoleswingup task, s ⊆ r4, a ⊆ r1; for the sparse halfcheetah
task, s ⊂ r20, a ⊆ r6; for the sparse swimmer task, s ⊆ r13, a ⊆ r2; for the swimmergather task, s ⊆ r33, a ⊆ r2; for the atari ram domain, s ⊆ r128, a ⊆ {1, ..., 18}. for the sparse mountaincar task, the agent receives a reward of 1 only when it escapes the valley. for the sparse cartpoleswingup task, the agent receives a reward of 1 only when cos(β) > 0.8, with β the pole angle. for the sparse halfcheetah task, the agent receives a reward of 1 when xbody ≥ 5. for the sparse swimmer task, the agent receives a reward of 1 + |vbody| when |xbody| ≥ 2. atari ram states, by default, take on values from 0 to 256 in integer intervals. we use a simple preprocessing step to map them onto values in (−1/3, 1/3). let x denote the raw ram state, and s the preprocessed ram state:
s = 1  ( x 128 − 1 ) .
b.2 policy and value functions
for all continuous control tasks we used fully-factored gaussian policies, where the means of the action distributions were the outputs of neural networks, and the variances were separate trainable parameters. for the sparse mountaincar and sparse cartpoleswingup tasks, the policy mean networks had a single hidden layer of 32 units. for sparse halfcheetah, sparse swimmer, and swimmergather, the policy mean networks were of size (64, 32). for the atari ram tasks, we used categorical distributions over actions, produced by neural networks of size (64, 32).
the value functions used for the sparse mountaincar and sparse cartpoleswingup tasks were neural networks with a single hidden layer of 32 units. for sparse halfcheetah, sparse swimmer, and swimmergather, time-varying linear value functions were used, as described by duan  [5]. for the atari ram tasks, the value functions were neural networks of size (64, 32). the neural network value functions were learned via single second-order step optimization; the linear baselines were obtained by least-squares fit at each iteration.
all neural networks were feed-forward, fully-connected networks with tanh activation units.
b.3 trpo hyperparameters
for all tasks, the mdp discount factor γ was fixed to 0.995, and generalized advantage estimators (gae) [21] were used, with the gae λ parameter fixed to 0.95.
in the table below, we show several other trpo hyperparameters. batch size refers to steps of experience collected at each iteration. the sub-sample factor is for the second-order optimization step, as detailed in appendix a.
b.4 exploration hyperparameters
for all tasks, fully-factored gaussian distributions were used as dynamics models, where the means and variances of the distributions were the outputs of neural networks.
for the sparse mountaincar and sparse cartpoleswingup tasks, the means and variances were parametrized by single hidden layer neural networks with 32 units. for all other tasks, the means and variances were parametrized by neural networks with two hidden layers of size 64 units each. all networks used tanh activation functions.
for all continuous control tasks except swimmergather, we used replay memories of size 5, 000, 000, and a kl-divergence step size of κ = 0.001. for swimmergather, the replay memory was the same size, but we set the kl-divergence size to κ = 0.005. for the atari ram domain tasks, we used replay memories of size 1, 000, 000, and a kl-divergence step size of κ = 0.01.
for all tasks except swimmergather and venture, 5000 time steps of experience were sampled from the replay memory at each iteration of dynamics model learning to take a stochastic step on (11), and a sub-sample factor of 1 was used in the second-order step optimizer. for swimmergather and venture, 10, 000 time steps of experience were sampled at each iteration, and a sub-sample factor of 0.5 was used in the optimizer.
for all continuous control tasks, the l2 penalty coefficient was set to α = 1. for the atari ram tasks except for venture, it was set to α = 0.01. for venture, it was set to α = 0.1.
for all continuous control tasks except swimmergather, η0 = 0.001. for swimmergather, η0 = 0.0001. for the atari ram tasks, η0 = 0.005.in this section, we provide an analysis of the time cost incurred by using vime or our bonuses, and derive the potential magnitude of speedup attained by our bonuses versus vime.
at each iteration, bonuses based on learned dynamics models incur two primary costs:
• the time cost of fitting the dynamics model, • and the time cost of computing the rewards.
we denote the dynamics fitting costs for vime and our methods as t fitvime and t fit ours. although the bayesian neural network dynamics model for vime is more complex than our model, the fit times can work out to be similar depending on the choice of fitting algorithm. in our speed test, the fit times were nearly equivalent, but used different algorithms.
for the time cost of computing rewards, we first introduce the following quantities:
• n: the number of cpu threads available, • tf : time for a forward pass through the model, • tb: time for a backward pass through the model, • n : batch size (number of samples per iteration), • k: the number of forward passes that can be performed simultaneously.
for our method, the time cost of computing rewards is
t rewours = ntf kn .
for vime, things are more complex. each reward requires the computation of a gradient through its model, which necessitates a forward and a backward pass. because gradient calculations cannot be efficiently parallelized by any deep learning toolkits currently available3, each (s, a, s′) tuple requires its own forward/backward pass. as a result, the time cost of computing rewards for vime is:
t rewvime = n(tf + tb)
n .
the speedup of our method over vime is therefore
t fitvime + n(tf+tb) n
t fitours + ntf kn
.
in the limit of large n , and with the approximation that tf ≈ tb, the speedup is a factor of ∼ 2k. 3if this is not correct, please contact the authors so that we can issue a correction! but to the best of our knowledge, this is currently true, at time of publication.",0
537.pdf.json,RENDERGAN: GENERATING REALISTIC LABELED DATA,"when an image is taken from a real world scene, many factors determine the final appearance: background, lighting, object shape, position and orientation of the object, the noise of the camera sensor, and more. in computer vision, high-level information such as class, shape, or pose is reconstructed from raw image data. most real-world applications require the reconstruction to be invariant to noise, background, and lighting changes.
in recent years, deep convolutional neural networks (dcnns) advanced to the state of the art in many computer vision tasks (krizhevsky , 2012; he , 2015; razavian , 2014). more training data usually increases the performance of dcnns. while image data is mostly abundant, labels for supervised training must often be created manually – a time-consuming and tedious activity. for complex annotations such as human joint angles, camera viewpoint or image segmentation, the costs of labeling can be prohibitive.
in this paper, we propose a method to drastically reduce the costs of labeling such that we can train a model to predict even complex sets of labels. we present a generative model that can sample from the joint distribution of labels and data. the training procedure of our model does not require any manual labeling. we show that the generated data is of high quality and can be used to train a model in a supervised setting, i.e. a model that maps from real samples to labels, without using any manually labeled samples.
we propose two modifications to the recently introduced gan framework (goodfellow , 2014). first, a simple 3d model is embedded into the generator network to produce samples from corresponding input labels. second, the generator learns to add missing image characteristics to the model output using a number of parameterized augmentation functions. in the adversarial training we leverage large amounts of unlabeled image data to learn the particular form of blur, lighting, background and image detail. by constraining the augmentation functions we ensure that the resulting image still represents the given set of labels. the resulting images are hard to distinguish from real samples and can be used to train a dcnn to predict the labels from real input data.
the rendergan framework was developed to solve the scarcity of labeled data in the beesbook project (wario , 2015) in which we analyze the social behavior of honeybees. a barcode-like marker is attached to the honeybees’ backs for identification (see fig. 1). annotating this data is tedious, and therefore only a limited amount of labeled data exists. a 3d model (see the upper row of fig. 2) generates a simple image of the tag based on position, orientation, and bit configuration. the rendergan then learns from unlabeled data to add lighting, background, and image details.
training a dcnn on data generated by the rendergan yields considerably better performance compared to various baselines. we furthermore include a previously used computer vision pipeline in the evaluation. the networks’ detections are used as feature to track the honeybees over time. when we use detections from the dcnn instead of the computer vision pipeline, the accuracy of assigning the true id increases from 55% to 96%.
our contributions are as follows. we present an extension of the gan framework that allows to sample from the joint distribution of data and labels. the generated samples are nearly indistinguishable from real data for a human observer and can be used to train a dcnn end-to-end to classify real samples. in a real-world use case, our approach significantly outperforms several baselines. our approach requires no manual labeling. the simple 3d model is the only form of supervision.there exists multiple approaches to reduce the costs associated with labeling.
a common approach to deal with limited amount of labels is data augmentation (goodfellow , 2016, chapter 7.4). translation, noise, and other deformations can often be applied without changing the labels, thereby effectively increasing the number of training samples and reducing overfitting.
dcnns learn a hierarchy of features – many of which are applicable to related domains (yosinski , 2014). therefore, a common technique is to pre-train a model on a larger dataset such as imagenet (deng , 2009) and then fine-tune its parameters to the task at hand (girshick , 2014; long , 2015; razavian , 2014). this technique only works in cases where a large enough related dataset exists. furthermore, labeling enough data for fine-tuning might still be costly.
if a basic model of the data exists (for example, a 3d model of the human body), it can be used to generate labeled data. peng  (2015) generated training data for a dcnn with 3d-cad models.
su  (2015) used 3d-cad models from large online repositories to generate large amounts of training images for the viewpoint estimation task on the pascal 3d+ dataset (xiang , 2014). massa  (2015) are matching natural images to 3d-cad models with features extracted from a dcnn. richter  (2016) and ros  (2016) used 3d game engines to collect labeled data for image segmentation. however, the explicit modeling of the image acquisition physics (scene lighting, reflections, lense distortions, sensor noise, etc.) is cumbersome and might still not be able to fully reproduce the particularities of the imaging process such as unstructured background or object specific noise. training a dcnn on generated data that misses certain features will result in overfitting and poor performance on the real data.
generative adversarial networks (gan) (see fig. 3) can learn to generate high-quality samples (goodfellow , 2014), i.e. sample from the data distribution p(x). denton  (2015) synthesized images with a gan on the cifar dataset (krizhevsky, 2009), which were hard for humans to distinguish from real images. while a gan implicitly learns a meaningful latent embedding of the data (radford , 2015), there is no simple relationship between the latent dimensions and the labels of interest. therefore, high-level information can’t be inferred from generated samples. cgans are an extension of gans to sample from a conditional distribution given some labels, i.e. p(x|l). however, training cgans requires a labeled dataset. springenberg (2015) showed that gans can be used in a semi-supervised setting but restricted their analysis to categorical labels. wang & gupta (2016) trained two separate gans, one to model the object normals and another one for the texture conditioned on the normals. as they rely on conditional gans, they need large amounts of labeled data. chen  (2016) used an information theoretic to disentangle the representation. they decomposed the representation into a structured and unstructured part. and successfully related on a qualitative level the structured part to high-level concepts such as camera viewpoint or hair style. however, explicitly controlling the relationship between the latent space and generated samples without using labeled data is an open problem, i.e. sampling from p(x, l) without requiring labels for training.most supervised learning tasks can be modeled as a regression problem, i.e. approximating a function f̂ : rn 7→ l that maps from data space r to label space l. we consider f̂ to be the best available function on this particular task. analogous to ground truth data, one could call f̂ the ground truth function.
in the rendergan framework, we aim to solve the inverse problem to this regression task: generate data given the labels. this is achieved by embedding a simple 3d model into the generator of a gan. the samples generated by the simple model must correspond to the given labels but may lack many factors of the real data such as background or lightning. through a cascade of augmentation functions, the generator can adapt the images from the 3d model to match the real data.
we formalize image augmentation as a function φ(x, d), which modifies the image x based on the augmentation parameter d (a tensor of any rank). the augmentation must preserve the labels of the image x. therefore, it must hold for all images x and all augmentations parameters d:
f̂ (φ(x, d)) = f̂(x) (1)
the augmentation function must furthermore be differentiable w.r.t. x and d as the gradient will be back-propagated through φ to the generator. image augmentations such as lighting, surrounding, and noise do preserve the labels and fit this definition. we will provide appropriate definitions of φ for the mentioned augmentations in the following section.
if appropriate augmentation functions are found that can model the missing factors and are differentiable, we can use the gan framework to find parameters that result in realistic output images. multiple augmentation functions can be combined to perform a more complex augmentation. here, we will consider multiple augmentation functions applied sequentially, i.e. we have k augmentation functions φi and k corresponding outputs gi from the generator. the output of the previous augmentation function is the input to the next one. thus, we can write the generator given some labels l as:
g(z, l) = φk(φk−1(. . . φ0(m(l), g0(z)) . . . , gk−1(z)), gk(z)) (2)
where m is the 3d model. we can furthermore learn the label distribution with the generator. as the discriminator loss must be backpropagated through the 3d model m, it must be differentiable. this can be achieved by emulating the 3d model with a neural network (dosovitskiy , 2015). the resulting generator g(z) can be written as (see fig. 4 for a visual interpretation):
g(z) = φk(φk−1(. . . φ0(m(gl(z)), g0(z)) . . . , gk−1(z)), gk(z)) (3)
as any differentiable function approximator can be employed in the gan framework, the theoretical properties still hold. the training is carried out as in the conventional gan framework. in a real application, the augmentation functions might restrict the generator from converging to the data distribution.
if the training converges, we can collect generated realistic data with g(z) and the high-level information captured in the 3d model with gl(z). we can now train a supervised learning algorithm on the labeled generated data (gl (z) , g (z)) and solve the regression task of approximating f̂ without depending on manual labels.in the beesbook project, we aim to understand the complex social behavior of honey bees. for identification, a tag with a binary code is attached to the back of the bees.
the orientations in space, position, and bits of the tags are required to track the bees over time. decoding this information is not trivial: the bees are oriented in any direction in space. the tag might be partially occluded. moreover, spotlights on the tag can sometimes even confuse humans. a previously used computer vision pipeline did not perform reliably. although we invested a substantial amount of time on labeling, a dcnn trained on this data did not perform significantly better (see sec. 3). we therefore wanted to synthesize labeled images which are realistic enough to train an improved decoder network.
following the idea outlined in section 3, we created a simple 3d model of a bee marker. the 3d model comprises a mesh which represents the structure of the marker and a simple camera model to project the mesh to the image plane. the model is parameterized by its position, its pitch, yaw and roll, and its id. given a parameter set, we obtain a marker image, a background segmentation mask
and a depth map. the generated images lack many important factors: blur, lighting, background, and image detail (see fig. 2). a dcnn trained on this data does not generalize well (see sec. 5).
over the last years we collected a large amount of unlabeled image data. we successfully augmented the 3d model using this dataset, as described below.
we trained a neural network to emulate the 3d model. its outputs are indistinguishable from the images of the 3d model. the discriminator error can now be backpropagated through the 3d model which allows the generator to also learn the distributions of positions and orientations of the bee marker. the ids are sampled uniformly during training. the weights of the 3d model network are fixed during the rendergan training.
we apply different augmentation functions that account for blur, lighting, background, and image detail. the output of the 3d model and of each augmentation function is of shape (64, 64) and in the range [−1, 1]. in fig. 5, the structure of the generator is shown. blurriness: the 3d model produces hard edges, but the images of the real tags show a broad range of blur. the generator produces a scalar α ∈ [0, 1] per image that controls the blur.
φblur(x, α) = (1− α) (x− bσ (x)) + bσ(x) (4)
where bσ(x) = x ∗ kσ denotes convolving the image x with a gaussian kernel kσ of scale σ. the implementation of the blur function is inspired by laplacian pyramids (burt & adelson, 1983). as required for augmentation functions, the labels are preserved, because we limit the maximum amount of blur by picking σ = 2. φblur is also differentiable w.r.t the inputs α and x.
lighting of the tag: the images from the 3d model are binary. in real images, tags exhibit different shades of gray. we model the lighting by a smooth scaling and shifting of the pixel intensities. the generator provides three outputs for the lighting: scaling of black parts sb, scaling of white parts sw and a shift t. all outputs have the same dimensions as the image x. an important invariant is that the black bits of the tag must stay darker than the white bits. otherwise, a bit could flip, and the label would change. by restricting the scaling sw and sb to be between 0.10 and 1, we ensure that this invariant holds. the lighting is locally corrolated and should cause smooth changes in the image. hence, gaussian blur b(x) is applied to sb, sw, and t.
φlighting(x, sw, sb, t) = x · b(sw) ·w (x) + x · b(sb) · (1−w (x)) + b(t) (5)
the segmentation mask w (x) is one for white parts and zero for the black part of the image. as the intensity of the input is distributed around -1 and 1, we can use thresholding to differentiate between black and white parts.
background: the background augmentation can change the background pixels arbitrarily. a segmentation mask bx marks the background pixels of the image x which are replaced by the pixels from the generated image d.
φbg(x, d) = x · (1−bx) + d ·bx (6)
the 3d model provides the segmentation mask. as φbg can only change background pixels, the labels remain unchanged.
details: in this stage, the generator can add small details to the whole image including the tag. the output of the generator d is passed through a high-pass filter to ensure that the added details are small enough not to flip a bit. furthermore, d is restricted to be in [−2, 2] to make sure the generator cannot avoid the highpass filter by producing huge values. with the range [−2, 2], the generator has the possibility to change black pixels to white, which is needed to model spotlights.
φdetail(x, d) = x+ highpass(d) (7) the high-pass is implemented by taking the difference between the image and a blurred version of the image (σ = 3.5). as the spotlights on the tags are only a little smaller than the bits, we increase its slope after the cutoff frequency by repeating the high-pass filter three times.
the image augmentations are applied in the order as listed above: φdetail ◦φbackground ◦φlighting ◦ φblur. please note that there exist parameters to the augmentation functions that could change the labels. as long as it is guaranteed that such augmentations will result in unrealistic looking images, the generator network will learn to avoid them. for example, even though the detail augmentation could be used to add high-frequency noise to obscure the tag, this artifact would be detected by the discriminator.
architecture of the generator: the generator network has to produce outputs for each augmentation function. we will outline only the most important parts. see our code available online for all the details of the networks1. the generator starts with a small network consisting of dense layers, which predicts the parameters for the 3d model (position, orientations). the output of another dense layer is reshaped and used as starting block for a chain of convolution and upsampling layers. we found it advantageous to merge a depth map of the 3d model into the generator as especially the lighting depends on the orientation of the tag in space. the input to the blur augmentation is predicted by reducing an intermediate convolutional feature map to a single scalar. an additional network is branched off to predict the input to the lighting augmentation. for the background generation, the output of the lighting network is merged back into the main generator network together with the actual image from the 3d model.
for the discriminator architecture, we mostly rely on the architecture given by radford  (2015), but doubled the number of convolutional layers and added a final dense layer. this change improved the quality of the generated images.
clip layer: some of the augmentation parameters have to be restricted to a range of values to ensure that the labels remain valid. the training did not converge when using functions like tanh or sigmoid due to vanishing gradients. we are using a combination of clipping and activity regularization to keep the output in a given interval [a, b]. if the input x is out of bounds, it is clipped and a regularization loss r depending on the distance between x and the appropriate bound is added.
r(x) =  γ||x− a||1 if x < a 0 if a ≤ x ≤ b γ||x− b||1 if x > b
(8)
f(x) = min(max(a, x), b) (9) with the scalar γ, the weight of the loss can be adapted. for us γ = 15 worked well. if γ is chosen too small, the regularization loss might not be big enough to move the output of the previous layer towards the interval [a, b]. during training, we observe that the loss decreases to a small value but never vanishes.
training: we train generator and discriminator as in the normal gan setting. we use 2.4m unlabeled images of tags to train the rendergan. we use adam (kingma & ba, 2014) as an optimizer with a starting learning rate of 0.0002, which we reduce in epoch 200, 250, and 300 by a factor of 0.25. in fig. 6b the training loss of the gan is shown. the gan does not converge to the point where the discriminator can no longer separate generated from real samples. the augmentation functions might restrict the generator too much such that it cannot model certain properties. nevertheless, it is hard for a human to distinguish the generated from real images. in some cases, the https://github.com/berleon/deepdecoder
generator creates unrealistic high-frequencies artifacts. the discriminator unfailingly assigns a low score to theses images. we can therefore discard them for the training of the supervised algorithm. more generated images are shown in appendix a. in fig. 7, we show random points in the latent space, while fixing the tag parameters. the generator indeed learned to model the various lighting conditions, noise intensities, and backgrounds.we constructed the rendergan to generate labeled data. but does a dcnn trained with the rendergan data perform better than one trained on the limited amounts of real data? and are learned augmentations indeed needed or do simple hand-designed augmentation achieve the same result? the following paragraphs describe the different datasets used in the evaluation. we focus on the performance of a dcnn on the generated data. thus, we do not compare our method to conventional gans as those do not provide labels and are generally hard to evaluate.
data from the rendergan: we generate 5 million tags with the rendergan framework. due to the abundance, one training sample is only used twice during training. it is not further augmented.
real data: the labels of the real data are extracted from ground truth data that was originally collected to evaluate bee trajectories. this ground truth data contains the path and id of each bee over multiple consecutive frames. data from five different time spans was annotated – in total 66k tags. as the data is correlated in time (same ids, similar lighting conditions), we assign the data from one time span completely to either the train or test set. the data from three time spans forms the train set (40k). the test set (26k) contains data from the remaining two time spans. the ground truth data lacks the orientation of the tags, which is therefore omitted for this evaluation. due to the smaller
size of the real training set, we augment it with random translation, rotation, shear transformation, histogram scaling, and noise (see appendix c for exact parameters).
rendergan + real: we also train a dcnn on generated and real data which is mixed at a 50:50 ratio.
handmade augmentations: we tried to emulate the augmentations learned by the rendergan by hand. for example, we generate the background by an image pyramid where the pixel intensities are drawn randomly. we model all effects, i.e. blur, lighting, background, noise and spotlights (see appendix b for details on their implementation). we apply the handmade augmentation to different learned representations of the rendergan, e.g. we use the learned lighting representation and add the remaining effects such as background and noise with handmade augmentations (hm li). see table 1 for the different combinations of learned representations and hand designed augmentations.
computer vision pipeline cv : the previously used computer vision pipeline (wario , 2015) is based on manual feature extraction. for example, a modified hough transformation to find ellipses. the mhd obtained by this model is only a rough estimate given that the computer vision pipeline had to be evaluated and fine-tuned on the same data set due to label scarcity.
training setup: an epoch consists of 1000 batches á 128 samples. we use early stopping to select the best parameters of the networks. for the training with generated data, we use the real training set as the validation set. when training on real data, the test set is also used for validation. we could alternatively reduce the real training set further and form an extra validation set, but this would harm the performance of the dcnn trained on the real data. we use the 34-layer resnet architecture (he , 2015) but start with 16 feature maps instead of 64. the dcnns are evaluated on the mean hamming distance (mhd) i.e. the expected value of bits decoded wrong. human experts can decode tags with a mhd of around 0.23.
results: in table 2, we present the results of the evaluation. the training losses of the networks are plotted in fig. 8. the model trained with the data generated by the rendergan has an mhd of 0.424. the performance can furthermore be slightly improved by combining the generated with real data. the small gap in performance when adding real data is a further indicator of the quality of the generated samples.
if we use predictions from this dcnn instead of the computer vision pipeline, the accuracy of the tracking improves from 55% of the ids assigned correctly to 96%. at this quality, it is possible to analyze the social behavior of the honeybees reliably.
compared to the handmade augmentations (hm 3d), data from the rendergan leads to considerably better performance. the large gap in performance between the hm 3d and hm li data highlights the importance of the learned lighting augmentation.we proposed a novel extension to the gan framework that is capable of rendering samples from a basic 3d model more realistic. compared to computer graphics pipelines, the rendergan can learn complex effects from unlabeled data that would be otherwise hard to model with explicit rules.
contrary to conventional gans, the generator provides explicit information about the synthesized images, which can be used as labels for a supervised algorithm. the training of the rendergan requires no labels.
we showed an application of the rendergan framework to the beesbook project, in which the generator adds blur, lighting, background, and details to images from a basic 3d model. the generated data looks strikingly real and includes fine details such as spotlights, compression artifacts, and sensor noise.
in contrast to previous work that applied 3d models to produce training samples for dcnns (su , 2015; richter , 2016; ros , 2016), we were able to train a dcnn from scratch with only generated data that still generalizes to unseen real data.
while some work is required to adapt the rendergan to a specific domain, once set up, arbitrary amounts of labeled data can be acquired cheaply, even if the data distribution changes. for example, if the tag design changes to include more bits, small adaptions to the 3d model’s source code and eventually the hyperparameters of the augmentation functions would be sufficient. however, if we had labeled the data by hand, then we would have to annotate data again.
while the proposed augmentations represent common image characteristics, a disadvantage of the rendergan framework is that these augmentation functions must be carefully customized for the application at hand to ensure that high-level information is preserved. furthermore, a suitable 3d model must be available.for future work, it would be interesting to see the rendergan framework used on other tasks where basic 3d models exist e.g. human faces, pose estimation, or viewpoint prediction. in this context, one could come up with different augmentation functions e.g. colorization, affine transformations, or diffeomorphism. the rendergan could be especially valuable to domains where pre-trained models are not available or when the annotations are very complex. another direction of future work might be to extend the rendergan framework to other fields. for example, in speech synthesis, one could use an existing software as a basic model and improve the realism of the output with a similar approach as in the rendergan framework.we constructed augmentations for blur, lighting, background, noise and spotlights manually. for synthesizing lighting, background and noise, we use image pyramids, i.e. a set of images l0, . . . , l6 of size (2i × 2i) for 0 ≤ i ≤ 6. each level li in the pyramid is weighted by a scalar ωi. each pixel of the different level li is drawn from n (0, 1). the generated image i6 is given by:
i0 = ω0l0 (10) ii = ωili + upscale(ii−1) (11)
, where upscale doubles the image dimensions. the pyramid enables us to generate random images while controlling their frequency domain by weighting the pyramid levels appropriately.
• blur: gaussian blur with randomly sampled scale. • lighting: similar as in the rendergan. here, the scaling of the white and black parts
and shifting is constructed with image pyramids. • background: image pyramids with the lower levels weight more. • noise: image pyramids with only the last two layer. • spotlights: overlay with possible multiple 2d gauss function with a random position on
the tag and random covariance.
we selected all parameters manually by comparing the generated to real images. however, using slightly more unrealistic images resulted in better performance of the dcnn trained with the hm 3d data. the parameters of the handmade augmentations can be found online in our source code repository.we scale and shift the pixel intensities randomly, i.e. si+t, where i is the image and s, t are scalars. the noise is sampled for each pixel fromn (0, ), where ∼ max(0, n (µn, σn)) is drawn for each image separately. different affine transformations (rotation, scale, translation, and shear) are used.",0
564.pdf.json,HIGHER ORDER RECURRENT NEURAL NETWORKS,"in the recent resurgence of neural networks in deep learning, deep neural networks have achieved successes in various real-world applications, such as speech recognition, computer vision and natural language processing. deep neural networks (dnns) with a deep architecture of multiple nonlinear layers are an expressive model that can learn complex features and patterns in data. each layer of dnns learns a representation and transfers them to the next layer and the next layer may continue to extract more complicated features, and finally the last layer generates the desirable output. from early theoretical work, it is well known that neural networks may be used as the universal approximators to map from any fixed-size input to another fixed-size output. recently, more and more empirical results have demonstrated that the deep structure in dnns is not just powerful in theory but also can be reliably learned in practice from a large amount of training data.
sequential modeling is a challenging problem in machine learning, which has been extensively studied in the past. recently, many deep neural network based models have been successful in this area, as shown in various tasks such as language modeling mikolov (2012), sequence generation graves (2013); sutskever  (2011), machine translation sutskever  (2014) and speech recognition graves  (2013). among various neural network models, recurrent neural networks (rnns) are appealing for modeling sequential data because they can capture long term dependency in sequential data using a simple mechanism of recurrent feedback. rnns can learn to model sequential data over an extended period of time, then carry out rather complicated transformations on the sequential data. rnns have been theoretically proved to be a turing complete machine siegelmann & sontag (1995). rnns in principle can learn to map from one variable-length sequence to another. when unfolded in time, rnns are equivalent to very deep neural networks that share model parameters and receive the input at each time step. the recursion in the hidden layer of rnns can act as an excellent memory mechanism for the networks. in each time step, the learned recursion weights may decide what information to discard and what information to keep in order to relay onwards along time. while rnns are theoretically powerful, the learning of rnns needs to use the back-propagation through time (bptt) method werbos (1990) due to the internal recurrent cycles. unfortunately, in practice, it turns out to be rather difficult to train rnns to capture long-term dependency due to the fact that
the gradients in bptt tend to either vanish or explode bengio  (1994). many heuristic methods have been proposed to solve these problems. for example, a simple method, called gradient clipping, is used to avoid gradient explosion mikolov (2012). however, rnns still suffer from the vanishing gradient problem since the gradients decay gradually as they are back-propagated through time. as a result, some new recurrent structures are proposed, such as long short-term memory (lstm) hochreiter & schmidhuber (1997) and gated recurrent unit (gru) cho  (2014). these models use some learnable gates to implement rather complicated feedback structures, which ensure that some feedback paths can allow the gradients to flow back in time effectively. these models have given promising results in many practical applications, such as sequence modeling graves (2013), language modeling sundermeyer  (2012), hand-written character recognition liwicki  (2012), machine translation cho  (2014), speech recognition graves  (2013).
in this paper, we explore an alternative method to learn recurrent neural networks (rnns) to model long term dependency in sequential data. we propose to use more memory units to keep track of more preceding rnn states, which are all recurrently fed to the hidden layers as feedback through different weighted paths. analogous to digital filters in signal processing, we call these new recurrent structures as higher order recurrent neural networks (hornns). at each time step, the proposed hornns directly combine multiple preceding hidden states from various history time steps, weighted by different matrices, to generate the feedback signal to each hidden layer. by aggregating more history information of the rnn states, hornns are provided with better short-term memory mechanism than the regular rnns. moreover, those direct connections to more previous rnn states allow the gradients to flow back smoothly in the bptt learning stage. all of these ensure that hornns can be more effectively learned to capture long term dependency. similar to rnns and lstms, the proposed hornns are general enough for variety of sequential modeling tasks. in this work, we have evaluated hornns for the language modeling task on two popular data sets, namely the penn treebank (ptb) and english text8 sets. experimental results have shown that hornns yield the state-of-the-art performance on both data sets, significantly outperforming the regular rnns as well as the popular lstms.hierarchical recurrent neural network proposed in hihi & bengio (1996) is one of the earliest papers that attempt to improve rnns to capture long term dependency in a better way. it proposes to add linear time delayed connections to rnns to improve the gradient descent learning algorithm to find a better solution, eventually solving the gradient vanishing problem. however, in this early work, the idea of multi-resolution recurrent architectures has only been preliminarily examined for some simple small-scale tasks. this work is somehow relevant to our work in this paper but the higher order rnns proposed here differs in several aspects. firstly, we propose to use weighted connections in the structure, instead of simple multi-resolution short-cut paths. this makes our models fall into the category of higher order models. secondly, we have proposed to use various pooling functions in generating the feedback signals, which is critical in normalizing the dynamic ranges of gradients flowing from various paths. our experiments have shown that the success of our models is largely attributed to this technique.
the most successful approach to deal with vanishing gradients so far is to use long short term memory (lstm) model hochreiter & schmidhuber (1997). lstm relies on a fairly sophisticated structure made of gates to control flow of information to the hidden neurons. the drawback of the lstm is that it is complicated and slow to learn. the complexity of this model makes the learning very time consuming, and hard to scale for larger tasks. another approach to address this issue is to add a hidden layer to rnns mikolov  (2014). this layer is responsible for capturing longer term dependencies in input data by making its weight matrix close to identity. recently, clockwork rnns koutnik  (2014) are proposed to address this problem as well, which splits each hidden layer into several modules running at different clocks. each module receives signals from input and computes its output at a predefined clock rate. gated feedback recurrent neural networks chung  (2015) attempt to implement a generalized version using the gated feedback connection between layers of stacked rnns, allowing the model to adaptively adjust the connection between consecutive hidden layers.
besides, short-cut skipping connections were considered earlier in wermter (1992), and more recently have been found useful in learning very deep feed-forward neural networks as well, such as lee  (2014); he  (2015). these skipping connections between various layers of neural networks can improve the flow of information in both forward and backward passes. among them, highway networks srivastava  (2015) introduce rather sophisticated skipping connections between layers, controlled by some gated functions.a recurrent neural network (rnn) is a type of neural network suitable for modeling a sequence of arbitrary length. at each time step t, an rnn receives an input xt, the state of the rnn is updated recursively as follows (as shown in the left part of figure 1):
ht = f(winxt +whht−1) (1)
where f(·) is an nonlinear activation function, such as sigmoid or rectified linear (relu), and win is the weight matrix in the input layer and wh is the state to state recurrent weight matrix. due to the recursion, this hidden layer may act as a short-term memory of all previous input data.
given the state of the rnn, i.e., the current activation signals in the hidden layer ht, the rnn generates the output according to the following equation:
yt = g(woutht) (2)
where g(·) denotes the softmax function and wout is the weight matrix in the output layer. in principle, this model can be trained using the back-propagation through time (bptt) algorithm werbos (1990). this model has been used widely in sequence modeling tasks like language modeling mikolov (2012).rnns are very deep in time and the hidden layer at each time step represents the entire input history, which acts as a short-term memory mechanism. however, due to the gradient vanishing problem in back-propagation, it turns out to be very difficult to learn rnns to model long-term dependency in sequential data.
in this paper, we extend the standard rnn structure to better model long-term dependency in sequential data. as shown in the right part of figure 1, instead of using only the previous rnn state as the feedback signal, we propose to employ multiple memory units to generate the feedback signal at each time step by directly combining multiple preceding rnn states in the past, where these timedelayed rnn states go through separate feedback paths with different weight matrices. analogous to the filter structures used in signal processing, we call this new recurrent structure as higher order rnns, hornns in short. the order of hornns depends on the number of memory units used for feedback. for example, the model used in the right of figure 1 is a 3rd-order hornn. on the other hand, regular rnns may be viewed as 1st-order hornns.
in hornns, the feedback signal is generated by combining multiple preceding rnn states. therefore, the state of an n -th order hornn is recursively updated as follows:
ht = f ( winxt +
n∑ n=1 whnht−n
) (3)
where {whn | n = 1, · · ·n} denotes the weight matrices used for various feedback paths. similar to
rnns, hornns can also be unfolded in time to get rid of the recurrent cycles. as shown in figure 2, we unfold a 3rd-order hornn in time, which clearly shows that each hornn state is explicitly decided by the current input xt and all previous 3 states in the past. this structure looks similar to the skipping short-cut paths in deep neural networks but each path in hornns maintains a learnable weight matrix. the new structure in hornns can significantly improve the model capacity to capture long-term dependency in sequential data. at each time step, by explicitly aggregating multiple preceding hidden activities, hornns may derive a good representation of the history information in sequences, leading to a significantly enhanced short-term memory mechanism.
during the backprop learning procedure, these skipping paths directly connected to more previous hidden states of hornns may allow the gradients to flow more easily back in time, which eventually leads to a more effective learning of models to capture long term dependency in sequences. therefore, this structure may help to largely alleviate the notorious problem of vanishing gradients in the rnn learning.
obviously, hornns can be learned using the same bptt algorithm as regular rnns, except that the error signals at each time step need to be back-propagated to multiple feedback paths in the network. as shown in figure 3, for a 3rd-order hornn, at each time step t, the error signal from the hidden layer ht will have to be back-propagated into four different paths: i) the first one back to the input layer, xt; ii) three more feedback paths leading to three different histories in time scales, namely ht−1, ht−2 and ht−3.
interestingly enough, if we use a fully-unfolded implementation for hornns as in figure 2, the overall computation complexity is comparable with regular rnns. given a whole sequence, we may first simultaneously compute all hidden activities (from xt to ht for all t). secondly, we recursively update ht for all t using eq.(3). finally, we use gpus to compute all outputs together from the updated hidden states (from ht to yt for all t) based on eq.(2). the backward pass in learning can also be implemented in the same three-step procedure. except the recursive updates in the second step (this issue remains the same in regular rnns), all remaining computation steps can be formulated as large matrix multiplications. as a result, the computation of hornns can be implemented fairly efficiently using gpus.as discussed above, the shortcut paths in hornns may help the models to capture long-term dependency in sequential data. on the other hand, they may also complicate the learning in a different way. due to different numbers of hidden layers along various paths, the signals flowing from different paths may vary dramatically in the dynamic range. for example, in the forward pass in figure 2, three different feedback signals from different time scales, e.g. ht−1, ht−2 and ht−3, flow into
the hidden layer to compute the new hidden state ht. the dynamic range of these signals may vary dramatically from case to case. the situation may get even worse in the backward pass during the bptt learning. for example, in a 3rd-order hornn in figure 2, the node ht−3 may directly receive an error signal from the node ht. in some cases, it may get so strong as to overshadow other error signals coming from closer neighbours of ht−1 and ht−2. this may impede the learning of hornns, yielding slow convergence or even poor performance.
here, we have proposed to use some pooling functions to calibrate the signals from different feedback paths before they are used to recursively generate a new hidden state, as shown in figure 4. in the following, we will investigate three different choices for the pooling function in figure 4, including max-based pooling, fofe-based pooling and gated pooling.max-based pooling is a simple strategy that chooses the most responsive unit (exhibiting the largest activation value) among various paths to transfer to the hidden layer to generate the new hidden state. many biological experiments have shown that biological neuron networks tend to use a similar strategy in learning and firing.
in this case, instead of using eq.(3), we use the following formula to update the hidden state of hornns: ht = f ( winxt +max n n=1 (whnht−n) ) (4)
where maximization is performed element-wisely to choose the maximum value in each dimension to feed to the hidden layer to generate the new hidden state. the aim here is to capture the most relevant feature and map it to a fixed predefined size.
the max pooling function is simple and biologically inspired. however, the max pooling strategy also has some serious disadvantages. for example, it has no forgetting mechanism and the signals may get stronger and stronger. furthermore, it loses the order information of the preceding histories since it only choose the maximum values but it does not know where the maximum comes from.the fixed-size ordinally-forgetting encoding (fofe) method was proposed in zhang  (2015) to encode any variable-length sequence of data into a fixed-size representation. in fofe, a single forgetting factor α (0 < α < 1) is used to encode the position information in sequences based on the idea of exponential forgetting to derive invertible fixed-size representations. in this work, we borrow this simple idea of exponential forgetting to calibrate all preceding histories using a pre-selected forgetting factor as follows:
ht = f ( winxt +
n∑ n=1 αn ·whnht−n
) (5)
where the forgetting factor α is manually pre-selected between 0 < α < 1. the above constant coefficients related to α play an important role in calibrating signals from different paths in both
forward and backward passes of hornns since they slightly underweight the older history over the recent one in an explicit way.in this section, we follow the ideas of the learnable gates in lstms hochreiter & schmidhuber (1997) and grus cho  (2014) as well as the recent soft-attention in bahdanau  (2014). instead of using constant coefficients derived from a forgetting factor, we may let the network automatically determine the combination weights based on the current state and input. in this case, we may use sigmoid gates to compute combination weights to regulate the information flowing from various feedback paths. the sigmoid gates take the current data and previous hidden state as input to decide how to weight all of the precede hidden states. the gate function weights how the current hidden state is generated based on all the previous time-steps of the hidden layer. this allows the network to potentially remember information for a longer period of time. in a gated hornn, the hidden state is recursively computed as follows:
ht = f ( winxt +
n∑ n=1 rn ( whnht−n )) (6)
where denotes element-wise multiplication of two equally-sized vectors, and the gate signal rn is calculated as
rn = σ (w g 1nxt +w g 2nht−n) (7)
where σ(·) is the sigmoid function, and w g1n and w g 2n denote two weight matrices introduced for each gate.
note that the computation complexity of gated hornns is comparable with lstms and grus, significantly exceeding the other hornn structures because of the overhead from the gate functions in eq. (7).in this section, we evaluate the proposed higher order rnns (hornns) on several language modeling tasks. a statistical language model (lm) is a probability distribution over sequences of words in natural languages. recently, neural networks have been successfully applied to language modeling bengio  (2003); mikolov  (2011), yielding the state-of-the-art performance. in language modeling tasks, it is quite important to take advantage of the long-term dependency of natural languages. therefore, it is widely reported that rnn based lms can outperform feedforward neural networks in language modeling tasks. we have chosen two popular lm data sets, namely the penn treebank (ptb) and english text8 sets, to compare our proposed hornns with traditional n-gram lms, rnn-based lms and the state-of-the-art performance obtained by lstms graves (2013); mikolov  (2014), fofe based feedforward nns zhang  (2015) and memory networks sukhbaatar  (2015).
in our experiments, we use the mini-batch stochastic gradient decent (sgd) algorithm to train all neural networks. the number of back-propagation through time (bptt) steps is set to 30 for all recurrent models. each model update is conducted using a mini-batch of 20 subsequences, each of which is of 30 in length. all model parameters (weight matrices in all layers) are randomly initialized based on a gaussian distribution with zero mean and standard deviation of 0.1. a hard clipping is set to 5.0 to avoid gradient explosion during the bptt learning. the initial learning rate is set to 0.5 and we halve the learning rate at the end of each epoch if the cross entropy function on the validation set does not decrease. we have used the weight decay, momentum and column normalization pachitariu & sahani (2013) in our experiments to improve model generalization. in the fofe-based pooling function for hornns, we set the forgetting factor, α, to 0.6. we have used 400 nodes in each hidden layer for the ptb data set and 500 nodes per hidden layer for the english text8 set. in our experiments, we do not use the dropout regularization zaremba  (2014) in all experiments since it significantly slows down the training speed, not applicable to any larger corpora. 1 we will soon release the code for readers to reproduce all results reported in this paper.the standard penn treebank (ptb) corpus consists of about 1m words. the vocabulary size is limited to 10k. the preprocessing method and the way to split data into training/validation/test sets are the same as mikolov  (2011). ptb is a relatively small text corpus. we first investigate various model configurations for the hornns based on ptb and then compare the best performance with other results reported on this task.in the first experiment, we first investigate how the used orders in hornns may affect the performance of language models (as measured by perplexity). we have examined all different higher order model structures proposed in this paper, including hornns and various pooling functions in hornns. the orders of these examined models varies among 2, 3 and 4. we have listed the performance of different models on ptb in table 1. as we may see, we are able to achieve a significant improvement in perplexity when using higher order rnns for language models on ptb, roughly 10-20 reduction in ppl over regular rnns. we can see that performance may improve slightly when the order is increased from 2 to 3 but no significant gain is observed when the order is further increased to 4. as a result, we choose the 3rd-order hornn structure for the following experiments. among all different hornn structures, we can see that fofe-based pooling and gated structures yield the best performance on ptb.
in language modeling, both input and output layers account for the major portion of model parameters. therefore, we do not significantly increase model size when we go to higher order structures. for example, in table 1, a regular rnn contains about 8.3 millions of weights while a 3rd-order hornn (the same for max or fofe pooling structures) has about 8.6 millions of weights. in comparison, an lstm model has about 9.3 millions of weights and a 3rd-order gated hornn has about 9.6 millions of weights.
as for the training speed, most hornn models are only slightly slower than regular rnns. for example, one epoch of training on ptb running in one nvidia’s titan x gpu takes about 80 seconds for an rnn, about 120 seconds for a 3rd-order hornn (the same for max or fofe pooling structures). similarly, training of gated hornns is also slightly slower than lstms. for example, one epoch on ptb takes about 200 seconds for an lstm, and about 225 seconds for a 3rd-order gates hornn.at last, we report the best performance of various hornns on the ptb test set in table 2. we compare our 3rd-order hornns with all other models reported on this task, including rnn mikolov  (2011), stack rnn pascanu  (2014), deep rnn pascanu  (2014), fofe-fnn zhang  (2015) and lstm graves (2013). 2 from the results in table 2, we can see that our proposed higher order rnn architectures significantly outperform all other baseline models reported on this task. both fofe-based pooling and gated hornns have achieved the state-of-the-art performance, all models in table 2 do not use the dropout regularization, which is somehow equivalent to data augmentation. in zaremba  (2014); kim  (2015), the proposed lstm-lms (word level or character level) achieve lower perplexity but they both use the dropout regularization and much bigger models and it takes days to train the models, which is not applicable to other larger tasks.
table 2: perplexities on the ptb test set for various examined models.
models test kn 5-gram mikolov  (2011) 141 rnn mikolov  (2011) 123 cslm5aransa  (2015) 118.08 lstm graves (2013) 117 gencnn wang  (2015) 116.4 gated word&charmiyamoto & cho (2016) 113.52 e2e mem net sukhbaatar  (2015) 111 stack rnn pascanu  (2014) 110 deep rnn pascanu  (2014) 107 fofe-fnn zhang  (2015) 108 hornn (3rd order) 108 max hornn (3rd order) 109 fofe hornn (3rd order) 101 gated hornn (3rd order) 100
table 3: perplexities on the text8 test set for various models.
models test rnn mikolov  (2014) 184 lstm mikolov  (2014) 156 scrnn mikolov  (2014) 161 e2e mem net sukhbaatar  (2015) 147 hornn (3rd order) 172 max hornn (3rd order) 163 fofe hornn (3rd order) 154 gated hornn (3rd order) 144
i.e., 100 in perplexity on this task. to the best of our knowledge, this is the best reported performance on ptb under the same training condition.in this experiment, we will evaluate our proposed hornns on a much larger text corpus, namely the english text8 data set. the text8 data set contains a preprocessed version of the first 100 million characters downloaded from the wikipedia website. we have used the same preprocessing method as mikolov  (2014) to process the data set to generate the training and test sets. we have limited the vocabulary size to about 44k by replacing all words occurring less than 10 times in the training set with an <unk> token. the text8 set is about 20 times larger than ptb in corpus size. the model training on text8 takes longer to finish. we have not tuned hyperparameters in this data set. we simply follow the best setting used in ptb to train all hornns for the text8 data set. meanwhile, we also follow the same learning schedule used in mikolov  (2014): we first initialize the learning rate to 0.5 and run 5 epochs using this learning rate; after that, the learning rate is halved at the end of every epoch.
because the training is time-consuming, we have only evaluated 3rd-order hornns on the text8 data set. the perplexities of various hornns are summarized in table 3. we have compared our hornns with all other baseline models reported on this task, including rnn mikolov  (2014), lstm mikolov  (2014), scrnn mikolov  (2014) and end-to-end memory networks sukhbaatar  (2015). results have shown that all hornn models work pretty well in this data set except the normal hornn significantly underperforms the other three models. among them, the gated hornn model has achieved the best performance, i.e., 144 in perplexity on this task, which is slightly better than the recent result obtained by end-to-end memory networks (using a rather complicated structure). to the best of our knowledge, this is the best performance reported on this task.in this paper, we have proposed some new structures for recurrent neural networks, called as higher order rnns (hornns). in these structures, we use more memory units to keep track of more preceding rnn states, which are all fed along various feedback paths to the hidden layer to generate the feedback signals. in this way, we may enhance the model to capture long term dependency in sequential data. moreover, we have proposed to use several types of pooling functions to calibrate multiple feedback paths. experiments have shown that the pooling technique plays a critical role in learning higher order rnns effectively. in this work, we have examined hornns for the language modeling task using two popular data sets, namely the penn treebank (ptb) and text8 sets. experimental results have shown that the proposed higher order rnns yield the state-of-the-art performance on both data sets, significantly outperforming the regular rnns as well as the popular lstms. as the future work, we are going to continue to explore hornns for other sequential modeling tasks, such as speech recognition, sequence-to-sequence modelling and so on.",0
580.pdf.json,INTELLIGIBLE LANGUAGE MODELING WITH INPUT SWITCHED AFFINE NETWORKS,"neural networks and the general field of deep learning have made remarkable progress over the last few years in fields such as object recognition (krizhevsky , 2012), language translation (sutskever , 2014), and speech recognition (graves , 2013). for all of the success of the deep learning approach however, there are certain application domains in which intelligibility of the system is an essential design requirement. one commonly used example is the necessity to understand the decisions that a self-driving vehicle makes when avoiding various obstacles in its path. another example is the application of neural network methodologies to scientific discovery (mante , 2013). even where intelligibility is not an overt design requirement, it is fair to say that most users of neural networks would like to better understand the models they deploy.
there are at least two approaches to creating intelligible network models. one approach is to build networks as normal, and then apply analysis techniques after training. often this approach yields systems that perform extremely well, and whose intelligibility is limited. a second approach is to build a neural network where intelligibility is an explicit design constraint. in this case, the typical result is a system that can be understood reasonably well, but may underperform. in this work we follow this second approach and build intelligibility into our network model, yet without sacrificing performance for the task we studied.
designing intelligibility into neural networks for all application domains is a worthy, but daunting goal. here we contribute to that larger goal by focusing on a commonly studied task, that of character based
∗this work was performed as an intern at google brain. †work done as a member of the google brain residency program (g.co/brainresidency) ‡work performed when author was a visiting faculty at google brain.
language modeling. we develop and analyze a model trained on a one-step-ahead prediction task of the text8 dataset, which is 10 million characters of wikipedia text (mahoney, 2011). the model we use is a switched affine system, where the input determines the switching behavior by selecting a transition matrix and bias as a function of that input, and there is no nonlinearity. surprisingly, we find that this simple architecture performs as well as a vanilla rnn, gated recurrent unit (gru) (cho , 2014), irnn (le , 2015), or long short term memory (lstm) (hochreiter & schmidhuber, 1997) in this task, despite being a simpler and potentially far more computationally efficient architecture.
in what follows, we discuss related work, define our input switched affine network (isan) model, demonstrate its performance on the one-step-ahead prediction task, and then analyze the model in a multitude of ways, most of which would be currently difficult or impossible to accomplish with modern nonlinear recurrent architectures.work by the authors of (karpathy , 2015) attempted to use character-based language modeling to begin to understand how the lstm (hochreiter & schmidhuber, 1997) functions. in it, they employ n-gram word models to highlight what the lstm has – and has not – learned about the text corpus. they were able to break down lstm language model errors into classes, such as e.g., ""rare word"" errors. the authors of (greff , 2015) engaged in a large study to understand the relative importance of the various components of an lstm. the authors of (collins , 2016) performed an enormous hyperparameter study to disentangle the effects of capacity and trainability in a number of rnn architectures.
attempts to understand networks in more general contexts include the use of linearization and nonlinear dynamical systems theory to understand rnns in (sussillo & barak, 2013). in feedforward networks the use of linear probes has been suggested by (alain & bengio, 2016), and there exist a host of back-propagation techniques used to infer the most important input to drive various components of the feed-forward network, e.g. (le , 2012).
the isan uses an input-switched affine model. the highly related linear time-varying systems are standard material in undergraduate electrical engineering text books. probabilistic versions of switching linear models with discrete latent variables have a history in the context of probabilistic graphical models. a recent example is the switched linear dynamical system in (linderman , 2016). focusing on language modeling, (belanger & kakade, 2015) defined a probabilistic linear dynamical system as a generative language model for creating context-dependent token embeddings and then used steady-state kalman filtering for inference over token sequences. they used singular value decomposition and discovered that the right and left singular vectors were semantically and syntactically related. one difference between the isan and the lds is that the weight matrices of the isan are input token dependent (while the biases of both models are input dependent). finally, multiplicative neural networks (mrnns) were proposed precisely for character based language modeling in (sutskever , 2011; martens & sutskever, 2011). the mrnn architecture is similar to our own, in that the dynamics matrix switches as a function of the input character. however, the mrnn relied on a tanh nonlinearity, while our model is explicitly linear. it is this property of our model which makes it both amenable to analysis, and computationally efficient.
the observable operator model (oom) (jaeger, 2000) is similar to the isan in that the oom updates a latent state using a separate transition matrix for each input symbol and performs probabilistic sequence modeling. unlike the isan, the oom requires that a linear projection of the hidden state corresponds to a normalized sequence probability. this imposes strong constraints on both the model parameters and the model dynamics, and restricts the choice of training algorithms. in contrast, the isan applies an affine readout to the hidden state to obtain logits, which are then pushed through a softmax to obtain probabilities. therefore no constraints need to be imposed on the isan’s parameters and training is easy using backprop. lastly, the isan is formulated as an affine, rather than linear model. while this doesn’t change the class of processes that can be modeled, it enhances the stability of training and greatly enhances interpretability. we elaborate upon these ideas in section 6.1.in what follows wx and bx respectively denote a transition matrix and a bias vector for a specific input x, the symbol xt is the input at time t, and ht is the hidden state at time t. our isan model is defined as
ht = wxt ht−1 + bxt . (1)
the network also learns an initial hidden state h0. we emphasize the intentional absence of any nonlinear activation function.the rnns are trained on the text8 wikipedia dataset, for one-step-ahead character prediction. the text8 dataset consists only of the 27 characters ‘a’-‘z’ and ‘_’ (space). given a character sequence of x1, ...,xt, the rnns are trained to minimize the cross-entropy between the true next character, and the output prediction. we map from the hidden state, ht, into a logit space via an affine map. the probabilities are computed as
p (xt+1) = softmax (lt) (2) lt = wro ht + bro, (3)
where wro and bro are the readout weights and biases, and lt is the logit vector. in line with (collins , 2016) we split the training data into 80%, 10%, and 10% for train, test, and evaluation set respectively. the network was trained with the same hyperparameter tuning infrastructure as in (collins , 2016). analysis in this paper is carried out on the best-performing isan model, which has 1, 271, 619 parameters, corresponding to 216 hidden units, and 27 dynamics matrices wx and biases bx.the results on text8 are shown in figure 1a. for the largest parameter count, the isan matches almost exactly the performance of all other nonlinear models with the same number of maximum parameters: rnn, irnn, gru, lstm. however, we note that for small numbers of parameters the isan performs considerably worse than other architectures. all analyses use isan trained with 1.28e6 maximum parameters (1.58 bpc cross entropy). samples of generated text from this model are relatively coherent. we show two examples, after priming with ""annual reve"", at inverse temperature of 1.5, and 2.0, respectively:
• “annual revenue and producer of the telecommunications and former communist action and saving its new state house of replicas and many practical persons”
• “annual revenue seven five three million one nine nine eight the rest of the country in the united states and south africa new”.
as a preliminary, comparative analysis, we performed pca on the state sequence over a large set of sequences for the vanilla rnn, gru of varying sizes, and isan. this is shown in figure 1b. the eigenvalue spectra, in log of variance explained, was significantly flatter for the isan than the other architectures.
we also compare the isan performance to a fully linear rnn without input switched dynamics. this achieves a cross-entropy of 3.1 bits / char, independent of network size. this perplexity is only slightly better than that of a naive bayes model on the task, at 3.3 bits / char. the output probability of the fully linear network is a product of contributions from each previous character, as in naive bayes. those factorial contributions are learned however, giving isan a slight advantage. we also run a comparison to a fully linear network with a non-linear readout. this achieves 2.15 bits /
char, independent of network size. both of these comparisons illustrate the importance of the input switched dynamics for achieving good results in the absence of non-linear hidden state dynamics.
lastly we also test to what extent the isan can deal with large dictionaries by running it on a byte-pair encoding of the text8 task, where the input dictionary consists of the 272 different possible character combinations. we find that in this setup the lstm consistently outperforms the isan for the same number of parameters. at 1.3m parameters the lstm achieves a cross entropy of 3.4 bits / char-pair, while isan achieves 3.55. one explanation for this finding is that the matrices in isan are a factor of 27 smaller than the matrices of the lstms. for very large numbers of parameters the performance of any architecture saturates in the number of parameters, at which point the isan can ‘catch-up’ with more parameter efficient architectures like lstms.taking advantage of the linearity of the hidden state dynamics for any sequence of inputs, we can decompose the current latent state ht into contributions originating from different timepoints s in the history of the input:
ht = t∑ s=0
( t∏
s′=s+1
wxs′ ) bxs , (4)
where the empty product when s + 1 > t is 1 by convention, and bx0 = h0 is the learned initial hidden state. this is useful because we can analyze which factors were important in the past, for determining the current character prediction.
using this decomposition and the linearity of matrix multiplication we can also write the unnormalized logit-vector, lt, as a sum of terms linear in the biases,
lt = bro + t∑ s=0 κts (5)
κts = wro
( t∏
s′=s+1
wxs′ ) bxs , (6)
where κts is the contribution from timestep s to the logits at timestep t, and κ t t = bxt . for notational convenience we will sometimes replace the subscript s with the corresponding input character xs at step s when referring to κts – e.g. κ t ‘q’ to refer to the contribution from the character ‘q’ in a string.
similarly, when discussing the summed contributions from a word or substring we will sometimes write κtword to mean the summed contributions of all the κ t s from that source word, ∑ s∈word κ t s – e.g. κt‘the’ to refer to the total logit contribution from the word ‘the’.
while in standard rnns the nonlinearity causes interdependence of the bias terms across time steps, in the isan the bias terms can be interpreted as independent linear contributions to the state that are propagated and transformed through time. we emphasize that κts includes the multiplicative contributions from the wxs′ for s < s
′ ≤ t. it is however independent of prior inputs, xs′ for s′ < s. this is the main difference between the analysis we can carry out with the isan compared to a non-linear rnn. in general the contribution of a specific character sequence will depend on the hidden state at the start of the sequence. due to the linearity of the dynamics, this dependency does not exist in the isan.
in figure 2 we show an example of how this decomposition allows us to understand why a particular prediction is made at a given point in time, and how previous characters influence the decoding. for example, the sequence ‘_annual_revenue_’ is processed by the isan: starting with an all-zero hidden state, we use equation (6) to accumulate a sequence of κt‘_′ ,κ t ‘a′ ,κ t ‘n′ ,κ t ‘n′ , .... these values can then be used to understand the prediction of the network at some time t, by simple addition across the s index, which is shown in figure 2.
in figure 3 we provide a detailed view of how past characters contribute to the logits predicting the next character. there are two competing options for the next letter in the word stem ‘reve’: either ‘revenue’ or ‘reverse’. we show that without the contributions from ‘_annual’ the most likely decoding of the character after the second ‘e’ is ‘r’ (to form ‘reverse’), while the contributions from ‘_annual’ tip the balance in favor of ‘n’, decoding to ‘revenue’. in a standard rnn a similar analysis could be carried out by comparing the prediction given an artificially limited history.
using the decomposition of current step predictions in to κts, we can also investigate how quickly the contributions of κts decay as a function of t− s. in figure 4a we can see that this contribution decays on two different exponential timescales. we hypothesize that the first time scale corresponds to the decay within a word, while the next corresponds to the decay of information across words and sentences. this effect is also visible in figure 5. we note that it would be difficult to carry out this analysis in a non-linear rnn.
we can also show the relevance of the κts contributions to the decoding of characters at different positions in the word. for examples, we observe that κt‘_’ makes important contributions to the prediction of the next character at time t. we show that using only the κt‘_’, the model can achieve
a cross entropy of < 1 / char when the position of the character is more than 3 letters from the beginning of the word.
furthermore we can link back from the norm-decay to the importance of past characters for the decoding quality. by artificially limiting the number of past κ available for prediction, figure 4c, we show that the prediction quality improves rapidly when extending the history from 0 to 10 characters and then saturates. this rapid improvement aligns with the range of faster decay in figure 4a.the isan provides a natural means of moving from character level representation to word level. using the linearity of the hidden state dynamics we can aggregate all of the κts belonging to a given
word and visualize them as a single contribution to the prediction of the letters in the next word. this allows us to understand how each preceding word impacts the decoding for the letters of later words. in figure 5 we show that the words ‘higher’ and ‘than’ make large contributions to the prediction of the characters ‘h’ and ‘n’ in ‘tevenue’, as measured by the norm of the κt‘_the’ and κt‘_annual’.
in figure 6 we show that these κtword are more than a mathematical convenience and even capture word-level semantic information. shown is a t-sne embedding of the κtword for the most common 4000 words in the data-set, with examples of the kind of clusters that arise.we are free to perform a change of basis on the hidden state, and then to run the affine isan dynamics in that new basis. note that this change of basis is not possible for other rnn architectures, since the action of the nonlinearity depends on the choice of basis.
in particular we can construct a ‘readout basis’ that explicitly divides the latent space into a subspace pro‖ spanned by the rows of the readout matrix wro, and its orthogonal complement p ro ⊥ . this representation explicitly divides the hidden state dynamics into a 27-dimensional ‘readout’ subspace that is accessed by the readout matrix to make predictions, and a ‘computational’ subspace comprising the remaining 216− 27 dimensions that are orthogonal to the readout matrix. we apply this change of basis to analyze an intriguing observation about the hidden offsets bx: as shown in figure 7, the norm of the bx is strongly correlated to the log-probability of the unigram x in the training data. re-expressing network parameters using the ‘readout basis’ shows that this correlation is not related to reading out the next-step prediction. this is because the norm of the projection of bx into pro⊥ remains strongly correlated with character frequency, while the projections into pro‖ have norms that show little correlation. this indicates that the information content or surprise of a letter is encoded through the norm of the component of bx in the computational space, rather than in the readout space.
similarly, in figure 8 we illustrate that the structure in the correlations between the bx is due to their components in pro‖ , while the correlation in p ro ⊥ is relatively uniform. we can clearly see two blocks of high correlations between the vowels and consonants respectively, while b‘_’ is uncorrelated to either. .5 comparison with n-gram model with backoff
we compared the computation performed by n-gram language models and those performed by the isan. an n-gram model with back-off weights expresses the conditional probability p (xt|x1...xt−1) as a sum of smoothed count ratios of n-grams of different lengths, with the contribution of shorter n-grams down-weighted by backoff weights. on the other hand, the computations performed by the isan start with the contribution of bro to the logits, which as shown in figure 9a) corresponds to the unigram log-probabilities. the logits are then additively updated with contributions from longer n-grams, represented by κts. this additive contribution to the logits corresponds to a multiplicative modification of the emission probabilities from histories of different length. for long time lags, the additive correction to log-probabilities becomes small (figure 2), which corresponds to multiplication by a uniform distribution. despite these differences in how n-gram history is incorporated, we
nevertheless observe an agreement between empirical models estimated on the training set and model predictions for unigrams and bigrams. figure 9 shows that the bias term bro gives the unigram probabilities of letters, while the addition of the offset terms bx accurately predict the bigram distribution of p (xt+1|xt). shown are both an example, p (x|‘_′), and a summary plot for all 27 letters.
we further explore the n-gram comparison by artificially limiting the length of the character history that is available to the isan for making predictions, as shown in figure 4c).to show the interpretability of the isan we train a model on the parenthesis counting task. bringing together ideas from sections 4.4 and 6.1 we re-express the transition dynamics in a new basis that fully reveals computations performed by the isan.
we analyze the simple task of parentheses counting, which was defined in (collins , 2016). briefly, the rnn is required keep track of the nesting level of 3 different types of parentheses
independently. the inputs are the one-hot encoding of the different opening and closing parentheses (e.g. ‘(’, ‘)’, ‘{’, ‘}’) as well as a noise character (‘a’). the output is the one-hot encoding of the nesting level between (0-5), one set of counts for each parentheses task. one change from (collins , 2016) is that we slightly simplify the problem by exchanging the cross-entropy error with an l2 error and linear readout (this change leads to slightly cleaner figures, but does not qualitatively change the results).
we first re-express the transition dynamics in terms of linear, rather than affine operations. consider the matrix w′ ∈ r(n+1)×(n+1):
w′ = [ w b 0 1 ] , (7)
where 0 is a row vector of zeros. the matrix w′ emulates the affine transition for any hidden state h ∈ rn×1: w′ [ h 1 ] = [ wh+ b 1 ] . (8)
the matrices w and w′ are closely connected. each eigenvalue of w is also an eigenvalue of w′. moreover, eigenvectors of w become the eigenvectors of w′ when expanded with a zero dimension. in fact, w′ only has one extra eigenvalue of exactly 1 that is necessary to preserve the last dimension of the expanded hidden state.
to analyze the the parentheses task we analyze w′. the key to understanding how the network solves the parentheses task is to find a change of bases that clarifies the dynamics necessary to count 3 sets of independent parentheses nesting levels. in this case we use a matrix composed of the readout matrix, modified by adding a set of vectors that spans the null space of the readout (including the additional bias dimension).
w′ro =
[ wro bro
o
] (9)
where o is the orthogonal complement of the subspace spanned by the row vectors of [wro bro] in an n + 1-dimensional space. we perform the following change of basis of the dynamics matrices,
wx(ro) ′ = wro ′wx ′ (w′ro) −1 (10)
and visualize the results in fig. 10. figure 10 shows that this system created delay lines which count the nesting level, with fixed point dynamics at the 0 count (5 count), so that the system stays at both numbers when the input would otherwise increment (decrement) the count. the matrices also implement fixed point dynamics, as implemented via an identity submatrix to preserve the memory of the parenthesis nesting counts when an unrelated symbol enters the system (e.g. the ‘{}’ count is preserved by the ‘(’ matrix when a ‘(’ symbol enters the system).in this paper we motivated an input-switched affine recurrent network for the purpose of intelligibility. we showed that a switched affine architecture achieves the same performance, for the same number of maximum parameters, on a language modeling task as do more common rnn architectures, including grus and lstms. we performed a series of analyses, demonstrating that the simplicity of the latent dynamics makes the trained rnn far easier to understand and interpret.isan uses affine operators to model state transitions assigned to each input symbol. following eq. (1) each transition consists of matrix multiplication and bias vector addition. an important question is whether the biases are needed and how the isan would be impacted if linear transition operators were used instead of affine ones. the answer is two-fold. first, affine dynamics can be exactly implemented using linear operators in a hidden space expanded by one additional dimension. therefore, the expressivity of isan does not depend on choosing a linear or affine formulation. however, we found that the affine parametrization of transitions is much easier to train. we attempted to train models using only linear transitions, but achieved a loss of only 4.1 bits per character, which
corresponds to the performance of a unigram character model. second, affine operators are easier to interpret because they permit easy visualization of contributions of each input token on the final network’s prediction, as demonstrated in section 4.2.switched affine networks hold the potential to be massively more computationally and memory efficient for text processing than standard rnns, as explained in the next two subsections.as shown in figure 1a, the performance for fixed parameter count is nearly identical between the isan and other recurrent networks. however, at each time step, only the parameters associated with a single input are used. for k possible inputs and n parameters, the computational cost per update
step is o ( n k ) , a factor of k speedup over non-switched architectures. similarly, the number of
hidden units is o (√
n k
) , a factor of k 1 2 memory improvement for storage of the latent state.the memory and computational benefits in section 6.2.1 are shared by other switched networks. however, isan is unique in its ability to precompute affine transformations corresponding to input strings. this is possible because the composition of affine transformations is also an affine transformation. this property is used in section 4.3 to evaluate the linear contributions of words, rather than characters. this means that the hidden state update corresponding to an entire input sequence can be computed with identical cost to the update for a single character (plus the dictionary lookup cost for the composed transformation). isan can therefore achieve very large speedups on input processing, at the cost of increased memory use, by accumulating large lookup tables of the wx and bx corresponding to common input sequences. of course, practical implementations will have to incorporate complexities of memory management, batching, etc.there are some obvious future directions to this work. currently, we define switching behavior using an input set with finite and manageable cardinality. studying word-level language models with enormous vocabularies may require some additional logic to scale. adapting this model to continuous-valued inputs is another important direction. one approach is to use a tensor factorization similar to that employed by the mrnn (sutskever , 2014). another is to build a language model which switches on bigrams or trigrams, rather than characters or words, targeting an intermediate number of affine transformations.
training very large switched linear models has the potential to be extremely fruitful, due both to their improved computational efficiency, and our ability to better understand and manipulate their behavior.we would like to thank jasmine collins for her help and advice, and quoc le, david ha and mohammad norouzi for helpful discussions.",0
590.pdf.json,,"reading comprehension-based question answering (rcqa) is the task of answering a question with a chunk of text taken from related document(s). a variety of neural models have been proposed recently either for extracting a single entity or a single token as an answer from a given text (hermann , 2015; kadlec , 2016; trischler , 2016b; dhingra , 2016; chen , 2016; sordoni , 2016; cui , 2016a); or for selecting the correct answer by ranking a small set of human-provided candidates (yin , 2016; trischler , 2016a). in both cases, an answer boundary is either easy to determine or already given.
different from the above two assumptions for rcqa, in the real-world qa scenario, people may ask questions about both entities (factoid) and non-entities such as explanations and reasons (nonfactoid) (see table 1 for examples).
in this regard, rcqa has the potential to complement other qa approaches that leverage structured data (e.g., knowledge bases) for both the above question types. this is because rcqa can exploit the textual evidences to ensure increased answer coverage, which is particularly helpful for nonfactoid answers. however, it is also challenging for rcqa to identify answer in arbitrary position in the passage with arbitrary length, especially for non-factoid answers which might be clauses or sentences.
as a result, apart from a few exceptions (rajpurkar , 2016; wang & jiang, 2016), this research direction has not been fully explored yet.
compared to the relatively easier rc task of predicting single tokens/entities1, predicting answers of arbitrary lengths and positions significantly increase the search space complexity:
the number of possible candidates to consider is in the order of o(n2), where n is the number of passage words. in contrast, for previous works in which answers are single tokens/entities or from candidate lists, the complexity is in o(n) or the size of candidate lists l (usually l ≤5), respectively. to address the above complexity, rajpurkar  (rajpurkar , 2016) used a two-step chunkand-rank approach that employs a rule-based algorithm to extract answer candidates from a passage,
∗both authors contribute equally 1state-of-the-art rc models have a decent accuracy of ∼70% on the widely used cnn/dailymail dataset
(hermann , 2015).
followed by a ranking approach with hand-crafted features to select the best answer. the rule-based chunking approach suffered from low coverage (≈ 70% recall of answer chunks) that cannot be improved during training; and candidate ranking performance depends greatly on the quality of the hand-crafted features. more recently, wang and jiang (wang & jiang, 2016) proposed two end-toend neural network models, one of which chunks a candidate answer by predicting the answer’s two boundary indices and the other classifies each passage word into answer.ot-answer. both models improved significantly over the method proposed by rajpurkar  (rajpurkar , 2016).
our proposed model, called dynamic chunk reader (dcr), not only significantly differs from both the above systems in the way that answer candidates are generated and ranked, but also shares merits with both works. first, our model uses deep networks to learn better representations for candidate answer chunks, instead of using fixed feature representations as in (rajpurkar , 2016). second, it represents answer candidates as chunks, as in (rajpurkar , 2016), instead of wordlevel representations (wang & jiang, 2016), to make the model aware of the subtle differences among candidates (importantly, overlapping candidates).
the contributions of this paper are three-fold. (1) we propose a novel neural network model for joint candidate answer chunking and ranking, where the candidate answer chunks are dynamically constructed and ranked in an end-to-end manner. (2) we propose a new question-attention mechanism to enhance passage word representation, which is subsequently used to construct chunk representations. (3) we also propose several simple but effective features to strengthen the attention mechanism, which fundamentally improves candidate ranking, with the by-product of higher exact boundary match accuracy.
the experiments on the stanford question answering dataset (squad) (rajpurkar , 2016), which contains a variety of human-generated factoid and non-factoid questions, have shown the effectiveness of above three contributions.
our paper is organized as follows. we formally define the rcqa problem first. next, we describe our baseline with a neural network component. we present the end-to-end dynamic chunk reader model next. finally, we analyze our experimental results and discuss the related work. in appendix, we show formal equations and details of the model.table 1 shows an example of our rc setting where the goal is to answer a question qi, factoid (q1) or non-factoid (q2 and q3), based on a supporting passage pi, by selecting a continuous sequence of text ai ⊆ pi as answer. qi, pi, and ai are all word sequences, where each word is drawn from a vocabulary, v . the i-th instance in the training set is a triple in the form of (pi, qi, ai), where pi = (pi1, . . . , pi|pi|), qi = (qi1, . . . , qi|qi|), and ai = (ai1, . . . , ai|ai|) (pi·, qi·, ai· ∈ v ). owing to the disagreement among annotators, there could be more than one correct answer for the same question; and the k-th answer to qi is denoted by aki = {aki1, . . . , aki|aki |}. an answer candidate for the i-th training example is defined as cm,ni , a sub-sequence in pi, that spans from position m to n (1 ≤ m ≤ n ≤ |pi|). the ground truth answer ai could be included in the set of all candidates
ci = {cm,ni |∀m,n ∈ n+, subj(m,n, pi) and 1 ≤ m ≤ n ≤ |pi|}, where subj(m,n, pi) is the constraint put on the candidate chunk for pi, such as, “c m,n i can have at most 10 tokens”, or “cm,ni must have a pre-defined pos pattern”. to evaluate a system’s performance, its top answer to a question is matched against the corresponding gold standard answer(s).
remark: categories of rc tasks other simpler variants of the aforementioned rc task were explored in the past. for example, quiz-style datasets (e.g., mctest (richardson , 2013), movieqa (tapaswi , 2015)) have multiple-choice questions with answer options. cloze-style datesets(hermann , 2015; hill , 2015; onishi , 2016), usually automatically generated, have factoid “question”s created by replacing the answer in a sentence from the text with blank. for the answer selection task this paper focuses on, several datasets exist, e.g. trec-qa for factoid answer extraction from multiple given passages, babi (weston , 2014) designed for inference purpose, and the squad dataset (rajpurkar , 2016) used in this paper. to the best of our knowledge, the squad dataset is the only one for both factoid and non-factoid answer extraction with a question distribution more close to real-world applications.in this section we modified a state-of-the-art rc system for cloze-style tasks for our answer extraction purpose, to see how much gap we have for the two type of tasks, and to inspire our end-to-end system in the next section. in order to make the cloze-style rc system to make chunk-level decision, we use the rc model to generate features for chunks, which are further used in a feature-based ranker like in (rajpurkar , 2016). as a result, this baseline can be viewed as a deep learning based counterpart of the system in (rajpurkar , 2016). it has two main components: 1) a standalone answer chunker, which is trained to produce overlapping candidate chunks, and 2) a neural rc model, which is used to score each word in a given passage to be used thereafter for generating chunk scores.
answer chunking to reduce the errors generated by the rule-based chunker in (rajpurkar , 2016), first, we capture the part-of-speech (pos) pattern of all answer sub-sequences in the training dataset to form a pos pattern trie tree, and then apply the answer pos patterns to passage pi to acquire a collection of all subsequences (chunk candidates) ci whose pos patterns can be matched to the pos pattern trie. this is equivalent to putting an constraint subj(m,n, pi) to candidate answer chunk generation process that only choose the chunk with a pos pattern seen for answers in the training data. then the sub-sequences ci are used as answer candidates for pi. note that overlapping chunks could be generated for a passage, and we rely on the ranker to choose the best candidate based on features from the cloze-style rc system. experiments showed that for > 90% of the questions on the development set, the ground truth answer is included in the candidate set constructed in such manner.
feature extraction and ranking for chunk ranking, we (1) use neural rcqa model to annotate each pij in passage pi to get score sij , then (2) for every chunk c m,n i in passage i, collect scores (sim, . . . , sin) for all the (pim, ..., pin) contained within c m,n i , and (3) extract features on the sequence of scores (sim, . . . , sin) to characterize its scale and distribution information, which serves as the feature representation of cm,ni . in step (1) to acquire sij we train and apply a word-level single-layer gated attention reader 2 (dhingra , 2016), which has state-of-the-art performance on cnn/dailymail cloze-style rc task. in step (3) for chunk cm,ni , we designed 5 features, including 4 statistics on (sim, . . . , sin): maximum, minimum, average and sum; as well as the count of matched pos pattern within the chunk, which serves as an answer prior. we use these 5 features in a state-of-the-art ranker (ganjisaffar , 2011).the dynamic chunk reader (dcr) model is presented in figure 1. inspired by the baseline we built, dcr is deemed to be superior to the baseline for 3 reasons. first, each chunk has a representation constructed dynamically, instead of having a set of pre-defined feature values. second, each passage we tried using more than one layers in gated attention reader, but no improvement was observed.
word’s representation is enhanced by word-by-word attention that evaluates the relevance of the passage word to the question. third, these components are all within a single, end-to-end model that can be trained in a joint manner.
dcr works in four steps. first, the encoder layer encodes passage and question separately, by using bidirectional recurrent neural networks (rnn).
second, the attention layer calculates the relevance of each passage word to the question.
third, the convolution layer generates unigram, bigram and trigram representation for each word. bigram and trigram of a word ends with the same word, and proper padding is applied on the first word to make sure the output is the same length as input to cnn layer.
fourth, the chunk representation layer dynamically extracts the candidate chunks from the given passage, and create chunk representation that encodes the contextual information of each chunk.
fifth, the ranker layer scores the relevance between the representations of a chunk and the given question, and ranks all candidate chunks using a softmax layer.
we describe each step below.
encoder layer we use bi-directional rnn encoder to encode pi and qi of example i, and get hidden state for each word position pij and qik.3 as rnn input, a word is represented by a row vector x ∈ rn. x can be the concatenation of word embedding and word features (see fig. 1). the word vector for the t-th word is xt. a word sequence is processed using an rnn encoder with gated recurrent units (gru) (cho , 2014), which was proved to be effective in rc and neural machine translation tasks (bahdanau , 2015; kadlec , 2016; dhingra , 2016). for each position t, gru computes ht with input xt and previous state ht−1, as: we can have separated parameters for question and passage encoders but a single shared encoder for both works better in the experiments.
rt = σ(wrxt + urht−1) (1) ut = σ(wuxt + uuht−1) (2) h̄t = tanh(wxt + u(rt ht−1)) (3) ht = (1− ut) · ht−1 + ut · h̄t (4)
where ht, rt, and ut ∈ rd are d-dimensional hidden state, reset gate, and update gate, respectively; w{r,u}, w ∈ rn×d and u{r,u}, u ∈ rd×d are the parameters of the gru; σ is the sigmoid function, and denotes element-wise production. for a word at t, we use the hidden state −→h t from the forward rnn as a representation of the preceding context, and the←−h t from a backward rnn that encodes text reversely, to incorporate the context after t. next, ht = [ −→ ht ; ←− ht ], the bi-directional contextual encoding of xt, is formed. [·; ·] is the concatenation operator. to distinguish hidden states from different sources, we denote the hj of j-th word in p and the hk of k-th word in q as h p j and hqk respectively.
attention layer attention mechanism in previous rc tasks (kadlec , 2016; hermann , 2015; sordoni , 2016; dhingra , 2016; cui , 2016a;b) enables question-aware passage representations. we propose a novel attention mechanism inspired by word-by-word style attention methods (rocktäschel , 2015; wang & jiang, 2015; santos , 2016). for each pj , a questionattended representation vj is computed as follows (example index i is omitted for simplicity):
αjk = h p j · h q k, (5)
βj = |q|∑ k=1 αjkh q k (6) vj = [h p j ;βj ] (7)
where hpj and h q k are hidden states from the bi-directional rnn encoders (see figure 1). an inner product, αjk, is calculated between h p j and every question word h q k. it indicates how well the passage word pj matches with every question word qk. βj is a weighted pooling of |q| question hidden states, which serves as a pj-aware question representation. the concatenation of h p j and βj leads to a passage-question joint representation, vj ∈ r4d.4 next, we apply a second bi-gru layer taking the vjs as inputs, and obtain forward and backward representations −→γj and←−γj ∈ rd, and in turn their concatenation, γj = [−→γj ;←−γj ]. convolution layer every word is encoded with complete passage context through attention layer rnn. we would like to model more complex representation of the words, by introducing unigram, bigram and trigram representations. there are two benefits for this enhanced representation: 1) each word could be enhanced with local context information to help identify the boundary of the answer chunk. using previous words has been a common feature used in pos tagging and named entity recognition; and 2) the information brought in by the ngram into the word representation could enhance the semantic match between the answer chunk internal and the question. imagine scenario of a three word candidate, where the last word representation includes the two previous words through the convolution layer. matching to the last word could also lead to the match to the semantics of the internal of the chunk. specifically, we create for every word position j three representations, by using ngrams ending with the hidden state j:
γ̃j1 = γj ·wc1 (8) γ̃j2 = [γj−1; γj ] ·wc2 (9) γ̃j3 = [γj−2; γj−1; γj ] ·wc3 (10) we tried another word-by-word attention methods as in (santos , 2016), which has similar passage representation input to question side. however, this does not lead to improvement due to the confusion caused by long passages in rc. consequently, we used the proposed simplified version of word-by-word attention on passage side only.
the details shown in equations above. we used three different convolution kernels for different n-grams.
chunk representation layer a candidate answer chunk representation is dynamically created given convolution layer output. we first decide the text boundary for the candidate chunk, and then form a chunk representation using all or part of those γj outputs inside the chunk. to decide a candidate chunk (boundary): we tried two ways: (1) adopt the pos trie-based approach used in our baseline, and (2) enumerate all possible chunks up to a maximum number of tokens. for (2), we create up to n (max chunk length) chunks starting from any position j in pj . approach (1) can generate candidates with arbitrary lengths, but fails to recall candidates whose pos pattern is unseen in training set; whereas approach (2) considers all possible candidates within a window and is more flexible, but over-generates invalid candidates.
for a candidate answer chunk cm,n spanning from position m to n inclusively, we construct chunk representation γlm,n ∈ r2d using every γ̃jl within range [m,n], with a function g(·), and l ∈ {1, 2, 3}. formally,
γlm,n = g(γ̃ml, . . . , γ̃nl)
each γ̃jl is a convolution output over concatenated forward and backward rnn hidden states from attention layer. so the first half in γ̃jl encodes information in forward rnn hidden states and the second half encodes information in backward rnn hidden states. we experimented with several pooling functions (e.g., max, average) for g(·), and found out that, instead of pooling, the best g(·) function is to concatenate the first half of convolution output of the chunk’s first word and the second half of convolution output of the chunk’s last word. formally,
γlm,n = g(γ̃ml, . . . , γ̃nl) = [ −→ γ̃ml; ←− γ̃nl] (11)
where −→γ̃ml is half of the hidden state for l-gram word representation corresponding to forward attention rnn output. we hypothesize that the hidden states at that two ends can better represent the chunk’s contexts, which is critical for this task, than the states within the chunk. this observation also agrees with (kobayashi , 2016).
ranker layer a score slm,n for each l-gram chunk representation γlm,n denoting the probability of that chunk to be the true answer is calculated by dot product with question representation. the question representation is the concatenation of the last hidden state in forward rnn and the first hidden state in backward rnn. formally for the chunk cm,ni we have
sl(cm,ni |pi, qi) = γ l m,n · [ −−→ hqi|qi|; ←−− hqi1 ] (12)
where sl denotes the score generated from l-gram representation. −−→ hqik or ←−− hqik is the k-th hidden state output from question qi’s forward and backward rnn encoder, respectively.
after that, the final score for cm,ni is evaluated as the linear combination of three scores, followed by a softmax:
s(cm,ni |pi, qi) = softmax(w · [s 1; s2; s3]) (13)
where sl is the shorthand notation for sl(cm,ni |pi, qi); w ∈ r3. in runtime, the chunk with the highest probability is taken as the answer. in training, the following negative log likelihood is minimized:
l = − n∑ i=1 logp(ai|pi, qi) (14)
note that the i-th training instance is only used when ai is included in the corresponding candidate chunk set ci, i.e. ∃m,nai = cm,ni . the softmax in the final layer serves as the list-wise ranking module similar in spirit to (cao , 2007).dataset we used the stanford question answering dataset (squad) (rajpurkar , 2016) for the experiment. squad came into our sight because it is a mix of factoid and non-factoid
questions, a real-world data (crowd-sourced), and of large scale (over 100k question-answer pairs collected from 536 wikipedia articles). answers range from single words to long, variable-length phrase/clauses. it is a relaxation of assumptions by the cloze-style and quiz-style rc datasets in the problem definition section.
features the input vector representation of each word w to encoder rnns has six parts including a pre-trained 300-dimensional glove embedding (pennington , 2014) and five features (see figure 1): (1) a one-hot encoding (46 dimensions) for the part-of-speech (pos) tag of w; (2) a one-hot encoding (14 dimensions) for named entity (ne) tag of w; (3) a binary value indicating whether w’s surface form is the same to any word in the quesiton; (4) if the lemma form of w is the same to any word in the question; and (5) if w is caplitalized. feature (3) and (4) are designed to help the model align the passage text with question. note that some types of questions (e.g., “who”, “when” questions) have answers that have a specific pos/ne tag pattern. for instance, “who” questions mostly have proper nouns/persons as answers and “when” questions may frequently have numbers/dates (e.g., a year) as answers. thus, we believe that the model could exploit the co-relation between question types and answer pos/ne patterns easier with pos and ne tag features. implementation details we pre-processed the squad dataset using stanford corenlp tool5 (manning , 2014) with its default setting to tokenize the text and obtain the pos and ne annotations. to train our model, we used stochastic gradient descent with the adam optimizer (kingma & ba, 2014), with an initial learning rate of 0.001. all gru weights were initialized from a uniform distribution between (-0.01, 0.01). the hidden state size, d, was set to 300 for all grus. the question bi-gru shared parameters with the passage bi-gru, while the attention-based passage bi-gru had its own parameters. we shuffled all training examples at the beginning of each epoch and adopted a curriculum learning approach (bengio , 2009), by sorting training instances by length in every 10 batches, to enable the model start learning from relatively easier instances and to harder ones. we also applied dropout of rate 0.2 to the embedding layer of input bi-gru encoder, and gradient clipping when the norm of gradients exceeded 10. we trained in mini-batch style (mini-batch size is 180) and applied zero-padding to the passage and question inputs in each batch. we also set the maximum passage length to be 300 tokens, and pruned all the tokens after the 300-th token in the training set to save memory and speed up the training process. this step reduced the training set size by about 1.6%. during test, we test on the full length of passage, so that we don’t prune out the potential candidates. we trained the model for at most 30 epochs, and in case the accuracy did not improve for 10 epochs, we stopped training.
for the feature ranking-based system, we used jforest ranker (ganjisaffar , 2011) with lambdamart-regressiontree algorithm and the ranking metric was ndcg@10. for the gated attention reader in baseline system, we replicated the method and use the same configurations as in (dhingra , 2016).
results
table 2 shows our main results on the squad dataset. compared to the scores reported in (wang & jiang, 2016), our exact match (em) and f1 on the development set and em score on the test set are better, and f1 on the test set is comparable. we also studied how each component in our model contributes to the overall performance. table 3 shows the details as well as the results of the baseline ranker. as the first row of table 3 shows, our baseline system improves 10% (em) over rajpurkar  (rajpurkar , 2016) (table 2, row 1), the feature-based ranking system. however when compared to our dcr model (table 3, row 2), the baseline (row 1) is more than 12% (em) behind  stanfordnlp.github.io/corenlp/
we also did ablation tests on our dcr model. first, replacing the word-by-word attention with attentive reader style attention (hermann , 2015) decreases the em score by about 4.5%, showing the strength of our proposed attention mechanism.
second, we remove the features in input to see the contribution of each feature. the result shows that pos feature (1) and question-word feature (3) are the two most important features.
finally, combining the dcr model with the proposed pos-trie constraints yields a score similar to the one obtained using the dcr model with all possible n-gram chunks. the result shows that (1) our chunk representations are powerful enough to differentiate even a huge amount of chunks when no constraints are applied; and (2) the proposed pos-trie reduces the search space at the cost of a small drop in performance.
analysis to better understand our system, we calculated the accuracy of the attention mechanism of the gated attention reader used in our deep learning-based baseline. we found that it is 72% accurate i.e., 72% of the times a word with the highest attention score is inside the correct answer span. this means that, if we could accurately detect the boundary around the word with the highest attention score to form the answer span, we could achieve an accuracy close to 72%. in addition, we checked the answer recall of our candidate chunking approach. when we use a window size of 10, 92% of the time, the ground truth answer will be included in the extracted candidate chunk set. thus the upper bound of the exact match score of our baseline system is around 66% (92% (the answer recall) × 72%). from the results, we see our dcr system’s exact match score is at 62%. this shows that dcr is proficient at differentiating answer spans dynamically.
to further analyze the system’s performance while predicting answers of different lengths, we show the exact match (em) and f1 scores for answers with lengths up to 10 tokens in figure 2(a). from the graph, we can see that, with the increase of answer length, both em and f1 drops, but in different speed. the gap between f1 and exact match also widens as answer length increases. however, the model still yields a decent accuracy when the answer is longer than a single word. additionally, figure 2(b) shows that the system is better at “when” and “who” questions, but performs poorly
on “why” questions. the large gap between exact match and f1 on “why” questions means that perfectly identifying the span is harder than locating the core of the answer span.
since “what”, “which”, and “how” questions contain a broad range of question types, we split them further based on the bigram a question starts with, and figure 3 shows the breakdown for “what” questions. we can see that “what” questions asking for explanations such as “what happens” and “what happened” have lower em and f1 scores. in contrast, “what” questions asking for year and numbers have much higher scores and, for these questions, exact match scores are close to f1 scores, which means chunking for these questions are easier for dcr.attentive reader was the first neural model for factoid rcqa (hermann , 2015). it uses bidirectional rnn (cho , 2014; chung ,2014) to encode document and query respectively, and use query representation to match with every token from the document. attention sum reader (kadlec , 2016) simplifies the model to just predicting positions of correct answer in the document and the training speed and test accuracy are both greatly improved on the cnn/daily mail dataset. (chen , 2016) also simplified attentive reader and reported higher accuracy. windowbased memory networks (memn2n) is introduced along with the cbt dataset (hill , 2015), which does not use rnn encoders, but embeds contexts as memory and matches questions with embedded contexts. those models’ mechanism is to learn the match between answer context with question/query representation. in contrast, memory enhanced neural networks like neural turing machines (graves , 2014) and its variants (zhang , 2015; gulcehre , 2016; zaremba & sutskever, 2015; chandar , 2016; grefenstette , 2015) were also potential candidates for the task, and gulcehre  (gulcehre , 2016) reported results on the babi task, which is worse than memory networks. similarly, sequence-to-sequence models were also used (yu , 2015; hermann , 2015), but they did not yield better results either.
recently, several models have been proposed to enable more complex inference for rc task. for instance, gated attention model (dhingra , 2016) employs a multi-layer architecture, where each layer encodes the same document, but the attention is updated from layer to layer. epireader (trischler , 2016b) adopted a joint training model for answer extractor and reasoner, where the extractor proposes top candidates, and the reasoner weighs each candidate by examining entailment relationship between question-answer representation and the document. an iterative alternating attention mechanism and gating strategies were proposed in (sordoni , 2016) to optimize the attention through several hops. in contrast, cui  (cui , 2016a;b) introduced fine-grained document attention from each question word and then aggregated those attentions from each question token by summation with or without weights. this system achieved the state-of-the-art score on the cnn dataset. those different variations all result in roughly 3-5% improvement over attention sum reader, but none of those could achieve higher than that. other methods include using dynamic entity representation with max-pooling (kobayashi , 2016) that aims to change entity representation with context, and weissenborn’s (weissenborn, 2016) system, which tries to separate entity from the context and then matches the question to context, scoring an accuracy around 70% on the cnn dataset.
however, all of those models assume that the answers are single tokens. this limits the type of questions the models can answer. wang and jiang (wang & jiang, 2016) proposed a match-lstm and achieved good results on squad. however, this approach predicts a chunk boundary or whether a word is part of a chunk or not. in contrast, our approach explicitly constructs the chunk representations and similar chunks are compared directly to determine correct answer boundaries.in this paper we proposed a novel neural reading comprehension model for question answering. different from the previously proposed models for factoid rcqa, the proposed model, dynamic chunk reader, is not restricted to predicting a single named entity as an answer or selecting an answer from a small, pre-defined candidate list. instead, it is capable of answering both factoid and nonfactoid questions as it learns to select answer chunks that are suitable for an input question. dcr achieves this goal with a joint deep learning model enhanced with a novel attention mechanism and five simple yet effective features. error analysis shows that the dcr model achieves good performance, but still needs to improve on predicting longer answers, which are usually non-factoid in nature.",0
598.pdf.json,SPEECH RECOGNITION SYSTEM,"we present an end-to-end system to speech recognition, going from the speech signal (e.g. melfrequency cepstral coefficients (mfcc), power spectrum, or raw waveform) to the transcription. the acoustic model is trained using letters (graphemes) directly, which take out the need for an intermediate (human or automatic) phonetic transcription. indeed, the classical pipeline to build state of the art systems for speech recognition consists in first training an hmm/gmm model to force align the units on which the final acoustic model operates (most often context-dependent phone states). this approach takes its roots in hmm/gmm training (woodland & young, 1993). the improvements brought by deep neural networks (dnns) (mohamed , 2012; hinton , 2012) and convolutional neural networks (cnns) (sercu , 2015; soltau , 2014) for acoustic modeling only extend this training pipeline.
the current state of the art on librispeech (the dataset that we used for our evaluations) uses this approach too (panayotov , 2015; peddinti , 2015b), with an additional step of speaker adaptation (saon , 2013; peddinti , 2015a). recently, senior  (2014) proposed gmmfree training, but the approach still requires to generate a force alignment. an approach that cut ties with the hmm/gmm pipeline (and with force alignment) was to train with a recurrent neural network (rnn) (graves , 2013) for phoneme transcription. there are now competitive end-to-end approaches of acoustic models toppled with rnns layers as in (hannun , 2014; miao , 2015; saon , 2015; amodei , 2015), trained with a sequence criterion (graves , 2006). however these models are computationally expensive, and thus take a long time to train.
compared to classical approaches that need phonetic annotation (often derived from a phonetic dictionary, rules, and generative training), we propose to train the model end-to-end, using graphemes directly. compared to sequence criterion based approaches that train directly from speech signal to graphemes (miao , 2015), we propose a simple(r) architecture (23 millions of parameters for our best model, vs. 100 millions of parameters in (amodei , 2015)) based on convolutional networks
for the acoustic model, toppled with a graph transformer network (bottou , 1997), trained with a simpler sequence criterion. our word-error-rate on clean speech is slightly better than (hannun , 2014), and slightly worse than (amodei , 2015), in particular factoring that they train on 12,000 hours while we only train on the 960h available in librispeech’s train set. finally, some of our models are also trained on the raw waveform, as in (palaz , 2013; 2015; sainath , 2015). the rest of the paper is structured as follows: the next section presents the convolutional networks used for acoustic modeling, along with the automatic segmentation criterion. the following section shows experimental results comparing different features, the criterion, and our current best word error rates on librispeech.our speech recognition system is a standard convolutional neural network (lecun & bengio, 1995) fed with various different features, trained through an alternative to the connectionist temporal classification (ctc) (graves , 2006), and coupled with a simple beam search decoder. in the following sub-sections, we detail each of these components. .1 features
we consider three types of input features for our model: mfccs, power-spectrum, and raw wave. mfccs are carefully designed speech-specific features, often found in classical hmm/gmm speech systems (woodland & young, 1993) because of their dimensionality compression (13 coefficients are often enough to span speech frequencies). power-spectrum features are found in most recent deep learning acoustic modeling features (amodei , 2015). raw wave has been somewhat explored in few recent work (palaz , 2013; 2015). convnets have the advantage to be flexible enough to be used with either of these input feature types. our acoustic models output letter scores (one score per letter, given a dictionary l).the acoustic models we considered in this paper are all based on standard 1d convolutional neural networks (convnets). convnets interleave convolution operations with pointwise non-linearity operations. often convnets also embark pooling layers: these type of layers allow the network to “see” a larger context, without increasing the number of parameters, by locally aggregating the previous convolution operation output. instead, our networks leverage striding convolutions. given (xt)t=1...tx an input sequence with tx frames of dx dimensional vectors, a convolution with kernel width kw, stride dw and dy frame size output computes the following:
yit = bi + dx∑ j=1 kw∑ k=1 wi,j,k x j dw×(t−1)+k ∀1 ≤ i ≤ dy, (1)
where b ∈ rdy and w ∈ rdy×dx×kw are the parameters of the convolution (to be learned).
pointwise non-linear layers are added after convolutional layers. in our experience, we surprisingly found that using hyperbolic tangents, their piecewise linear counterpart hardtanh (as in (palaz , 2015)) or relu units lead to similar results.
there are some slight variations between the architectures, depending on the input features. mfcc-based networks need less striding, as standard mfcc filters are applied with large strides on the input
raw sequence. with power spectrum-based and raw wave-based networks, we observed that the overall stride of the network was more important than where the convolution with strides were placed. we found thus preferrable to set the strided convolutions near the first input layers of the network, as it leads to the fastest architectures: with power spectrum features or raw wave, the input sequences are very long and the first convolutions are thus the most expensive ones.
the last layer of our convolutional network outputs one score per letter in the letter dictionary (dy = |l|). our architecture for raw wave is shown in figure 1 and is inspired by (palaz , 2015). the architectures for both power spectrum and mfcc features do not include the first layer. the full network can be seen as a non-linear convolution, with a kernel width of size 31280 and stride equal to 320; given the sample rate of our data is 16khz, label scores are produced using a window of 1955 ms, with steps of 20ms.most large labeled speech databases provide only a text transcription for each audio file. in a classification framework (and given our acoustic model produces letter predictions), one would need the segmentation of each letter in the transcription to train properly the model. unfortunately, manually labeling the segmentation of each letter would be tedious. several solutions have been explored in the speech community to alleviate this issue: hmm/gmm models use an iterative em procedure: (i) during the estimation step, the best segmentation is inferred, according to the current model, by maximizing the joint probability of the letter (or any sub-word unit) transcription and input sequence. (ii) during the maximization step the model is optimized by minimizing a frame-level criterion, based on the (now fixed) inferred segmentation. this approach is also often used to boostrap the training of neural network-based acoustic models.
other alternatives have been explored in the context of hybrid hmm/nn systems, such as the mmi criterion (bahl , 1986) which maximizes the mutual information between the acoustic sequence and word sequences or the minimum bayse risk (mbr) criterion (gibson & hain, 2006).
more recently, standalone neural network architectures have been trained using criterions which jointly infer the segmentation of the transcription while increase the overall score of the right transcription (graves , 2006; palaz , 2014). the most popular one is certainly the connectionist temporal classification (ctc) criterion, which is at the core of baidu’s deep speech architecture (amodei , 2015). ctc assumes that the network output probability scores, normalized at the frame level. it considers all possible sequence of letters (or any sub-word units), which can lead to a to a given transcription. ctc also allow a special “blank” state to be optionally inserted between each letters. the rational behind the blank state is two-folds: (i) modeling “garbage” frames which might occur between each letter and (ii) identifying the separation between two identical consecutive letters in a transcription. figure 2a shows an example of the sequences accepted by ctc for a given transcription. in practice, this graph is unfolded as shown in figure 2b, over the available frames output by the acoustic model. we denote gctc(θ, t ) an unfolded graph over t frames for a given transcription θ, and π = π1, . . . , πt ∈ gctc(θ, t ) a path in this graph representing a (valid) sequence of letters for this transcription. at each time step t, each node of the graph is assigned with the corresponding log-probability letter (that we denote ft(·)) output by the acoustic model. ctc aims at maximizing the “overall” score of paths in gctc(θ, t ); for that purpose, it minimizes the forward score:
ctc(θ, t ) = − logadd π∈gctc(θ,t ) t∑ t=1 fπt(x) , (2)
where the “logadd” operation, also often called “log-sum-exp” is defined as logadd(a, b) = exp(log(a) + log(b)). this overall score can be efficiently computed with the forward algorithm. to put things in perspective, if one would replace the logadd(·) by a max(·) in (2) (which can be then efficiently computed by the viterbi algorithm, the counterpart of the forward algorithm), one would then maximize the score of the best path, according to the model belief. the logadd(·) can be seen as a smooth version of the max(·): paths with similar scores will be attributed the same weight in the overall score (and hence receive the same gradient), and paths with much larger score will have much more overall weight than paths with low scores. in practice, using the logadd(·) works much better than the max(·). it is also worth noting that maximizing (2) does not diverge, as the acoustic model is assumed to output normalized scores (log-probabilities) fi(·).
in this paper, we explore an alternative to ctc, with three differences: (i) there are no blank labels, (ii) un-normalized scores on the nodes (and possibly un-normalized transition scores on the edges) (iii) global normalization instead of per-frame normalization:
• the advantage of (i) is that it produces a much simpler graph (see figure 3a and figure 3b). we found that in practice there was no advantage of having a blank class to model the possible “garbage” frames between letters. modeling letter repetitions (which is also an important quality of the blank label in ctc) can be easily replaced by repetition character labels (we used two extra labels for two and three repetitions). for example “caterpillar” could be written as “caterpil2ar”, where “2” is a label to represent the repetition of the previous letter. not having blank labels also simplifies the decoder.
• with (ii) one can easily plug an external language model, which would insert transition scores on the edges of the graph. this could be particularly useful in future work, if one wanted to model representations more high-level than letters. in that respect, avoiding normalized transitions is important to alleviate the problem of “label bias” bottou (1991); lafferty  (2001). in this work, we limited ourselves to transition scalars, which are learned together with the acoustic model.
• the normalization evoked in (iii) is necessary when using un-normalized scores on nodes or edges; it insures incorrect transcriptions will have a low confidence.
in the following, we name our criterion “auto segmentation criterion” (asg). considering the same notations than for ctc in (2), and an unfolded graph gasg(θ, t ) over t frames for a given transcription θ (as in figure 3b), as well as a fully connected graph gfull(θ, t ) over t frames (representing all possible sequence of letters, as in figure 3c), asg aims at minimizing:
asg(θ, t ) = − logadd π∈gasg(θ,t ) t∑ t=1 (fπt(x) + gπt−1,πt(x)) + logadd π∈gfull(θ,t ) t∑ t=1 (fπt(x) + gπt−1,πt(x)) , (3) where gi,j(·) is a transition score model to jump from label i to label j. the left-hand part of 3 promotes sequences of letters leading to the right transcription, and the right-hand part demotes all sequences of letters. as for ctc, these two parts can be efficiently computed with the forward algorithm. derivatives with respect to fi(·) and gi,j(·) can be obtained (maths are a bit tedious) by applying the chain rule through the forward recursion.we wrote our own one-pass decoder, which performs a simple beam-search with beam threholding, histogram pruning and language model smearing steinbiss  (1994). we kept the decoder as
simple as possible (under 1000 lines of c code). we did not implement any sort of model adaptation before decoding, nor any word graph rescoring. our decoder relies on kenlm heafield  (2013) for the language modeling part. it also accepts un-normalized acoustic scores (transitions and emissions from the acoustic model) as input. the decoder attempts to maximize the following:
l(θ) = logadd π∈gasg(θ,t ) t∑ t=1 (fπt(x) + gπt−1,πt(x)) + α logplm(θ) + β|θ| , (4)
where plm(θ) is the probability of the language model given a transcription θ, α and β are two hyper-parameters which control the weight of the language model and the word insertion penalty respectively.we implemented everything using torch71. the asg criterion as well as the decoder were implemented in c (and then interfaced into torch).
we consider as benchmark librispeech, a large speech database freely available for download (panayotov , 2015). librispeech comes with its own train, validation and test sets. except when specified, we used all the available data (about 1000h of audio files) for training and validating our models. we use the original 16 khz sampling rate. the vocabulary l contains 30 graphemes: the standard english alphabet plus the apostrophe, silence, and two special “repetition” graphemes which encode the duplication (once or twice) of the previous letter (see section 2.3).
the architecture hyper-parameters, as well the decoder ones were tuned using the validation set. in the following, we either report letter-error-rates (lers) or word-error-rates (wers). wers have been obtained by using our own decoder (see section 2.4), with the standard 4-gram language model provided with librispeech2. http://www.torch.ch. 2http://www.openslr.org/11.
mfcc features are computed with 13 coefficients, a 25 ms sliding window and 10 ms stride. we included first and second order derivatives. power spectrum features are computed with a 25 ms window, 10 ms stride, and have 257 components. all features are normalized (mean 0, std 1) per input sequence.table 1 reports a comparison between ctc and asg, in terms of ler and speed. our asg criterion is implemented in c (cpu only), leveraging sse instructions when possible. our batching is done with an openmp parallel for. we picked the ctc criterion implementation provided by baidu3. both criteria lead to the same ler. for comparing the speed, we report performance for sequence sizes as reported initially by baidu, but also for longer sequence sizes, which corresponds to our average use case. asg appears faster on long sequences, even though it is running on cpu only. baidu’s gpu ctc implementation seems more aimed at larger vocabularies (e.g. 5000 chinese characters).
we also investigated the impact of the training size on the dataset, as well as the effect of a simple data augmentation procedure, where shifts were introduced in the input frames, as well as stretching. for that purpose, we tuned the size of our architectures (given a particular size of the dataset), to avoid over-fitting. figure 4a shows the augmentation helps for small training set size. however, with enough training data, the effect of data augmentation vanishes, and both type of features appear to perform similarly. figure 4b reports the wer with respect to the available training data size. we observe that we compare very well against deep speech 1 & 2 which were trained with much more data hannun  (2014); amodei  (2015).
finally, we report in table 2 the best results of our system so far, trained on 1000h of speech, for each type of features. the overall stride of architectures is 320 (see figure 1), which produces a label every 20 ms. we found that one could squeeze out about 1% in performance by refining the precision of the output. this is efficiently achieved by shifting the input sequence, and feeding it to the network several times. results in table 2 were obtained by a single extra shift of 10 ms. both power spectrum and raw features are performing slightly worse than mfccs. one could expect, however, that with enough data (see figure 4) the gap would vanish. https://github.com/baidu-research/warp-ctc.we have introduced a simple end-to-end automatic speech recognition system, which combines a standard 1d convolutional neural network, a sequence criterion which can infer the segmentation, and a simple beam-search decoder. the decoding results are competitive on the librispeech corpus with mfcc features (7.2% wer), and promising with power spectrum and raw speech (9.4% wer and 10.1% wer respectively). we showed that our autosegcriterion can be faster than ctc (graves , 2006), and as accurate (table 1). our approach breaks free from hmm/gmm pre-training and force-alignment, as well as not being as computationally intensive as rnn-based approaches (amodei , 2015) (on average, one librispeech sentence is processed in less than 60ms by our convnet, and the decoder runs at 8.6x on a single thread).",0
614.pdf.json,RECURRENT COEVOLUTIONARY FEATURE EMBEDDING PROCESSES FOR RECOMMENDATION,"e-commerce platforms and social service websites, such as reddit, amazon, and netflix, attracts thousands of users every second. effectively recommending the appropriate service items to users is a fundamentally important task for these online services. it can significantly boost the user activities on these sites and leads to increased product purchases and advertisement clicks.
the interactions between users and items play a critical role in driving the evolution of user interests and item features. for example, for music streaming services, a long-time fan of rock music listens to an interesting blues one day, and starts to listen to more blues instead of rock music. similarly, a single music may also serve different audiences at different times,e.g., a music initially targeted for an older generation may become popular among the young, and the features of this music need to be updated. furthermore, as users interact with different items, users’ interests and items’ features can also co-evolve over time, i.e., their features are intertwined and can influence each other:
• user → item. in online discussion forums such as reddit, although a group (item) is initially created for statistics topics, users with very different interest profiles can join this group. hence, the participants can shape the features of the group through their postings. it is likely that this group can finally become one about deep learning because most users concern about deep learning. • item→ user. as the group is evolving towards topics on deep learning, some users may become more interested in deep learning topics, and they may participate in other specialized groups on deep learning. on the opposite side, some users may gradually gain interests in pure math groups, lose interests in statistics and become inactive in this group.
such co-evolutionary nature of user-item interactions raises very important questions on how to learn them from the increasingly available data. however, existing methods either treat the temporal user-item interactions data as a static graph or use epoch based methods such as tensor factorization to learn the latent features (chi & kolda, 2012; koren, 2009; yang , 2011). these methods are not able to capture the fine grained temporal dynamics of user-item interactions. recent point process based models treat time as a random variable and improves over the traditional methods significantly (du , 2015; wang , 2016b). however, these works make strong assumptions
∗authors have equal contributions.
about the function form of the generative processes, which may not reflect the reality or accurate enough to capture the complex and nonlinear user-item influence in real world.
in this paper, we propose a recurrent coevolutionary feature embedding process framework. it combines recurrent neural network (rnn) with point process models, and efficiently captures the co-evolution of user-item features. our model can automatically find an efficient representation of the underlying user and item latent feature without assuming a fixed parametric forms in advance. figure 1 summarizes our framework. in particular, our work makes the following contributions:
• novel model. we propose a novel model that captures the nonlinear co-evolution nature of users’ and items’ embeddings. it assigns an evolving feature embedding process for each user and item, and the co-evolution of these latent feature processes is modeled with two parallel components: (i) item→ user component, a user’s latent feature is determined by the nonlinear embedding of latent features of the items he interacted with; and (ii) user→ item component, an item’s latent features are also determined by the latent features of the users who interact with the item. • technical challenges. we use rnn to parametrize the interdependent and intertwined user and item embeddings. the increased flexibility and generality further introduces technical challenges on how to train rnn on the co-evolving graphs. the co-evolution nature of the model makes the samples inter-dependent and not identically distributed, which is contrary to the assumptions in the traditional setting and significantly more challenging. we are the first to propose an efficient stochastic training algorithm that makes the btpp tractable in the co-evolving graph. • strong performance. we evaluate our method over multiple datasets, verifying that our method can lead to significant improvements in user behavior prediction compared to previous state-of-thearts. precise time prediction is especially novel and not possible by most prior work.recent work predominantly fix the latent features assigned to each user and item (salakhutdinov & mnih, 2008; chen , 2009; agarwal & chen, 2009; ekstrand , 2011; koren & sill, 2011; yang , 2011; yi , 2014; wang & pal, 2015). in more sophisticated methods, the time is divided into epochs, and static latent feature models are applied to each epoch to capture some temporal aspects of the data (koren, 2009; karatzoglou , 2010; xiong , 2010; karatzoglou , 2010; xiong , 2010; chi & kolda, 2012; gultekin & paisley, 2014; charlin , 2015; preeti bhargava, 2015; gopalan , 2015; hidasi & tikk, 2015; wang , 2016a). for such methods, it is not clear how to choose the epoch length parameter. first, different users may have very different timescale when they interact with those service items, making it difficult to choose a unified epoch length. second, it is not easy for these methods to answer time-sensitive queries such as when a user will return to the service item. the predictions are only in the resolution of the chosen epoch length. recently, (du , 2015) proposed a low-rank point process based model for time-sensitive recommendations from recurrent user activities. however, it fails to capture the heterogeneous coevolutionary properties of user-item interactions. wang  (2016b) models the co-evolutionary property, but uses a simple linear representation of the users’ and items’ latent features, which might not be expressive enough to capture the real world patterns. as demonstrated in du  (2016),
the nonlinear rnn is quite flexible to approximate many point process models. also we will show that, our model only has o(#user + #item) regardless of rnn related parameters, and can also be potentially applied to online setting.
in the deep learning community, (wang , 2015a) proposed a hierarchical bayesian model that jointly performs learning for the content features and collaborative filtering for the ratings matrix. (hidasi , 2016) applied rnn and adopt item-to-item recommendation approach with session based data. (tan , 2016) improved this model with techniques like data augmentation, temporal change adaptation. (ko , 2016) proposed collaborative rnn that extends collaborative filtering method to capture history of user behavior. specifically, they used static global latent factors for items and assign separate latent factors for users that are dependent on their past history. (song , 2016) extended the deep semantic structured model to capture multi-granularity temporal preference of users. they use separate rnn for each temporal granularity and combine them with feed forward network which models users’ and items’ long term static features. however, none of these works model the coevolution of users’ and items’ latent features and are still extensions of epoch based methods. our work is unique since we explicitly treat time as a random variable and captures the coevolution of users’ and items’ latent features using temporal point processes. finally, our work is inspired from the recurrent marked temporal point process model (du , 2016). however, this work only focuses on learning a one-dimension point process. our work is significantly different since we focus on the recommendation system setting with the novel idea of feature coevolution and we use multi-dimensional point processes to capture user-item interactions.a temporal point process (cox & isham, 1980; cox & lewis, 2006; aalen , 2008) is a random process whose realization consists of a list of discrete events localized in time, {ti} with ti ∈ r+. equivalently, a given temporal point process can be represented as a counting process, n(t), which records the number of events before time t. an important way to characterize temporal point processes is via the conditional intensity function λ(t), a stochastic model for the time of the next event given all the previous events. formally, λ(t)dt is the conditional probability of observing an event in a small window [t, t+dt) given the historyh(t) up to t and that the event has not happen before t, i.e.,
λ(t)dt := p {event in [t, t+ dt)|h(t)} = e[dn(t)|h(t)], where one typically assumes that only one event can happen in a small window of size dt, i.e., dn(t) ∈ {0, 1}. then, given a time t > 0, we can also characterize the conditional probability that no event happens during [0, t) as: s(t) = exp ( − ∫ t 0 λ(τ) dτ ) and the conditional density that an event occurs at time t is defined as f(t) = λ(t)s(t) (1)
the function form of the intensity λ(t) is often designed to capture the phenomena of interests. some commonly used form includes:
• hawkes processes (hawkes, 1971; wang , 2016c), whose intensity models the mutual excitation between events, i.e., λ(t) = µ + α ∑ ti∈h(t) κω(t − ti), where κω(t) := exp(−ωt)
is an exponential triggering kernel, µ > 0 is a baseline intensity. here, the occurrence of each historical event increases the intensity by a certain amount determined by the kernel κω and the weight α > 0, making the intensity history dependent and a stochastic process by itself. • rayleigh process, whose intensity function is λ(t) = αt, where α > 0 is the weight parameter.in this section, we present the generative framework for modeling the temporal dynamics of user-item interactions. we first use rnn to explicitly capture the co-evolving nature of users’ and items’ latent feature. then, based on the compatibility between the users’ and items’ latent feature, we model the user-item interactions by a multi-dimensional temporal point process. we further parametrize the intensity function by the compatibility between users’ and items’ latent features.given m users and n items, we denote the ordered list of n observed events as o = {ej = (uj , ij , tj , qj)}nj=1 on time window [0, t ], where uj ∈ {1, . . . ,m}, ij ∈ {1, . . . , n}, tj ∈ r+, 0 6 t1 6 t2 . . . 6 t . this represents the interaction between user uj , item ij at time tj , with the interaction context qj ∈ rd. here qj can be a high dimension vector such as the text review, or
simply the embedding of static user/item features such as user’s profile and item’s categorical features. for notation simplicity, we defineou = {euj = (iuj , tuj , quj )} as the ordered listed of all events related to user u, and oi = {eij = (uij , tij , qij)} as the ordered list of all events related to item i. we also set ti0 = t u 0 = 0 for all the users and items. tk− denotes the time point just before time tk.we associate feature embeddings uu(t) ∈ rk with each user u and ii(t) ∈ rk with each item i. these features represent the subtle properties which cannot be directly observed, such as the interests of a user and the semantic topics of an item. specifically, we model the drift, evolution, and co-evolution of uu(t) and ii(t) as a piecewise constant function of time that has jumps only at event times. specifically, we define:
user latent feature embedding process. for each user u, the corresponding embedding after user u’s k-th event euk = (i u k , t u k , q u k ) can be formulated as:
uu(t u k) = σ ( w1(t
u k − tuk−1)︸ ︷︷ ︸
temporal drift
+w2uu(t u k−1)︸ ︷︷ ︸
self evolution
+ w3iik(t u k−)︸ ︷︷ ︸
co-evolution: item feature
+ w4q u,ik k︸ ︷︷ ︸
interaction feature
) (2)
item latent feature embedding process. for each item i, we specify ii(t) at time tik as:
ii(t i k) = σ ( v1(t
i k − tik−1)︸ ︷︷ ︸
temporal drift
+v2ii(t i k−1)︸ ︷︷ ︸
self evolution
+ v3uuk(t i k−)︸ ︷︷ ︸
co-evolution: item feature
+ v4q i,uk k︸ ︷︷ ︸
interaction feature
) (3)
where t− means the time point just before time t, w4,v4 ∈ rk×d are the embedding matrices mapping from the explicit high-dimensional feature space into the low-rank latent feature space and w1,v1 ∈ rk, w2,v2,w3,v3 ∈ rk×k are weights parameters. σ(·) is the nonlinear activation function, such as commonly used tanh or sigmoid for rnn. for simplicity, we use basic recurrent neural network to formulate the recurrence, but it is also straightforward to extend it using gru or lstm to gain more expressive power. figure 1 summarizes the basic setting of our model.
here both the user and item’s feature embedding processes are piecewise constant functions of time and only updated if an interaction event happens. a user’s attribute changes only when he has a new interaction with some item. for example, a user’s taste for music changes only when he listens to some new or old musics. also, an item’s attribute changes only when some user interacts with it. different from chen  (2013) who also models the time change with piecewise constant function, but their work has no coevolve modeling, and is not capable of predicting the future time point.
next we discuss the rationale of each term in detail:
• temporal drift. the first term is defined based on the time difference between consecutive events of specific user or item. it allows the basic features of users (e.g., a user’s self-crafted interests) and items (e.g., textual categories and descriptions) to smoothly drift through time. such changes of basic features normally are caused by external influences. • self evolution. the current user feature should also be influenced by its feature at the earlier time. this captures the intrinsic evolution of user/item features. for example, a user’s current taste should be more or less similar to his/her tastes two days ago. • user-item coevolution. users’ and items’ latent features can mutually influence each other. this term captures the two parallel processes. first, a user’s embedding is determined by the latent features of the items he interacted with. at each time tk, the latent item feature is iik(t u k−).
we capture both the temporal influence and feature of each history item as a latent embedding. conversely, an item’s embedding is determined by the feature embedding of the user who just interacts with the item. • evolution with interaction features. users’ and items’ features can evolve and be influenced by the characteristics of their interactions. for instance, the genre changes of movies indicate the changing tastes of users. the theme of a chatting-group can be easily shifted to certain topics of the involved discussions. in consequence, this term captures the influence of the current interaction features to the changes of the latent user (item) features. • interaction feature. this is the additional information happened in the user-item interactions. for example, in online discussion forums such as reddit, the interaction features are the posts and comments. in online review sites such as yelp, it is the reviews of the businesses.
to summarize, each feature embedding process evolves according to the respective base temporal user (item) features and also are mutually dependent on each other due to the endogenous influences from the interaction features and the entangled latent features.for each user, we model the recurrent occurrences of all users interaction with all items as a multidimensional temporal point process, with each user-item pair as one dimension. in particular, the intensity function in the (u, i)-th dimension (user u and item i) is modeled as a rayleigh process:
λu,i(t|t′) = exp ( uu(t ′)>ii(t ′) )︸ ︷︷ ︸
user-item compatibility
· (t− t′)︸ ︷︷ ︸ time lapse
(4)
where t > t′, and t′ is the last time point where either user u’s embedding or item i’s embedding changes before time t. the rationale behind this formulation is three-fold:
• time as a random variable. instead of discretizing the time into epochs as traditional methods (charlin , 2015; preeti bhargava, 2015; gopalan , 2015; hidasi & tikk, 2015; wang , 2016a), we explicitly model the timing of each interaction event as a random variable, which naturally captures the heterogeneity of the temporal interactions between users and items. • short term preference. the probability for user u to interact with item i depends on the compatibility of their instantaneous embeddings, which is evaluated through the inner product at the last event time t′. because uu(t) and ii(t) co-evolve through time, their inner-product measures a general representation of the cumulative influence from the past interactions to the occurrence of the current event. the exp(·) function ensures the intensity is positive and well defined. • rayleigh time distribution. the user and item embeddings are piecewise constant, and we use the time lapse term to make the intensity piecewise linear. this form leads to a rayleigh distribution for the time intervals between consecutive events in each dimension. it is well-adapted to modeling fads, where the event-happening likelihood f(·) in (1) rises to a peak and then drops extremely rapidly. furthermore, it is computationally easy to obtain an analytic form of f(·). one can then use f(·) to make item recommendation by finding the dimension that f(·) reaches the peak.
with the parameterized intensity function, we can further estimate the parameters using maximum likelihood estimation of all events. the joint negative log-likelihood is (daley & vere-jones, 2007):
` = − n∑ j=1 log ( λuj ,ij (tj |t′j) ) ︸ ︷︷ ︸
intensity of interaction event
+ m∑ u=1 n∑ i=1 ∫ t 0
λu,i(τ |τ ′) dτ︸ ︷︷ ︸ survival probability of event not happened
(5)
the rationale of the objective two-fold: (i) the negative intensity summation term ensures the probability of all interaction events is maximized; (ii) the second survival probability term penalizes the non-presence of an interaction between all possible user-item pairs on the observation window. hence, our framework not only explains why an event happens, but also why an event did not happen.in this section, we propose an efficient algorithm to learn the parameters {vi}4i=1 and {wi} 4 i=1. the batch objective function is presented in (5). the back propagation through time (bptt) is the standard way to train a rnn. to make the back propagation tractable, one typically needs to do truncation during training. however, due to the novel co-evolutionary nature of our model, all the events are related to each other by the user-item bipartite graph (figure 2), which makes it hard to decompose.
hence, in sharp contrast to works (hidasi , 2016; du , 2016) in sequential data where one can easily break the sequences into multiple segments to make the bptt trackable, it is a challenging task to design bptt in our case. to efficiently solve this problem, we first order all the events globally and then do mini-batch training in a sliding window fashion. each time when conducting feed forward and back propagation, we take the consecutive events within current sliding window to build the computational graph. thus in our case the truncation is on the global timeline, instead over individual independent sequences as in prior works.
next, we explain our procedure in detail. given a mini-batch of m ordered events õ = {ej}mj=1, we set the time span to be [t0 = t1, t = tm ]. below we show how to compute the intensity and survival probability term in the objective function (5) respectively.
embedding is shown. (b) survival probability for a user-item pair (u, i). the integral
∫ t  λu,i(τ |τ ′)dτ is decomposed into 4 inter-event intervals separated by {t0, · · · , t3}, with close form on each interval.
computing the intensity function. each time when a new event ej happens between uj and ij , their corresponding feature embeddings will evolve according to a computational graph, as illustrated in figure 2a. due to the change of feature embedding, all the dimensions related to uj or ij will be influenced and the intensity function for that dimension will change consequently. such crossdimension influence dependency is shown in figure 2b. in our implementation, we first compute the corresponding intensity λuj ,ij (tj |t′j) according to (4), and then update the embedding of uj and ij . this operation takes o(m) complexity, and is independent to the number of users or items.
computing the survival function. to compute the survival probability − ∫ t t0 λu,i(τ |τ ′)dτ for each pair (u, i), we first collect all the time stamps {tk} that have events related to either u or i. for notation simplicity, let |{tk}| = nu,i and t1 = t0, tnu,i = t . since the embeddings are piecewise constant, the corresponding intensity function is piecewise linear, according to (4). thus, the integration is decomposed into each time interval where the intensity is constant, i.e.,∫ t
t0 λu,i(τ |τ ′)dτ = nu,i−1∑ k=1 ∫ tk+1 tk λu,i(τ |τ ′)dτ = nu,i−1∑ k=1 (t2k+1 − t2k) exp ( uu(tk) >ii(tk) ) (6)
figure 3 visualizes the computation. although the survival probability term exists in close form, we still need to solve two challenges. first, it is still expensive to compute it for each user item pair. moreover, since the user-item interaction bipartite graph is very sparse, it is not necessary to monitor each dimension in the stochastic training setting. to speed up the computation, we propose a novel random-sampling scheme as follows.
note that the intensity term in the objective function (5) tries to maximize the inner product between user and item that has interaction event, while the survival term penalize over all other pairs of inner
products. we observe that this is similar to softmax computing for classification problem. hence, inspired by the noise-contrastive estimation method (gutmann & hyvärinen, 2012) that is widely used in language models (mnih & kavukcuoglu, 2013), we keep the dimensions that have events on them, while randomly sample dimensions without events in current mini-batch.
the second challenge lies in the fact that the user-item interactions vary a lot across mini-batches, hence the corresponding computational graph also changes greatly. to make the learning efficient, we use the graph embedding framework (dai , 2016) which allows training deep learning models where each term in the objective has a different computational graphs but with shared parameters. the adam optimizer (kingma & ba, 2014) together with gradient clip is used in our experiment.we evaluate our model on real-world datasets. for each sequence of user activities, we use all the events up to time t · p as the training data, and the rest events as the testing data, where t is the observation window. we tune the latent rank of other baselines using 5-fold cross validation with grid search. we vary the proportion p ∈ {0.7, 0.72, 0.74, 0.76, 0.78} and report the averaged results over five runs on two tasks (we will release code and data once published):
• item prediction. at each test time t, we predict the item that the user u will interact with. we rank all the items in the descending order of the conditional density fu,i(t) = λu,i(t)su,i(t). we report the mean average rank (mar) of each test item at the test time. ideally, the item associated with the test time t should rank one, hence smaller value indicates better predictive performance. • time prediction. we predict the expected time when a testing event will occur between a given user-item pair. using rayleigh distribution, it is given by et∼fu,i(t)(t) = √ π  exp(uu(t−)>ii(t−)) .
we report the mean absolute error (mae) between the predicted and true time.we compared our deepcoevolve with the following methods. table 1 summarizes the differences.
• lowrankhawkes (du , 2015): this is a low rank hawkes process model which assumes user-item interactions to be independent of each other and does not capture the co-evolution of user and item features. • coevolving (wang , 2016b): this is a multi-dimensional point process model which uses a simple linear embedding to model the co-evolution of user and item features. • poissontensor (chi & kolda, 2012): poisson tensor factorization has been shown to perform better than factorization methods based on squared loss (karatzoglou , 2010; xiong , 2010; wang , 2015b) on recommendation tasks. the performance for this baseline is reported using the average of the parameters fitted over all time intervals. • timesvd++ (koren, 2009) and fip (yang , 2011): these two methods are only designed for explicit ratings, the implicit user feedbacks (in the form of a series of interaction events) are converted into the explicit ratings by the respective frequency of interactions with users. • stic (kapoor , 2015): it fits a semi-hidden markov model (hmm) to each observed user-item pair and is only designed for time prediction.we use three real world datasets as follows.
• iptv. it contains 7,100 users’ watching history of 385 tv programs in 11 months (jan 1 - nov 30 2012), with around 2m events, and 1,420 movie features (including 1,073 actors, 312 directors, 22 genres, 8 countries and 5 years). • yelp. this data was available in yelp dataset challenge round 7. it contains reviews for various businesses from october, 2004 to december, 2015. the dataset we used here contains 1,005 users and 47,924 businesses, with totally 291,716 reviews.
• reddit. we collected discussion related data on different subreddits (groups) for the month of january 2014. we filtered all bot users’ and their posts from this dataset. furthermore, we randomly selected 1,000 users, 1,403 groups, and 10,000 discussion events.figure 4 shows that deepcoevolve significantly outperforms both epoch-based baselines and state-of-arts point process based methods. lowrankhawkes has good performance on item prediction but not on time prediction, while coevolving has good performance on time prediction but not on item prediction. we discuss the performance regarding the two metrics below.
item prediction. note that the best possible mar one can achieve is 1, and our method gets quite accurate results: with the value of 1.7 on iptv and 1.9 on reddit. note lowrankhawkes achieves comparable item prediction performance, but not as good on the time prediction task. we think the reason is as follows. since one only need the rank of conditional density f(·) in (1) to conduct item prediction, lowrankhawkes may still be good at differentiating the conditional density function, but could not learn its actual value accurately, as shown in the time prediction task where the value of the conditional density function is needed for precise prediction.
time prediction. the second row of figure 4 shows that deepcoevolve outperforms other methods. compared with lowrankhawkes that achieves comparable time predication performance, 6× improvement on reddit, it has 10× improvement on yelp, and 30× improvement on iptv. the time unit is hour. hence it has 2 weeks accuracy improvement on iptv and 2 days on reddit. this is important for online merchants to make time sensitive recommendations. an intuitive explanation is that our method accurately captures the nonlinear pattern between user and item interactions. the competitor lowrankhawkes assumes specific parametric forms of the user-item interaction process, hence may not be accurate or expressive enough to capture real world temporal patterns. furthermore, it models each user-item interaction dimension independently, which may lose the important affection from user’s interaction with other items while predicting the current item’s reoccurrence time. our work also outperforms coevolving, e.g., with around 3×mae improve on iptv. moreover, the item prediction performance is also much better than coevolving. it shows the importance of using rnn to capture the nonlinear embedding of user and item latent features, instead of the simple parametrized linear embedding in coevolving.we will look deeper and provide rationale behind the prediction results in the following two subsections. first, to understand the difficulty of conducting prediction tasks in each dataset, we study their different sparsity properties. for the multidimensional point process models, the fewer events we observe in each dimension, the more sparse the dataset is. our approach alleviates the sparsity problem via the modeling of dependencies among dimensions, thus is consistently doing better than other baseline algorithms.
next, we fix one dataset and evaluate how different levels of sparsity in training data influences each algorithm’s performance.we visualize the three datasets in figure 5 according to (i) the number of events per user, and (ii) the user-item interaction graph.
sparsity in terms of the number of events per user. typically, the more user history data we have, the better results we will obtain in the prediction tasks. we can see in iptv dataset, users typically have longer length of history than the users in reddit and yelp datasets. thus our algorithm and all other baseline methods have their best performance on this dataset. however, the reddit dataset and yelp dataset are hard to tell the performance based only on the distribution of history length, thus we do a more detailed visualization.
sparsity in terms of diversity of items to recommend. from the bipartite graph, it is easy to see that yelp dataset has higher density than the other two datasets. the density of the interaction graph reflects the variety of history per each user. for example, the users in iptv only has 385 programs to watch, but they can have 47,924 businesses to choose in yelp dataset. also, the yelp dataset has 9 times more items than iptv and reddit dataset in the bipartite graph. this means the users in yelp dataset has more diverse tastes than users in other two datasets. this is because if users has similar tastes, the distinct number of items in the union of their history should be small.
based on the above two facts, we can see yelp dataset is the most sparse, since it has shorter length of history per user, and much more diversity of the items, it is not surprising that this dataset is much harder than the other iptv and reddit dataset.with the case study on the most challenging yelp dataset, we further evaluate how each algorithm performs with lower level of sparsity as compared to the one used in figure 4 (c).we use this to demonstrate that our work is most robust and performs well across different levels of sparsity.
we first create yelp100, a more dense dataset, by filtering the original yelp dataset to keep the top 100 users. each user would have at least 200 events. figure 6 (a) shows the statistics of this dataset. on average the users have more history events than the original yelp dataset in figure 5(c).
on this dense dataset, figure 6 (b) and (c) show that all the algorithms’ performances improve with more history events, comparing to the performance in original yelp dataset. for example, lowrankhawkes has similar rank prediction results as our deepcoevolve on this dense dataset. however, as the dataset becomes sparse, the performance of lowrankhawkes drops significantly, as shown in figure 4(c). for example, the rank prediction error goes from 90 to 2128, and the
time error goes from 724 to 11043.5. we think it is because this model relies more on the history information per each user-item pair.
on the contrary, our deepcoevolve still has superior performance with such high level of sparsity. the rank error only changes from 87 to 107, and the time error changes from 72 to 884 as the data becomes sparse. it shows that our work is the most robust to the sparsity in the data. we think it is because our work accurately captures the nonlinear multidimensional dependencies between users and items latent features.we have proposed an efficient framework to model the nonlinear co-evolution nature of users’ and items’ latent features. moreover, the user and item’s evolving and co-evolving processes are captured by the rnn. it is based on temporal point processes and models time as a random variable. hence it is in sharp contrast to prior epoch based works. we demonstrate the superior performance of our method on both the time and item prediction task, which is not possible by most prior work. future work includes extending to other social applications, such as group dynamics in message services.computing gradient. for illustration purpose, we here use sigmoid as the nonlinear activation function σ. in order to get gradient with respect to parameter w ’s, we first compute gradients with respect to each varying points of embeddings. for user u’s embedding after his k-th event, the corresponding partial derivatives are computed by:
∂`
∂uu(tuk) = −iiuk︸︷︷︸
from intensity
+ n∑ i=1
∂ ∫ tuk+1 tuk
λu,i(τ |τ ′)dτ ∂uu(tuk)︸ ︷︷ ︸
from survival
+ ∂`
∂uu(tuk+1) (1− uu(tuk+1)) uu(tuk+1)w2︸ ︷︷ ︸ from user u’s next embedding
+ ∂`
∂iiuk+1(t u k+1)
(1− iiuk+1(t u k+1)) iiuk+1(t u k+1)︸ ︷︷ ︸
from user u’s next item embedding
where denotes element-wise multiplication. the gradient coming from the second term (i.e., the survival term) is also easy to compute, since the rayleigh distribution has closed form of survival function. for a certain item i, if its feature doesn’t changed between time interval [tuk , t u k+1], then we have
∂ ∫ tuk+1 tuk
λu,i(τ |τ ′)dτ ∂uu(tuk) = (tuk+1 − tuk)2 2 exp
( uu(t u k) >ii(t u k)ii(t u k) )
(7)
on the other hand, if the embedding of item i changes during this time interval, then we should break this interval into segments and compute the summation of gradients in each segment in a way similar to (7). thus, we are able to compute the gradients with respect to wi, i ∈ {1, 2, 3, 4} as follows.
∂`
∂w1 = m∑ u=1 ∑ k
∂`
∂uu(tuk) (i− uu(tuk)) uu(tuk)(tuk − tuk−1)
∂`
∂w2 = m∑ u=1 ∑ k ( ∂` ∂uu(tuk) (i− uu(tuk)) uu(tuk) ) uu(t u k−1) >
∂`
∂w3 = m∑ u=1 ∑ k ( ∂` ∂uu(tuk) (i− uu(tuk)) uu(tuk) ) iik(t u k−)>
∂`
∂w4 = m∑ u=1 ∑ k ( ∂` ∂uu(tuk) (i− uu(tuk)) uu(tuk) ) qu,ikk
since the items are treated symmetrically as users, the corresponding derivatives can be obtained in a similar way.",0
657.pdf.json,,"text classification is an important problem in natural language processing (nlp). real world usecases include spam filtering or e-mail categorization. it is a core component in more complex systems such as search and ranking. recently, deep learning techniques based on neural networks have achieved state of the art results in various nlp applications. one of the main successes of deep learning is due to the effectiveness of recurrent networks for language modeling and their application to speech recognition and machine translation (mikolov, 2012). however, in other cases including several text classification problems, it has been shown that deep networks do not convincingly beat the prior state of the art techniques (wang & manning, 2012; joulin , 2016).
in spite of being (typically) orders of magnitude slower to train than traditional techniques based on n-grams, neural networks are often regarded as a promising alternative due to compact model sizes, in particular for character based models. this is important for applications that need to run on systems with limited memory such as smartphones.
this paper specifically addresses the compromise between classification accuracy and the model size. we extend our previous work implemented in the fasttext library1. it is based on n-gram features, dimensionality reduction, and a fast approximation of the softmax classifier (joulin , 2016). we show that a few key ingredients, namely feature pruning, quantization, hashing, and retraining, allow us to produce text classification models with tiny size, often less than 100kb when trained on several popular datasets, without noticeably sacrificing accuracy or speed.
we plan to publish the code and scripts required to reproduce our results as an extension of the fasttext library, thereby providing strong reproducible baselines for text classifiers that optimize the compromise between the model size and accuracy. we hope that this will help the engineering community to improve existing applications by using more efficient models.
this paper is organized as follows. section 2 introduces related work, section 3 describes our text classification model and explains how we drastically reduce the model size. section 4 shows the effectiveness of our approach in experiments on multiple text classification benchmarks. https://github.com/facebookresearch/fasttextmodels for text classification. text classification is a problem that has its roots in many applications such as web search, information retrieval and document classification (deerwester , 1990; pang & lee, 2008). linear classifiers often obtain state-of-the-art performance while being scalable (agarwal , 2014; joachims, 1998; joulin , 2016; mccallum & nigam, 1998). they are particularly interesting when associated with the right features (wang & manning, 2012). they usually require storing embeddings for words and n-grams, which makes them memory inefficient.
compression of language models. our work is related to compression of statistical language models. classical approaches include feature pruning based on entropy (stolcke, 2000) and quantization. pruning aims to keep only the most important n-grams in the model, leaving out those with probability lower than a specified threshold. further, the individual n-grams can be compressed by quantizing the probability value, and by storing the n-gram itself more efficiently than as a sequence of characters. various strategies have been developed, for example using tree structures or hash functions, and are discussed in (talbot & brants, 2008).
compression for similarity estimation and search. there is a large body of literature on how to compress a set of vectors into compact codes, such that the comparison of two codes approximates a target similarity in the original space. the typical use-case of these methods considers an indexed dataset of compressed vectors, and a query for which we want to find the nearest neighbors in the indexed set. one of the most popular is locality-sensitive hashing (lsh) by charikar (2002), which is a binarization technique based on random projections that approximates the cosine similarity between two vectors through a monotonous function of the hamming distance between the two corresponding binary codes. in our paper, lsh refers to this binarization strategy2. many subsequent works have improved this initial binarization technique, such as spectal hashing (weiss , 2009), or iterative quantization (itq) (gong & lazebnik, 2011), which learns a rotation matrix minimizing the quantization loss of the binarization. we refer the reader to two recent surveys by wang  (2014) and wang  (2015) for an overview of the binary hashing literature.
beyond these binarization strategies, more general quantization techniques derived from jegou  (2011) offer better trade-offs between memory and the approximation of a distance estimator. the product quantization (pq) method approximates the distances by calculating, in the compressed domain, the distance between their quantized approximations. this method is statistically guaranteed to preserve the euclidean distance between the vectors within an error bound directly related to the quantization error. the original pq has been concurrently improved by ge  (2013) and norouzi & fleet (2013), who learn an orthogonal transform minimizing the overall quantization loss. in our paper, we will consider the optimized product quantization (opq) variant (ge , 2013).
softmax approximation the aforementioned works approximate either the euclidean distance or the cosine similarity (both being equivalent in the case of unit-norm vectors). however, in the context of fasttext, we are specifically interested in approximating the maximum inner product involved in a softmax layer. several approaches derived from lsh have been recently proposed to achieve this goal, such as asymmetric lsh by shrivastava & li (2014), subsequently discussed by neyshabur & srebro (2015). in our work, since we are not constrained to purely binary codes, we resort a more traditional encoding by employing a magnitude/direction parametrization of our vectors. therefore we only need to encode/compress an unitary d-dimensional vector, which fits the aforementioned lsh and pq methods well.
neural network compression models. recently, several research efforts have been conducted to compress the parameters of architectures involved in computer vision, namely for state-of-theart convolutional neural networks (cnns) (han , 2016; lin , 2015). some use vector quantization (gong , 2014) while others binarize the network (courbariaux , 2016). denil  (2013) show that such classification models are easily compressed because they are overparametrized, which concurs with early observations by lecun  (1990). in the literature, lsh refers to multiple distinct strategies related to the johnson-lindenstrauss lemma. for instance, lsh sometimes refers to a partitioning technique with random projections allowing for sublinear search via cell probes, see for instance the e2lsh variant of datar  (2004).
some of these works both aim at reducing the model size and the speed. in our case, since the fasttext classifier on which our proposal is built upon is already very efficient, we are primilarly interested in reducing the size of the model while keeping a comparable classification efficiency.in the context of text classification, linear classifiers (joulin , 2016) remain competitive with more sophisticated, deeper models, and are much faster to train. on top of standard tricks commonly used in linear text classification (agarwal , 2014; wang & manning, 2012; weinberger , 2009), joulin  (2016) use a low rank constraint to reduce the computation burden while sharing information between different classes. this is especially useful in the case of a large output space, where rare classes may have only a few training examples. in this paper, we focus on a similar model, that is, which minimizes the softmax loss ` over n documents:
n∑ n=1 `(yn, baxn), (1)
where xn is a bag of one-hot vectors and yn the label of the n-th document. in the case of a large vocabulary and a large output space, the matrices a and b are big and can require gigabytes of memory. below, we describe how we reduce this memory usage.product quantization is a popular method for compressed-domain approximate nearest neighbor search (jegou , 2011). as a compression technique, it approximates a real-valued vector by finding the closest vector in a pre-defined structured set of centroids, referred to as a codebook. this codebook is not enumerated, since it is extremely large. instead it is implicitly defined by its structure: a d-dimensional vector x ∈ rd is approximated as
x̂ = k∑ i=1 qi(x), (2)
where the different subquantizers qi : x 7→ qi(x) are complementary in the sense that their respective centroids lie in distinct orthogonal subspaces, i.e., ∀i 6= j, ∀x, y, 〈qi(x)|qj(y)〉 = 0. in the original pq, the subspaces are aligned with the natural axis, while opq learns a rotation, which amounts to alleviating this constraint and to not depend on the original coordinate system. another way to see this is to consider that pq splits a given vector x into k subvectors xi, i = 1 . . . k, each of dimension d/k: x = [x1 . . . xi . . . xk], and quantizes each sub-vector using a distinct k-means quantizer. each subvector xi is thus mapped to the closest centroid amongst 2b centroids, where b is the number of bits required to store the quantization index of the subquantizer, typically b = 8. the reconstructed vector can take 2kb distinct reproduction values, and is stored in kb bits.
pq estimates the inner product in the compressed domain as
x>y ≈ x̂>y = k∑
i=1
qi(x i)>yi. (3)
this is a straightforward extension of the square l2 distance estimation of jegou  (2011). in practice, the vector estimate x̂ is trivially reconstructed from the codes, i.e., from the quantization indexes, by concatenating these centroids.
the two parameters involved in pq, namely the number of subquantizers k and the number of bits b per quantization index, are typically set to k ∈ [2, d/2], and b = 8 to ensure byte-alignment.
discussion. pq offers several interesting properties in our context of text classification. firstly, the training is very fast because the subquantizers have a small number of centroids, i.e., 256 centroids for b = 8. secondly, at test time it allows the reconstruction of the vectors with almost no
computational and memory overhead. thirdly, it has been successfully applied in computer vision, offering much better performance than binary codes, which makes it a natural candidate to compress relatively shallow models. as observed by sánchez & perronnin (2011), using pq just before the last layer incurs a very limited loss in accuracy when combined with a support vector machine.
in the context of text classification, the norms of the vectors are widely spread, typically with a ratio of 1000 between the max and the min. therefore kmeans performs poorly because it optimizes an absolute error objective, so it maps all low-norm vectors to 0. a simple solution is to separate the norm and the angle of the vectors and to quantize them separately. this allows a quantization with no loss of performance, yet requires an extra b bits per vector.
bottom-up strategy: re-training. the first works aiming at compressing cnn models like the one proposed by (gong , 2014) used the reconstruction from off-the-shelf pq, i.e., without any re-training. however, as observed in sablayrolles  (2016), when using quantization methods like pq, it is better to re-train the layers occurring after the quantization, so that the network can re-adjust itself to the quantization. there is a strong argument arguing for this re-training strategy: the square magnitude of vectors is reduced, on average, by the average quantization error for any quantizer satisfying the lloyd conditions; see jegou  (2011) for details.
this suggests a bottom-up learning strategy where we first quantize the input matrix, then retrain and quantize the output matrix (the input matrix being frozen). experiments in section 4 show that it is worth adopting this strategy.
memory savings with pq. in practice, the bottom-up pq strategy offers a compression factor of 10 without any noticeable loss of performance. without re-training, we notice a drop in accuracy between 0.1% and 0.5%, depending on the dataset and setting; see section 4 and the appendix.the memory usage strongly depends on the size of the vocabulary, which can be large in many text classification tasks. while it is clear that a large part of the vocabulary is useless or redundant, directly reducing the vocabulary to the most frequent words is not satisfactory: most of the frequent words, like “the” or “is” are not discriminative, in contrast to some rare words, e.g., in the context of tag prediction. in this section, we discuss a few heuristics to reduce the space taken by the dictionary. they lead to major memory reduction, in extreme cases by a factor 100. we experimentally show that this drastic reduction is complementary with the pq compression method, meaning that the combination of both strategies reduces the model size by a factor up to ×1000 for some datasets.
pruning the vocabulary. discovering which word or n-gram must be kept to preserve the overall performance is a feature selection problem. while many approaches have been proposed to select groups of variables during training (bach , 2012; meier , 2008), we are interested in selecting a fixed subset of k words and ngrams from a pre-trained model. this can be achieved by selecting the k embeddings that preserve as much of the model as possible, which can be reduced to selecting the k words and ngrams associated with the highest norms.
while this approach offers major memory savings, it has one drawback occurring in some particular cases: some documents may not contained any of the k best features, leading to a significant drop in performance. it is thus important to keep the k best features under the condition that they cover the whole training set. more formally, the problem is to find a subset s in the feature set v that maximizes the sum of their norms ws under the constraint that all the documents in the training set d are covered:
max s⊆v ∑ s∈s ws s.t. |s| ≤ k, p1s ≥ 1d,
where p is a matrix such that pds = 1 if the s-th feature is in the d-th document, and 0 otherwise. this problem is directly related to set covering problems that are np-hard (feige, 1998). standard greedy approaches require the storing of an inverted index or to do multiple passes over the dataset, which is prohibitive on very large dataset (chierichetti , 2010). this problem can be cast as an instance of online submodular maximization with a rank constraint (badanidiyuru , 2014;
bateni , 2010). in our case, we use a simple online parallelizable greedy approach: for each document, we verify if it is already covered by a retained feature and, if not, we add the feature with the highest norm to our set of retained features. if the number of features is below k, we add the features with the highest norm that have not yet been picked.
hashing trick & bloom filter. on small models, the dictionary can take a significant portion of the memory. instead of saving it, we extend the hashing trick used in joulin  (2016) to both words and n-grams. this strategy is also used in vowpal wabbit (agarwal , 2014) in the context of online training. this allows us to save around 1-2mb with almost no overhead at test time (just the cost of computing the hashing function).
pruning the vocabulary while using the hashing trick requires keeping a list of the indices of the k remaining buckets. at test time, a binary search over the list of indices is required. it has a complexity of o(log(k)) and a memory overhead of a few hundreds of kilobytes. using bloom filters instead reduces the complexityo(1) at test time and saves a few hundred kilobytes. however, in practice, it degrades performance.this section evaluates the quality of our model compression pipeline and compare it to other compression methods on different text classification problems, and to other compact text classifiers.
evaluation protocol and datasets. our experimental pipeline is as follows: we train a model using fasttext with the default setting unless specified otherwise. that is 2m buckets, a learning rate of 0.1 and 10 training epochs. the dimensionality d of the embeddings is set to powers of 2 to avoid border effects that could make the interpretation of the results more difficult. as baselines, we use locality-sensitive hashing (lsh) (charikar, 2002), pq (jegou , 2011) and opq (ge , 2013) (the non-parametric variant). note that we use an improved version of lsh where random orthogonal matrices are used instead of random matrix projection jégou  (2008). in a first series of experiments, we use the 8 datasets and evaluation protocol of zhang  (2015). these datasets contain few million documents and have at most 10 classes. we also explore the limit of quantization on a dataset with an extremely large output space, that is a tag dataset extracted from the yfcc100m collection (thomee , 2016)3, referred to as flickrtag in the rest of this paper.compression techniques. we compare three popular methods used for similarity estimation with compact codes: lsh, pq and opq on the datasets released by zhang  (2015). figure 1 shows the accuracy as a function of the number of bytes used per embedding, which corresponds to the number k of subvectors in the case of pq and opq. see more results in the appendix. as discussed in section 2, lsh reproduces the cosine similarity and is therefore not adapted to un-normalized data. therefore we only report results with normalization. once normalized, pq and opq are almost lossless even when using only k = 4 subquantizers per embedding (equivalently, bytes). we observe in practice that using k = d/2, i.e., half of the components of the embeddings, works well in practice. in the rest of the paper and if not stated otherwise, we focus on this setting. the difference between the normalized versions of pq and opq is limited and depends on the dataset. therefore we adopt the normalized pq (npq) for the rest of this study, since it is faster to train. data available at https://research.facebook.com/research/fasttext/
pruning. figure 2 shows the performance of our model with different sizes. we fix k = d/2 and use different pruning thresholds. npq offers a compression rate of×10 compared to the full model. as the pruning becomes more agressive, the overall compression can increase up up to ×1, 000 with little drop of performance and no additional overhead at test time. in fact, using a smaller dictionary makes the model faster at test time. we also compare with character-level convolutional neural networks (cnn) (zhang , 2015; xiao & cho, 2016). they are attractive models for text classification because they achieve similar performance with less memory usage than linear models (xiao & cho, 2016). even though fasttext with the default setting uses more memory, npq is already on par with cnns’ memory usage. note that cnns are not quantized, and it would be worth seeing how much they can be quantized with no drop of performance. such a study is beyond the scope of this paper. our pruning is based on the norm of the embeddings according to the guidelines of section 3.3. table 1 compares the ranking obtained with norms to the ranking obtained using entropy, which is commonly used in unsupervised settings stolcke (2000).
extreme compression. finally, in table 2, we explore the limit of quantized model by looking at the performance obtained for models under 64kib. surprisingly, even at 64kib and 32kib, the drop of performance is only around 0.8% and 1.7% despite a compression rate of ×1, 000− 4, 000.in this section, we explore the limit of compression algorithms on very large datasets. similar to joulin  (2016), we consider a hashtag prediction dataset containing 312, 116 labels. we set the minimum count for words at 10, leading to a dictionary of 1, 427, 667 words. we take 10m buckets for n-grams and a hierarchical softmax. we refer to this dataset as flickrtag.
output encoding. we are interested in understanding how the performance degrades if the classifier is also quantized (i.e., the matrix b in eq. 1) and when the pruning is at the limit of the minimum number of features required to cover the full dataset.
table 3 shows that quantizing both the “input” matrix (i.e., a in eq. 1) and the “output” matrix (i.e., b) does not degrade the performance compared to the full model. we use embeddings with d = 256 dimensions and use k = d/2 subquantizers. we do not use any text specific tricks, which leads to a compression factor of 8. note that even if the output matrix is not retrained over the embeddings, the performance is only 0.2% away from the full model. as shown in the appendix, using less subquantizers significantly decreases the performance for a small memory gain.
pruning. table 4 shows how the performance evolves with pruning. we measure this effect on top of a fully quantized model. the full model misses 11.6% of the test set because of missing words (some documents are either only composed of hashtags or have only rare words). there are 312, 116 labels and thus it seems reasonable to keep embeddings in the order of the million. a naive pruning with 1m features misses about 30−40% of the test set, leading to a significant drop of performance. on the other hand, even though the max-coverage pruning approach was set on the train set, it does not suffer from any coverage loss on the test set. this leads to a smaller drop of performance. if the pruning is too aggressive, however, the coverage decreases significantly.it may be possible to obtain further reduction of the model size in the future. one idea is to condition the size of the vectors (both for the input features and the labels) based on their frequency (chen , 2015; grave , 2016). for example, it is probably not worth representing the rare labels by full 256-dimensional vectors in the case of the flickrtag dataset. thus, conditioning the vector size on the frequency and norm seems like an interesting direction to explore in the future.
we may also consider combining the entropy and norm pruning criteria: instead of keeping the features in the model based just on the frequency or the norm, we can use both to keep a good set of features. this could help to keep features that are both frequent and discriminative, and thereby to reduce the coverage problem that we have observed.
additionally, instead of pruning out the less useful features, we can decompose them into smaller units (mikolov , 2012). for example, this can be achieved by splitting every non-discriminative word into a sequence of character trigrams. this could help in cases where training and test examples are very short (for example just a single word).in this paper, we have presented several simple techniques to reduce, by several orders of magnitude, the memory complexity of certain text classifiers without sacrificing accuracy nor speed. this is achieved by applying discriminative pruning which aims to keep only important features in the trained model, and by performing quantization of the weight matrices and hashing of the dictionary.
we will publish the code as an extension of the fasttext library. we hope that our work will serve as a baseline to the research community, where there is an increasing interest for comparing the performance of various deep learning text classifiers for a given number of parameters. overall, compared to recent work based on convolutional neural networks, fasttext.zip is often more accurate, while requiring several orders of magnitude less time to train on common cpus, and incurring a fraction of the memory complexity.",0
663.pdf.json,,"product classification is a key issue in e-commerce domains. a product is typically represented by metadata such as its title, image, color, weight and so on, and most of them are assigned manually by the seller. once a product is uploaded to an e-commerce website, it is typically placed in multiple categories. categorizing products helps e-commerce websites to provide costumers a better shopping experience, for example by efficiently searching the products catalog or by developing recommendation systems. a few examples of categories are internal taxonomies (for business needs), public taxonomies (such as groceries and office equipment) and the product’s shelf (a group of products that are presented together on an e-commerce web page). these categories vary with time in order to optimize search efficiency and to account for special events such as holidays and sports events. in order to address these needs, e-commerce websites typically hire editors and use crowdsourcing platforms to classify products. however, due to the high amount of new products uploaded daily and the dynamic nature of the categories, machine learning solutions for product classification are very appealing as means to reduce the time and economic costs. thus, precisely categorizing items emerges as a significant issue in e-commerce domains.
a shelf is a group of products presented together on an e-commerce website page, and usually contain products with a given theme/category (e.g., women boots, folding tables). product to shelf classification is a challenging problem due to data size, category skewness, and noisy metadata and labels. in particular, it presents three fundamental challenges for machine learning algorithms. first, it is typically a multi-class problem with thousands of classes. second, a product may belong to multiple shelves making it a multi-label problem. and last, a product has both an image and a text input making it a multi-modal problem.
products classification is typically addressed as a text classification problem because most metadata of items are represented as textual features (pyo , 2010). text classification is a classic topic for natural language processing, in which one needs to assign predefined categories to text inputs.
standard methods follow a classical two-stage scheme of extraction of (handcrafted) features, followed by a classification stage. typical features include bag-of-words or n-grams, and their tf-idf. on the other hand, deep neural networks use generic priors instead of specific domain knowledge (bengio , 2013) and have been shown to give competitive results on text classification tasks (zhang , 2015). in particular, convolutional neural networks (cnns) (kim, 2014; zhang , 2015; conneau , 2016) and recurrent nns (lai , 2015; pyo , 2010; xiao & cho, 2016) can efficiently capture the sequentiality of the text. these methods are typically applied directly to distributed embedding of words (kim, 2014; lai , 2015; pyo , 2010) or characters (zhang , 2015; conneau , 2016; xiao & cho, 2016), without any knowledge on the syntactic or semantic structures of a language. however, all of these architectures were only applied on problems with a small amount of labels (∼ 20) while e-commerce shelf classification problems typically have thousands of labels with multiple labels per product.
in image classification, cnns are widely considered the best models, and achieve state-of-theart results on the imagenet large-scale visual recognition challenge (russakovsky , 2015; krizhevsky , 2012; simonyan & zisserman, 2014; he , 2015). however, as good as they are, the classification accuracy of machine learning systems is often limited in problems with many classes of object categories. one remedy is to leverage data from other sources, such as text data. however, the studies on multi-modal deep learning for large-scale item categorization are still rare to the best of our belief. in particular in a setting where there is a significant difference in discriminative power between the two types of signals.
in this work, we propose a multi-modal deep neural network model for product classification. our design principle is to leverage the specific prior for each data type by using the current state-ofthe-art classifiers from the image and text domains. the final architecture has 3 main components (figure 2, right): a text cnn (kim, 2014), an image cnn (simonyan & zisserman, 2014) and a policy network that learns to choose between them. we collected a large-scale data set of 1.2 million products from the walmart.com website. each product has a title and an image and needs to be classified to a shelf (label) with 2890 possible shelves. examples from this dataset can be seen in figure 1 and are also available on-line at the walmart.com website. for most of the products, both the image and the title of each product contain relevant information for customers. however, it is interesting to observe that for some of the products, both input types may not be informative for shelf prediction (figure 1). this observation motivates our work and raises interesting questions: which input type is more useful for product classification? is it possible to forge the inputs into a better architecture?
in our experiments, we show that the text cnn outperforms the image one. however, for a relatively large number of products (∼ 8%), the image cnn is correct while the text cnn is wrong, indicating a potential gain from using a multi-modal architecture. we also show that the policy is able to choose between the two models and give a performance improvement over both state-of-the-art networks.
to the best of our knowledge, this is the first work that demonstrates a performance improvement on top-1 classification accuracy by using images and text on a large-scale classification problem. in particular, our main contributions are:
• we demonstrate that the text classification cnn (kim, 2014) outperforms the vgg network (simonyan & zisserman, 2014) on a real-world large-scale product to shelf classification problem.
• we analyze the errors made by the different networks and show the potential gain of multimodality.
• we propose a novel decision-level fusion policy that learns to choose between the text and image networks and improve over both.over the years, a large body of research has been devoted to improving classification using ensembles of classifiers (kittler , 1998; hansen & salamon, 1990). inspired by their success, these methods have also been used in multi-modal settings (e.g.,guillaumin  (2010); poria  (2016)), where the source of the signals, or alternatively their modalities, are different. some examples include audio-visual speech classification (ngiam , 2011), image and text retrieval (kiros ), sentiment analysis and semi-supervised learning (guillaumin , 2010).
combining classifiers from different input sources presents multiple challenges. first, classifiers vary in their discriminative power, thus, an optimal unification method should be able to adapt itself for specific combinations of classifiers. second, different data sources have different state-ofthe-art architectures, typically deep neural networks, which vary in depth, width, and optimization algorithm; making it non-trivial to merge them. moreover, a multi-modal architecture potentially has more local minima that may give unsatisfying results. finally, most of the publicly available real-world big data classification datasets, an essential building block of deep learning systems, typically contain only one data type.
nevertheless, the potential performance boost of multi-modal architectures has motivated researchers over the years. frome  (2013) combined an image network (krizhevsky , 2012) with a skip-gram language model in order to improve classification results on imagenet. however, they were not able to improve the top-1 accuracy prediction, possibly because the text input they used (image labels) didn’t contain a lot of information. other works, used multi-modality to learn good embedding but did not present results on classification benchmarks (lynch , 2015; kiros ; gong , 2014). kannan  (2011) suggested to improve text-based product classification by adding an image signal, training an image classifier and learning a decision rule between the two. however, they only experimented with a small dataset and a low number of labels, and it is not clear how to scale their method for extreme multi-class multi-label applications that characterize real-world problems in e-commerce.
adding modalities can improve the classification of products that have a non-informative input source (e.g., image or text). in e-commerce, for example, classifiers that rely exclusively on text suffer from short and non-informative titles, differences in style between vendors and overlapping text across categories (i.e., a word that helps to classify a certain class may appear in other classes). figure 1 presents a few examples of products that have only one informative input type. these examples suggest that a multi-modal architecture can potentially outperform a classifier with a single input type.
most unification techniques for multi-modal learning are partitioned between feature-level fusion techniques and decision-level fusion techniques (figure 2, left).feature-level fusion is characterized by three phases: (a) learning a representation, (b) supervised training, and (c) testing. the different unification techniques are distinguished by the availability of the data in each phase (guillaumin , 2010). for example, in cross-modality training, the representation is learned from all the modalities, but only one modality is available for supervised training and testing. in other cases, all of the modalities are available at all stages but we may want (or not) to limit their usage given a certain budget. another source for the distinction is the order in which phases (a) and (b) are made. for example, one may first learn the representation and then learn a classifier from it, or learn both the representation and the classifier in parallel. in the deep learning context, there are two common approaches. in the first approach, we learn an end-to-end deep nn; the nn has multiple input-specific pipes that include a data source followed by input specific layers. after a certain depth, the pipes are concatenated followed by additional layers such that the nn is trained end-to-end. in the second approach, input specific deep nns are learned first, and a multi-modal representation vector is created by concatenating the input specific feature vectors (e.g., the neural network’s last hidden layer). then, an additional classifier learns to classify from the multi-modal representation vector. while multi-modal methods have shown potential to boost performance on small datasets (poria , 2016), or on top-k accuracy measures (frome , 2013), we are not familiar with works that succeeded with applying it on a large-scale classification problem and received performance improvement in top-1 accuracy.in this approach, an input specific classifier is learned for each modality, and the goal is to find a decision rule between them. the decision rule is typically a pre-defined rule (guillaumin , 2010) and is not learned from the data. for example, poria  (2016) chose the classifier with the maximal confidence, while krizhevsky  (2012) average classifier predictions. however, in this work we show that learning the decision rule yields significantly better results on our data.in this section, we give the details of our multi-modal product classification architecture. the architecture is composed of a text cnn and an image cnn which are forged together by a policy network, as can be seen in figure 2, right.our cost function is the weighted sigmoid cross entropy with logits, a common cost function for multi-label problems. let x be the logits, z be the targets, q be a positive weight coefficient, used as a multiplier for the positive targets, and σ(x) = 11+exp(−x) . the loss is given by:
cost(x,z;q) = − qz · log(σ(x))− (1− z) · log(1− σ(x)) = (1− z) · x+ (1 + (q − 1) · z) · log(1 + exp(−x)).
the positive coefficient q, allows one to trade off recall and precision by up- or down-weighting the cost of a positive error relative to a negative error. we found it to have a significant effect in practice.for the text signal, we use the text cnn architecture of kim (2014). the first layer embeds words into low-dimensional vectors using random embedding (different than the original paper). the next layer performs convolutions over time on the embedded word vectors using multiple filter sizes (3, 4 and 5), where we use 128 filters from each size. next, we max-pool-over-time the result of each convolution filter and concatenated all the results together. we add a dropout regularization layer (0.5 dropping rate), followed by a fully connected layer, and classify the result using a softmax layer. an illustration of the text cnn can be seen in figure 2.for the image signal, we use the vgg network (simonyan & zisserman, 2014). the input to the network is a fixed-size 224 x 224 rgb image. the image is passed through a stack of convolutional layers with a very small receptive field: 3 x 3. the convolution stride is fixed to 1 pixel; the spatial padding of the convolutional layer is 1 pixel. spatial pooling is carried out by five max-pooling layers, which follow some of the convolutional layers. max-pooling is performed over a 2 x 2 pixel window, with stride 2. a stack of convolutional layers is followed by three fully-connected (fc) layers: the first two have 4096 channels each, the third performs 2890-way product classification and thus contains 2890 channels (one for each class). all hidden layers are followed by a relu non-linearity. the exact details can be seen in figure 2.we experimented with four types of multi-modal architectures. (1) learning decision-level fusion policies from different inputs. (1a) policies that use the text and image cnns class probabilities as input (figure 2). we experimented with architectures that have one or two fully connected layers (the two-layered policy is using 10 hidden units and a relu non-linearity between them). (1b) policies that use the text and/or image as input. for these policies, the architecture of policy network was either the text cnn or the vgg network. in order to train policies, labels are collected from the image and text networks predictions, i.e., the label is 1 if the image network made a correct prediction while the text network made a mistake, and 0 otherwise. on evaluation, we use the policy predictions to select between the models, i.e., if the policy prediction is 1 we use the image network, and use the text network otherwise. (2) pre-defined policies that average the predictions of the different cnns or choose the cnn with the highest confidence. (3) end-to-end feature-level fusion, each input type is processed by its specific cnn. we concatenate the last hidden layers of the cnns and add one or two fully connected layers. all the layers are trained together end-to-end (we also tried to initialize the input specific weights from pre-trained single-modal networks). (4) multistep feature-level fusion. as in (3), we create shared representation vector by concatenating the last hidden layers. however, we now keep the shared representation fixed and learn a new classifier from it.our dataset contains 1.2 million products (title image and shelf) that we collected from walmart.com (offered online and can be viewed at the website) and were deemed the hardest to classify by the current production system. we divide the data into training (1.1 million) validation (50k) and test (50k). we train both the image network and the text network on the training dataset and evaluate them on the test dataset. the policy is trained on the validation dataset and is also evaluated on the test dataset. the objective is to classify the product’s shelf, from 2890 possible choices. each product is typically assigned to more than one shelf (3 on average), and the network is considered accurate if its most probable shelf is one of them.preprocess: we build a dictionary of all the words in the training data and embed each word using a random embedding into a one hundred dimensional vector. we trim titles with more than 40 words and pad shorter titles with nulls.
we experimented with different batch sizes, dropout rates, and filters stride, but found that the vanilla architecture (kim, 2014) works well on our data. this is consistent with zhang & wallace (2015), who showed that text cnns are not very sensitive to hyperparameters. we tuned the cost function positive coefficient parameter q, and found out that the value 30 performed best in practice (we will also use this value for the image network). the best cnn that we trained classified 70.1% of the products from the test set correctly (table 1).preprocess: we re-size all the images into 224 x 224 pixels and reduce the image mean.
the vgg network that we trained classified 57% of the products from the test set correctly. this is a bit disappointing if we compare it to the performance of the vgg network on imagenet (∼ 75%). there are a few differences between these two datasets that may explain this gap. first, our data has 3 times more classes and contains multiple labels per image making the classification harder, and second, figure 1 implies that some of our images are not informative for shelf classification. some works claim that the features learned by vgg on imagenet are global feature extractors (lynch , 2015). we therefore decided to use the weights learned by vgg on imagenet and learn only the last layer. this configuration yielded only 36.7% accuracy. we believe that the reason is that some of the imagenet classes are irrelevant for e-commerce (e.g., vehicles and animals) while some relevant categories are misrepresented (e.g., electronics and office equipment). it could also be that our images follow some specific pattern of white background, well-lit studio etc., that characterizes e-commerce.is a picture worth a thousand words? inspecting figure 3, we can see that the text network outperformed the image network on this dataset, classifying more products correctly. similar results were reported before (pyo , 2010; kannan , 2011) but to the best of our knowledge, this is the first work that compares state-of-the-art text and image cnns on a real-world large-scale ecommerce dataset. what is the potential of multi-modality? we identified that for 7.8% of the products the image network made a correct prediction while the text network was wrong. this observation is encouraging since it implies that there is a relative big potential to harness via multi-modality. we find this large gap surprising since different neural networks applied to the same problem tend to make the same mistakes (szegedy , 2013). unification techniques for multi-modal problems typically use the last hidden layer of each network as features (frome , 2013; lynch , 2015; pyo , 2010). we therefore decided to visualize the activations of this layer using a tsne map (maaten & hinton, 2008). figure 3, depicts such a map for the activations of the text model (the image model yielded similar results). in particular,
we were looking for regions in the tsne map where the image predictions are correct and the text is wrong (figure 3, green). finding such a region will imply that a policy network can learn good decision boundaries. however, we can see that there are no well-defined regions in the tsne maps where the image network is correct and the title is wrong (green), thus implying that it might be hard to identify these products using the activations of the last layers.our error analysis experiment highlights the potential of merging image and text. still, we found it hard to achieve the upper bound provided by the error analysis in practice. we now describe the policies that managed to achieve performance boost in top-1 accuracy % over the text and image networks, and then provide discussion on other approaches that we tried but didn’t work.
decision-level fusion: we trained policies from different data sources (e.g., title, image, and each cnn class probabilities), using different architectures and different hyperparameters. looking at table 1, we can see that the best policies were trained using the class probabilities (the softmax probabilities) of the image and text cnns as inputs. the amount of class probabilities that were used (top-1, top-3 or all) did not have a significant effect on the results, indicating that the top-1 probability contains enough information to learn good policies. this result makes sense since the top-1 probability measures the confidence of the network in making a prediction. still, the top-3 probabilities performed slightly better, indicating that the difference between the top probabilities may also matter. we can also see that the 2-layer architecture outperformed the 1-layer, indicating that a linear policy is too simple, and deeper models can yield better results. last, the cost function positive coefficient q had a big impact on the results. we can see that for q = 1, the policy network is more accurate in its prediction however it achieves worse results on shelf classification. for q = 5 we get the best results, while higher values of q (e.g., 7 or 10) resulted in inaccurate policies that did not perform well in practice.
while it may not seem surprising that combining text and image will improve accuracy, in practice we found it extremely hard to leverage this potential. to the best of our knowledge, this is the first work that demonstrates a direct performance improvement on top-1 classification accuracy from using images and text on a large-scale classification problem. we experimented with pre-defined policies that do not learn from the data. specifically, we tried to average the logits, following (krizhevsky , 2012; simonyan & zisserman, 2014), and to choose the network with the maximal confidence following (poria , 2016). both of these experiments yielded significantly worse results, probably, since the text network is much more accurate than the image one (table 1). we also tried to learn policies from the text and/or the image input, using a policy network which is either a text cnn, a vgg network or a combination. however, all of these experiments resulted in policies that overfit the data and performed worse than the title model on the test data (table 1). we also experimented with early stopping criteria, various regularization methods (dropout, l1, l2) and reduced model size but none could make the policy network generalize.
feature-level fusion: training a cnn end-to-end can be tricky. for example, each input source has its own specific architecture, with specific learning rate and optimization algorithm. we experimented with training the network end-to-end, but also with first training each part separately and then learning the concatenated parts. we tried different unification approaches such as gating functions (srivastava , 2015), cross products and a different number of fully connected layers after the concatenation. these experiments resulted in models that were inferior to the text model. while this may seem surprising, the only successful feature level fusion that we are aware of (frome , 2013), was not able to gain accuracy improvement on top-1 accuracy.in this work, we investigated a multi-modal multi-class multi-label product classification problem and presented results on a challenging real-world dataset that we collected from walmart.com. we discovered that the text network outperforms the image network on our dataset, and observed a big potential of fusing text and image inputs. finally, we suggested a multi-modal decision-level fusion approach that leverages state-of-the-art results from image and text classification and forges them into a multi-modal architecture that outperforms both.
state-of-the-art image cnns are much larger than text cnns, and take more time to train and to run. thus, extracting image features during run time, or getting the image network predictions may be prohibitively expensive. in this context, an interesting observation is that feature level fusion methods require using the image signal for each product, while decision level fusion methods require using the image network selectively making them more appealing. moreover, our experiments suggest that decision-level fusion performs better than feature-level fusion in practice.
finally, we were only able to realize a fraction of the potential of multi-modality. in the future, we plan to investigate deeper policy networks and more sophisticated measures of confidence. we also plan to investigate ensembles of image networks (krizhevsky , 2012) and text networks (pyo , 2010). we believe that the insights from training policy networks will eventually lead us to train end to end differential multi-modal networks.",0
673.pdf.json,HIERARCHICAL MEMORY NETWORKS,"until recently, traditional machine learning approaches for challenging tasks such as image captioning, object detection, or machine translation have consisted in complex pipelines of algorithms, each being separately tuned for better performance. with the recent success of neural networks and deep learning research, it has now become possible to train a single model end-to-end, using backpropagation. such end-to-end systems often outperform traditional approaches, since the entire model is directly optimized with respect to the final task at hand. however, simple encode-decode style neural networks often underperform on knowledge-based reasoning tasks like question-answering or dialog systems. indeed, in such cases it is nearly impossible for regular neural networks to store all the necessary knowledge in their parameters.
neural networks with memory (graves , 2014; weston , 2015b) can deal with knowledge bases by having an external memory component which can be used to explicitly store knowledge. the memory is accessed by reader and writer functions, which are both made differentiable so that the entire architecture (neural network, reader, writer and memory components) can be trained end-to-end using backpropagation. memory-based architectures can also be considered as generalizations of rnns and lstms, where the memory is analogous to recurrent hidden states. however they are much richer in structure and can handle very long-term dependencies because once a vector (i.e., a memory) is stored, it is copied from time step to time step and can thus stay there for a very long time (and gradients correspondingly flow back time unhampered).
there exists several variants of neural networks with a memory component: memory networks (weston , 2015b), neural turing machines (ntm) (graves , 2014), dynamic memory net∗corresponding author: apsarathchandar@gmail.com
works (dmn) (kumar , 2015). they all share five major components: memory, input module, reader, writer, and output module.
memory: the memory is an array of cells, each capable of storing a vector. the memory is often initialized with external data (e.g. a database of facts), by filling in its cells with a pre-trained vector representations of that data.
input module: the input module is to compute a representation of the input that can be used by other modules.
writer: the writer takes the input representation and updates the memory based on it. the writer can be as simple as filling the slots in the memory with input vectors in a sequential way (as often done in memory networks). if the memory is bounded, instead of sequential writing, the writer has to decide where to write and when to rewrite cells (as often done in ntms).
reader: given an input and the current state of the memory, the reader retrieves content from the memory, which will then be used by an output module. this often requires comparing the input’s representation or a function of the recurrent state with memory cells using some scoring function such as a dot product.
output module: given the content retrieved by the reader, the output module generates a prediction, which often takes the form of a conditional distribution over multiple labels for the output.
for the rest of the paper, we will use the name memory network to describe any model which has any form of these five components. we would like to highlight that all the components except the memory are learnable. depending on the application, any of these components can also be fixed. in this paper, we will focus on the situation where a network does not write and only reads from the memory.
in this paper, we focus on the application of memory networks to large-scale tasks. specifically, we focus on large scale factoid question answering. for this problem, given a large set of facts and a natural language question, the goal of the system is to answer the question by retrieving the supporting fact for that question, from which the answer can be derived. application of memory networks to this task has been studied by bordes  (2015). however, bordes  (2015) depended on keyword based heuristics to filter the facts to a smaller set which is manageable for training. however heuristics are invariably dataset dependent and we are interested in a more general solution which can be used when the facts are of any structure. one can design soft attention retrieval mechanisms, where a convex combination of all the cells is retrieved or design hard attention retrieval mechanisms where one or few cells from the memory are retrieved. soft attention is achieved by using softmax over the memory which makes the reader differentiable and hence learning can be done using gradient descent. hard attention is achieved by using methods like reinforce (williams, 1992), which provides a noisy gradient estimate when discrete stochastic decisions are made by a model.
both soft attention and hard attention have limitations. as the size of the memory grows, soft attention using softmax weighting is not scalable. it is computationally very expensive, since its complexity is linear in the size of the memory. also, at initialization, gradients are dispersed so much that it can reduce the effectiveness of gradient descent. these problems can be alleviated by a hard attention mechanism, for which the training method of choice is reinforce. however, reinforce can be brittle due to its high variance and existing variance reduction techniques are complex. thus, it is rarely used in memory networks (even in cases of a small memory).
in this paper, we propose a new memory selection mechanism based on maximum inner product search (mips) which is both scalable and easy to train. this can be considered as a hybrid of soft and hard attention mechanisms. the key idea is to structure the memory in a hierarchical way such that it is easy to perform mips, hence the name hierarchical memory network (hmn). hmns are scalable at both training and inference time. the main contributions of the paper are as follows:
• we explore hierarchical memory networks, where the memory is organized in a hierarchical fashion, which allows the reader to efficiently access only a subset of the memory.
• while there are several ways to decide which subset to access, we propose to pose memory access as a maximum inner product search (mips) problem.
• we empirically show that exact mips-based algorithms not only enjoy similar convergence as soft attention models, but can even improve the performance of the memory network. • since exact mips is as computationally expensive as a full soft attention model, we propose
to train the memory networks using approximate mips techniques for scalable memory access. • we empirically show that unlike exact mips, approximate mips algorithms provide a
speedup and scalability of training, though at the cost of some performance.in this section, we describe the proposed hierarchical memory network (hmn). in this paper, hmns only differ from regular memory networks in two of its components: the memory and the reader.
memory: instead of a flat array of cells for the memory structure, hmns leverages a hierarchical memory structure. memory cells are organized into groups and the groups can further be organized into higher level groups. the choice for the memory structure is tightly coupled with the choice of reader, which is essential for fast memory access. we consider three classes of approaches for the memory’s structure: hashing-based approaches, tree-based approaches, and clustering-based approaches. this is explained in detail in the next section.
reader: the reader in the hmn is different from the readers in flat memory networks. flat memorybased readers use either soft attention over the entire memory or hard attention that retrieves a single cell. while these mechanisms might work with small memories, with hmns we are more interested in achieving scalability towards very large memories. so instead, hmn readers use soft attention only over a selected subset of the memory. selecting memory subsets is guided by a maximum inner product search algorithm, which can exploit the hierarchical structure of the organized memory to retrieve the most relevant facts in sub-linear time. the mips-based reader is explained in more detail in the next section.
in hmns, the reader is thus trained to create mips queries such that it can retrieve a sufficient set of facts. while most of the standard applications of mips (ram & gray, 2012; bachrach , 2014; shrivastava & li, 2014) so far have focused on settings where both query vector and database (memory) vectors are precomputed and fixed, memory readers in hmns are learning to do mips by updating the input representation such that the result of mips retrieval contains the correct fact(s).  memory reader with k-mips attention
in this section, we describe how the hmn memory reader uses maximum inner product search (mips) during learning and inference.
we begin with a formal definition of k-mips. given a set of points x = {x1, . . . , xn} and a query vector q, our goal is to find
argmax (k) i∈x q >xi (1)
where the argmax(k) returns the indices of the top-k maximum values. in the case of hmns, x corresponds to the memory and q corresponds to the vector computed by the input module.
a simple but inefficient solution for k-mips involves a linear search over the cells in memory by performing the dot product of q with all the memory cells. while this will return the exact result for k-mips, it is too costly to perform when we deal with a large-scale memory. however, in many practical applications, it is often sufficient to have an approximate result for k-mips, trading speed-up at the cost of the accuracy. there exist several approximate k-mips solutions in the literature (shrivastava & li, 2014; 2015; bachrach , 2014; neyshabur & srebro, 2015).
all the approximate k-mips solutions add a form of hierarchical structure to the memory and visit only a subset of the memory cells to find the maximum inner product for a given query. hashingbased approaches (shrivastava & li, 2014; 2015; neyshabur & srebro, 2015) hash cells into multiple bins, and given a query they search for k-mips cell vectors only in bins that are close to the bin
associated with the query. tree-based approaches (ram & gray, 2012; bachrach , 2014) create search trees with cells in the leaves of the tree. given a query, a path in the tree is followed and mips is performed only for the leaf for the chosen path. clustering-based approaches (auvolat , 2015) cluster cells into multiple clusters (or a hierarchy of clusters) and given a query, they perform mips on the centroids of the top few clusters. we refer the readers to (auvolat , 2015) for an extensive comparison of various state-of-the-art approaches for approximate k-mips.
our proposal is to exploit this rich approximate k-mips literature to achieve scalable training and inference in hmns. instead of filtering the memory with heuristics, we propose to organize the memory based on approximate k-mips algorithms and then train the reader to learn to perform mips. specifically, consider the following softmax over the memory which the reader has to perform for every reading step to retrieve a set of relevant candidates:
rout = softmax(h(q)m t ) (2)
where h(q) ∈ rd is the representation of the query, m ∈ rn×d is the memory with n being the total number of cells in the memory. we propose to replace this softmax with softmax(k) which is defined as follows:
c = argmax(k) h(q)mt (3)
rout = softmax (k)(h(q)mt ) = softmax(h(q)m [c]t ) (4)
where c is the indices of top-k mip candidate cells and m [c] is a sub-matrix of m where the rows are indexed by c.
one advantage of using the softmax(k) is that it naturally focuses on cells that would normally receive the strongest gradients during learning. that is, in a full softmax, the gradients are otherwise more dispersed across cells, given the large number of cells and despite many contributing a small gradient. as our experiments will show, this results in slower training.
one problematic situation when learning with the softmax(k) is when we are at the initial stages of training and the k-mips reader is not including the correct fact candidate. to avoid this issue, we always include the correct candidate to the top-k candidates retrieved by the k-mips algorithm, effectively performing a fully supervised form of learning.
during training, the reader is updated by backpropagation from the output module, through the subset of memory cells. additionally, the log-likelihood of the correct fact computed using ksoftmax is also maximized. this second supervision helps the reader learn to modify the query such that the maximum inner product of the query with respect to the memory will yield the correct supporting fact in the top k candidate set.
until now, we described the exact k-mips-based learning framework, which still requires a linear look-up over all memory cells and would be prohibitive for large-scale memories. in such scenarios, we can replace the exact k-mips in the training procedure with the approximate k-mips. this is achieved by deploying a suitable memory hierarchical structure. the same approximate k-mipsbased reader can be used during inference stage as well. of course, approximate k-mips algorithms might not return the exact mips candidates and will likely to hurt performance, but at the benefit of achieving scalability.
while the memory representation is fixed in this paper, updating the memory along with the query representation should improve the likelihood of choosing the correct fact. however, updating the memory will reduce the precision of the approximate k-mips algorithms, since all of them assume that the vectors in the memory are static. designing efficient dynamic k-mips should improve the performance of hmns even further, a challenge that we hope to address in future work. .1 reader with clustering-based approximate k-mips
clustering-based approximate k-mips was proposed in (auvolat , 2015) and it has been shown to outperform various other state-of-the-art data dependent and data independent approximate kmips approaches for inference tasks. as we will show in the experiments section, clustering-based mips also performs better when used to training hmns. hence, we focus our presentation on the clustering-based approach and propose changes that were found to be helpful for learning hmns.
following most of the other approximate k-mips algorithms, auvolat  (2015) convert mips to maximum cosine similarity search (mcss) problem:
argmax (k) i∈x qtxi ||q|| ||xi|| = argmax (k) i∈x qtxi ||xi||
(5)
when all the data vectors xi have the same norm, then mcss is equivalent to mips. however, it is often restrictive to have this additional constraint. instead, auvolat  (2015) append additional dimensions to both query and data vectors to convert mips to mcss. in hmn terminology, this would correspond to adding a few more dimensions to the memory cells and input representations.
the algorithm introduces two hyper-parameters, u < 1 and m ∈ n∗. the first step is to scale all the vectors in the memory by the same factor, such that maxi ||xi||2 = u . we then apply two mappings, p and q, on the memory cells and on the input vector, respectively. these two mappings simply concatenate m new components to the vectors and make the norms of the data points all roughly the same (shrivastava & li, 2015). the mappings are defined as follows:
p (x) = [x, 1/2− ||x||22, 1/2− ||x||42, . . . , 1/2− ||x||2 m  ] (6) q(x) = [x, 0, 0, . . . , 0] (7)
we thus have the following approximation of mips by mcss for any query vector q:
argmax (k) i q >xi ' argmax(k)i q(q)>p (xi)
||q(q)||2 · ||p (xi)||2 (8)
once we convert mips to mcss, we can use spherical k-means (zhong, 2005) or its hierarchical version to approximate and speedup the cosine similarity search. once the memory is clustered, then every read operation requires only k dot-products, where k is the number of cluster centroids.
since this is an approximation, it is error-prone. as we are using this approximation for the learning process, this introduces some bias in gradients, which can affect the overall performance of hmn. to alleviate this bias, we propose three simple strategies.
• instead of using only the top-k candidates for a single read query, we also add top-k candidates retrieved for every other read query in the mini-batch. this serves two purposes. first, we can do efficient matrix multiplications by leveraging gpus since all the k-softmax in a minibatch are over the same set of elements. second, this also helps to decrease the bias introduced by the approximation error.
• for every read access, instead of only using the top few clusters which has a maximum product with the read query, we also sample some clusters from the rest, based on a probability distribution log-proportional to the dot product with the cluster centroids. this also decreases the bias.
• we can also sample random blocks of memory and add it to top-k candidates.
we empirically investigate the effect of these variations in section 5.5.memory networks have been introduced in (weston , 2015b) and have been so far applied to comprehension-based question answering (weston , 2015a; sukhbaatar , 2015), large scale question answering (bordes , 2015) and dialogue systems (dodge , 2015). while (weston , 2015b) considered supervised memory networks in which the correct supporting fact is given during the training stage, (sukhbaatar , 2015) introduced semi-supervised memory networks that can learn the supporting fact by itself. (kumar , 2015; xiong , 2016) introduced dynamic memory networks (dmns) which can be considered as a memory network with two types of memory: a regular large memory and an episodic memory. another related class of model is the neural turing machine (graves , 2014), which uses softmax-based soft attention. later (zaremba & sutskever, 2015) extended ntm to hard attention using reinforcement learning. (dodge , 2015; bordes , 2015) alleviate the problem of the scalability of soft attention by having
an initial keyword based filtering stage, which reduces the number of facts being considered. our work generalizes this filtering by using mips for filtering. this is desirable because mips can be applied for any modality of data or even when there is no overlap between the words in a question and the words in facts.
the softmax arises in various situations and most relevant to this work are scaling methods for large vocabulary neural language modeling. in neural language modeling, the final layer is a softmax distribution over the next word and there exist several approaches to achieve scalability. (morin & bengio, 2005) proposes a hierarchical softmax based on prior clustering of the words into a binary, or more generally n-ary tree, that serves as a fixed structure for the learning process of the model. the complexity of training is reduced from o(n) to o(log n). due to its clustering and tree structure, it resembles the clustering-based mips techniques we explore in this paper. however, the approaches differ at a fundamental level. hierarchical softmax defines the probability of a leaf node as the product of all the probabilities computed by all the intermediate softmaxes on the way to that leaf node. by contrast, an approximate mips search imposes no such constraining structure on the probabilistic model, and is better thought as efficiently searching for top winners of what amounts to be a large ordinary flat softmax. other methods such as noice constrastive estimation (mnih & gregor, 2014) and negative sampling (mikolov , 2013) avoid an expensive normalization constant by sampling negative samples from some marginal distribution. by contrast, our approach approximates the softmax by explicitly including in its negative samples candidates that likely would have a large softmax value. jean  (2015) introduces an importance sampling approach that considers all the words in a mini-batch as the candidate set. this in general might also not include the mips candidates with highest softmax values.
(spring & shrivastava, 2016) is the only work that we know of, proposing to use mips during learning. it proposes hashing-based mips to sort the hidden layer activations and reduce the computation in every layer. however, a small scale application was considered and data-independent methods like hashing will likely suffer as dimensionality increases. rae  (2016) have also independently proposed a model called sam to use approximate search methods for memory access in ntm-like architectures. however, our motivation is different. while rae  (2016) focus on architectures where the memory is written by the controller itself, we focus on handling memory access to large external knowledge bases. while both the models fix the memory access mechanism (hmn uses mips and sam uses nns), our controller works in a much more constrained setting. moreover, our experiments suggest that the performance of sam could be improved using a clustering-based approach as in our work, instead of tree/hash-based approaches for memory search used by sam.in this section, we report experiments on factoid question answering using hierarchical memory networks. specifically, we use the simplequestions dataset bordes  (2015). the aim of these experiments is not to achieve state-of-the-art results on this dataset. rather, we aim to propose and analyze various approaches to make memory networks more scalable and explore the achieved tradeoffs between speed and accuracy.we use simplequestions (bordes , 2015) which is a large scale factoid question answering dataset. simplequestions consists of 108,442 natural language questions, each paired with a corresponding fact from freebase. each fact is a triple (subject,relation,object) and the answer to the question is always the object. the dataset is divided into training (75910), validation (10845), and test (21687) sets. unlike bordes  (2015) who additionally considered fb2m (10m facts) or fb5m (12m facts) with keyword-based heuristics for filtering most of the facts for each question, we only use simplequestions, with no keyword-based heuristics. this allows us to do a direct comparison with the full softmax approach in a reasonable amount of time. moreover, we would like to highlight that for this dataset, keyword-based filtering is a very efficient heuristic since all questions have an appropriate source entity with a matching word. nevertheless, our goal is to design a general purpose architecture without such strong assumptions on the nature of the data.let vq be the vocabulary of all words in the natural language questions. let wq be a |vq| ∗ m matrix where each row is some m dimensional embedding for a word in the question vocabulary. this matrix is initialized with random values and learned during training. given any question, we represent it with a bag-of-words representation by summing the vector representation of each word in the question. let q = {wi}pi=1,
h(q) = p∑ i=1 wq[wi]
then, to find the relevant fact from the memory m, we call the k-mips-based reader module with h(q) as the query. this uses equation 3 and 4 to compute the output of the reader rout. the reader is trained by minimizing the negative log likelihood (nll) of the correct fact.
jθ = n∑ i=1 −log(rout[fi])
where fi is the index of the correct fact in wm. we are fixing the memory embeddings to the transe (bordes , 2013) embeddings and learning only the question embeddings.
this model is simpler than the one reported in (bordes , 2015) so that it is esay to analyze the effect of various memory reading strategies.we trained the model with the adam optimizer (kingma & ba, 2014), with a fixed learning rate of 0.001. we used mini-batches of size 128. we used 200 dimensional embeddings for the transe entities, yielding 600 dimensional embeddings for facts by concatenating the embeddings of the subject, relation and object. we also experimented with summing the entities in the triple instead of concatenating, but we found that it was difficult for the model to differentiate facts this way. the only learnable parameters by the hmn model are the question word embeddings. the entity distribution in simplequestions is extremely sparse and hence, following bordes  (2015), we also add artificial questions for all the facts for which we do not have natural language questions. unlike bordes  (2015), we do not add any other additional tasks like paraphrase detection to the model, mainly to study the effect of the reader. we stopped training for all the models when the validation accuracy consistently decreased for 3 epochs. .4 exact k-mips improves accuracy
in this section, we compare the performance of the full soft attention reader and exact k-mips attention readers. our goal is to verify that k-mips attention is in fact a valid and useful attention mechanism and see how it fares when compared to full soft attention. for k-mips attention, we tried k ∈ 10, 50, 100, 1000. we would like to emphasize that, at training time, along with k candidates for a particular question, we also add the k-candidates for each question in the minibatch. so the exact size of the softmax layer would be higer than k during training. in table 1, we report the test performance of memory networks using the soft attention reader and k-mips attention reader. we also report the average softmax size during training. from the table, it is clear that the k-mips attention readers improve the performance of the network compared to soft attention reader. in fact, smaller the value of k is, better the performance. this result suggests that it is better to use a k-mips layer instead of softmax layer whenever possible. it is interesting to see that the convergence of the model is not slowed down due to this change in softmax computation (as shown in figure 1).
this experiment confirms the usefulness of k-mips attention. however, exact k-mips has the same complexity as a full softmax. hence, to scale up the training, we need more efficient forms of k-mips attention, which is the focus of next experiment.
model test acc. avg. softmax size full-softmax 59.5 108442 0-mips 62.2 1290 50-mips 61.2 6180 -mips 60.6 11928 1000-mips 59.6 70941 clustering 51.5 20006 pca-tree 32.4 21108 wta-hash 40.2 20008
table 1: accuracy in sq test-set and average size of memory used. 10-softmax has high performance while using only smaller amount of memory. .5 approximate k-mips based learning
as mentioned previously, designing faster algorithms for k-mips is an active area of research. auvolat  (2015) compared several state-of-the-art data-dependent and data-independent methods for faster approximate k-mips and it was found that clustering-based mips performs significantly better than other approaches. however the focus of the comparison was on performance during the inference stage. in hmns, k-mips must be used at both training stage and inference stages. to verify if the same trend can been seen during learning stage as well, we compared three different approaches:
clustering: this was explained in detail in section 3.
wta-hash: winner takes all hashing (vijayanarasimhan , 2014) is a hashing-based k-mips algorithm which also converts mips to mcss by augmenting additional dimensions to the vectors. this method used n hash functions and each hash function does p different random permutations of the vector. then the prefix constituted by the first k elements of each permuted vector is used to construct the hash for the vector.
pca-tree: pca-tree (bachrach , 2014) is the state-of-the-art tree-based method, which converts mips to nns by vector augmentation. it uses the principal components of the data to construct a balanced binary tree with data residing in the leaves.
for a fair comparison, we varied the hyper-parameters of each algorithm in such a way that the average speedup is approximately the same. table 1 shows the performance of all three methods, compared to a full softmax. from the table, it is clear that the clustering-based method performs significantly better than the other two methods. however, performances are lower when compared to the performance of the full softmax.
as a next experiment, we analyze various the strategies proposed in section 3.1 to reduce the approximation bias of clustering-based k-mips:
top-k: this strategy picks the vectors in the top k clusters as candidates.
sample-k: this strategy samples k clusters, without replacement, based on a probability distribution based on the dot product of the query with the cluster centroids. when combined with the top-k strategy, we ignore clusters selected by the top-k strategy for sampling.
rand-block: this strategy divides the memory into several blocks and uniformly samples a random block as candidate.
we experimented with 1000 clusters and 2000 clusters. while comparing various training strategies, we made sure that the effective speedup is approximately the same. memory access to facts per query for all the models is approximately 20,000, hence yielding a 5x speedup.
results are given in table 2. we observe that the best approach is to combine the top-k and samplek strategies, with rand-block not being beneficial. interestingly, the worst performances correspond to cases where the sample-k strategy is ignored.in this paper, we proposed a hierarchical memory network that exploits k-mips for its attentionbased reader. unlike soft attention readers, k-mips attention reader is easily scalable to larger memories. this is achieved by organizing the memory in a hierarchical way. experiments on the simplequestions dataset demonstrate that exact k-mips attention is better than soft attention. however, existing state-of-the-art approximate k-mips techniques provide a speedup at the cost of some accuracy. future research will investigate designing efficient dynamic k-mips algorithms, where the memory can be dynamically updated during training. this should reduce the approximation bias and hence improve the overall performance.",0
682.pdf.json,,"in this paper, we are interested in deep generative models. one may naively classify these models into a family of directed deep generative models trainable by back-propagation (e.g., kingma & welling, 2013; goodfellow , 2014), and deep energy-based models, such as deep belief network (hinton , 2006) and deep boltzmann machine (salakhutdinov & hinton, 2009). the building block of deep energy-based models is a bipartite graphical model called restricted boltzmann machine (rbm). the rbm model consists of two layers, visible and hidden. the resulting graphical model which can account for higher-order interactions of the visible units (visible layer) using the hidden units (hidden layer). it also makes the inference easier that there are no interactions between the variables in each layer.
the conventional rbm uses bernoulli units for both the hidden and visible units (smolensky, 1986). one extension is using gaussian visible units to model general natural images (freund & haussler, 1994). for hidden units, we can also generalize bernoulli units to the exponential family (welling , 2004; ravanbakhsh , 2016).
nair & hinton (2010) propose a variation using rectified linear unit (relu) for the hidden layer with a heuristic sampling procedure, which has promising performance in terms of reconstruction error and classification accuracy. unfortunately, due to its lack of strict monotonicity, relu rbm does not fit within the framework of exponential family rbms (ravanbakhsh , 2016). instead we study leaky-relu rbm (leaky rbm) in this work and address two important issues i) a better training (sampling) algorithm for relu rbm and; ii) a better quantification of leaky rbm –i.e., evaluation of its performance in terms of likelihood.
we study some of the fundamental properties of leaky rbm, including its joint and marginal distributions (section 2). by analyzing these distributions, we show that the leaky rbm is a union of
truncated gaussian distributions. in this paper, we show that training leaky rbm involves underlying positive definite constraints. because of this, the training can diverge if these constrains are not satisfied. this is an issue that was previously ignored in relu rbm, as it was mainly used for pre-training rather than generative modeling.
our contribution in this paper is three-fold: i) we systematically identify and address model constraints in leaky rbm (section 3); ii) for the training of leaky rbm, we propose a meta algorithm for sampling, which anneals leakiness during the gibbs sampling procedure (section 3) and empirically show that it can boost contrastive divergence with faster mixing (section 5); iii) we demonstrate the power of the proposed sampling algorithm on estimating the partition function. in particular, comparison on several benchmark datasets shows that the proposed method outperforms the conventional ais (salakhutdinov & murray, 2008) in terms of efficiency and accuracy (section 4). moreover, we provide an incentive for using leaky rbm by showing that the leaky relu hidden units perform better than the bernoulli units in terms of the model log-likelihood (section 4).the boltzmann distribution is defined as p(x) = e−e(x)/z where z = ∑ x e −e(x) is the partition function. restricted boltzmann machine (rbm) is a boltzmann distribution with a bipartite structure it is also the building block for many deep models (e.g., hinton , 2006; salakhutdinov & hinton, 2009; lee , 2009), which are widely used in numerous applications (bengio, 2009). the conventional bernoulli rbm, models the joint probability p(v, h) for the visible units v ∈ [0, 1]i and the hidden units h ∈ [0, 1]j as p(v, h) ∝ exp(−e(v, h)), where e(v, h) = a>v − v>wh + b>h. the parameters are a ∈ ri , b ∈ rj and w ∈ ri×j . we can derive the conditional probabilities as
p(vi = 1|h) = σ  j∑ j=1 wijhj + ai  and p(hj = 1|v) = σ( i∑ i=1 wijvi + bj ) , (1)
where σ(x) = (1 + e−x)−1 is the sigmoid function.
one extension of bernoulli rbm is replacing the binary visible units by linear units v ∈ ri with independent gaussian noise. the energy function in this case is given by
e(v, h) = i∑ i=1 (vi − ai)2 2σ2i − i∑ i=1 j∑ j=1 vi σi wijhj + b >h.
to simplify the notation, we assume a normalized data so that ai and σi is no longer required. the energy function is accordingly simplified to e(v, h) = ‖v‖ 2  − v >wh + b>h (note that the
elimination does not influence the discussion and one can easily extend all the results in this paper to the model that includes ai and σi.).
the conditional distributions are as follows:
p(vi|h) = n  j∑ j=1 wijhj , 1  and p(hj = 1|v) = σ( i∑ i=1 wijvi + bj ) , (2)
where n (µ, v ) is a gaussian distribution with mean µ and variance v . to simplify the notation, in the following we define ηj = ∑i i=1wijvi + bj – that is ηj is the input to the j
th hidden layer neuron and similarly define νi = ∑j j=1wijhj + ai. using this notation the conditionals in the (2) are p(vi|νi) = n (νi, 1) and p(hj = 1|ηj) = σ(ηj).from (1) and (2), we can see that the mean of the p(hj |v) is the nonlinearity of the hidden unit at ηj = ∑i i=1wijvi + bj – e.g., mean of the bernoulli unit is the sigmoid function. from this perspective, we can extend the sigmoid function to other functions and thus allow rbm to have more expressive power (ravanbakhsh , 2016). in particular, it would be interesting to use rectified linear unit (relu) nonlinearity, f(ηj) = max(0, ηj), for generative modeling.
nair & hinton (2010) use an rbm with visible gaussian unit and relu hidden activation functions for pretraining. they suggest sampling from max(0, ηj+n (0, σ(ηj)) for conditional sampling from the hidden units (compare to (2)). however, this sampling heuristic does not suggest the parametric form of the joint relu-gaussian distribution. this also means we cannot evaluate it using methods such as annealed importance sampling that require access to this parametric form. in fact, only strictly monotonic activation functions can derive feasible joint and conditional distributions in the exponential familly rbm and relu is not strictly monotonic ravanbakhsh  (2016). similar activation functions that are monotonic are softplus, f(ηj) = log(1 + eηj ) and leaky relu (maas , 2013), defined as f(ηj) = max(cηj , ηj), where c ∈ (0, 1) is the leakiness parameter. in contrast to the relu rbm the joint parametric form of these two distributions are available. however, the energy (logarithm of the joint probability) in the case of softplus activation function contains a polylogarithmic term that requires evaluation of an infinite series; see table 1 in ravanbakhsh  (2016). for this reason, here we focus on leaky-relu activation function.
by ravanbakhsh  (2016), the conditional probability of the activation, assuming the nonlinearity f(ηj), is generally defined as p(hj |v) = exp (−df (ηj‖hj) + g(hj)), where df (ηj‖hj) is the bregman divergence associated with f, and g(hj) is the base (or carrier) measure in the exponential family which ensures the distribution is well-defined. the bergman divergence, for strictly monotonic function f , is df (ηj‖hj) = −ηjhj + f (ηj) + f ∗(hj), where f with ddηj f (ηj) = f(ηj) is the anti-derivative (integral) of f and f ∗ is the anti-derivative of f−1 (i.e., f−1(f(η)) = η); note that due to the strict monotonicity of f , f−1 is well-defined, and f and f ∗ are commonly referred to as conjugate duals.
considering the leaky relu activation function f(η) = max(cη, η), using this formalism, the conditional distributions of hidden units in the leaky rbm simplifies to (see appendix a.1 for details)
p(hj |v) = { n (ηj , 1), if ηj > 0 n (cηj , c), if ηj ≤ 0.
(3)
since the visible units uses the identity function, the corresponding conditional distribution is a gaussian1
p(vi|h) = n  j∑ j=1 wijhj , 1  , (4) having these two conditional distributions is enough for training a leaky rbm model using contrastive divergence (hinton, 2002) or some other alternatives (e.g., tieleman, 2008; tieleman & hinton, 2009).given the conditional distributions p(v|h) and p(h|v), the joint distribution p(v, h) from the general treatment for mrf model is (yang , 2012; ravanbakhsh , 2016)
p(v, h) ∝ exp v>wh− i∑ i=1 (f̃ ∗(vi) + g(vi))− j∑ j=1 (f ∗(hj) + g(hj))  , (5) where f̃ ∗(vi) and f ∗(hj) are anti-derivatives of the inverses of the activation functions f̃(vi) and f(hj) for visible units vi and hidden units hj , respectively (see section 2.1). assuming f(ηj) = max(cηj , c) and f̃(νi) = νi in leaky-relu rbm, the joint distribution above becomes (see appendix a.2 for details)
p(v, h) ∝ exp v>wh− ‖v‖2 2 − ∑ ηj>0 ( h2j 2 + log √ 2π ) − ∑ ηj≤0 ( h2j 2c + log √ 2cπ ) + b>h  , 1which can also be written as p(vi|h) = exp ( −df̃ (νi‖vi) + g(vi) ) , where νi = ∑ j=1wijhj and
f̃(νi) = νi and df̃ (νi‖vi) = (νi − vi) 2 and g(vi) = − log
√ 2π.
and the corresponding visible marginal distribution is
p(v) ∝ exp −1 2 v> i −∑ ηj>0 wjw > j − c ∑ ηj≤0 wjw > j  v + ∑ ηj>0 bjw > j v + c ∑ ηj≤0 bjw > j v  . (6)
where wj is the j-th column of w .from (6) we see that the marginal probability is determined by the affine constraints ηj > 0 or ηj ≤ 0 for all hidden units j. by combinatorics, these constraints divide ri (the visible domain) into at most m = ∑i i=1 ( j i ) convex regions r1, · · ·rm . an example with i = 2 and j = 3 is shown in figure 1. if i > j , then we have at most 2j regions.
we discuss the two types of these regions. for bounded regions, such as r1 in figure 1, the integration of (6) is also bounded, which results in a valid distribution. before we discuss the unbounded cases, we define ω = i − ∑j j=1 αjwjw > j , where αj = 1ηj>0 + c1ηj≤0. for the unbounded region, if ω ∈ ri×i is a positive definite (pd) matrix, then the probability density is proportional to a multivariate gaussian distribution with mean µ = ω−1 (∑j j=1 αjbjwj ) and precision matrix ω (covariance matrix ω−1) but over an affine-constrained region. therefore, the distribution of each unbounded region can be treated as a truncated gaussian distribution. the marginal distrubution can be treated as a union of truncated gaussain distribution. note that leaky rbm is different from su  (2017), which use single truncated gaussian distribution to model joint (conditional) distributions and require approximated and more complicated sampling algorithms for truncated gaussian distribution, while leaky rbm only requires to sample from gaussian distributions.
on the other hand, if ω is not pd, and the region ri contains the eigenvectors with negative eigenvalues of ω, the integration of (6) over ri is divergent (infinite), which can not result in a valid probability distribution. in practice, with this type of parameter, when we do gibbs sampling on the conditional distributions, the sampling will diverge. however, it is unfeasible to check exponentially many regions for each gradient update. theorem 1. if i −ww> is positive definite, then i − ∑ j αjwjw > j is also positive definite, for all αj ∈ [0, 1].
the proof is shown in appendix 1. from theorem 1 we can see that if the constraint i −ww> is pd, then one can guarantee that the distribution of every region is a valid truncated gaussian distribution. therefore, we introduce the following projection step for each w after the gradient update.
argmin w̃
‖w − w̃‖2f
s.t. i − w̃w̃> 0 (7)
theorem 2. the above projection step (7) can be done by shrinking the singular values to be less than 1.
the proof is shown in appendix c. the training algorithm of the leaky rbm is shown in algorithm 1. by using the projection step (7), we could treat the leaky rbm as the union of truncated gaussian distributions, which uses weight vectors to divide the space of visible units into several regions and use a truncated gaussian distribution to model each region. note that the leaky rbm model is different from su  (2016), which uses a truncated gaussian distribution to model the conditional distribution p(h|v) instead of the marginal distribution. the empirical study about the divergent values and the necessity of the projection step is shown in appendix d. without the projection step, when we run gibbs sampling for several iterations from the model, the sampled values will diverge because the model does not have a valid marginal distribution p(v). it also implies that we cannot train leaky rbm with larger cd steps without projection, which would result in divergent gradients. the detailed discussion is shown in appendix d.
algorithm 1 training leaky rbm for t = 1, . . . , t do
estimate gradient gθ by cd or other algorithms with (13) and (4), where θ = {w,a, b}. θ(t) ← θ(t−1) + ηgθ. project w (t) by (7).
end forgibbs sampling is the core procedure for rbm, including training, inference, and estimating the partition function (fischer & igel, 2012; tieleman, 2008; salakhutdinov & murray, 2008). for every task, we start from randomly initializing v by an arbitrary distribution q, and iteratively sample from the conditional distributions. gibbs sampling guarantees the procedure result in the stationary distribution in the long run for any initialized distribution q. however, if q is close to the target distribution p, it can significantly shorten the number of iterations to achieve the stationary distribution. if we set the leakiness c to be 1, then (6) becomes a simple multivariate gaussian distribution n ( (i −ww>)−1wb, (i −ww>)−1 ) , which can be easily sampled without gibbs sampling. also, the projection step (7) guarantees it is a valid gaussian distribution. then we decrease the leakiness with a small , and use samples from the multivariate gaussian distribution when c = 1 as the initialization to do gibbs sampling. note that the distribution of each region is a truncated gaussian distribution. when we only decrease the leakiness with a small amount, the resulted distribution is a “similar” truncated gaussian distribution with more concentrated density. from this observation, we could expect the original multivariate gaussian distribution serves as a good initialization. the one-dimensional example is shown in figure 2. we then repeat this procedure until we reach the target leakiness. the algorithm can be seen as annealing the leakiness during the gibbs sampling procedure. the meta algorithm is shown in algorithm 2. next, we show the proposed sampling algorithm can help both the partition function estimation and the training of leaky rbm.
algorithm 2 meta algorithm for sampling from leaky rbm. sample v from n ( (i −ww>)−1wb, (i −ww>)−1 ) = (1− c)/t and c′ = 1 for t = 1, . . . , t do
decrease c′ = c′ − and perform gibbs sampling by using (13) and (4) with leakiness c′ end forit is known that estimating the partition function of rbm is intractable (salakhutdinov & murray, 2008). existing approaches, including salakhutdinov & murray (2008); grosse  (2013); liu  (2015); carlson  (2016) focus on using sampling to approximate the partition function of the conventional bernoulli rbm instead of the rbm with gaussian visible units and non-bernoulli hidden units. in this paper, we focus on extending the classic annealed importance sampling (ais) algorithm (salakhutdinov & murray, 2008) to leaky rbm.
assuming that we want to estimate the partition function z of p(v) with p(v) = p∗(v)/z and p∗(v) ∝ ∑ h exp(−e(v, h)), salakhutdinov & murray (2008) start from a initial distribution
p0(v) ∝ ∑ h exp(−e0(v, h)), where computing the partition z0 of p0(v) is tractable and we can draw samples from p0(v). they then use the “geometric path” to anneal the intermediate distribution as pk(v) ∝ p∗k(v) = ∑ h exp (−βke0(v, h)− (1− βk)e(v, h)), where they grid βk from 1 to 0. if we let β0 = 1, we can draw samples vk from pk(v) by using samples vk−1 from pk−1(v) for k ≥ 1 via gibbs sampling. the partition function is then estimated via z = z0m ∑m i=1 ω (i), where
ω(i) = p∗1(v (i) 0 )
p∗0(v (i) 0 )
p∗2(v (i) 1 ) p∗1(v (i) 1 ) · · · p∗k−1(v (i) k−2) p∗k−2(v (i) k−2) p∗k(v (i) k−1) p∗k−1(v (i) k−1) , and βk = 0.
salakhutdinov & murray (2008) use the initial distribution with independent visible units and without hidden units. we consider application of ais to the leaky-relu case with e0(v, h) = ‖v‖2 2 , which results in a multivariate gaussian distribution p0(v). compared with the meta algorithm shown in algorithm 2 which anneals between leakiness, ais anneals between energy functions.as we discussed in section 3.1, leaky rbm with j hidden units is a union of 2j truncated gaussian distributions. here we perform a study on the leaky rbm with a small number hidden units. since in this example the number of hidden units is small, we can integrate out all possible configurations of h. however, integrating a truncated gaussian distribution with general affine constraints does not have analytical solutions, and several approximations have been developed (e.g., pakman & paninski, 2014). to compare our results with the exact partition function, we consider a special case that has the following form:
p(v) ∝ exp −1 2 v> i −∑ ηj>0 wjw > j − c ∑ ηj≤0 wjw > j  v  . (8)
compared to (6), it is equivalent to the setting where b = 0. geometrically, everywj passes through the origin. we further put the additional constraint wi ⊥ wj ,∀i 6= j. therefore. we divide the whole space into 2j equally-sized regions. a three dimensional example is shown in figure 3. then the partition function of this special case has the analytical form
z = 1 j ∑ αj∈{1,c},∀j (2π)− i 2 ∣∣∣∣∣∣∣ i − j∑ j=1 αjwjw > j − 12 ∣∣∣∣∣∣∣ .
we randomly initialize w and use svd to make columns orthogonal. also, we scale ‖wj‖ to satisfy i −ww> 0. the leakiness parameter is set to be 0.01. for salakhutdinov & murray (2008) (ais-energy), we use 105 particles with 105 intermediate distributions. for the proposed method (ais-leaky), we use only 104 particles with 103 intermediate distributions. in this small problem we study the cases when the model has 5, 10, 20 and 30 hidden units and 3072 visible units. the true log partition function logz is shown in table 1 and the difference between logz and the estimates given by the two algorithms are shown in table 2.
from table 1, we observe that ais-leaky has significantly better and more stable estimations than ais-energy especially and this gap increases as we increase the number of hidden units. ais-leaky achieves this with orders magnitude reduced computation –e.g., here it uses ∼.1% of resources used by conventional ais. for example, when we increase j from 5 to 30, the bias (difference) of ais-leaky only increases from 0.02 to 0.13; however, the bias of ais-energy increases from 1.76 to 9.6. we further study the implicit connection between the proposed ais-leaky and ais-energy in appendix e, which shows ais-leaky is a special case of ais-energy under certain conditions.it is known that the reconstruction error is not a proper approximation of the likelihood (hinton, 2012). one commonly adopted way to compare generative models is to sample from the model, and visualize the images to check the quality. however, theis  (2016) show the better visualization does not imply better likelihood. also, the single layer model cannot adequately model the complicated natural images (the result for bernoulli-gaussian rbm has been shown in ranzato & hinton (2010)), which makes the visualization comparison difficult (appendix f has few visualization results).
fortunately, our accurate estimate of the partition function for leaky rbm can produce a reliable quantitative estimate of the representation power of leaky rbm. we compare the bernoulligaussian rbm2, which has bernoulli hidden units and gaussian visible units. we trained both models with cd-203 and momentum. for both model, we all used 500 hidden units. we initialized w by sampling from unif(0, 0.01), a = 0, b = 0 and σ = 1. the momentum parameter was 0.9 and the batch size was set to 100. we tuned the learning rate between 10−1 and 10−6. we studied two benchmark data sets, including cifar10 and svhn. the data was normalized to have zero mean and standard deviation of 1 for each pixel. the results of the log-likelihood are reported in table 3.
from table 3, leaky rbm outperforms bernoulli-gaussian rbm significantly. the unsatisfactory performance of bernoulli-gaussian rbm may be in part due to the optimization procedure. if we tune the decay schedule of the learning-rate for each dataset in an ad-hoc way, we observe the performance of bernoulli-gaussian rbm can be improved by ∼ 300 nats for both datasets. also, increasing cd-steps brings slight improvement. the other possibility is the bad mixing during the cd iterations. the advanced algorithms tieleman (2008); tieleman & hinton (2009) may help. although nair & hinton (2010) demonstrate the power of relu in terms of reconstruction error and classification accuracy, it does not imply its superior generative capability. our study confirms leaky rbm could have much better generative performance compared to bernoulli-gaussian rbm.in this section, we show the idea of annealing between leakiness benefit the mixing in gibbs sampling in other settings. a common procedure for comparison of sampling methods for rbm is through visualization. here, we are interested in more quantitative metrics and the practical benefits of improved sampling. for this, we consider optimization performance as the evaluation metric.
the gradient of the log-likelihood function l(θ|vdata) of general rbm models is
∂l(θ|vdata) ∂θ = eh|vdata
[ ∂e(v, h)
∂θ
] − ev,h [ ∂e(v, h)
∂θ
] . (9)
since the second expectation in (9) is usually intractable, different approximation algorithms are used (fischer & igel, 2012). our gpu implementation with gnumpy and cudamat can reproduce the results of http://www.cs.toronto.edu/ tang/code/gaussianrbm.m cd-n means that contrastive divergence was run for n steps
in this section, we compare two gradient approximation procedures. the baselines are the conventional contrastive divergence (cd) (hinton, 2002) and persistent contrastive divergence (tieleman, 2008) (pcd). the second method is using algorithm 2 (leaky) with the same number of mixing steps as cd. the experiment setup is the same as that of section 4.
the results are shown in figure 4. the proposed sampling procedure is slightly better than typical cd steps. the reason is we only anneals the leakiness for 20 steps. to get accurate estimation requires thousands of steps as shown in section 4 when we estimate the partition function. therefore, the estimated gradient is still inaccurate. however, it still outperforms the conventional cd algorithm. on the other hand, unlike the binary rbm case shown in tieleman (2008), pcd does not outperform cd with 20 mixing steps for leaky rbm.
the drawback of algorithm 2 is that sampling v from n ( (i −ww>)−1wb, (i −ww>)−1 ) requires computing mean, covariance and the cholesky decomposition of the covariance matrix in every iteration, which are computationally expensive. we study a mixture algorithm by combining cd and the idea of annealing leakiness. the mixture algorithm replaces the sampling from n ( (i −ww>)−1wb, (i −ww>)−1 ) with sampling from the empirical data distribution. the resulted mix algorithm is almost the same as cd algorithm while it anneals the leakiness over the iterations as algorithm 2. the results of the mix algorithm is also shown in figure 4.
the mix algorithm is slightly worse than the original leaky algorithm, but it also outperforms the conventional cd algorithm without additional computation cost. the comparison in terms of cpu time is shown in appendix f. annealing the leakiness helps the mix algorithm explore different modes of the distribution, thereby improves the training. the idea could also be combined with more advanced algorithms (tieleman, 2008; tieleman & hinton, 2009)4.in this paper, we study the properties of the exponential family distribution produced by leaky rbm. this study relates the leaky rbm model and truncated gaussian distribution and reveals an underlying positive definite constraint of training leaky rbm. we further proposed a meta sampling algorithm, which anneals between leakiness during the gibbs sampling procedure. we first demonstrate the proposed sampling algorithm is significantly more effective and efficient in estimating the partition function than the conventional ais algorithm. second, we show that the proposed sampling algorithm has comparatively better mixing properties (compared to cd). a few direction are worth further study; in particular we are investigating on speeding up the naive projection step; either using the barrier function as shown in hsieh  (2011) or by eliminating the need for projection by artificially bounding the domain via additional constraints. we studied the pcd extension of the proposed sampling algorithm. however, the performance is not as stable as cd.a.1 conditional distributions
for leaky rbm, the activation function of hidden units is defined as f(ηj) = max(cηj , ηj), where c ∈ (0, 1) and ηj = ∑i i=1wijvi + bj . the inverse function of f is f
−1(hj) = min(hj , hj/c). therefore, the anti-derivatives are
f (ηj) =
{ 1 2η 2 j , if ηj > 0
c 2η 2 j , else,
(10)
and
f ∗(hj) =
{ 1 2h 2 j , if ηj > 0  2ch 2 j , else.
(11)
the activation function of gaussian visible units can be treated as the linear unit f̃(νi) = νi, where νi = ∑j j=1wijhj . following the similar steps for deriving f and f
∗, we get the anti-derivatives f̃ (νi) = 1 2ν 2 i and f̃ ∗(vi) = 1 2v 2 i .
from ravanbakhsh  (2016), the conditional distribution is defined as
p(hj |ηj) = exp (−ηjhj + f (ηj) + f ∗(hj)) (12)
by plugging f and f ∗ into (12), we get the conditional distribution for leaky rbm
p(hj |v) = { n (ηj , 1)with g(hj) = − log( √ 2π), if ηj > 0
n (cηj , c)with g(hj) = − log( √ 2cπ), if ηj ≤ 0. (13)
similarly, we have p(vi|νi) = n (νi, 1) with g(vi) = − log( √ 2π).
a.2 joint and marginal distributions
given the conditional distributions p(v|h) and p(h|v), the joint distribution p(v, h) from the general treatment for mrf model given by yang  (2012) is
p(v, h) ∝ exp v>wh− i∑ i=1 (f̃ ∗(vi) + g(vi))− j∑ j=1 (f ∗(hj) + g(hj))  , (14) by plugging f ∗, f̃ ∗ and g from section a.1 into (14), we have
p(v, h) ∝ exp v>wh− ‖v‖2 2 − ∑ ηj>0 ( h2j 2 + log √ 2π ) − ∑ ηj≤0 ( h2j 2c + log √ 2cπ ) + b>h  , then the marginal distribution is
p(v) ∝ ∫ h p(v, h)dh
∝ ∫ h exp ( −‖v‖ 2 2 ) ∏ ηj>0 exp ( − h2j 2 + ηjhj − log √ 2π ) ∏ ηj≤0 ( − h2j 2c + hjηj − log √ 2cπ ) dh
∝ exp ( −‖v‖ 2  ) ∏ ηj>0 exp ( η2j 2 ) ∏ ηj≤0 ( cη2j 2 )
∝ exp −1 2 v> i −∑ ηj>0 wjw > j − c ∑ ηj≤0 wjw > j  v + ∑ ηj>0 bjw > j v + c ∑ ηj≤0 bjw > j v  .proof. since ww>− ∑ j αjwjwj = ∑ j(1−αj)wjw>j 0, we have ww> ∑ j αjwjwj .
therefore, i − ∑ j αjwjw > j i −ww> 0.proof. let the svd decomposition of w and w̃ as w = usv > and w̃ = ũ s̃ṽ >. then we have
‖w − w̃‖2f = ‖usv > − ũ s̃ṽ >‖2f ≥ i∑ i=1 (sii − s̃ii)2, (15)
and the constraint i − w̃w̃> 0 can be rewritten as 0 ≤ s̃ii ≤ 1,∀i. the transformed problem has a lasso-like formulation and we can solve it by s̃ii = min(sii, 1) (parikh & boyd, 2014). also, the lower bound ∑i i=1(sii − s̃ii)2 in (15) becomes a tight bound when we set ũ = u and ṽ = v , which completes the proof.we conduct a short comparison to demonstrate the projection step is necessary for the leaky rbm on generative tasks. we train two leaky rbm as follows. the first model is trained by the same setting in section 4. we use the convergence of log likelihood as the stopping criteria. the second model is trained by cd-1 with weight decay and without the projection step. we stop the training when the reconstruction error is less then 10−2. after we train these two models, we run gibbs sampling with 1000 independent chains for several steps and output the average value of the visible units. note that the visible units are normalized to zero mean. the results on svhn and cifar10 are shown in figure 5.
from figure 5, the model trained by weight decay without projection step is suffered by the problem of the diverged values. it confirms the study shown in section 3.1. it also implies that we cannot
train leaky rbm with larger cd steps when we do not do projection; otherwise, we would have the diverged gradients. therefore, the projection is necessary for training leaky rbm for the generative purpose. however, we also oberseve that the projection step is not necessary for the classification and reconstruction tasks. he reason may be the independency of different evaluation criteria (hinton, 2012; theis , 2016) or other implicit reasons to be studied.we analyze the performance gap between ais-leaky and ais-energy. one major difference is the initial distribution. the intermediate marginal distribution of ais-energy has the following form:
pk(v) ∝ exp −1 2 v> i − (1− βk) ∑ ηj>0 wjw > j − (1− βk)c ∑ ηj≤0 wjw > j  v  . (16)
here we eliminated the bias terms b for simplicity. compared with algorithm 2, (16) not only anneals the leakiness (1 − βk)c ∑ ηj≤0wjw > j when ηj ≤ 0, but also in the case (1 −
βk) ∑ ηj>0 wjw > j when ηj > 0, which brings more bias to the estimation. in other words, ais-leaky is a one-sided leakiness annealing while ais-energy is a two-sided leakiness annealing method.
to address the higher bias problem of ais-energy, we replace the initial distribution with the one used in algorithm 2. by elementary calculation, the marginal distribution becomes
pk(v) ∝ exp −1 2 v> i −∑ ηj>0 wjw > j − (βk + (1− βk)c) ∑ ηj≤0 wjw > j  v  , (17)
which recovers the proposed algorithm 2. from this analysis, we understand ais-leaky is a special case of conventional ais-energy with better initialization inspired by the study in section 3. also, by this connection between ais-energy and ais-leaky, we note that ais-leaky can be combined with other extensions of ais (grosse , 2013; burda , 2015) as well.f.1 sampled images
we show the sampled images from leaky rbm train on cifar10 and svhn datasets. we randomly initialize 20 chains and run gibbs sampling for 1000 iterations. the sampled results are shown in figure 6 the results shows that single layer rbm does not adequately model cifar10 and svhn
when compared to multilayer models. the similar results for single layer bernoulli-gaussian rbm from ranzato & hinton (2010) (in gray scale) is shown in figure 7. therefore, we instead focused on quantitative evaluation of the log-likelihood in table 3.
f.2 computational time between different sampling strategies
the comparison in terms of cpu time of different sampling algorithms discussed in section 5 is shown in figure 8. please note that the complexity of cd and mix are the almost the same. mix only need a few more constant time steps which can be ignored compared with sampling steps. leaky is more time-consuming because of computing and decomposing the covariance matrix as we discussed in section 5. we also report the execution time of each step of algorithms in table 4.
f.3 study on relu-bernoulli rbm
we study the idea of annealing leakiness on the rbm model with leaky relu hidden units and bernoulli visible units. we create the toy dataset with 20, 25 and 30 visible units as shown in figure 9. the small datasets allow exact computation of the partition function. for each dataset, we sample 60,000 images for training and 10,000 images for testing. we use 100 hidden units and pcd to train the model. the log likelihood results are shown in table 5.
compared to the gaussian visible units case we study in section 3, where p(v) is a multi-variate gaussian distribution when c = 1, the partition function of p(v) in relu-bernoulli when c = 1 does not have the analytical form. therefore, we do the following two-stage alternative. we first run the standard ais algorithm, which anneals the energy, to the distribution with leakiness c = 1. we then change to anneals the leakiness from 1 to the target value. for the typical ais algorithm (ais-energy), we use 104 chains with 2 × 104 intermediate distributions. for the proposed twostaged algorithm (ais-leaky), we use 104 chains with 104 intermediate distributions for annealing to c = 1 and the other 104 distributions for annealing the leakiness. the results are shown in table 6.
in table 6, the standard ais algorithm (ais-energy) has unsatisfactory performance. we show the performance of ais for estimating the partition function of models with different leakiness on toy20. we use the 104 independent chains and 2 × 104 intermediate distributions. the results are shown in table 7. from table 7, we observe that the ais performances worse when the leakiness is closer to 0. although we observed that increasing chains and intermediate distributions could improve the performance, but the improvements are limited. the study demonstrates when the
(a) i = 20
(b) i = 25
non-linearity of the distribution increases (the leakiness value c decreases), the standard ais cannot effectively estimate the partition function within feasible computational time. on the other hand, it also confirm the proposed idea, annealing the leakiness, can serve as an effective building block for algorithms without enhancing the algorithm complexity. note that the unsatisfactory performance of ais may be addressed by grosse  (2013). from appendix e, the two-stage algorithm used here can also be improved by applying grosse  (2013).
f.3.1 mnist and caltech datasets
we study mnist and caltech 101 silhouettes datasets with 500 hidden units and train the model with cd-25. the results are shown in table 8 and table 9. the leaky rbm is better than conventional bernoulli rbm and some deep models on mnist data. although leaky rbm deos not outperform su  (2017), but it enjoys the advantage of the simpler sampling procedure (gaussian distribution vs truncated gaussian distribution) in the binary visible unit case.",0
684.pdf.json,MULTI-TASK LEARNING WITH DEEP MODEL BASED REINFORCEMENT LEARNING,"recently, there has been a lot of success in applying neural networks to reinforcement learning, achieving super-human performance in many atari games (mnih  (2015); mnih  (2016)). most of these algorithms are based on q-learning, which is a model free approach to reinforcement learning. this approaches learn which actions to perform in each situation, but do not learn an explicit model of the environment. apart from that, learning to play multiple games simultaneously remains an open problem as these approaches heavily degrade when increasing the number of tasks to learn.
in contrast, we present a model based approach that can learn multiple tasks simultaneously. the idea of learning predictive models has been previously proposed (schmidhuber (2015); santana & hotz (2016)), but all of them focus on learning the predictive models in an unsupervised way. we propose using the reward as a means to learn a representation that captures only that which is important for the game. this also allows us to do the training in a fully supervised way. in the experiments, we show that our approach can surpass human performance simultaneously on three different games. in fact, we show that transfer learning occurs and it benefits from learning multiple tasks simultaneously.
in this paper, we first discuss why q-learning fails to learn multiple tasks and what are its drawbacks. then, we present our approach, predictive reinforcement learning, as an alternative to overcome those weaknesses. in order to implement our model, we present a recurrent neural network architecture based on residual nets that is specially well suited for our task. finally, we discuss our experimental results on several atari games.  previous work: deep q-learning
in recent years, approaches that use deep q-learning have achieved great success, making an important breakthrough when mnih  (2015) presented a neural network architecture that was able to achieve human performance on many different atari games, using just the pixels in the screen as input.
as the name indicates, this approach revolves around the q-function. given a state s and an action a, q(s, a) returns the expected future reward we will get if we perform action a in state s. formally, the q-function is defined in equation 1.
q(s, a) = es′ [ r + γmax
a′ q(s′, a′)|s, a
] (1)
for the rest of this subsection, we assume the reader is already familiar with deep q-learning and we discuss its main problems. otherwise, we recommend skipping to the next section directly as none of the ideas discussed here are necessary to understand our model.
as the true value of the q-function is not known, the idea of deep q-learning is iteratively approximating this function using a neural network1 which introduces several problems.
first, the q-values depend on the strategy the network is playing. thus, the target output for the network given a state-action pair is not constant, since it changes as the network learns. this means that apart from learning an strategy, the network also needs to remember which strategy it is playing. this is one of the main problems when learning multiple tasks, as the networks needs to remember how it is acting on each of the different tasks. rusu  (2015) and parisotto  (2015) have managed to successfully learn multiple tasks using q-learning. both approaches follow a similar idea: an expert network learns to play a single game, while a multi-tasking network learns to copy the behavior of an expert for each different game. this means that the multi-tasking network does not iteratively approximate the q-function, it just learns to copy the function that the single-task expert has approximated. that is why their approach works, they manage to avoid the problem of simultaneously approximating all the q-functions, as this is done by each single task expert.
apart from that, the network has to change the strategy very slightly at each update as drastically changing the strategy would change the q-values a lot and cause the approximation process to diverge/slow-down. this forces the model to interact many times with the environment in order to find good strategies. this is not problematic in simulated environments like atari games where the simulation can easily be speed up using more computing power. still, in real world environments, like for example robotics, this is not the case and data efficiency can be an important issue.in order to avoid the drawbacks of deep q-learning, we present predictive reinforcement learning (prl). in our approach, we separate the understanding of the environment from the strategy. this has the advantage of being able to learn from different strategies simultaneously while also being able to play strategies that are completely different to the ones that it learns from. we will also argue that this approach makes generalization easier. but before we present it, we need to define what we want to solve.the problem we want to solve is the following: given the current state of the environment and the actions we will make in the future, how is our score going to change through time?
to formalize this problem we introduce the following notation:
• ai: the observation of the environment at time i. in the case of atari games, this corresponds to the pixels of the screen.
• ri: the total accumulated reward at time i. in the case of atari games, this corresponds to the in-game score.
• ci: the control that was performed at time i. in the case of atari games, this corresponds to the inputs of the atari controller: up, right, shoot, etc. we do not explain the process, but mnih  (2015) give a good explanation on how this is done.
then, we want to solve the following problem: for a given time i and a positive integer k, let the input to our model be an observation ai and a set of future controls ci+1, . . . ci+k. then, we want to predict the change in score for the next k time steps, i.e. (ri+1 − ri), . . . , (ri+k − ri). figure 1 illustrates this with an example.
observe that, unlike in q-learning, our predictions do not depend on the strategy being played. the outputs only depend on the environment we are trying to predict. so, the output for a given state-actions pair is always the same or, in the case of non-deterministic environments, it comes from the same distribution.we have defined what we want to solve but we still need to specify how to implement a model that will do it. we will use neural networks for this and we will divide it into three different networks as follows:
• perception: this network reads a state ai and converts it to a lower dimensional vector h0 that is used by the prediction.
• prediction: for each j ∈ {1, . . . , k}, this network reads the vector hj−1 and the corresponding control ci+j and generates a vector hj that will be used in the next steps of the prediction and valuation. observe that this is actually a recurrent neural network.
• valuation: for each j ∈ {1, . . . , k}, this network reads the current vector hj of the prediction and predicts the difference in score between the initial time and the current one, i.e, ri+j − ri.
figure 2 illustrates the model. observe that what we actually want to solve is a supervised learning problem. thus, the whole model can be jointly trained with simple backpropagation. we will now proceed to explain each of the components in more detail.the perception has to be tailored for the kind of observations the environment returns. for now, we will focus only on vision based perception. as we said before, the idea of this network is to convert the high dimensional input to a low dimensional vector that contains only the necessary information for predicting the score. in the case of video games, it is easy to see that such vector exists. the input will consists of thousands of pixels but all we care about is the position of a few key objects, like for example, the main character or the enemies. this information can easily be
encoded using very few neurons. in our experiments, we convert an input consisting of 28k pixels into a vector of just 100 real values.
in order to do this, we use deep convolutional networks. these networks have recently achieved super-human performance in very complex image recognition tasks (he , 2015). in fact, it has been observed that the upper layers in these models learn lower dimensional abstract representations of the input (yosinski  (2015), karpathy & li (2015)). given this, it seems reasonable to believe that if we use any of the successful architectures for vision, our model will be able to learn a useful representation that can be used by the prediction.for the prediction network, we present a new kind of recurrent network based on residual neural networks (he , 2015), which is specially well suited for our task and it achieved better results than an lstm (hochreiter & schmidhuber, 1997) with a similar number of parameters in our initial tests.
residual recurrent neural network (rrnn) we define the rrnn in figure 3 using the following notation: ln is the layer normalization function (ba , 2016) which normalizes the activations to have a median of 0 and standard deviation of 1. ”·” is the concatenation of two vectors. f can be any parameterizable and differentiable function, e.g., a multilayer perceptron.
as in residual networks, instead of calculating what the new state of the network should be, we calculate how it should change (ri). as shown by he  (2015) this prevents vanishing gradients or optimization difficulties. ln outputs a vector with mean 0 and standard deviation 1. as we
proof2 in observation 1, this prevents internal exploding values that may arise from repeatedly adding r to h. it also avoids the problem of vanishing gradients in saturating functions like sigmoid or hyperbolic tangent.
observation 1. let x ∈ rn be a vector with median 0 and standard deviation 1. then, for all 1 ≤ i ≤ n, we get that xi ≤ √ n.
proof. taking into account that the median is 0 and the standard deviation is 1, simply substituting the values in the formula for the standard deviation shows the observation.
σ = √√√√ 1 n n∑ j=1 (xj − µ)2 (4)  = √√√√ 1 n n∑ j=1 x2j (5)
√ n = √√√√ n∑ j=1 x2j (6) √ n ≥ xi (7)
the idea behind this network is mimicking how a video game’s logic works. a game has some variables (like positions or speeds of different objects) that are slightly modified at each step. our intuition is that the network can learn a representation of these variables (h), while f learns how they are transformed at each frame. apart from that, this model decouples memory from computation allowing to increase the complexity of f without having to increase the number of neurons in h. this is specially useful as the number of real valued neurons needed to represent the state of a game is quite small. still, the function to move from one frame to the next can be quite complex, as it has to model all the interactions between the objects such as collisions, movements, etc.
even if this method looks like it may be just tailored for video games, it should work equally well for real world environments. after all, physics simulations that model the real world work in the same way, with some variables that represent the current state of the system and some equations that define how that system evolves over time.the valuation network reads the h vector at time i + j and outputs the change in reward for that time step, i.e. ri+j − rj . still, it is a key part of our model as it allows to decouple the representation learned by the prediction from the reward function. for example, consider a robot in a real world environment. if the perception learns to capture the physical properties of all surrounding objects (shape, mass, speed, etc.) and the prediction learns to make a physical simulation of the environment, this model can be used for any possible task in that environment, only the valuation would need to be changed.as we previously said, finding an optimal strategy is a very hard problem and this part is the most complicated. so, in order to test our model in the experiments, we opted for hard-coding a strategy. there, we generate a set of future controls uniformly at random and then we pick the one that would maximize our reward, given that the probability of dying is low enough. because of this, the games we have tried have been carefully selected such that they do not need very sophisticated and long-term strategies. the bound is not tight but it is sufficient for our purposes and straightforward to prove.
still, our approach learns a predictive model that is independent of any strategy and this can be beneficial in two ways. first, the model can play a strategy that is completely different to the ones it learns from. apart from that, learning a predictive model is a very hard task to over-fit. consider a game with 10 possible control inputs and a training set where we consider the next 25 time steps. then, there are 1025 possible control sequences. this means that every sequence we train on is unique and this forces the model to generalize. unfortunately, there is also a downside. our approach is not able to learn from good strategies because we test our model with many different ones in order to pick the best. some of these strategies will be quite bad and thus, the model needs to learn what makes the difference between a good and a bad set of moves.our experiments have been performed on a computer with a geforce gtx 980 gpu and an intel xeon e5-2630 cpu. for the neural network, we have used the torch7 framework and for the atari simulations, we have used alewrap, which is a lua wrapper for the arcade learning environment (bellemare , 2015). .2 model
for the perception, we used a network inspired in deep residual networks (he , 2015). figure 4 shows the architecture. the reason for this, is that even if the perception is relatively shallow, when unfolding the prediction network over time, the depth of the resulting model is over 50 layers deep.
for the prediction, we use a residual recurrent neural network. table 1 describes the network used for the f function. finally, table 2 illustrates the valuation network.in our experiments, we have trained on three different atari games simultaneously: breakout, pong and demon attack.
we preprocess the images following the same technique of mnih  (2015). we take the maximum from the last 2 frames to get a single 84 × 84 black and white image for the current observation. the input to the perception is a 4×84×84 tensor containing the last 4 observations. this is necessary to be able to use a feed-forward network for the perception. if we observed a single frame,
it would not be possible to infer the speed and direction of a moving object. not doing this would force us to use a recurrent network on the perception, making the training of the whole model much slower.
in order to train the prediction, we unfold the network over time (25 time steps) and treat the model as a feed-forward network with shared weights. this corresponds to approximately 1.7 seconds.
for our valuation, network we output two values. first, the probability that our score is higher than in the initial time step. second, we output the probability of dying. this is trained using cross entropy loss.
to train the model, we use an off-line learning approach for simplicity. during training we alternate between two steps. first, generate and store data and then, train the model off-line on that data.in order to generate the data, we store tuples (ai, c = {ci+1, . . . ci+25}, r = {ri+1 − ri, . . . ri+25 − ri}) as we are playing the game. that is, for each time i, we store the following:
• ai: a 4× 84× 84 tensor, containing 4 consecutive black and white frames of size 84× 84 each.
• c: for j ∈ {i+ 1, . . . , i+ 25}, each cj is a 3 dimensional vector that encodes the control action performed at time j. the first dimension corresponds to the shoot action, the second to horizontal actions and the third to vertical actions. for example, [1,−1, 0] represent pressing shoot and left.
• r: for j ∈ {i+1, . . . , i+25}, we store a 2 dimensional binary vector rj . rj1 is 1 if we die between time i and j. rj2 is 1 if we have not lost a life and we also earn a point between time i and j.
initially, we have an untrained model, so at each time step, we pick an action uniformly at random and perform it. for the next iterations, we pick a k and do the following to play the game: . run the perception network on the last 4 frames to obtain the initial vector. . generate k − 1 sequences of 25 actions uniformly at random. apart from that, take the best sequence from the previous time step and also consider it. this gives a total of k sequences. then, for each sequence, run the prediction and valuation networks with the vector obtained in step 1. . finally, pick a sequence of actions as follows. consider only the moves that have a low enough probability of dying. from those, pick the one that has the highest probability of earning a point. if none has a high enough probability, just pick the one with the lowest probability of dying.
we start with k = 25 and increase it every few iterations up to k = 200. for the full details check appendix a. in order to accelerate training, we run several games in parallel. this allows to run the perception, prediction and valuation networks together with the atari simulation in parallel, which heavily speeds up the generation of data without any drawback.in the beginning, we generate 400k training cases for each of the games by playing randomly, which gives us a total of 1.2m training cases. then, for the subsequent iterations, we generate 200k additional training cases per game (600k in total) and train again on the whole dataset. that is, at first we have 1.2m training cases, afterwards 1.8m , then 2.4m and so on.
the training is done in a supervised way as depicted in figure 2b. ai and c are given as input to the network and r as target. we minimize the cross-entropy loss using mini-batch gradient descent. for the full details on the learning schedule check appendix a.
in order to accelerate the process, instead of training a new network in each iteration, we keep training the model from the previous iteration. this has the effect that we would train much more on the initial training cases while the most recent ones would have an ever smaller effect as the training set grows. to avoid this, we assign a weight to each iteration and sample according to these weights during training. every three iterations, we multiply by three the weights we assign to them. by doing this, we manage to focus on recent training cases, while still preserving the whole training set.
observe that we never tell our network which game it is playing, but it learns to infer it from the observation ai. also, at each iteration, we add cases that are generated using a different neural network. so our training set contains instances generated using many different strategies.we have trained a model on the three games for a total of 19 iterations, which correspond to 4m time steps per game (74 hours of play at 60 hz). each iteration takes around two hours on our hardware. we have also trained an individual model for each game for 4m time steps. in the individual models, we reduced the length of the training such that the number of parameter updates per game is the same as in the multi-task case. unless some kind of transfer learning occurs, one would expect some degradation in performance in the multi-task model. figure 5 shows that not only there is no degradation in pong and demon attack, but also that there is a considerable improvement in breakout. this confirms our initial belief that our approach is specially well suited for multi-task learning.
we have also argued that our model can potentially play a very different strategy from the one it has observed. table 3 shows that this is actually the case. a model that has learned only from random play is able to play at least 7 times better.
demon attack’s plot in figure 5c shows a potential problem we mentioned earlier which also happens in the other two games to a lesser extent. once the strategy is good enough, the agent dies very rarely. this causes the model to ”forget” which actions lead to a death and makes the score oscillate.we have presented a novel model based approach to deep reinforcement learning. despite not achieving state of the art results, this papers opens new lines of research showing that a model based approach can work in environments as complex as atari. we have also shown that it can beat human performance in three different tasks simultaneously and that it can benefit from learning multiple tasks.
still, the model has two areas that can be addressed in future work: long-term dependencies and the instability during training. the first, can potentially be solved by combining our approach with q-learning based techniques. for the instability, balancing the training set or oversampling hard training cases could alleviate the problem.
finally, we have also presented a new kind of recurrent network which can be very useful for problems were little memory and a lot of computation is needed.i thank angelika steger and florian meier for their hardware support in the final experiments and comments on previous versions of the paper.",0
689.pdf.json,TENSORIAL MIXTURE MODELS,"generative models have played a crucial part in the early development of the field of machine learning. however, in recent years they were mostly cast aside in favor of discriminative models, lead by the rise of convnets (lecun , 2015), which were found to perform equally well or better than classical generative counter-parts on almost any task. despite the increased interest in unsupervised learning, many of the recent studies on generative models choose to focus solely on the generation capabilities of these models (goodfellow , 2014; gregor , 2015; van den oord , 2016; dinh , 2016; tran , 2016; chen , 2016; kingma , 2016; kim and bengio, 2016). there is much less emphasis on leveraging generative models to solve actual tasks, e.g. semi-supervised learning (kingma , 2014; springenberg, 2016; maaløe , 2016; forster , 2015; salimans , 2016), image restoration (dinh , 2014; bengio , 2014; van den oord , 2016; zoran and weiss, 2011; rosenbaum and weiss, 2015; sohl-dickstein , 2015; theis and bethge, 2015) or unsupervised feature representation (radford , 2016; coates , 2011). nevertheless, work on generative models for solving actual problems are yet to show a meaningful advantage over competing discriminative models.
on the most fundamental level, the difference between a generative model and a discriminative one is simply the difference between learning p (x,y ) and learning p (y |x), respectively. while it is always possible to infer p (y |x) given p (x,y ), it might not be immediately apparent why the generative objective is preferred over the discriminative one. in ng and jordan (2002), this question was studied w.r.t. the sample complexity, proving that under some cases it can be significantly lesser in favor of the generative classifier. however, their analysis was limited only to specific pairs of discriminative and generative classifiers, and they did not present a general case where the the generative method is undeniably preferred. we wish to highlight one such case, where learning
p (x,y ) is provenly better regardless of the models in question, by examining the problem of classification with missing data. despite the artificially well-behave nature of the typical classification benchmarks presented in current publications, real-world data is usually riddled with noise and missing values – instead of observing x we only have a partial observation x̂ – a situation that tends to be ignored in modern research. discriminative models have no natural mechanisms to handle missing data and instead must rely on data imputation, i.e. filling missing data by a preprocessing step prior to prediction. unlike the discriminative approaches, generative models are naturally fitted to handle missing data by simply marginalizing over the unknown values in p (x,y ), from which we can attain p (y |x̂) by an application of bayes rule. moreover, under mild assumptions which apply to many real-world settings, this method is proven to be optimal regardless of the process by which values become missing (see sec. 5 for a more detailed discussion).
while almost all generative models can represent p (x,y ), only few can actually infer its exact value efficiently. models which possess this property are said to have tractable inference. many studies specifically address the hard problem of learning generative models that do not have this property. notable amongst those are works based on variational inference (kingma and welling, 2014; kingma , 2014; blei , 2003; wang and grimson, 2007; makhzani , 2015; kingma , 2016), which only provide approximated inference, and ones based on generative adversarial networks (goodfellow , 2014; radford , 2016; springenberg, 2016; chen , 2016; salimans , 2016; makhzani , 2015), which completely circumvent the inference problem by restructuring the learning problem as a two-player game of discriminative objectives – both of these approaches are incapable of tractable inference.
there are several advantages to models with tractable inference (e.g. they could be simpler to train), and as we have shown above, this property is also a requirement for proper handling of missing data in the form of marginalization. in practice, to marginalize over p (x,y ) means to perform integration on it, thus, even if it is tractable to compute p (x,y ), it still might not be tractable to compute every possible marginalization. models which are capable of this are said to have tractable marginalization. mixture models (e.g. gaussian mixture models) are the classical example of a generative model with tractable inference, as well as tractable marginalization. though they are simple to understand, easy to train and even known to be universal – can approximate any distribution given sufficient capacity – they do not scale well to high-dimensional data. the gaussian mixture model is an example of a shallow model – containing just a single latent variable – with limited expressive efficiency. more generally, graphical models are deep and exponentially more expressive, capable of representing intricate relations between many latent variables. while not all kinds of graphical models are tractable, many are, e.g. latent tree models (zhang, 2004; mourad , 2013) and sum-product networks (poon and domingos, 2011). the main issue with generic graphical models is that by virtue of being too general they lack the inductive bias needed to efficiently model unstructured data, e.g. images or text. despite the success of structure learning algorithms (huang , 2015; gens and domingos, 2013; adel , 2015) on structured datasets, such as discovering a hierarchy among diseases in patients health records, there are no similar results on unstructured datasets. indeed some recent works on the subject have failed to solve even simple handwritten digit classification tasks (adel , 2015). thus deploying graphical models on such cases requires experts to manually design the model. other attempts which harness neural networks blocks (dinh , 2014; 2016) offer tractable inference, but not tractable marginalization.
to summarize, most generative models do not have tractable inference, and of the few models which do, they all possess one or more of the following shortcomings: (i) they do not possess the expressive capacity to model high-dimensional data (e.g. images), (ii) they require explicitly designing all the dependencies of the data, or (iii) they do not have tractable marginalization.
we present in this paper a family of generative models we call tensorial mixture models (tmms), which aim to address the above shortcomings of alternative models. under tmms, we assume that the data generated by our model is composed of a sequence of local-structures (e.g. patches in an image), where each local-structure is generated from a small set of simple component distributions (e.g. gaussian), and the dependencies between the local-structures are represented by a prior tensor holding the prior probabilities of assigning a component distribution to each local-structure. in their general form, tmms are intractable as the prior tensor is typically of exponential size. however, by decomposing the prior tensor, inference of tmms becomes realizable by convolutional arithmetic circuits (convacs) – a recently proposed (cohen , 2016a) convnet architecture based on two
operations, weighted sum and product pooling – which enables both tractable inference as well as tractable marginalization. while graphical models are typically hard to design, convacs follow the same design conventions of modern convnets, which reduces the task of designing a model to simply choosing the number of channels at each layer, and size of pooling windows. convacs were also the subject of several theoretical studies on its expressive capacity (cohen , 2016a; cohen and shashua, 2016b) and comparing them to convnets (cohen and shashua, 2016a), showing they are especially suitable for high-dimensional natural data (images, audio, etc.) with a non-negligible advantage over standard convnets. sum-product networks are another kind of graphical model realizable by arithmetic circuits, but they do not posses the same theoretical guarantees, nor do they provide a simple method to design efficient and expressive models.
the rest of the article is organized as follows. in sec. 2 we briefly review mathematical background on tensors required in order to follow our work. this is followed by sec. 3 which presents our generative model and its theoretical properties. how our model is trained is covered in sec. 4, and a thorough discussion on the importance of marginalization and its implications on our model is given in sec. 5. we conclude the article by presenting our experiments on classification with missing data in sec. 6, and revisit the main points of the article and future research in sec. 7.we begin by establishing the minimal background in the field of tensor analysis required for following our work (see app. a for a more detailed review of the subject). a tensor is best thought of as a multi-dimensional array ad1,...,dn ∈ r, where ∀i ∈ [n ], di ∈ [mi] and n is referred to as the order of the tensor. for our purposes we typically assume that m1 = . . . = mn = m , and denote it as a ∈ (rm )⊗n . it is immediately apparent that performing operations with tensors, or simply storing them, quickly becomes intractable due to their exponential size of mn . that is one of the primary motivations behind tensor decomposition, which can be seen as a generalization of low-rank matrix factorization.
the relationship between tensor decomposition and networks arises from the simple observation, that through decomposition one can tradeoff storage complexity with computation, where the type of computation consists of sums and products. specifically, the decompositions could be described by a compact representation coupled with a decoding algorithm of polynomial complexity to retrieve the entries of the tensor. most tensor decompositions have a decoding algorithm representable via computation graphs of products and weighted sums, also known as arithmetic circuits (shpilka and yehudayoff, 2010) or sum-product networks (poon and domingos, 2011). more specifically, these circuits take as input n indicator vectors δ1, . . . , δn , representing the coordinates (d1, . . . , dn ), where δi = 1[j=di], and output the value ofad1,...,dn , where the weights of these circuits form the compact representation of tensors.
applying this perspective to two of the most common decomposition formats, candecomp/parfac (cp) and hierarchical tucker (ht), give rise to a shared framework for representing their decoding circuits by convolutional networks as illustrated in fig. 1, where a shallow network with one hidden layer corresponds to the cp decomposition, and a deep network with log2(n) hidden layers corresponds to the ht decomposition. the networks consists of just product pooling and 1×1 conv layers. having no point-wise activations between the layers, the non-linearity of the models stems from the product pooling operation itself. the pooling layers also control the depth of the network by the choice of the size and the shape of pooling windows. the conv operator is not unlike the standard convolutional layer of convnets, with the sole difference being that it may operate without coefficient sharing, i.e. the filters that generate feature maps by sliding across the
previous layer may have different coefficients at different spatial locations. this is often referred to in the deep learning community as a locally-connected operator (taigman , 2014).
arithmetic circuits constructed from the above conv and product pooling layers are called convolutional arithmetic circuits, or convacs for short, first suggested by cohen  (2016a) as a theoretical framework for studying standard convolutional networks, sharing many of the defining traits of the latter, most noteworthy, the locality, sharing and pooling properties of convnets. unlike general circuits, the structure of the network is determined solely by two parameters, the number of channels of each conv layer and the size of pooling windows, which indirectly controls the depth of the network. any decomposition that corresponds to a convac can represent any tensor, given sufficient number of channels, though deeper circuits result in more efficient representations (cohen , 2016a).
finally, since we are dealing with generative models, the tensors we study are non-negative and sum to one, i.e. the vectorization of a (rearranging its entries to the shape of a vector), denoted by vec(a), is constrained to lie in the multi-dimensional simplex, denoted by: k := { x ∈ rk+1|
∑k+1 i=1 xi = 1,∀i ∈ [k + 1] : xi ≥ 0 }
(1)we represent the input signal x by a sequence of low-dimensional local structures
x = (x1, . . . ,xn ) ∈ (rs)n this representation is quite natural for many high-dimensional input domains such as images – where the local structures represent patches consisting of s pixels – voice through spectrograms, and text through words.
a well-known observation, which has been verified in several empirical studies (e.g. by zoran and weiss (2011)), is that the distributions of local structures typically found in natural data could be sufficiently modeled by a mixture model consisting of only few components (on the order of 100) of simple distributions (e.g. gaussian). assuming the above holds for x ∈ (rs)n and let {p (x|d; θd)}md=1 be the mixing components, parameterized by θ1, . . . , θm , from which local structures are generated, i.e. for all i ∈ [n ] there exist di ∈ [m ] such that xi ∼ p (x|di; θdi), where di is a hidden variable specifying the matching component for the i-th local structure, then the probability density of sampling x is fully described by:
p (x) = ∑m
d1,...,dn=1 p (d1, . . . , dn ) ∏n i=1
p (xi|di; θdi) (2) where p (d1, . . . , dn ) represents the prior probability of assigning components d1, . . . , dn to their respective local structures x1, . . . ,xn . even though we had to make an assumption on x to derive eq. 2, it is important to note that if we allow m to become unbounded, then any distribution with support in (rs)n could be approximated by this equation. the argument follows from the universality property of the common parametric families of distributions (gaussian, laplacian, etc.), where any distribution can be approximated given sufficient number of components from these families, and thus the assumption always holds to some degree (see app. b for the complete proof).
the prior probabilities p (d1, . . . , dn ) can also be represented by a tensora ∈ (rm )⊗n of ordern , given that the vectorization of a is constrained to the simplex, i.e. vec(a) ∈ 4(mn−1) (see eq. 1). thus, we refer to eq. 2 as a tensorial mixture model (tmm) with priors tensor a and mixing components p (x|d1; θ1), . . . , p (x|dn ; θn ). notice that if n = 1 then we obtain the standard mixture model, whereas for a general n it is equivalent to a mixture model with tensorised mixing weights and conditionally independent mixing components.
unlike standard mixture models, we cannot perform inference directly from eq. 2, nor can we even store the priors tensor directly given its exponential size of mn entries. therefore the tmm as presented by eq. 2 is not tractable. the way to make the tmm tractable is to replace the tensor ad1,...,dn by a tensor decomposition and, as described in the previous section, this gives rise to arithmetic circuits. but before we present our approach for tractable tmms through tensor decompositions, it is worth examining some of the tmm special cases and how they relate to other known generative models.we have already shown that tmms can be thought of as a special case of mixture models, but it is important to also note that diagonal gaussian mixture models (gmms), probably the most common type of mixture models, are a strict subset of tmms. assume m = n ·k, as well as:
p (d1, . . . , dn ) = { wk ∀i ∈ [n ], di=n ·(k−1)+i 0 otherwise
p (x|d; θd) = n (x;µki, diag(σ2ki)), d=n ·(k−1)+i then eq. 2 reduces to:
p (x) = ∑k k=1 wk ∏n i=1 n (x;µki, diag(σ2ki)) = ∑k k=1
wkn (x; µ̃k, diag(σ̃2k)) µ̃k = (µ t k1, . . . ,µ t kn ) t σ̃2k = ((σ 2 k1) t , . . . , (σ2kn ) t )t
which is equivalent to a diagonal gmm with mixing weights w ∈ 4k−1 and gaussian mixture components with means {µ̃k}kk=1 and covariances {diag(σ̃2k)}kk=1. while the previous example highlights another connection between tmms and mixture models, it does not take full advantage of the priors tensor, setting most of its entries to zero. perhaps the simplest assumption we could make about the priors tensor, without it becoming degenerate, would be to assume that that the hidden variables d1, . . . , dn are statistically independent, i.e. p (d1, . . . , dn )= ∏n i=1 p (di). then rearranging eq. 2 will result in a product of mixture models:
p (x) = ∏n
i=1 ∑m d=1 p (di = d)p (xi|di = d; θd)
if we also assume that the priors are identical in addition to being independent, i.e. p (d1 = d) = . . . = p (dn = d), then this model becomes a bag-of-words model, where the components {p (x|d; θd)}md=1 define a soft dictionary for translating local-structures into ”words”, as is often done when applying bag-of-words models to images. despite this familiar setting, had we subscribed to only using independent priors, we would lose the universality property of the general tmm model – it would not be capable of modeling dependencies between the local-structures.we have just seen that tmms could be made tractable through constraints on the priors tensor, but it was at the expense of either not taking advantage of its tensor structure, or losing its universality property. our approach for tractable tmms is to apply tensor decompositions to the priors tensor, which is the conventional method for tackling the exponential size of high-order tensors.
we have already mentioned in sec. 2 that any decomposition representable by convacs, including the well-known cp and ht decompositions, can represent any tensor, and thus applying them would not limit the expressivity of our model. fixing a convac representing the priors tensor, i.e. φθ(δ1, . . . , δn ) = ad1,...,dn where θ are the parameters of the convac and {δi}ni=1 are the indicators representation of {di}ni=1, and simply rearranging the terms of eq. 2 after substituting the entries of the priors tensor with the sums and products expression of φθ(δ1, . . . , δn ) results in:
p (x) = φθ(q 1, . . . ,qn ) ∀i ∈ [n ]∀d ∈ [m ], qid = p (xi|di = d) (3)
which is nearly equivalent to how the convac is used for computing the entries of the priors tensor, differing only in the way the input vectors are defined. namely, eq. 3 is a result of
replacing indicator vectors δi with probability vectors qi, which could be interpreted as a soft variant of indicator vectors. viewed as a network, it begins with a representation layer, mapping the local structures to the likelihood probabilities of belonging to each mixing component, i.e. {xi}ni=1→{p (xi|di=d; θd)}n,mi=1,d=1. following the representation layer is the same convac described by φθ(·, . . . , ·). the complete network is illustrated by fig. 2. unlike general tensors, for a tmm to represent a valid distribution, the priors tensor is constrained to the simplex and thus not every choice of parameters for the decomposition would result in a tensor holding this constraint. by restricting ourselves to non-negative decomposition parameters, i.e. use positive weights in the 1×1 conv layers, it guarantees the resulting tensors would be nonnegative as well. additionally, normalizing the non-negative tensor is equivalent to requiring the parameters to be restricted to the simplex, i.e. for every layer l and spatial position j the weight vector wl,j ∈ 4rl−1−1 of the respective 1×1 conv kernel is normalized to sum to one. under these constraints we refer to it as a generative decomposition. notice that restricting ourselves to generative decompositions does not limit the expressivity of our model, as we can still represent any non-negative tensor and thus any distribution that the original tmm could represent. in discussing the above, it helps to distinguish between the two extreme cases of generative decompositions representable by convacs, namely, the shallow generative cp decomposition referred to as the gcp-model, and the deep generative ht decomposition referred to as the ght-model.
non-negative matrix and tensor decompositions have a long history together with the development of corresponding generative models, e.g., plsa (hofmann, 1999) which uses non-negative matrix decompositions for text analysis, which was later extended for images with the help of “visual words” (li and perona, 2005). the non-negative variant of the cp decomposition presented above is related to the more general latent class models (zhang, 2004), which could be seen as a multi-dimensional plsa. likewise, the non-negative ht decomposition is related to the latent tree model (zhang, 2004; mourad , 2013) with the structure of a complete binary tree. thus both the gcp and ght models can be represented as a two-level graphical model, where the top level is either an lcm or an ltm, and the bottom level represent the local structures which are conditionally sampled from the mixing components of the tmm.
to conclude, the application of convacs to decompose the priors tensor leads to tractable tmms with inference implemented by convolutional networks, has deep roots to classical use of nonnegative factorizations of generative models, and given sufficient resources does not limit expressivity. however, practical considerations raise the question on the extent of the expressive capacity of our models when the size of the convac is polynomial with respect to the number of local structures and mixing components. this question was thoroughly studied in a series of works analyzing the importance of depth (cohen , 2016a), compared them to the expressive capacity of convnets (cohen and shashua, 2016a), showing the latter is less capable than convacs, and the ability of convacs to model the dependency structure typically found in natural data (cohen and shashua, 2016b). we prove in app. d that their main results are not hindered by the introduction of simplex constraints to convacs as we did above. together these results give us a detailed understanding of how the number of channels and size of pooling windows control the expressivity of the model. a more in depth overview of their results and its application to our models can be found in app. c.sum-product networks (spns) are a related class of generative models which are also realized by arithmetic circuits, though not strictly convolutional circuits as defined above. while spns can realize any convac and thus are universal and posses tractable inference, their lack of structure puts them at a disadvantage.
picking the right spn structure from the infinite possible combinations of sum and product nodes could be perplexing even for experts in the field. indeed poon and domingos (2011); gens and domingos (2012) had to hand-engineer complex structures for each dataset guided by prior knowledge and heuristics, and while their results were impressive for their time, they are poor by current measures. this lead to many works studying the task of learning the structure directly from the data itself (peharz , 2013; gens and domingos, 2013; adel , 2015; rooshenas and lowd, 2014), which indeed improved upon manually designed spns on some tasks. nevertheless, when
compared in absolute terms compared to other models, and not just average log-likelihood, they do not perform well even on simple handwritten digit classification datasets (adel , 2015).
as opposed to spns, tmms implemented with convacs have an easily designed architecture with only two set of parameters, size of pooling windows and number of channels, both of which can be directly related to the expressivity of the model as detailed in app. c. additionally, while spns are typically trained using special em-type algorithms, tmms are trained using the stochastic gradient descent type algorithms as is common in training neural networks (see sec. 4 for details), thereby benefiting from the shared experience of a large and growing community.until this point we presented the tmm as a generative model for high-dimensional data, which is universal, and whose structure is tightly coupled to that of convolutional networks. we have yet to incorporate classification and learning into our framework. this is the purpose of the current section.
the common way to introduce object classes into a generative framework is to consider a class variable y , and the distributions p (x|y ) of the instancex conditioned on y . under our model this is equivalent to having shared mixing components, but different priors tensors p (d1, . . . , dn |y=y) for each class. though it is possible to decompose each priors tensor separately, it is much more efficient to employ the concept of joint tensor decomposition, and use a shared convac instead. this results in a single convac computing inference, where instead of a single scalar output, multiple outputs are driven by the network – one for each class – as illustrated through the network in fig. 3.
heading on to predicting the class of a given instance, we note that in practice, naı̈ve implementation of convacs is not numerically stable, the reason being that high degree polynomials (as computed by such networks) are easily susceptible to numerical underflow or overflow. the conventional method for tackling this issue is to perform all computations in log-space. this transforms convacs into simnets, a recently introduced deep learning architecture (cohen and shashua, 2014; cohen , 2016b). finally, prediction is carried by returning the most likely class, which in the common setting of uniform class priors (pθ(y=y)≡1/k), translates to simply predicting the class for which the corresponding network output is maximal, in accordance with standard neural network practice:
ŷ (x) = argmaxy p (y = y|x) = argmaxy logp (x|y = y)
suppose now that we are given a training set s = {(x(i)∈(rs)n , y (i)∈[k])}|s|i=1 of instances and labels, and would like to fit the parameters θ of multi-class tmm according to the maximum likelihood method. equivalently, we minimize the negative log-likelihood (nll) loss function: l(θ) = e[− logpθ(x,y )], which can be factorized into two separate loss functions:
l(θ) = e[− logpθ(y |x)] + e[− logpθ(x)] where e[− logpθ(y |x)] is commonly known as the cross-entropy loss, which we refer to as the discriminative loss, while e[− logpθ(x)] corresponds to maximizing the prior likelihood p (x), and has no analogy in standard discriminative neural networks. it is this term that captures the generative nature of our model, and we accordingly refer to it as the generative loss. now, let nθ(x (i); y):= logpθ(x (i)|y=y) stand for the y’th output of the simnet (convac in log-space) realizing the tmm with parameters θ, then in the case of uniform class priors, the empirical estimation of l(θ) may be written as:
l(θ;s) = − 1|s| ∑|s| i=1 log enθ(x (i);y (i))
∑k y=1 e
nθ(x(i);y) − 1|s| ∑|s| i=1 log ∑k y=1 enθ(x (i);y) (4)
maximum likelihood training of generative models is oftentimes based on dedicated algorithms such as expectation-maximization, which are typically difficult to apply at scale. we leverage the resemblance between our objective (eq. 4) and that of standard neural networks, and apply the same optimization procedures used for the latter, which have proven to be extremely effective for training classifiers at scale. whereas other works have used tensor decompositions for the optimization of probabilistic models (song , 2013; anandkumar , 2014), we employ them strictly for modeling and instead make use of conventional methods. in particular, our implementation of tmms is based on the simnets extension of caffe toolbox (cohen , 2016b; jia , 2014), and uses standard stochastic gradient descent-type methods for optimization (see sec. 6 for more details).a major advantage of generative models over discriminative ones lies in the ability to cope with missing data, specifically in the context of classification. by and large, discriminative methods either attempt to complete missing parts of the data before classification, known as data imputation, or learn directly to classify data with missing values (little and rubin, 2002). the first of these approaches relies on the quality of data completion, a much more difficult task than the original one of classification with missing data. even if the completion was optimal, the resulting classifier is known to be sub-optimal (see app. e). the second approach does not make this assumption, but nonetheless assumes that the distribution of missing values at train and test times are similar, a condition which often does not hold in practice. indeed, globerson and roweis (2006) coined the term “nightmare at test time” to refer to the common situation where a classifier must cope with missing data whose distribution is different from that encountered in training.
as opposed to discriminative methods, generative models are endowed with a natural mechanism for classification with missing data. namely, a generative model can simply marginalize over missing values, effectively classifying under all possible completions, weighing each completion according to its probability. this, however, requires tractable inference and marginalization. we have already shown in sec. 3 that tmm support the former, and will show in sec. 5.1 bring forth marginalization which is just as efficient. beforehand, we lay out the formulation of classification with missing data.
let x be a random vector in rs representing an object, and y be a random variable in [k]:={1, . . . ,k} representing its label. denote byd(x ,y) the joint distribution of (x ,y), and by (x∈rs, y∈[k]) specific realizations thereof. assume that after sampling a specific instance (x, y), a random binary vectorm is drawn conditioned on x=x. more concretely, we sample a binary mask m∈{0, 1}s (realization ofm) according to a distributionq(·|x=x). xi is considered missing ifmi is equal to zero, and observed otherwise. formally, we consider the vector x m, whose i’th coordinate is defined to hold xi if mi=1, and the wildcard ∗ if mi=0. the classification task is then to predict y given access solely to x m. following the works of rubin (1976); little and rubin (2002), we consider three cases for the missingness distribution q(m=m|x=x): missing completely at random (mcar), where m is independent of x , i.e. q(m=m|x=x) is a function of m but not of x; missing at random (mar), wherem is independent of the missing values in x , i.e. q(m=m|x=x) is a function of both m and x, but is not affected by changes in xi if mi=0; and missing not at random (mnar), covering the rest of the distributions for whichm depends on missing values in x , i.e.q(m=m|x=x) is a function of both m and x, which at least sometimes is sensitive to changes in xi when mi=0.
let p be the joint distribution of the object x , label y , and missingness maskm: p(x=x,y=y,m=m) = d (x=x,y=y) · q(m=m|x=x)
for given x ∈ rs and m ∈ {0, 1}s, denote by o(x,m) the event where the random vector x coincides with x on the coordinates i for which mi = 1. for example, if m is an all-zero vector o(x,m) covers the entire probability space, and if m is an all-one vector o(x,m) corresponds to the event x = x. with these notations in hand, we are now in a position to characterize the optimal predictor in the presence of missing data: claim 1. for any data distribution d and missingness distribution q, the optimal classification rule in terms of 0-1 loss is given by:
h∗(x m) = argmaxy p(y=y|o(x,m))p(m=m|o(x,m),y=y)
proof. see app. e.
when the distributionq is mar (or mcar), the classifier admits a simpler form, referred to as the marginalized bayes predictor: corollary 1. under the conditions of claim 1, if the distributionq is mar (or mcar), the optimal classification rule may be written as:
h∗(x m) = argmaxy p(y=y|o(x,m)) (5)
proof. see app. e.
corollary 1 indicates that in the mar setting, which is frequently encountered in practice, optimal classification does not require prior knowledge regarding the missingness distribution q. as long as one is able to realize the marginalized bayes predictor (eq. 5), or equivalently, to compute the likelihoods of observed values conditioned on labels (p(o(x,m)|y=y)), classification with missing data is guaranteed to be optimal, regardless of the corruption process taking place. this is in stark contrast to discriminative methods, which require access to the missingness distribution during training, and thus are not able to cope with unknown conditions at test time.
most of this section dealt with the task of prediction given an input with missing data, where we assumed we had access to a complete and uncorrupted training set, and only faced missingness during prediction. however, many times we wish to tackle the reverse problem, where the training set itself is riddled with missing data. generative methods can once again leverage their natural ability to handle missing data in the form of marginalization during the learning stage. generative models are typically learned through the maximum likelihood principle. when it comes to learning from missing data, the marginalized likelihood objective is used instead. under the mar assumption, this method results in an unbiased classifier (little and rubin, 2002).as discussed above, with generative models optimal classification with missing data (in the mar setting) is oblivious to the specific missingness distribution. however, it requires tractable computation of the likelihood of observed values conditioned on labels, i.e. tractable marginalization over missing values. the plurality of generative models that have recently gained attention in the deep learning community (goodfellow , 2014; kingma and welling, 2014; dinh , 2014; 2016) do not meet this requirement, and thus are not suitable for classification with missing data. tmms on the other hand bring forth extremely efficient marginalization, requiring only a single forward pass through the corresponding network. details follow.
recall from sec. 3 and 4 that a multi-class tmm realizes the following form:
p (x1, . . . ,xn |y=y) = ∑m
d1,...,dn p (d1, . . . , dn |y=y) ∏n i=1
p (xi|di; θdi) (6) suppose now that only the local structures xi1 . . .xiv are observed, and we would like to marginalize over the rest. integrating eq. 6 gives:
p (xi1 , . . . ,xiv |y=y) = ∑m
d1,...,dn p (d1, . . . , dn |y=y) ∏v v=1
p (xiv |div ; θdiv ) from which it is evident that the same convac used to compute p (x1, . . . ,xn |y=y), can be used to compute p (xi1 , . . . ,xiv |y=y) – all it requires is a slight adaptation of the representation layer. namely, the latter would represent observed values through the usual likelihoods, whereas missing (marginalized) values would now be represented via constant ones:
rep(i, d) = {  , xi is missing (marginalized) p (xi|d; θ) , xi is visible (not marginalized)
to conclude, with tmms marginalizing over missing values is just as efficient as plain inference – requires only a single pass through the corresponding convac. accordingly, the marginalized bayes predictor (eq. 5) is realized efficiently, and classification with missing data (in the mar setting) is optimal, regardless of the missingness distribution. this capability is not provided by discriminative methods, which rely on the distribution of missing values being know at training, and by contemporary generative models, which do not bring forth tractable marginalization.we demonstrate the properties of our models through both qualitative and quantitative experiments. in subsec. 6.1 we present our state-of-the-art results on image classification with missing data, with robustness to various missingness distributions. in app. g we show visualizations produced by our models, which gives us insight into its inner workings. our experiments were conducted on the mnist digit classification dataset, consisting of 60000 grayscale images of single digit numbers, as well as the small norb 3d object recognition dataset, consisting of 48600 grayscale stereo images of toys belonging to 5 categories: four-legged animals, human figures, airplanes, trucks, and cars
in all our experiments we use either the gcp or ght model with gaussian mixing components. the weights of the conv layers are partially shared as described in sec 3.2, and are represented in log-space. for the case of the ght model, we use 2× 2 pooling windows for all pooling layers. we train our model according to the loss described in sec. 4, using the adam (kingma and ba, 2015) variant of sgd and decaying learning rates. we apply l2-regularization to the weights while taking into account they are stored in log-space. additionally, we also adapt a probabilistic interpretation of dropout (?) by introducing random marginalization layers, that randomly select spatial locations in the input and marginalize over them. we provide a complete and detailed description of our experiments in app. f.
our implementation, which is based on caffe (jia , 2014) and maps (ben-nun , 2015), as well as other code for reproducing our experiments, is available through our github repository: https://github.com/huji-deep/tmm.we demonstrate the effectiveness of our method for classification with missing data of unknown missingness distribution (see sec. 5), by conducting three kinds of experiments on the mnist dataset, and an additional experiment on the norb dataset. we begin by following the protocol of globerson and roweis (2006) – the binary classification problem of digit pairs with feature deletion noise – where we compare our method to the best known result on that benchmark (dekel and shamir, 2008). for our main experiment, we move to the harder multi-class digit classification under two different mar missingness distributions, comparing against other methods which do not assume a specific missingness distribution. we repeat this experiment on the norb dataset as well. finally, our last experiment demonstrates the failure of purely discriminative methods to adapt to previously unseen missingness distributions, underlining the importance of the generative approach to missing data. we do wish to emphasize that missing data is not typically found in most image data, nevertheless, experiments on images with missing data are very common, for both classification and inpainting tasks. additionally, there is nothing about our method, nor the methods we compare it against, that is very specific to the image domain, and thus any conclusion drawn should not be limited to the chosen datasets, but be taken in the broader context of the missing data problem.
the problem of learning classifiers which are robust to unforeseen missingness distributions at test time was first proposed by globerson and roweis (2006). they suggested missing values could be denoted by values which were deleted, i.e. their values were changed to zero, and a robust classifier would have to assume that any of its zero-value inputs could be the result of such a deletion process, and must be treated as missing. their solution was to train a linear classifier and formulate the optimization as a quadric program under the constraint that n of its features could be deleted. in dekel and shamir (2008), this solution was improved upon and generalized to other kinds of corruption beyond deletion as well as to an adversarial setting.
we follow the central experiment of these articles, conducted on binary classification of digits pairs from the mnist dataset, where n non-zero pixels are deleted with uniform probability over the set of n non-zero pixel locations of the given image. we compare our method, using the deep ghtmodel, solely against the lp-based algorithm of dekel and shamir (2008), which is the previous state-of-the-art on this task. due to the limited computational resources at the time, the original experiments were limited to training sets of just 50 images per digit. we have repeated their experiment, using the implementation kindly supplied to us by the authors, and increased the limit to 300 images per digit, which is the maximal amount possible with our current computational resources. though it is possible to train our own models using much larger training sets, we have trained them under the same limitations. despite the fact that missingness distribution of this experiment is of the mnar type, which our method was not guarantied to be optimal under, the test results (see table 1) clearly show the large gap between our method and theirs. additionally, whereas our method uses a single model trained once and with no prior knowledge on the missingness distribution, their method requires training special classifiers for each value of n , chosen through a cross-validation process, disqualifying it from being truly blind to the missingness distribution.
we continue to our main experiments on multi-class blind classification with missing data, where the missingness distribution is completely unknown during test time, and a single classifier must handle all possible distributions. we simulate two kinds of mar missingness distributions: (i) an i.i.d. mask with a fixed probability p ∈ [0, 1] of missing each pixel, and (ii) a mask composed of the union of n possibly overlapping rectangles of width and height equal to w , each with a randomly assigned position in the image, distributed uniformly. we evaluate both our shallow gcp-model as well as the deep ght-model against the most widely used methods for blind classification with missing data. we repeat these experiments on the mnist and norb datasets, the results of which are presented in fig. 4.
as a baseline for our results, we use k-nearest neighbors (knn) to vote on the most likely class of a given example. we extend knn to missing data by comparing distances using only the observed entries, i.e. for a corrupted instance x m, and a clean image from the training set x̃, we compute: d(x̃,x m)=∑mij=1(x̃ij−xij)2. though it scores better than the majority of modern methods we have compared, in practice knn is very inefficient, even more so for missing data, which prevents most common memory and runtime optimizations typically employed to reduce its inefficiency. additionally, knn does not generalize well for more complex datasets, as is evident by its poor performance on the clean test set of the norb dataset.
as discusses in sec. 5, data-imputation is the most common method to handle missing data of unknown missingness distributions. despite the popularity of this method, high quality data imputations are very hard to produce, amplified by the fact that classification algorithms are known to be highly sensitive to even a small noise applied to their inputs (?). even if we assume the dataimputation step was done optimally, it would still not give optimal performance under all mar missingness distributions, and under some settings could produce results which are only half as good as our method (see app. e for such a case). in our experiments, we have applied several data-imputations methods to complete the missing data, followed by classifying its outputs using a standard convnet fitted to the fully-observed training set. we first tested naive heuristics, filling missing values with zeros or the mean pixel value computed over all the images in the dataset. we then tested three generative models: gsn (bengio , 2014), nice (dinh , 2014) and dpm (sohl-dickstein , 2015), which are known to work well for inpainting. gsn was omitted from the norb experiments as we have not manage to properly train it on that dataset. though the data-imputation methods are competitive when only few of the pixels are missing, they all fall far behind our models above a certain threshold, with more than 50 percentage points separating our ght-model from the best data-imputation method under some of the cases. additionally, all the generative models require very long runtimes, which prevents from using them in most real-world applications. while we tried to be as comprehensive as possible when choosing which inpainting methods to use, some of the most recent studies on the subject, e.g. the works of van den oord  (2016) and pathak  (2016), have either not yet published their code or only partially published it. we have also ruled out inpainting algorithms which are made specifically for images, as we did not want to limit the implications of these experiments solely to images.
we have also compared ourselves to the published results of the mpdbm model (goodfellow , 2013). unlike the previous generative models we tested, mpdbm is a generative classifier similar to our method. however, unlike our model, mpdbm does not posses the tractable marginalization nor the tractable inference properties, and uses approximations instead. its lesser performance underlines the importance of these properties for achieving optimality under missing data. an additional factor might also be their training method, which includes randomly picking a subset of variables to act as missing, which might have introduced a bias to the specific missingness distribution used during their training.
in order to demonstrate the ineffectiveness of purely discriminative models, we trained convnets directly on randomly corrupted instances according to pre-selected missingness distributions on the mnist dataset. unlike the previous experiments, we do allow prior knowledge about the missingness distribution during training time. we found that the best results are achieved when replacing missing values with zeros, and adding as an extra input channel the mask of missing values (known as flag data-imputation). the results (see fig. 5) unequivocally show the effectiveness of this method when tested on the same distribution it was trained on, achieving a high accuracy even when only 10% of the pixels are visible. however, when tested on different distributions, whether on a completely different kind or even on the same kind but with different parameters, the accuracy drops by a large factor, at times by more than 35 percentage points. this illustrate the disadvantage of the discriminative method, as it necessarily incorporates bias towards the corruption process it had seen during training, which makes it fail on other distributions. one might wonder whether it is
possible for a single network to be robust on more than a single distribution. we found out that the latter is true, and if we train a network on multiple different missingness distributions1, then the network will achieve good performance on all such distributions, though at some cases not reaching the optimal performance. however, though it is possible to train a network to be robust on more than one distribution, the type of missingness distributions are rarely known in advance, and there is no known method to train a neural network against all possible distributions, limiting the effectivity of this method in practice.
unlike all the above methods, our ght-model, which is trained only once on the clean dataset, match or sometimes even surpass the performance of convnets that are trained and tested on the same distribution, showing it is achieving near optimal performance – as much as possible on any given distribution. additionally, note that similar to convnets and according to the theory in app. c, the deep ght-model is decidedly superior to the shallow gcp-model. experimenting on more complex datasets is left for further research. progress on optimization and regularization of networks based on product pooling (even in log-space) is required, and ways to incorporate larger b×b convolutional operations with overlaps would be useful before we venture into larger and complex datasets. nevertheless, our preliminary results demonstrate an overwhelming advantage of our tmm models compared to competing methods, both in terms of robustness to different types of missing data, as well as in terms of raw performance, with very wide gaps in absolute accuracy than the next best method, at times as large as 50 percentage points more than the next best method.we have introduced a new family of probabilistic models, which we call tensorial mixture models. tmms are based on a simple assumption on the data, which stems from known empirical results on natural images, that gives rise to mixture models with tensorial structure represented by the priors tensor. when the priors tensor is decomposed it gives rise to an arithmetic circuit which in turn transforms the tmm into a convolutional arithmetic circuit (convac). a convac corresponds to a shallow (single hidden layer) network when the priors tensor is decomposed by a cp (sum of rank-1) approach and corresponds to a deep network when the decomposition follows the hierarchical tucker (ht) model.
the convac representation of a tmm possesses several attractive properties. first, the inference is tractable and is implemented by a forward pass through a deep network. second, the architectural design of the model follows the deep networks community design, i.e., the structure of tmms is determined by just two easily understood factors: size of pooling windows and number of channels. finally, we have demonstrated the effectiveness of our model when tackling the problem of classification with missing data, leveraging tmms unique ability of tractable marginalization which leads to optimal classifiers regardless of the missingness distribution.
there are several avenues for future research on tmms which we are currently looking at, including other problems which tmms could solve (e.g. semi-supervised learning), experimenting with other convacs architectures (e.g. through different decompositions), and further progress on optimization and regularization of networks with product pooling.we begin by establishing the minimal background in the field of tensor analysis required for following our work. a tensor is best thought of as a multi-dimensional array ad1,...,dn ∈ r, where ∀i ∈ [n ], di ∈ [mi]. the number of indexing entries in the array, which are also called modes, is referred to as the order of the tensor. the number of values an index of a particular mode can take is referred to as the dimension of the mode. the tensor a ∈ rm1⊗...⊗mn mentioned above is thus of order n with dimension mi in its i-th mode. for our purposes we typically assume that m1 = . . . = mn = m , and simply denote it as a ∈ (rm )⊗n .
the fundamental operator in tensor analysis is the tensor product. the tensor product operator, denoted by ⊗, is a generalization of outer product of vectors (1-ordered vectors) to any pair of tensors. specifically, leta and b be tensors of order p and q respectively, then the tensor product a⊗ b results in a tensor of order p +q, defined by: (a⊗ b)d1,...,dp+q = ad1,...,dp · bdp+1,...,dp+q .
the main concept from tensor analysis we use in our work is that of tensor decompositions. the most straightforward and common tensor decomposition format is the rank-1 decomposition, also known as a candecomp/parafac decomposition, or in short, a cp decomposition. the cp decomposition is a natural extension of low-rank matrix decomposition to general tensors, both built upon the concept of a linear combination of rank-1 elements. similarly to matrices, tensors of the form v(1) ⊗ · · · ⊗ v(n), where v(i) ∈ rmi are non-zero vectors, are regarded as n -ordered rank-1 tensors, thus the rank-z cp decomposition of a tensor a is naturally defined by:
a = z∑ z=1 aza z,1 ⊗ · · · ⊗ az,n
⇒ ad1,...,dn = z∑ z=1 az n∏ i=1 az,idi (7)
where {az,i ∈ rmi}n,zi=1,z=1 and a ∈ r z are the parameters of the decomposition. as mentioned above, for n = 2 it is equivalent to low-order matrix factorization. it is simple to show that any tensor a can be represented by the cp decomposition for some z, where the minimal such z is known as its tensor rank.
another decomposition we will use in this paper is of a hierarchical nature and known as the hierarchical tucker decomposition (hackbusch and kühn, 2009), which we will refer to as ht decomposition. while the cp decomposition combines vectors into higher order tensors in a single step, the ht decomposition does that more gradually, combining vectors into matrices, these matrices into 4th ordered tensors and so on recursively in a hierarchically fashion. specifically, the following describes the recursive formula of the ht decomposition2  more precisely, we use a special case of the canonical ht decomposition as presented in hackbusch and kühn (2009). in the terminology of the latter, the matrices al,j,γ are diagonal and equal to diag(al,j,γ) (using the notations from eq. 8).
for a tensor a ∈ (rm )⊗n where n = 2l, i.e. n is a power of two3:
φ1,j,γ = r0∑ α=1 a1,j,γα a 0,2j−1,α ⊗ a0,2j,α
· · ·
φl,j,γ = rl−1∑ α=1
al,j,γα φ l−1,2j−1,α︸ ︷︷ ︸ order 2l−1 ⊗φl−1,2j,α︸ ︷︷ ︸ order 2l−1
· · ·
φl−1,j,γ = rl−2∑ α=1 al−1,j,γα φ l−2,2j−1,α︸ ︷︷ ︸
order n 4
⊗φl−2,2j,α︸ ︷︷ ︸ order n  a = rl−1∑ α=1
alα φ l−1,1,α︸ ︷︷ ︸ order n 
⊗φl−1,2,α︸ ︷︷ ︸ order n 
(8)
where the parameters of the decomposition are the vectors {al,j,γ∈rrl−1}l∈{0,...,l−1},j∈[n/2l],γ∈[rl] and the top level vector al ∈ rrl−1 , and the scalars r0, . . . , rl−1 ∈ n are referred to as the ranks of the decomposition. similar to the cp decomposition, any tensor can be represented by an ht decomposition. moreover, any given cp decomposition can be converted to an ht decomposition by only a polynomial increase in the number of parameters.
the relationship between tensor decomposition and networks arises from the simple observation that through decomposition one can tradeoff storage complexity with computation where the type of computation consists of sums and products. specifically, tensor decompositions could be seen as a mapping, that takes a tensor of exponential size and converts it into a polynomially sized representation, coupled with a decoding algorithm of polynomial runtime complexity to retrieve the original entries of tensor – essentially trading off space complexity for computational complexity. examining the decoding algorithms for the cp and ht decompositions, i.e. eq. 7 and eq. 8, respectively, reveal a shared framework for representing these algorithms via computation graphs of products and weighted sums, also known as arithmetic circuits (shpilka and yehudayoff, 2010) or sum-product networks (poon and domingos, 2011). more specifically, these circuits take as inputn indicator vectors δ1, . . . , δn , representing the coordinates (d1, . . . , dn ), where δi = 1[j=di], and output the value of ad1,...,dn . in the case of the cp decomposition, the matching decoding circuit is defined by eq. 9 below:
az,idi = m∑ d=1 az,id δid ⇒ ad1,...,dn = z∑ z=1 az n∏ i=1 m∑ d=1 az,id δid (9)
the above formula is better represented by the network illustrated in fig. 6, beginning with an input layer of√ n × √ n m -dimensional indicator vectors arranged in a 3d array, followed by a 1 × 1 conv operator, a global product pooling layer, and ends with a dense linear layer outputtingad1,...,dn . the conv operator is not unlike the standard convolutional layer of convnets, with the sole difference being that it may operate without coefficient sharing, i.e. the filters that generate feature maps by sliding across the previous layer may have different coefficients at different spatial locations. this is often referred to in the deep learning community as a locally-connected operator (taigman , 2014). similarly to the cp decomposition, retrieving the entries of a tensor from its ht decomposition can be computed by the circuit represented in fig. 7, where instead of a single pair of conv and pooling layers there are log2 n such pairs, with pooling windows of size 2. though the canonical ht decomposition dictates size 2 pooling windows, any pooling structure used in practice still results in a valid ht decomposition.
arithmetic circuits constructed from the above conv and product pooling layers are called convolutional arithmetic circuits, or convacs for short, first suggested by cohen  (2016a) as a theoretical framework for studying standard convolutional networks, sharing many of the defining traits of the latter, most noteworthy, the locality, sharing and pooling properties of convnets. unlike general circuits, the structure of the network is determined solely by two parameters, the number of channels of each conv layer and the size of pooling windows, which indirectly controls the depth of the network. the requirement for n to be a power of two is solely for simplifying the definition of the ht decomposition. more generally, instead of defining it through a complete binary tree describing the order of operations, the canonical decomposition can use any balanced binary tree.in this section we prove the universality property of tmms, as discussed in sec. 3. we begin by taking note from functional analysis and define a new property called pdf total set, which is similar in concept to a total set, followed by proving that this property is invariant under the cartesian product of functions, which entails the universality of tmms as a corollary. definition 1. let f be a set of pdfs over rs. f is pdf total iff for any pdf h(x) over rs and for all > 0 there exists m ∈ n, {f1(x), . . . , fm (x)} ⊂ f and w ∈ 4m−1 s.t. ∥∥∥h(x)−∑mi=1 wifi(x)∥∥∥ 1 < . in other words, a set is a pdf total set if its convex span is a dense set under l1 norm.
claim 2. let f be a set of pdfs over rs and let f⊗n = { ∏n i=1 fi(x)|∀i, fi(x) ∈ f} be a set of pdfs over the product space (rs)n . if f is a pdf total set then f⊗n is pdf total set.
proof. if f is the set of gaussian pdfs over rs with diagonal covariance matrices, which is known to be a pdf total set, then f⊗n is the set of gaussian pdfs over (rs)n with diagonal covariance matrices and the claim is trivially true.
otherwise, let h(x1, . . . ,xn ) be a pdf over (rs)n and let > 0. from the above, there exists k ∈ n, w ∈ 4m1−1 and a set of diagonal gaussians {gij(x)}i∈[m1],j∈[n ] s.t.∥∥∥∥∥g(x)− m1∑ i=1 wi n∏ j=1 gij(xj) ∥∥∥∥∥ 1 < 2 (10) additionally, since f is a pdf total set then there exists m2 ∈ n, {fk(x)}k∈[m2] ⊂ f and {wij ∈ 4m2−1}i∈[m1],j∈[n ] s.t. for all i ∈ [m1], j ∈ [n ] it holds that ∥∥∥gij(x)−∑m2k=1 wijkfk(x)∥∥∥ 1 < 2n , from which it is trivially proven using a telescopic sum and the triangle inequality that:∥∥∥∥∥ m1∑ i=1 wi n∏ j=1 gij(x)− m1∑ i=1 wi n∏ j=1 m2∑ k=1 wijkfk(xj) ∥∥∥∥∥ 1 < 2 (11) from eq. 10, eq. 11 the triangle inequality it holds that:∥∥∥∥∥∥g(x)− m2∑
k1,...,kn=1
ak1,...,kn n∏ j=1 fkj (xj) ∥∥∥∥∥∥ 1 <
where ak1,...,kn = ∑m1 i=1 wi ∏n j=1 wijkj which holds ∑m2 k1,...,kn=1 ak1,...,kn = 1. taking m = m n 2 ,
{ ∏n j=1 fkj (xj)}k1∈[m2],...,kn∈[m2] ⊂ f ⊗n and w = vec(a) completes the proof.
corollary 2. let f be a pdf total set of pdfs over rs, then the family of tmms with mixture components from f can approximate any pdf over (rs)n arbitrarily well, given arbitrarily many components.the expressiveness of convacs has been extensively studied, and specifically the non-generative variants of our models, named cp-model and ht-model respectively. in cohen  (2016a) it was shown that convacs
posses the property known as complete depth efficiency. namely, almost all functions4 realized by an ht-model of polynomial size, for them to be realized (or approximated) by a cp-model, require it to be of exponential size. in other words, the expressiveness borne out of depth is exponentially stronger than a shallow network, almost always. it is worth noting that in the followup paper (cohen and shashua, 2016a), the authors have shown that the same result does not hold for standard convnets – while there are specific instances where depth efficiency holds, it is not complete, i.e. there is a non-zero probability that a function realized by a polynomially sized deep convnet can also be realized by a polynomially sized shallow convnet. despite the additional simplex constraints put on the parameters, complete depth efficiency does hold for the generative convacs of our work, proof of which can be found in app. d, which shows the advantage of the deeper ght-model over the shallow gcp-model. additionally, this illustrates how the two factors controlling the architecture – number of channels and size of pooling windows – control the expressive capacity of the ght-model. while the above shows why the deeper ght-model is preferred over the shallow gcp-model, there is still the question of whether a polynomially sized ght-model is sufficient for describing the complexities of natural data. though a complete and definite answer is unknown as of yet, there are some strong theoretical evidence that it might. one aspect of being sufficient for modeling natural data is the ability of the model to describe the dependency structures typically found in the data. in cohen and shashua (2016b), the authors studied the separation rank – a measure of correlation, which for a given input partition, measures how far a function is from being separable – and found that a polynomially sized ht-model is capable of exponential separation rank for interleaved partitions, i.e. that it can model high correlations in local areas in the input. additionally, for non-contiguous partitions, the separation rank can be at most polynomial, i.e. it can only model a limited correlation between far away areas in the input. these two results combined suggest that the ht-model, and thus also our ght-model, is especially fit for modeling the type of correlations typically found in natural images and audio, even if it is only of polynomial size. finally, from an empirical perspective, convolutional hierarchical structures have shown great success on multitude of different domains and tasks. our models leverage these structures, taking them to a probabilistic setting, which leads us to believe that they will be able to effectively model distributions in practice – a belief we verify by experiments.in this section we prove that the depth efficiency property of convacs proved in cohen  (2016a) applies also to the generative convacs we have introduced in sec. 3.2. more specifically, we prove the following theorem, which is the generative analog of theorem 1 from (cohen , 2016a): theorem 1. let ay be a tensor of order n and dimension m in each mode, generated by the recursive formulas in eq. 8, under the simplex constraints introduced in sec. 3.2. define r := min{r0,m}, and consider the space of all possible configurations for the parameters of the decomposition – {al,j,γ ∈ 4rl−1−1}l,j,γ . in this space, the generated tensoray will have cp-rank of at least rn/2 almost everywhere (w.r.t. the product measure of simplex spaces). put differently, the configurations for which the cp-rank of ay is less than rn/2 form a set of measure zero. the exact same result holds if we constrain the composition to be “shared”, i.e. sj,γ ≡ al,γ and consider the space of {al,γ ∈ 4rl−1−1}l,γ configurations.
the only differences between convacs and their generative counter-parts are the simplex constraints applied to the parameters of the models, which necessitate a careful treatment to the measure theoretical arguments of the original proof. more specifically, while the k-dimensional simplex4k is a subset of the k+ 1-dimensional space rk+1, it has a zero measure with respect to the lebesgue measure over rk+1. the standard method to define a measure over 4k is by the lebesgue measure over rk of its projection to that space, i.e. let λ : rk → r be the lebesgue measure over rk, p : rk+1 → rk, p(x) = (x1, . . . , xk)t be a projection, and a ⊂ 4k be a subset of the simplex, then the latter’s measure is defined as λ(p(a)). notice that p(4k) has a positive measure, and moreover that p is invertible over the set p(4k), and that its inverse is given by p−1(x1, . . . , xk) = (x1, . . . , xk, 1 − ∑k i=1 xi). in our case, the parameter space is the cartesian product of several simplex spaces of different dimensions, for each of them the measure is defined as above, and the measure over their cartesian product is uniquely defined by the product measure. though standard, the choice of the projection function p above could be seen as a limitation, however, the set of zero measure sets in 4k is identical for any reasonable choice of a projection π (e.g. all polynomial mappings). more specifically, for any projection π : rk+1 → rk that is invertible over π(4k), π−1 is differentiable, and the jacobian of π−1 is bounded over π(4k), then a subset a ⊂ 4k is of measure zero w.r.t. the projection π iff it is of measure zero w.r.t. p (as defined above). this implies that if we sample the weights of the generative decomposition (eq. 8 with simplex constraints) by a continuous distribution, a property that holds with probability 1 under the standard parameterization (projection p), will hold with probability 1 under any reasonable parameterization. ”almost all functions” in this context means, that for any continuous distribution over the parameters of the ht-model, with probability one the following statement is true for a function realized by an ht-model with sampled parameters.
we now state and prove a lemma that will be needed for our proof of theorem 1.
lemma 1. let m,n,k ∈ n, 1 ≤ r ≤ min{m,n} and a polynomial mapping a : rk → rm×n (i.e. for every i ∈ [m ], j ∈ [n ] then aij : rk → r is a polynomial function). if there exists a point x ∈ rk s.t. rank (a(x)) ≥ r, then the set {x ∈ rk |rank (a(x)) < r} has zero measure.
proof. remember that rank (a(x)) ≥ r iff there exits a non-zero r × r minor of a(x), which is polynomial in the entries of a(x), and so it is polynomial in x as well. let c = ( m r ) · ( n r ) be the number of minors in a,
denote the minors by {fi(x)}ci=1, and define the polynomial function f(x) = ∑c i=1 fi(x) . it thus holds that f(x) = 0 iff for all i ∈ [c] it holds that fi(x) = 0, i.e. f(x) = 0 iff rank (a(x)) < r.
now, f(x) is a polynomial in the entries of x, and so it either vanishes on a set of zero measure, or it is the zero polynomial (see caron and traynor (2005) for proof). since we assumed that there exists x ∈ rk s.t. rank(a(x)) ≥ r, the latter option is not possible.
following the work of cohen  (2016a), our main proof relies on following notations and facts:
• we denote by [a] the matricization of an n -order tensor a (for simplicity, n is assumed to be even), where rows and columns correspond to odd and even modes, respectively. specifically, if a ∈ rm1×···mn , the matrix [a] has m1 ·m3 · . . . ·mn−1 rows and m2 ·m4 · . . . ·mn columns, rearranging the entries of the tensor such that ad1,...,dn is stored in row index 1 + ∑n/2 i=1(d2i−1 − ) ∏n/2 j=i+1 m2j−1 and column index 1 + ∑n/2 i=1(d2i − 1) ∏n/2 j=i+1 m2j . additionally, the matricization is a linear operator, i.e. for all scalars α1, α2 and tensors a1,a2 with the order and dimensions in every mode, it holds that [α1a1 + α2a2] = α1[a1] + α2[a2].
• the relation between the kronecker product (denoted by ) and the tensor product (denoted by ⊗) is given by [a⊗ b] = [a] [b].
• for any two matrices a and b, it holds that rank (a b) = rank (a) · rank (b). • let z be the cp-rank of a, then it holds that rank ([a]) ≤ z (see (cohen , 2016a) for proof).
proof of theorem 1. stemming from the above stated facts, to show that the cp-rank of ay is at least rn/2, it is sufficient to examine its matricization [ay] and prove that rank ([ay]) ≥ rn/2.
notice from the construction of [ay], according to the recursive formula of the ht-decomposition, that its entires are polynomial in the parameters of the decomposition, its dimensions are mn/2 each and that 1 ≤ rn/2 ≤ mn/2. in accordance with the discussion on the measure of simplex spaces, for each vector parameter al,j,γ ∈ 4rl−1−1, we instead examine its projection ãl,j,γ = p(al,j,γ) ∈ rrl−1−1, and notice that p−1(ãl,j,γ) is a polynomial mapping5 w.r.t. ãl,j,γ . thus, [ay] is a polynomial mapping w.r.t. the projected parameters {ãl,j,γ}l,j,γ , and using lemma 1 it is sufficient to show that there exists a set of parameters for which rank ([ay]) ≥ rn/2.
denoting for convenience φl,1,1 := ay and rl = 1, we will construct by induction over l = 1, ..., l a set of parameters, {al,j,γ}l,j,γ , for which the ranks of the matrices {[φl,j,γ ]}j∈[n/2l],γ∈[rl] are at least r l/2, while enforcing the simplex constraints on the parameters. more so, we’ll construct these parameters s.t. al,j,γ = al,γ , thus proving both the ”unshared” and ”shared” cases.
for the case l = 1 we have:
φ1,j,γ = r0∑ α=1 a1,j,γα a 0,2j−1,α ⊗ a0,2j,α
and let a1,j,γα = 1α≤r r and a0,j,αi = 1α=i for all i, j, γ and α ≤ m , and a 0,j,α i = 1i=1 for all i and α > m , and so
[φ1,j,γ ]i,j = { 1/r i = j ∧ i ≤ r 0 otherwise
which means rank ( [φ1,j,γ ] ) = r, while preserving the simplex constraints, which proves our inductive hypothesis for l = 1. as we mentioned earlier, p is invertible only over p(4k), for which its inverse is given by p−1(x1, . . . , xk) = (x1, . . . , xk, 1 − ∑k i=1 xi). however, to simplified the proof and notations, we use p −1 as defined here over the entire range rk−1, even where it does not serve as the inverse of p.
assume now that rank ( [φl−1,j ′,γ′ ] ) ≥ r2
l−1/2 for all j′ ∈ [n/2l−1] and γ′ ∈ [rl−1]. for some specific choice of j ∈ [n/2l] and γ ∈ [rl] we have:
φl,j,γ = rl−1∑ α=1 al,j,γα φ l−1,2j−1,α ⊗ φl−1,2j,α
=⇒ [φl,j,γ ] = rl−1∑ α=1 al,j,γα [φ l−1,2j−1,α] [φl−1,2j,α]
denote mα := [φl−1,2j−1,α] [φl−1,2j,α] for α = 1, ..., rl−1. by our inductive assumption, and by the general property rank (a b) = rank (a) · rank (b), we have that the ranks of all matricesmα are at least r 2l−1/2 · r2 l−1/2 = r 2l/2. writing [φl,j,γ ] = ∑rl−1 α=1 a l,j,γ α ·mα, and noticing that {mα} do not depend on al,j,γ , we simply pick al,j,γα = 1α=1, and thus φl,j,γ = m1, which is of rank r 2l/2. this completes the proof of the theorem.
from the perspective of tmms, theorem 1 leads to the following corollary:
corollary 3. assume the mixing componentsm = {fi(x) ∈ l2(r2)∩l1(rs)}mi=1 are square integrable6 probability density functions, which form a linearly independent set. consider a deep ght-model of polynomial size whose parameters are drawn at random by some continuous distribution. then, with probability 1, the distribution realized by this network requires an exponential size in order to be realized (or approximated w.r.t. the l2 distance) by the shallow gcp-model. the claim holds regardless of whether the parameters of the deep ght-model are shared or not.
proof. given a coefficient tensora, the cp-rank ofa is a lower bound on the number of channels (denoted by z in the body of the article) required to represent that tensor by the convac following the cp decomposition as introduced in sec. 2. additionally, since the mixing components are linearly independent, their products { ∏n i=1 fi(xi)|fi ∈ m} are linearly independent as well, which entails that any distribution representable by the tmm with mixing components m has a unique coefficient tensor a. from theorem 1, the set of parameters of a polynomial ght-model with a coefficient tensor of a polynomial cp-rank, the requirement for a polynomial gcp-model realizing that distribution exactly, forms a set of measure zero.
it is left to prove, that not only is it impossible to exactly represent a distribution with an exponential coefficient tensor by a gcp-model, it is also impossible to approximate it. this follows directly from lemma 7 in appendix b of cohen  (2016a), as our case meets the requirement of that lemma.in this section we give short proofs for the claims from sec. 5, on the optimality of the marginalized bayes predictor under missing-at-random (mar) distribution, when the missingness mechanism is unknown, as well as the general case when we do not add additional assumptions. in addition, we will also present a counter example proving data imputation results lead to suboptimal classification performance. we begin by introducing several notations that augment the notations already introduced in the body of the article.
given a specific mask realization m ∈ {0, 1}s, we use the following notations to denote partial assignments to the random vector x . for the observed indices of x , i.e. the indices for which mi = 1, we denote a partial assignment by x \m = xo, where xo ∈ rdo is a vector of length do equal to the number of observed indices. similarly, we denote by x ∩ m = xm a partial assignment to the missing indices according to m, where xm ∈ rdm is a vector of length dm equal to the number of missing indices. as an example of the notation, for given realizations x ∈ rs and m ∈ {0, 1}s, we defined in sec. 5 the event o(x,m), which using current notation is marked by the partial assignment x \m = xo where xo matches the observed values of the vector x according to m.
with the above notations in place, we move on to prove claim 1, which describes the general solution to the optimal prediction rule given both the data and missingness distributions, and without adding any additional assumptions. it is important to note that most commonly used distribution functions are square integrable, e.g. most members of the exponential family such as the gaussian distribution.
proof of claim 1. fix an arbitrary prediction rule h. we will show that l(h∗) ≤ l(h), where l is the expected 0-1 loss. − l(h)=e(x,m,y)∼(x ,m,y)[1h(x m)=y] = ∑
m∈{0,1}s ∑ y∈[k] ∫ rs p(m=m,x=x,y=y)1h(x m)=ydx
= ∑
m∈{0,1}s ∑ y∈[k] ∫ rdo ∫ rdm p(m=m,x\m=xo,x∩m=xm,y=y)1h(x⊗m)=ydxodxm
=1 ∑
m∈{0,1}s ∑ y∈[k] ∫ rdo 1h(x m)=ydxo ∫ rdm p(m=m,x\m=xo,x∩m=xm,y=y)dxm
=2 ∑
m∈{0,1}s ∑ y∈[k] ∫ rdo 1h(x m)=yp(m=m,x\m=xo,y=y)dxo
=3 ∑
m∈{0,1}s
∫ rdo p(x\m=xo) ∑ y∈[k] 1h(x m)=yp(y=y|x\m=xo)p(m=m|x\m=xo,y=y)dxo
≤4 ∑
m∈{0,1}s
∫ rdo p(x\m=xo) ∑ y∈[k] 1h∗(x m)=yp(y=y|x\m=xo)p(m=m|x\m=xo,y=y)dxo
=1− l(h∗) where (1) is because the output of h(x m) is independent of the missing values, (2) by marginalization, (3) by conditional probability definition and (4) because by definition h∗(x m) maximizes the expression p(y=y|x\m=xo)p(m=m|x\m=xo,y=y) w.r.t. the possible values of y for fixed vectors m and xo. finally, by replacing integrals with sums, the proof holds exactly the same when instances (x ) are discrete.
we now continue and prove corollary 1, a direct implication of claim 1 which shows that in the mar setting, the missingness distribution can be ignored, and the optimal prediction rule is given by the marginalized bayes predictor.
proof of corollary 1. using the same notation as in the previous proof, and denoting by xo the partial vector containing the observed values of x m, the following holds:
p(m=m|o(x,m),y=y) := p(m=m|x\m=xo,y=y)
= ∫ rdm p(m=m,x ∩m=xm|x\m=xo,y=y)dxm
= ∫ rdm p(x∩m=xm|x\m=xo,y=y) · p(m=m|x∩m=xm,x\m=xo,y=y)dxm
=1 ∫ rdm p(x∩m=xm|x\m=xo,y=y) · p(m=m|x∩m=xm,x\m=xo)dxm
=2 ∫ rdm p(x∩m=xm|x\m=xo,y=y) · p(m=m|x\m=xo)dxm
=p(m=m|x\m=xo) ∫ rdm p(x∩m=xm|x\m=xo,y=y)dxm
=p(m=m|o(x,m)) where (1) is due to the independence assumption of the events y = y andm = m conditioned on x = x, while noting that (x \m = xo) ∧ (x ∩m = xm) is a complete assignment of x . (2) is due to the mar assumption, i.e. that for a given m and xo it holds for all xm ∈ rdm :
p(m=m|x\m=xo,x∩m=xm) = p(m=m|x\m=xo) we have shown that p(m=m|o(x,m),y = y) does not depend on y, and thus does not affect the optimal prediction rule in claim 1. it may therefore be dropped, and we obtain the marginalized bayes predictor.
having proved that in the mar setting, classification through marginalization leads to optimal performance, we now move on to show that the same is not true for classification through data-imputation. though there are many methods to perform data-imputation, i.e. to complete missing values given the observed ones, all of these methods can be seen as the solution of the following optimization problem, or more typically its approximation:
g(x m) = argmax x′∈rs∧∀i:mi=1→x′i=xi
p(x = x′)
where g(x m) is the most likely completion of x m. when data-imputation is carried out for classification purposes, one is often interested in data-imputation conditioned on a given class y = y, i.e.:
g(x m; y) = argmax x′∈rs∧∀i:mi=1→x′i=xi
p(x = x′|y = y)
given a classifier h : rs → [k] and an instance x with missing values according to m, classification through data-imputation is simply the result of applying h on the output of g. when h is the optimal classifier for complete data, i.e. the bayes predictor, we end up with one of the following prediction rules:
unconditional: h(x m) = argmax y p(y = y|x = g(x m))
conditional: h(x m) = argmax y p(y = y|x = g(x m; y))
claim 3. there exists a data distribution d and mar missingness distribution q s.t. the accuracy of classification through data-imputation is almost half the accuracy of the optimal marginalized bayes predictor, with an absolute gap of more than 33 percentage points.
proof. for simplicity, we will give an example for a discrete distribution over the binary set x ×y = {0, 1}2 × {0, 1}. let 1> > 0 be some small positive number, and we defined according to table 2, where each triplet (x1, x2, y) ∈ x×y is assigned a positive weight, which through normalization defines a distribution over x×y . the missingness distribution q is defined s.t. pq(m1 = 1,m2 = 0|x = x) = 1 for all x ∈ x , i.e. x1 is always observed andx2 is always missing, which is a trivial mar distribution. given the above data distribution d, we can easily calculate the exact accuracy of the optimal data-imputation classifier and the marginalized bayes predictor under the missingness distribution q, as well as the standard bayes predictor under full-observability. first notice that whether we apply conditional or unconditional data-imputation, and whether x1 is equal to 0 or 1, the completion will always be x2 = 1 and the predicted class will always be y = 1. since the data-imputation classifiers always predict the same class y = 1 regardless of their input, the probability of success is simply the probability p (y = 1) = 1+  (for = 10−4 it equals approximately 3.337%). similarly, the marginalized bayes predictor always predicts y = 0 regardless of its input, and so its probability of success is p (y = 0) = 2−  (for = 10−4 it equals approximately 66.663%), which is
almost double the accuracy achieved by the data-imputation classifier. additionally, notice that the marginalized bayes predictor achieves almost the same accuracy as the bayes predictor under full-observability, which equals exactly 2  .experiments are meaningful only if they could be reproduced by other proficient individuals. providing sufficient details to enable others to replicate our results is the goal of this section. we hope to accomplish this by making our code public, as well as documenting our experiments to a sufficient degree allowing for their reproduction from scratch. our complete implementation of the models presented in this paper, as well as our modifications to other open-source projects and scripts used in the process of conducting our experiments, are available at our github repository: https://github.com/huji-deep/tmm. we additionally wish to invite readers to contact the authors, if they deem the following details insufficient in their process to reproduce our results.in the following we give concise descriptions of each classification method we have used in our experiments. the results of the experiment on mp-dbm (goodfellow , 2013) were taken directly from the paper and
were not conducted by us, hence we do not cover it in this section. we direct the reader to that article for exact details on how to reproduce their results.in dekel and shamir (2008), binary linear classifiers were trained by formulating their optimization as a quadric program under the constraint that some of its features could be deleted, i.e. their original value was changed to zero. while the original source code was never published, the authors have kindly agreed to share with us their code, which we used to reproduced their results, but on larger datasets. the algorithm has only a couple hyper-parameters, which were chosen by a grid-search through a cross-validation process. for details on the exact protocol for testing binary classifiers on missing data, please see sec. f.2.1.k-nearest neighbors (knn) is a classical machine learning algorithm used for both regression and classification tasks. its underlying mechanism is finding the k nearest examples (called neighbors) from the training set, (x1, y1), . . . , (xk, yk) ∈ s, according to some metric function d(·, ·) : x × x → r+, after which a summarizing function f is applied to the targets of the k nearest neighbors to produce the output y∗ = f(y1, . . . , yk). when knn is used for classification, f is typically the majority voting function, returning the class found in most of the k nearest neighbors.
in our experiments we use knn for classification with missing data, where the training set consists of complete examples with no missing data, but at classification time the inputs have missing values. given an input with missing values x m and an example x′ from the training set, we use a modified euclidean distance metric, where we compare the distance only against the non-missing coordinates of x, i.e. the metric is defined by d(x′,x m) = ∑ i:mi=1 (x′i − xi) 2. through a process of cross-validation we have chosen k = 5 for all of our experiments. our implementation of knn is based on the popular scikit-learn python library (pedregosa , 2011).the most widespread and successful discriminative method nowadays are convolutional neural networks (convnets). standard convnets are represented by a computational graph consisted of different kinds of nodes, called layers, with a convolutional-like operators applied to their inputs, followed by a non-linear point-wise activation function, e.g. max(0, x) known as relu.
for our experiments on mnist, both with and without missing data, we have used the lenet convnet architecture (lecun , 1998) that is bundled with caffe (jia , 2014), trained for 20,000 iterations using sgd with 0.9 momentum and 0.01 base learning rate, which remained constant for 10,000 iterations, followed by a linear decrease to 0.001 for another 5,000 iterations, followed by a linear decrease to 0 learning rate for the remaining 5,000 iterations. the model also used l2-regularization (also known as weight decay), which was chosen through cross-validation for each experiment separately. no other modifications were made to the model or its training procedure.
for our experiments on norb, we have used an ensemble of 3 convnets, each using the following architecture: 5×5 convolution with 128 output channels, 3×3 max pooling with stride 2, relu activation, 5×5 convolution with 128 output channels, relu activation, dropout layer with probability 0.5, 3×3 average pooling with stride 2, 5×5 convolution with 256 output channels, relu activation, dropout layer with probability 0.5, 3×3 average pooling with stride 2, fully-connected layer with 768 output channels, relu activation, dropout layer with probability 0.5, and ends with fully-connected layer with 5 output channels. the stereo images were represented as a two-channel input image when fed to the network. during training we have used data augmentation consisting of randomly scaling and rotation transforms. the networks were trained for 40,000 iterations using sgd with 0.99 momentum and 0.001 base learning rate, which remained constant for 30,000 iterations, followed by a linear decrease to 0.0001 for 6000 iterations, followed by a linear decrease to 0 learning rate for the remaining 4,000 iterations. the model also used 0.0001 weight decay for additional regularization.
when convnets were trained on images containing missing values, we passed the network the original image with missing values zeroed out, and an additional binary image as a separate channel, containing 1 for missing values at the same spatial position, and 0 otherwise – this missing data format is sometimes known as flag data imputation. other formats for representing missing values were tested (e.g. just using zeros for missing values), however, the above scheme performed significantly better than other formats. in our experiments, we assumed that the training set was complete and missing values were only present in the test set. in order to design convnets that are robust against specific missingness distributions, we have simulated missing values during training, sampling a different mask of missing values for each image in each mini-batch. as covered in sec. 6, the results of training convnets directly on simulated missingness distributions resulted in classifiers
which were biased towards the specific distribution used in training, and performed worse on other distributions compared to convnets trained on the same distribution.
in addition to training convnets directly on missing data, we have also used them as the classifier for testing different data imputation methods, as describe in the next section.the most common method for handling missing data, while leveraging available discriminative classifiers, is through the application of data imputation – an algorithm for the completion of missing values – and then passing the results to a classifier trained on uncorrupted dataset. we have tested five different types of data imputation algorithms:
• zero data imputation: replacing every missing value by zero. • mean data imputation: replacing every missing value by the mean value computed over the dataset. • generative data imputation: training a generative model and using it to complete the missing values
by finding the most likely instance that coincides with the observed values, i.e. solving the following
g(x m) = argmax x′∈rs∧∀i,mi=1→x′i=xi
p (x = x′)
we have tested the following generative models:
– generative stochastic networks (gsn) (bengio , 2014): we have used their original source code from https://github.com/yaoli/gsn, and trained their example model on mnist for 1000 epochs. whereas in the original article they have tested completing only the left or right side of a given image, we have modified their code to support general masks. our modified implementation can be found at https://github.com/huji-deep/gsn.
– non-linear independent components estimation (nice) (dinh , 2014): we have used their original source code from https://github.com/laurent-dinh.ice, and trained it on mnist using their example code without changes. similarly to our modification to the gsn code, here too we have adapted their code to support general masks over the input. additionally, their original inpainting code required 110,000 iterations, which we have reduced to just 8,000 iterations, since the effect on classification accuracy was marginal. for the norb dataset, we have used their cifar10 example, with lower learning rate of 10−4. our modified code can be found at https://github.com/huji-deep.ice.
– diffusion probabilistic models (dpm) (sohl-dickstein , 2015): we have user their original source code from https://github.com/sohl-dickstein/ diffusion-probabilistic-models, and trained it on mnist using their example code without changes. similarly to our modifications to gsn, we have add support for a general mask of missing values, but other than that kept the rest of the parameters for inpainting unchanged. for norb we have used the same model as mnist. we have tried using their cifar10 example for norb, however, it produced exceptions during training. our modified code can be found at https://github.com/huji-deep/diffusion-probabilistic-models.for a complete theoretical description of our model please see the body of the article. our models were implemented by performing all intermediate computations in log-space, using numerically aware operations. in practiced, that meant our models were realized by the simnets architecture (cohen and shashua, 2014; cohen , 2016b), which consists of similarity layers representing gaussian distributions, mex layers representing weighted sums performed on log-space input and outputs, as well as standard pooling operations. the learned parameters of the mex layers are called offsets, which represents the weights of the weighted sum, but saved in log-space. the parameters of the mex layers can be optionally shared between spatial regions, or alternatively left with no parameter sharing at all. additionally, when used to implement our generative models, the offsets are normalized to have a soft-max (i.e., log (∑ i exp(xi) ) ) of zero.
the network architectures we have tested in this article, consists of m different gaussian mixture components with diagonal covariance matrices, over non-overlapping patches of the input of size 2× 2, which were implemented by a similarity layer as specified by the simnets architecture, but with an added gaussian normalization term.
we first describe the architectures used for the mnist dataset. for the gcp-model, we used m = 800, and following the similarity layer is a 1 × 1 mex layer with no parameter sharing over spatial regions and 10 output channels. the model ends with a global sum pooling operation, followed by another 1 × 1 mex layer
with 10 outputs, one for each class. the ght-model starts with the similarity layer with m = 32, followed by a sequence of four pairs of 1 × 1 mex layer followed by 2 × 2 sum pooling layer, and after the pairs and additional 1 × 1 mex layer lowering the outputs of the model to 10 outputs as the number of classes. the number of output channels for each mex layer are as follows 64-128-256-512-10. all the mex layers in this network do not use parameter sharing, except the first mex layer, which uses a repeated sharing pattern of 2 × 2 offsets, that analogous to a 2 × 2 convolution layer with stride 2. both models were trained with the losses described in sec. 4, using the adam sgd variant for optimizing the parameters, with a base learning rate of 0.03, and β1 = β2 = 0.9. the models were trained for 25,000 iterations, where the learning rate was dropped by 0.1 after 20,000 iterations.
for the norb dataset, we have trained only the ght-model with m = 128 for the similarity layer. the mex layers use the same parameter sharing scheme as the one for mnist, and the number of output channels for each mex layer are as follows: 256-256-256-512-5. training was identical to the mnist models, with the exception of using 40,000 iterations instead of just 25,000. additionally, we have used an ensemble of 4 models trained separately, each trained using a different generative loss weight (see below for more information). we have also used the same data augmentation methods (scaling and rotation) which were used in training the convnets for norb used in this article.
the standard l2 weight regularization (sometimes known as weight decay) did not work well on our models, which lead us to adapt it to better fit to log-space weights, by minimizing λ ∑ i (exp (xi))  instead of λ||x||2 = λ ∑ i x 2 i , where the parameter λ was chosen through cross-validation. additionally, since even with large values of λ our model was still overfitting, we have added another form of regularization in the form of random marginalization layers. a random marginalization layer, is similar in concept to dropout, but instead of zeroing activations completely in random, it choses spatial locations at random, and then zero out the activations at those locations for all the channels. under our model, zeroing all the activations in a layer at a specific location, is equivalent to marginalizing over all the inputs for the receptive field for that respective location. we have used random marginalization layers in between all our layers during training, where the probability for zeroing out activations was chosen through cross-validation for each layer separately. though it might raise concern that random marginalization layers could lead to biased results toward the missingness distributions we have tested it on, in practice the addition of those layers only helped improve our results under cases where only few pixels where missing.
finally, we wish to discuss a few optimization tricks which had a minor effects compared to the above, but were nevertheless very useful in achieving slightly better results. first, instead of optimizing directly the objective defined by eq. 4, we add smoothing parameter β between the two terms, as follows:
θ∗ = argmin θ − |s|∑ i=1 log enθ(x (i);y (i))∑k y=1 e nθ(x (i);y) − β |s|∑ i=1 log k∑ y=1 enθ(x (i);y)
setting β too low diminish the generative capabilities of our models, while setting it too high diminish the discriminative performance. through cross-validation, we decided on the value β = 0.01 for the models trained on mnist, while for norb we have used a different value of β for each of the models, ranging in {0.01, 0.1, 0.5, 1}. second, we found that performance increased if we normalized activations before applying the 1 × 1 mex operations. specifically, we calculate the soft-max over the channels for each spatial location which we call the activation norm, and then subtract it from every respective activation. after applying the mex operation, we add back the activation norm. though might not be obvious at first, subtracting a constant from the input of a mex operation and adding it to its output is equivalent does not change the mathematical operation. however, it does resolve the numerical issue of adding very large activations to very small offsets, which might result in a loss of precision. finally, we are applying our model in different translations of the input and then average the class predictions. since our model can marginalize over inputs, we do not need to crop the original image, and instead mask the unknown parts after translation as missing. applying a similar trick to standard convnets on mnist does not seem to improve their results. we believe this method is especially fit to our model, is because it does not have a natural treatment of overlapping patches like convnets do, and because it is able to marginalize over missing pixels easily, not limiting it just to crop translation as is typically done.in this section we will give a detailed description of the protocol we have used during our experiments.this experiment focuses on the binary classification problem derived from mnist, by limiting the number of classes to two different digits at a time. we use the same non-zero feature deletion distribution as suggested by globerson and roweis (2006), i.e. for a given image we uniformly sample a set of n non-zero pixels from the
image (if the image has less than n non-zero pixels then they are non-zero pixels are chosen), and replace their values with zeros. this type of missingness distribution falls under the mnar type defined in sec.5.
we test values of n in {0, 25, 50, 75, 100, 125, 150}. for a given value of n , we train a separate classifier on each digit pair classifier on a randomly picked subset of the dataset containing 300 images per digit (600 total). during training we use a fixed validation set with 1000 images per digit. after picking the best classifier according to the validation set, the classifier is tested against a test set with a 1000 images per digits with a randomly chosen missing values according to the value of n . this experiment is repeated 10 times for each digit pair, each time using a different subset for the training set, and a new corrupted test set. after conducting all the different experiments, all the accuracies are averaged for each value of n , which are reported in table 1.this experiment focuses on the complete multi-class digit classification of the mnist dataset, in the presence of missing data according to different missingness distributions. under this setting, only the test set contains missing values, whereas the training set does not. we test two kinds of missingness distributions, which both fall under the mar type defined in sec.5. the first kind, which we call i.i.d. corruption, each pixel is missing with a fixed probability p. the second kind, which we call missing rectangles corruption, the positions of n rectangles of widthw or chosen uniformly in the picture, where the rectangles can overlap one another. during the training stage, the models to be tested are not to be biased toward the specific missingness distributions we have chosen, and during the test stage, the same classifier is tested against all types of missingness distributions, and without supplying it with the parameters or type of the missingness distribution it is tested against. this rule prevent the use of convnets trained on simulated missingness distributions. to demonstrate that the latter lead to biased classifiers, we have conducted a separate experiment just for convnets, where the previous rule is ignored, and we train a separate convnet classifier on each type and parameter of the missingness distributions we have used. we then tested each of those convnets on all other missingness distributions, the results of which are in fig. 5, which confirmed our hypothesis.
g image generation and network visualization
following the graphical model perspective of our models allows us to not only generate random instances from the distribution, but to also generate the most likely patches for each neuron in the network, effectively explaining its role in the classification process. we remind the reader that every neuron in the network corresponds to a possible assignment of a latent variable in the graphical model. by looking for the most likely assignments for each of its child nodes in the graphical tree model, we can generate a patch that describes that neuron. unlike similar suggested methods to visualize neural networks (zeiler and fergus, 2014), often relying on brute-force search or on solving some optimization problem to find the most likely image, our method emerges naturally from the probabilistic interpretation of our model.
in fig. 8, we can see conditional samples generates for each digit, while in fig. 9 we can see a visualization of the top-level layers of network, where each small patch matches a different neuron in the network. the common wisdom of how convnets work is by assuming that simple low-level features are composed together to create more and more complex features, where each subsequent layer denotes features of higher abstraction – the visualization of our network clearly demonstrate this hypothesis to be true for our case, showing small strokes iteratively being composed into complete digits.for both presentational and page layout reasons we have chosen to present most of results in the form of charts in the body or the article. considering that exact results are important for both reproducibility as well as future comparisons to our work, we provide below the raw results of our experiments in the form of detailed tables. for completeness, some of the tables we did include in the body of the article are duplicated to here as well.",0
728.pdf.json,REINFORCEMENT LEARNING THROUGH NEURAL ENCODING,"in the early days of rl, understanding the behavior of trained policies could be done rather easily (sutton, 1990). researchers focused on simpler problems (peng and williams, 1993), and policies were built using lighter models than today (tesauro, 1994). as a result, a meaningful analysis of policies was possible even by working with the original state representation and relating to primitive actions. however, in recent years research has made a huge step forward. fancier models such as deep neural networks (dnns) have become a commodity (mnih , 2015), and the rl community tackles bigger and more challenging problems (silver , 2016). artificial agents are even expected to be used in autonomous systems such as self-driving cars. the need to reason the behavior of trained agents, and understand the mechanisms that govern its choice of actions is pressing more than ever.
analyzing a trained policy modeled by a dnn (either graphically using the state-action diagram, or by any other mean) is practically impossible. a typical problem consists of an immense number of states, and policies often rely on skills (mankowitz, mann, and mannor, 2014), creating more than a single level of planning. the resulting markov reward processes induced by such policies are too complicated to comprehend through observation. simplifying the behavior requires finding a suitable representation of the state space; a long-standing problem in machine learning, where extensive research has been conducted over the years (boutilier, dean, and hanks, 1999). there, the goal is to come up with a transformation of the state space φ : s → ŝ, that can facilitate learning.
∗these authors contributed equally
in the field of rl, where problems are sequential in nature, this problem is exacerbated since the representation of a state needs to account for the dynamics of the problem as well.
finding a suitable state representation can be phrased as a learning problem itself (ng, 2011; lee , 2006). dnns are very useful in this context since they automatically build a hierarchy of representations with an increasing level of abstraction along the layers. in this work, we show that the state representation that is learned automatically by dnns is suitable for building abstractions in rl. to this end, we introduce the samdp model; a modeling approach that creates abstractions both in space and time. contrary to other modeling approaches, samdp is built in a transformed state space, where the problem of creating spatial abstractions (i.e., state aggregation), and temporal abstractions (i.e., identifying skills) is facilitated using spatiotemporal clustering. we provide an example for building an samdp model for a basic gridworld problem where φ(s) is hand-crafted. however, the real strength of the model is demonstrated on challenging atari2600 games solved using dqns (mnih , 2015). there, we set φ(s) to be the state representation automatically learned by the dnn (i.e. the last hidden layer). we continue by presenting methods for evaluating the fitness of the samdp model to the trained policy at hand. finally, we describe a method for using the samdp as a monitor that alerts when the policy’s performance weakens, and provide initial results showing how the samdp model is useful for shared autonomy systems.we briefly review the standard reinforcement learning framework of discrete-time finite markov decision processes (mdps). an mdp is defined by a five-tuple < s,a, p,r, γ >. at time t an agent observes a state st ∈ s, selects an action at ∈ a, and receives a reward rt. following the agent’s action choice, it transitions to the next state st+1 ∈ s according to a markovian probability matrix pa ∈ p . the cumulative return at time t is given by rt = ∑∞ t′=t γ
t′−trt, where γ ∈ [0, 1] is the discount factor. in this framework, the goal of an rl agent is to maximize the expected return by learning a policy π : s → ∆a; a mapping from states s ∈ s to a probability distribution over actions. the action-value function qπ(s, a) = e[rt|st = s, at = a, π] represents the expected return after observing state s, taking action a and then following policy π. the optimal action-value function obeys a fundamental recursion known as the optimal bellman equation: q∗(st, at) = e [ rt + γmax
a′ q∗(st+1, a
′) ] .
skills, options (sutton, precup, and singh, 1999) are temporally extended control structures, denoted by σ. a skill is defined by a triplet: σ =< i, π, β >, where i defines the set of states where the skill can be initiated, π is the intra-skill policy, and β is the set of termination probabilities determining when a skill will stop executing. β is typically either a function of state s or time t. any mdp with a fixed set of skills is a semi-mdp (smdp). planning with skills can be performed by learning for each state the value of choosing each skill. more formally, an smdp is defined by a five-tuple < s,σ, p,r, γ >. s is the set of states, σ is the set of skills, p is the smdp transition
matrix, γ is the discount factor and the smdp reward is defined by:
rσs = e[rσs ] = e[rt+1 + γrt+2 + · · ·+ γk−1rt+k|st = s, σ]. (1)
the skill policy µ : s → ∆σ is a mapping from states to a distribution over skills. the action-value function qµ(s, σ) = e[ ∑∞ t=0 γ
trt|(s, σ), µ] represents the value of choosing skill σ ∈ σ at state s ∈ s, and thereafter selecting skills according to policy µ. the optimal skill value function is given by: q∗σ(s, σ) = e[rσs + γkmax
σ′∈σ q∗σ(s ′, σ′)] (stolle and precup, 2002).reinforcement learning problems are typically modeled using the mdp formulation. given an mdp, a variety of algorithms have been proposed to find an optimal policy. however, when one wishes to analyze a trained policy, mdp may not be the best modeling choice due to the size of the state space and the length of the planning horizon. in this section, we present the smdp and aggregated mdp (amdp) models which can simplify the analysis by using temporal and spatial abstractions respectively. we also introduce the new semi-aggregated mdp (samdp) model, that combines smdp and amdp models in a novel way which leverages the abstractions made in each modeling approach. smdp (sutton, precup, and singh, 1999), can simplify the analysis of a trained policy by using temporal abstractions. the model extends the mdp action space a to allow the agent to plan with temporally extended actions σ (i.e., skills). analyzing policies using the smdp model shortens the planning horizon and simplifies the analysis. however, there are two problems with this approach. first, one still faces the high complexity of the state space, and second, the smdp model requires to identify skills.
skill identification is an ill-posed problem that can be addressed in many ways, and for which extensive research has been done over the years. the popular approaches are to identify bottlenecks in the state space (mcgovern and barto, 2001),or to search for common behavior trajectories, or common state region policies (mcgovern, 2002). a different approach can be to build a graphical model of the agent’s interaction with the environment and to use betweenness centrality measures to identify subtasks (şimşek and barreto, 2009). no matter what the method is, identifying skills solely by observing an agent play is a challenging task.
alternative approach to smdp modeling is to analyze a policy using spatial abstractions in the state space. if there is a reason to believe that groups of states share common attributes such as similar policy or value function, it is possible to use state aggregation (moore, 1991). state aggregation is a well-studied problem that typically involves identifying clusters as the new states of an aggregated mdp, where the set of clusters c replaces the mdp states s. applying rl on aggregated states is potentially advantageous because the dimensions of the transition probability matrix p , the reward signal r and the policy π are decreased (singh, jaakkola, and jordan, 1995). however, the amdp modeling approach has two drawbacks. first, the action space a is not modified, and therefore the planning horizon remains intractable, and second, amdps are not necessarily markovian (bai, srivastava, and russell, 2016). in this paper, we propose a model that combines the advantages of the smdp and amdp approaches and denote it by samdp. under samdp modeling, aggregation defines both the states and the set of skills, allowing analysis with spatiotemporal abstractions (the state-space dimensions and the planning horizon are reduced). however, samdps are still not necessarily markovian. we summarize the different modeling approaches in figure 1. the rest of this section is devoted to explaining the five stages of building an samdp model: (0) feature selection, (1) state aggregation, (2) skill identification, (3) inference, and (4) model selection. (0) feature selection. we define the mapping from mdp states to features, by a mapping function φ : s → s′ ⊂ rm. the features may be raw (e.g., spatial coordinates, frame pixels) or higher level abstractions (e.g., the last hidden layer of an nn). the feature representation has a significant effect on the quality of the resulting samdp model and vice versa; a good model can point out a good feature representation. (1) aggregation via spatio-temporal clustering. the goal of aggregation is to find a mapping (clustering) from the mdp feature space s′ ⊂ rm to the amdp state space c. clustering algorithms typically assume that data is drawn from an i.i.d distribution. however, in our problem data
is generated from an mdp which violates this assumption. we alleviate this problem using two different approaches. first, we decouple the clustering step from the samdp model, by creating an ensemble of clustering candidates and building an samdp model for each (following stages 2 and 3). in stage 4, we will explain how to run a non-analytic outer optimization loop to choose between these candidates based on spatiotemporal evaluation criteria. second, we introduce a novel extension of the celebrated k-means algorithm (macqueen and others, 1967), which enforces temporal coherency along trajectories. in the vanilla k-means algorithm, a point xt is assigned to cluster ci with mean µi if µi is the closest cluster center to xt (for further details please see the supplementary material). we modified this step as follows:
c(xt) = { ci : ∥∥xt − µi∥∥2f ≤ ∥∥xt − µj∥∥2f ,∀j ∈ [1,k]}, where f stands for the frobenius norm, k is the number of clusters, t is the time index of xt, and xt is a set of 2w+ 1 centered at xt from the same trajectory: { xj ∈ xt ⇐⇒ j ∈ [t−w, t+w] } . the dimensions of µ correspond to a single point, but is expanded to the dimensions of xt. in this way, we enforce temporal coherency since a point xt is assigned to a cluster ci if its neighbors in time along the trajectory are also close to µi. we have also experimented with other clustering methods such as spectral clustering, hierarchical agglomerative clustering and entropy minimization (please refer to the supplementary material for more details). (2) skill identification. we define an samdp skill σi,j ∈ σ uniquely by a single initiation state ci ∈ c and a single termination state cj ∈ c : σij =< ci, πi,j , cj > . more formally, at time t the agent enters an amdp state ci at an mdp state st ∈ ci. it chooses a skill according to its samdp policy and follows the skill policy πi,j for k time steps until it reaches a state st+k ∈ cj , s.t i 6= j. we do not define the skill length k apriori nor the skill policy but infer the skill length from the data. as for the skill policies, our model does not define them explicitly, but we will observe later that our model successfully identifies skills that are localized in time and space.
(3) inference. given the samdp states and skills, we infer the skill length, the samdp reward and the samdp probability transition matrix from observations. the skill length, is inferred for a skill σi,j by averaging the number of mdp states visited since entering samdp state ci until leaving for samdp state cj . the skill reward is inferred similarly using equation 1. the inference of the samdp transition matrices is a bit more puzzling, since the probability of seeing the next samdp state depends both on the mdp dynamics and the agent policy in the mdp state space. we now turn to discuss how to infer these matrices by observing transitions in the mdp state space. our goal is to infer two quantities: (a) the samdp transition probability matrices pς : p σ∈σ i,j = pr(cj |ci, σ), measures the probability of moving from state ci to cj given that skill σ is chosen. these matrices are defined uniquely by our definition of skills as deterministic probability matrices. (b) the probability of moving from state ci to cj given that skill σ is chosen according to the agent samdp policy: pπi,j = pr(cj |ci, σ = π(ci)). this quantity involves both the samdp transition probability matrices and the agent policy. however, since samdp transition probability matrices are deterministic, this is equivalent to the agent policy in the samdp state space. therefore by inferring transitions between samdp states, we directly infer the agent’s samdp policy. given an mdp with a deterministic environment and an agent with a nearly deterministic mdp policy (e.g., a deterministic policy that uses an -greedy exploration ( 1)), it is intuitive to assume that we would observe a nearly deterministic samdp policy. however, there are two mechanisms that cause stochasticity in the samdp policy: (1) stochasticity that is accumulated along skill trajectories. (2) approximation errors in the aggregation process. a given samdp state may contain more than one ”real” state and therefore more than one skill. performing inference in this setup, we might observe a stochastic policy that chooses randomly between skills. therefore, it is very likely to infer a stochastic samdp transition matrix, even though the samdp transition probability matrices and the mdp environment are deterministic, and the mdp policy is nearly deterministic. (4) model selection. so far we have explained how to build an samdp from observations. in this stage, we’ll explain how to choose between different samdp model candidates. there are two advantages of choosing between multiple samdps. first, there are different hyperparameters to tune: two examples are the number of samdp states (k) and the window size (w) for the clustering algorithm. second, there is randomness in the aggregation step. hence, clustering multiple times and picking the best result will potentially yield better models.
we developed, therefore, evaluation criteria that allow us to select the best model, motivated by hallak, di-castro, and mannor (2013). we follow the occams razor principle and aim to find the simplest model which best explains the data. (i) value mean square error(vmse), measures the consistency of the model with the observations. the estimator is given by
vmse = ‖v−vsamdp ‖/‖v‖, (2)
where v stands for the samdp value function of the given policy, and vsamdp is given by: vsamdp = (i + γ
kp )−1r, where p is measured under the samdp policy. (ii) inertia, the kmeans algorithm objective function, is given by : i = ∑n i=0 minµj∈c(||xj − µi||2). inertia measures the variance inside clusters and encourages spatial coherency. motivated by ncut and spectral clustering (von luxburg, 2007), we define (iii) the intensity factor as the fraction of out/in cluster transitions. however, we define edges between states that are connected along the trajectory (a transition between them was observed) and give them equal weights (instead of defining the edges by euclidean distances as in spectral clustering). minimizing the intensity factor encourages longer duration skills. (iv)had been entropy, is defined on the samdp probability transition matrix as follows: e = − ∑ i{|ci| · ∑ j pi,j logpi,j}. low entropy encourages clusters to have less skills, i.e., clusters that are localized both in time and space.we first illustrate the advantages of samdp in a basic gridworld problem (figure 2). in this task, an agent is placed at the origin (marked in x), where the goal is to reach the green ball and return. the state s ∈ r3 is given by: s = {x, y, b}, where (x, y) are the coordinates and b ∈ {0, 1} indicates whether the agent has reached the ball or not. the policy is trained to find skills following the algorithm of mankowitz, mann, and mannor (2014). we are given trajectories of the trained agent, and wish to analyze its behavior by building the state-action graph for all four modeling approaches. for clarity, we plot the graphs on the maze using the coordinates of the state. the mdp graph (figure 2(a)), consists of a vast number of states. it is also difficult to understand what skills the agent is using. in the smdp graph (figure 2(b)), the number of states remain high, however
coloring the edges by the skills, helps to understand the agent’s behavior. unfortunately, producing this graph is seldom possible because we rarely receive information about the skills. on the other hand, abstracting the state space can be done more easily using state aggregation. however, in the amdp graph (figure 2(c)), the clusters are not aligned with the played skills because the routes leading to and from the ball overlap. for building the samdp model (figure 2(d)), we transform the state space in a way that disentangles the routes:
φ(x, y) = { (x, y), if b is 0 (2l− x, y), if b is 1 ,
where l is the maze width. the transformation φ flip and translate the states where b = 1. now that the routes to and from the ball are disentangled, the clusters are perfectly aligned with the skills. understanding the behavior of the agent is now possible by examining inter-cluster and intra-cluster transitions.feature extraction: we evaluate a pre-trained dqn agent for multiple trajectories with an -greedy policy on three atari2600 games, pacman (a game where dqn performs very well), seaquest (for the opposite reason) and breakout (for its popularity). we let the trained agent play 120k game states, and record the neural activations of the last hidden layer as well as the q values. we also keep the time index of each state to be able to find temporal neighbors. features from other layers can also be used. however, we rely on the results from zahavy, zrihem, and mannor (2016) that showed that the features learned in the last hidden layer capture a spatiotemporal hierarchy and therefore make a good candidate for state aggregation. we then apply t-sne on the neural activations data, a non-linear dimensionality reduction method that is particularly good at creating a single map that reveals structure at many different scales. we use the two coordinates of the t-sne map and the value estimation as the mdp state features. each coordinate is normalized to have zero mean and
unit variance. we have experimented with other configurations such as using the activations without t-sne as well as different normalization. however, we found that this configuration results in better samdp models. we also use two approximations in the inference stage which we found to work well: 1) overlooking transitions with a small skill length (shorter than 2) and 2) truncating transitions with probability less than 0.1. we only present results for the breakout game and refer the reader to the supplementary material for results on pacman and seaquest. model selection: we perform a grid search on two parameters: i) number of clusters k ∈ [15, 25]. ii) window size w ∈ [1, 7]. we found that models larger (smaller) than that are too cumbersome (simplistic) to analyze. we select the best model in the following way: we first sort all models by the four evaluation criteria (samdp section, stage 4) from best to worst. then, we iteratively intersect the p-prefix of all sets (i.e., the first p elements of each set) starting with 1-prefix. we stop when the intersection is nonempty and choose the configuration at the intersection. the resulted samdp model for breakout can be seen in figure 3. we also measure the p-value of the chosen model. for the null hypothesis, we take the samdp model constructed with random clusters. we tested 10000 random samdp models, none of which scored better than the chosen model (for all the evaluation criteria). qualitative evaluation: examining the resulting samdp (figure 3) it is interesting to note the sparsity of transitions, which implies low entropy. inspecting the mean image of each cluster reveals insights about the nature of the skills hiding within and uncovers the policy hierarchy as described in zahavy, zrihem, and mannor (2016). the agent begins to play in low value (blue) clusters (e.g., 1,5,8,9,13,16,18,19). these clusters are well connected between them and are disconnected from other clusters. once the agent transitions to the ”tunnel-digging” option in clusters 4,12,14, it stays in there until it finishes to curve the tunnel, then it transitions to cluster 11. from cluster 11 the agent progresses through the ”left banana” and hops between clusters 2,21,5,10,0,7 and 3 in that order. model evaluation: we first measure the vmse criterion, as defined in equation 2 (figure 4, top). we infer v by averaging the dqn value estimates in each cluster: vdqn (cj) =  |cj | ∑ i:si∈cj v
dqn (si), and evaluate vsamdp as defined above. since the atari environment is deterministic, the vsamdp estimate is accurate with respect to the dqn policy. therefore, the vmse criterion measures how well the samdp model approximates the true mdp. in practice, we observe that the dqn and samdp values are very similar; indicating that the samdp model fits the data well. second, we evaluate the greedy policy with respect to the samdp value function by: πgreedy(ci) = argmax
j {rσi,j + γ kσi,j vsamdp (cj)}. we then measure the correlation between the greedy policy decisions and the trajectory reward. for a given trajectory j we measure p ji : the empirical distribution of choosing the greedy policy at state ci and the cumulative reward rj . finally, we present the correlation between these two measures in each state: corri = corr(p j i , r j) in (figure 4, center). a
positive correlation indicates that following the greedy policy leads to high reward. indeed for most of the states, we observe positive correlation, supporting the consistency of the model. the third evaluation is close in spirit to the second one. we partition the data to a train and test sets. we evaluate the greedy policy based on the train set and create two transition matrices t+, t− using the k top and bottom rewarded trajectories respectively from the test set. we measure the correlation of the greedy policy tg with each of the transition matrices for different values of k (figure 4 bottom). as clearly seen, the correlation of the greedy policy and the top trajectories is higher than the correlation with the bottom trajectories. eject button: the motivation for this experiment stems from the idea of shared autonomy pitzer  (2011). there are domains where errors are dreadful, and performance must be as high as possible. the idea of shared autonomy, is to allow an operator to intervene in the decision loop at critical times. for example, in 20% of commercial flights, the auto-pilot returns the control to the human pilots. in the following experiment, we show how the samdp model can help to identify where the agent’s behavior deteriorates. setup. (a) evaluate a dqn agent, create a trajectory data set, and evaluate the features for each state (stage 0). (b) divide the data into two groups: train (100 trajectories) and test (60). then build an samdp model (stages 1-4) on the train data. (c) split the train data to k top and bottom rewarded trajectories t+, t− and re-infer the model parameters separately for each (stage 3). (d) project the test data on the samdp model (mapping each state to the nearest samdp state). (e) eject when the transitions of the agent are more likely under the t− matrix rather then under t+ (inspired by the idea of option interruption sutton, precup, and singh (1999)). (f) we average the trajectory reward on (i) the entire test set, and (ii) the un-ejected trajectories sub set. we measure 36% ± 7.7%, 20% ± 8.0%, and 4.7% ± %1.2 performance gain for breakout seaquest and pacman, respectively. the eject experiment indicates that the samdp model can be used to make a given dqn policy robust by identifying when the agent is not going to perform well and return control to a human operator or some other ai agent. other eject mechanisms are also possible. for example, ejecting by looking at mdp values. however, the q value is not monotonically decreasing along the trajectory as expected (see figure 3). the solution we propose is to eject by monitoring transitions and not state values, which makes the mdp impractical in this case because it’s state-action diagram is too large to construct, and too expensive to process.samdp modeling offers a way to present a trained policy in a concise way by creating abstractions that relate to the spatiotemporal structure of the problem. we showed that by using the right representation, time-aware state aggregation could be used to identify skills. it implies that the crucial step in building an samdp is the state aggregation phase. the aggregation depends on the state features and the clustering algorithm at hand.
in this work, we presented a basic k-means variant that relies on temporal information. however, other clustering approaches are possible. we also experimented with agglomerative methods but found them to be significantly slower without providing any benefit. we believe that clustering methods that better relate to the topology, such as spectral clustering, would produce the best results. regarding the state features; in the dqn example, we used the 2d t-sne map. this map, however, is built under the i.i.d assumption that overlooks the temporal dimension of the problem. an interesting line of future work will be to modify the t-sne algorithm to take into account temporal distances as well as spatial ones. a tsne algorithm of this kind may produce 2d maps with even lower entropy which will decrease the aggregation artifacts that affect the quality of the samdp model.
in this work we analyzed discrete-action policies, however samdp can also be applied for continuous-action policies that maintain a value function (since our algorithm depends on it for construction and evaluation), as in the case of actor-critic methods. another issue we wish to investigate is the question of consistency in re-building an samdp. we would like the samdp to be unique for a given problem. however, there are several aspects of randomness that may cause divergence. for instance, when using a dqn, randomness exists in the creation of the t-sne map, and in the clustering phase. from our experience, though, different models built for the same problem are reasonably consistent. in future work, we wish to address the same problem by laying out an optimization problem that will directly account for all of the performance criteria introduced here. it would be interesting to see what clustering method will be drawn out of this process and to compare the principled solution with our current approach.",0
732.pdf.json,GENERATIVE PARAGRAPH VECTOR,"a central problem in many text based applications, e.g., sentiment classification (pang & lee, 2008), question answering (stefanie tellex & marton., 2003) and machine translation (i. sutskever & le, 2014), is how to capture the essential meaning of a piece of text in a fixed-length vector. perhaps the most popular fixed-length vector representations for texts is the bag-of-words (or bag-of-ngrams) (harris, 1954). besides, probabilistic latent semantic indexing (plsi) (hofmann, 1999) and latent dirichlocation (lda) (blei & jordan, 2003) are two widely adopted alternatives.
a recent paradigm in this direction is to use a distributed representation for texts (t. mikolov & dean, 2013a). in particular, le and mikolov (quoc le, 2014; andrew m.dai, 2014) show that their method, paragraph vector (pv), can capture text semantics in dense vectors and outperform many existing representation models. although pv is an efficient method for learning high-quality distributed text representations, it suffers a similar problem as plsi that it provides no model on text vectors: it is unclear how to infer the distributed representations for texts outside of the training set with the learned model (i.e., learned text and word vectors). such a limitation largely restricts the usage of the pv model, especially in those prediction focused scenarios.
inspired by the completion and improvement of lda over plsi, we first introduce the generative paragraph vector (gpv) with a complete generation process for a corpus. specifically, gpv can be viewed as a probabilistic extension of the distributed bag of words version of paragraph vector (pvdbow), where the text vector is viewed as a hidden variable sampled from some prior distributions, and the words within the text are then sampled from the softmax distribution given the text and word vectors. with a complete generative process, we are able to infer the distributed representations of new texts based on the learned model. meanwhile, the prior distribution over text vectors also acts as a regularization factor from the view of optimization, thus can lead to higher-quality text representations.
more importantly, with the ability to infer the distributed representations for unseen texts, we now can directly incorporate labels paired with the texts into the model to guide the representation learning, and turn the model into a supervised version, namely supervised generative paragraph vector (sgpv). note that supervision cannot be directly leveraged in the original pv model since it has no
generalization ability on new texts. by learning the sgpv model, we can directly employ sgpv to predict labels for new texts. as we know, when the goal is prediction, fitting a supervised model would be a better choice than learning a general purpose representations of texts in an unsupervised way. we further show that sgpv can be easily extended to accommodate n-grams so that we can take into account word order information, which is important in learning semantics of texts.
we evaluated our proposed models on five text classification benchmark datasets. for the unsupervised gpv, we show that its superiority over the existing counterparts, such as bag-of-words, lda, pv and fastsent (felix hill, 2016). for the sgpv model, we take into comparison both traditional supervised representation models, e.g. mnb (s. wang, 2012), and a variety of state-of-the-art deep neural models for text classification (kim, 2014; n. kalchbrenner, 2014; socher & potts, 2013; irsoy & cardie, 2014). again we show that the proposed sgpv can outperform the baseline methods by a substantial margin, demonstrating it is a simple yet effective model.
the rest of the paper is organized as follows. we first review the related work in section 2 and briefly describe pv in section 3. we then introduce the unsupervised generative model gpv and supervised generative model sgpv in section 4 and section 5 respectively. experimental results are shown in section 6 and conclusions are made in section 7.many text based applications require the text input to be represented as a fixed-length feature vector. the most common fixed-length representation is bag-of-words (bow) (harris, 1954). for example, in the popular tf-idf scheme (salton & mcgill, 1983), each document is represented by tfidf values of a set of selected feature-words. however, the bow representation often suffers from data sparsity and high dimension. meanwhile, due to the independent assumption between words, bow representation has very little sense about the semantics of the words.
to address this shortcoming, several dimensionality reduction methods have been proposed, such as latent semantic indexing (lsi) (s. deerwester & harshman, 1990), probabilistic latent semantic indexing (plsi) (hofmann, 1999) and latent dirichlocation (lda) (blei & jordan, 2003). both plsi and lda have a good statistical foundation and proper generative model of the documents, as compared with lsi which relies on a singular value decomposition over the term-document cooccurrence matrix. in plsi, each word is generated from a single topic, and different words in a document may be generated from different topics. while plsi makes great effect on probabilistic modeling of documents, it is not clear how to assign probability to a document outside of the training set with the learned model. to address this issue, lda is proposed by introducing a complete generative process over the documents, and demonstrated as a state-of-the-art document representation method. to further tackle the prediction task, supervised lda (david m.blei, 2007) is developed by jointly modeling the documents and the labels.
recently, distributed models have been demonstrated as efficient methods to acquire semantic representations of texts. a representative method is word2vec (tomas mikolov & dean, 2013b), which can learn meaningful word representations in an unsupervised way from large scale corpus. to represent sentences or documents, a simple approach is then using a weighted average of all the words. a more sophisticated approach is combing the word vectors in an order given by a parse tree (richard socher & ng, 2012). later, paragraph vector (pv) (quoc le, 2014) is introduced to directly learn the distributed representations of sentences and documents. there are two variants in pv, namely the distributed memory model of paragraph vector (pv-dm) and the distributed bag of words version of paragraph vector (pv-dbow), based on two different model architectures. although pv is a simple yet effective distributed model on sentences and documents, it suffers a similar problem as plsi that it provides no model on text vectors: it is unclear how to infer the distributed representations for texts outside of the training set with the learned model.
besides these unsupervised representation learning methods, there have been many supervised deep models with directly learn sentence or document representations for the prediction tasks. recursive neural network (recursivenn) (richard socher & ng, 2012) has been proven to be efficient in terms of constructing sentence representations. recurrent neural network (rnn) (ilya sutskever & hinton, 2011) can be viewed as an extremely deep neural network with weight sharing across time. convolution neural network (cnn) (kim, 2014) can fairly determine discriminative phrases in a
text with a max-pooling layer. however, these deep models are usually quite complex and thus the training would be time-consuming on large corpus.since our model can be viewed as a probabilistic extension of the pv-dbow model with a complete generative process, we first briefly review the pv-dbow model for reference.
in pv-dbow, each text is mapped to a unique paragraph vector and each word is mapped to a unique word vector in a continuous space. the paragraph vector is used to predict target words randomly sampled from the paragraph as shown in figure 1. more formally, let d={d1, . . . ,dn} denote a corpus of n texts, where each text dn = (wn1 , w n 2 , . . . , w n ln
), n ∈ 1, 2, . . . , n is an lnlength word sequence over the word vocabulary v of size m . each text d ∈ d and each word w ∈ v is associated with a vector ~d ∈ rk and ~w ∈ rk , respectively, where k is the embedding dimensionality. the predictive objective of the pv-dbow for each word wnl ∈ dn is defined by the softmax function
p(wni |dn) = exp(~wni · ~dn)∑ w′∈v exp(~w ′ · ~dn) (1)
the pv-dbow model can be efficiently trained using the stochastic gradient descent (rumelhart & williams, 1986) with negative sampling (t. mikolov & dean, 2013a).
as compared with traditional topic models, e.g. plsi and lda, pv-dbow conveys the following merits. firstly, pv-dbow using negative sampling can be interpretated as a matrix factorization over the words-by-texts co-occurrence matrix with shifted-pmi values (omer levy & ramat-gan, 2015). in this way, more discriminative information (i.e., pmi) can be modeled in pv as compared with the generative topic models which learn over the words-by-texts co-occurrence matrix with raw frequency values. secondly, pv-dbow does not have the explicit “topic” layer and allows words automatically clustered according to their co-occurrence patterns during the learning process. in this way, pv-dbow can potentially learn much finer topics than traditional topic models given the same hidden dimensionality of texts. however, a major problem with pv-dbow is that it provides no model on text vectors: it is unclear how to infer the distributed representations for unseen texts.in this section, we introduce the gpv model in detail. overall, gpv is a generative probabilistic model for a corpus. we assume that for each text, a latent paragraph vector is first sampled from some prior distributions, and the words within the text are then generated from the normalized exponential (i.e. softmax) distribution given the paragraph vector and word vectors. in our work, multivariate normal distribution is employed as the prior distribution for paragraph vectors. it could
be replaced by other prior distributions and we will leave this as our future work. the specific generative process is as follows:
for each text dn ∈d, n = 1, 2, . . . , n : (a) draw paragraph vector ~dn ∼ n (µ,σ) (b) for each word wni ∈ dn, i = 1, 2, . . . , ln :
draw word wni ∼ softmax(~dn ·w )i
where w denotes a k ×m word embedding matrix with w∗j = ~wj , and softmax(~dn ·w )i is the softmax function defined the same as in equation (1). figure 2 (left) provides the graphical model of this generative process. note that gpv differs from pv-dbow in that the paragraph vector is a hidden variable generated from some prior distribution, which allows us to infer the paragraph vector over future texts given the learned model. based on the above generative process, the probability of the whole corpus can be written as follows:
p(d)= n∏ n=1 ∫ p(~dn|µ,σ) ∏ wni ∈dn p(wni |w, ~dn)d~dn
to learn the model, direct maximum likelihood estimation is not tractable due to non-closed form of the integral. we approximate this learning problem by using map estimates for ~dn, which can be formulated as follows:
(µ∗,σ∗,w ∗) = arg max µ,σ,w
∏ p(d̂n|µ,σ) ∏ wni ∈dn p(wni |w, d̂n)
where d̂n denotes the map estimate of ~dn for dn, (µ∗,σ∗,w ∗) denotes the optimal solution. note that for computational simplicity, in this work we fixed µ as a zero vector and σ as a identity matrix. in this way, all the free parameters to be learned in our model are word embedding matrix w . by taking the logarithm and applying the negative sampling idea to approximate the softmax function, we obtain the final learning problem
l= n∑ n=1 ( −1 2 ||d̂n||2+ ∑ wni ∈dn ( log σ(~wni ·d̂n)+k·ew′∼pnw log σ(− ~w′ · d̂n) )) where σ(x) = 1/(1 + exp(−x)), k is the number of “negative” samples, w′ denotes the sampled word and pnw denotes the distribution of negative word samples. as we can see from the final objective function, the prior distribution over paragraph vectors actually act as a regularization term. from the view of optimization, such regularization term could constrain the learning space and usually produces better paragraph vectors.
for optimization, we use coordinate ascent, which first optimizes the word vectors w while leaving the map estimates (d̂) fixed. then we find the new map estimate for each document while leaving the word vectors fixed, and continue this process until convergence. to accelerate the learning, we adopt a similar stochastic learning framework as in pv which iteratively updates w and estimates ~d by randomly sampling text and word pairs.
at prediction time, given a new text, we perform an inference step to compute the paragraph vector for the input text. in this step, we freeze the vector representations of each word, and apply the same map estimation process of ~d as in the learning phase. with the inferred paragraph vector of the test text, we can feed it to other prediction models for different applications.with the ability to infer the distributed representations for unseen texts, we now can incorporate the labels paired with the texts into the model to guide the representation learning, and turn the model into a more powerful supervised version directly towards prediction tasks. specifically, we introduce an additional label generation process into gpv to accommodate text labels, and obtain the supervised generative paragraph vector (sgpv) model. formally, in sgpv, the n-th text dn and the corresponding class label yn ∈ {1, 2, . . . , c} arise from the following generative process:
for each text dn ∈d, n = 1, 2, . . . , n : (a) draw paragraph vector ~dn ∼ n (µ,σ) (b) for each word wni ∈ dn, i = 1, 2, . . . , ln :
draw word wni ∼ softmax(~dn ·w )i (c) draw label yn|~dn, u, b ∼ softmax(u · ~dn+b)
where u is a c ×k matrix for a dataset with c output labels, and b is a bias term. the graphical model of the above generative process is depicted in figure 2 (right). sgpv defines the probability of the whole corpus as follows
p(d)= n∏ n=1 ∫ p(~dn|µ,σ) ( ∏ wni ∈dn p(wni |w, ~dn) ) p(yn|~dn, u, b)d~dn
we adopt a similar learning process as gpv to estimate the model parameters. since the sgpv includes the complete generative process of both paragraphs and labels, we can directly leverage it to predict the labels of new texts. specifically, at prediction time, given all the learned model parameters, we conduct an inference step to infer the paragraph vector as well as the label using map estimate over the test text.
the above sgpv may have limited modeling ability on text representation since it mainly relies on uni-grams. as we know, word order information is often critical in capturing the meaning of texts. for example, “machine learning” and “learning machine” are totally different in meaning with the same words. there has been a variety of deep models using complex architectures such as convolution layers or recurrent structures to help capture such order information at the expense of large computational cost.
here we propose to extend sgpv by introducing an additional generative process for n-grams, so that we can incorporate the word order information into the model and meanwhile keep its simplicity in learning. we name this extension as sgpv-ngram. here we take the generative process of sgpvbigram as an example.
for each text dn ∈d, n = 1, 2, . . . , n : (a) draw paragraph vector ~dn ∼ n (µ,σ) (b) for each word wni ∈ dn, i = 1, 2, . . . , ln :
draw word wni ∼ softmax(~dn ·w )i
(c) for each bigram gni ∈ dn, i = 1, 2, . . . , sn : draw bigram gni ∼ softmax(~dn ·g)i
(d) draw label yn|~dn, u, b ∼ softmax(u · ~dn+b)
where g denotes a k × s bigram embedding matrix with g∗j = ~gj , and s denotes the size of bigram vocabulary. the joint probability over the whole corpus is then defined as
p(d)= n∏ n=1 ∫ p(~dn|µ,σ) ( ∏ wni ∈dn p(wni |w, ~dn) )( ∏ gni ∈dn p(gni |g, ~dn) ) p(yn|~dn, u, b)d~dnin this section, we introduce the experimental settings and empirical results on a set of text classification tasks.we made use of five publicly available benchmark datasets in comparison.
trec: the trec question classification dataset (li & roth, 2002)1 which consists of 5, 452 train questions and 500 test questions. the goal is to classify a question into 6 different types depending on the answer they seek for.
subj: subjectivity dataset (pang & lee, 2004) which contains 5, 000 subjective instances and 5, 000 objective instances. the task is to classify a sentence as being subjective or objective.
mr: movie reviews (pang & lee, 2005) 2 with one sentence per review. there are 5, 331 positive sentences and 5, 331 negative sentences. the objective is to classify each review into positive or negative category.
sst-1: stanford sentiment treebank (socher & potts, 2013) 3. sst-1 is provided with train/dev/test splits of size 8, 544/1, 101/2, 210. it is a fine-grained classification over five classes: very negative, negative, neutral, positive, and very positive.
sst-2: sst-2 is the same as sst-1 but with neutral reviews removed. we use the standard train/dev/test splits of size 6, 920/872/1, 821 for the binary classification task.
preprocessing steps were applied to all datasets: words were lowercased, non-english characters and stop words occurrence in the training set are removed. for fair comparison with other published results, we use the default train/test split for trec, sst-1 and sst-2 datasets. since explicit split of train/test is not provided by subj and mr datasets, we use 10-fold cross-validation instead.
in our model, text and word vectors are randomly initialized with values uniformly distributed in the range of [-0.5, +0.5]. following the practice in (tomas mikolov & dean, 2013b) , we set the noise distributions for context and words as pnw(w) ∝ #(w)0.75. we adopt the same linear learning rate strategy where the initial learning rate of our models is 0.025. for unsupervised methods, we use support vector machines (svm) 4 as the classifier.we adopted both unsupervised and supervised methods on text representation as baselines.bag-of-word-tfidf and bag-of-bigram-tfidf. in the bag-of-word-tfidf scheme (salton & mcgill, 1983) , each text is represented as the tf-idf value of chosen feature-words. the bag-of- http://cogcomp.cs.illinois.edu/data/qa/qc/ 2https://www.cs.cornell.edu/people/pabo/movie-review-data/ 3http:/.lp.stanford.edu/sentiment/ 4http://www.csie.ntu.edu.tw/˜cjlin/libsvm/
bigram-tfidf model is constructed by selecting the most frequent unigrams and bigrams from the training subset. we use the vanilla tfidf in the gensim library5.
lsi (s. deerwester & harshman, 1990) and lda (blei & jordan, 2003). lsi maps both texts and words to lower-dimensional representations in a so-called latent semantic space using svd decomposition. in lda, each word within a text is modeled as a finite mixture over an underlying set of topics. we use the vanilla lsi and lda in the gensim library with topic number set as 100.
cbow (tomas mikolov & dean, 2013b). continuous bag-of-words model. we use average pooling as the global pooling mechanism to compose a sentence vector from a set of word vectors.
pv (quoc le, 2014). paragraph vector is an unsupervised model to learn distributed representations of words and paragraphs.
fastsent (felix hill, 2016). in fastsent, given a simple representation of some sentence in context, the model attempts to predict adjacent sentences.
note that unlike lda and gpv, lsi, cbow, and fastsent cannot infer the representations of unseen texts. therefore, these four models need to fold-in all the test data to learn representations together with training data, which makes it not efficient in practice.nbsvm and mnb (s. wang, 2012). naive bayes svm and multinomial naive bayes with unigrams and bi-grams.
dan (mohit iyyer & iii, 2015). deep averaging network uses average word vectors as the input and applies multiple neural layers to learn text representation under supervision.
cnn-multichannel (kim, 2014). cnn-multichannel employs convolutional neural network for sentence modeling.
dcnn (n. kalchbrenner, 2014). dcnn uses a convolutional architecture that replaces wide convolutional layers with dynamic pooling layers.
mv-rnn (richard socher & ng, 2012). matrix-vector rnn represents every word and longer phrase in a parse tree as both a vector and a matrix.
drnn (irsoy & cardie, 2014). deep recursive neural networks is constructed by stacking multiple recursive layers.
dependency tree-lstm (kai sheng tai & manning, 2015). the dependency tree-lstm based on lstm structure uses dependency parses of each sentence.we first evaluate the gpv model by comparing with the unsupervised baselines on the trec, subj and mr datasets. as shown in table 1, gpv works better than pv over the three tasks. it demonstrates the benefits of introducing a prior distribution (i.e., regularization) over the paragraph vectors. moreover, gpv can also outperform almost all the baselines on three tasks except bow-tfidf and bigram-tfidf on the trec collection. the results show that for unsupervised text representation, bag-of-words representation is quite simple yet powerful which can beat many embedding models. meanwhile, by using a complete generative process to infer the paragraph vectors, our model can achieve the state-of-the-art performance among the embedding based models.we compare sgpv model to supervised baselines on all the five classification tasks. empirical results are shown in table 2. we can see that sgpv achieves comparable performance against other deep learning models. note that sgpv is much simpler than these deep models with significantly less parameters and no complex structures. moreover, deep models with convolutional layers or recurrent structures can potentially capture compositional semantics (e.g., phrases), while sgpv only http://radimrehurek.com/gensim/
relies on uni-gram. in this sense, sgpv is quite effective in learning text representation. meanwhile, if we take table 1 into consideration, it is not surprising to see that sgpv can consistently outperform gpv on all the three classification tasks. this also demonstrates that it is more effective to directly fit supervised representation models than to learn a general purpose representation in prediction scenarios.
by introducing bi-grams, sgpv-bigram can outperform all the other deep models on four tasks. in particular, the improvements of sgpv-bigram over other baselines are significant on sst-1 and sst-2. these results again demonstrated the effectiveness of our proposed sgpv model on text representations. it also shows the importance of word order information in modeling text semantics.in this paper, we introduce gpv and sgpv for learning distributed representations for pieces of texts. with a complete generative process, our models are able to infer vector representations as well as labels over unseen texts. our models keep as simple as pv models, and thus can be efficiently learned over large scale text corpus. even with such simple structures, both gpv and sgpv can produce state-of-the-art results as compared with existing baselines, especially those complex deep models. for future work, we may consider other probabilistic distributions for both paragraph vectors and word vectors.",0
733.pdf.json,HOST-BASED INTRUSION DETECTION SYSTEMS,"an intrusion detection system (ids) refers to a hardware/software platform for monitoring network or system activities to detect malicious signs therefrom. nowadays, practically all existing computer systems operate in a networked environment, which continuously makes them vulnerable to a variety of malicious activities. over the years, the number of intrusion events is significantly increasing across the world, and intrusion detection systems have already become one of the most critical components in computer security. with the explosive growth of logging data, the role of machine learning in effective discrimination between malicious and benign system activities has never been more important.
a survey of existing ids approaches needs a multidimensional consideration. depending on the scope of intrusion monitoring, there exist two main types of intrusion detection systems: networkbased (nids) and host-based (hids). the network-based intrusion detection systems monitor communications between hosts, while the host-based intrusion detection systems monitor the activity on a single system. from a methodological point of view, intrusion detection systems can also be classified into two classes (jyothsna , 2011): signature-based and anomaly-based. the signaturebased approaches match the observed behaviors against templates of known attack patterns, while the anomaly-based techniques compare the observed behaviors against an extensive baseline of normal behaviors constructed from prior knowledge, declaring each of anomalous activities to be an attack. the signature-based methods detect already known and learned attack patterns well but have an innate difficulty in detecting unfamiliar attack patterns. on the other hand, the anomaly-based methods can potentially detect previously unseen attacks but may suffer from making a robust baseline of normal behavior, often yielding high false alarm rates. the ability to detect a ‘zero-day’ attack (i.e., vulnerability unknown to system developers) in a robust manner is becoming an important requirement of an anomaly-based approach. in terms of this two-dimensional taxonomy, we can classify our proposed method as an anomaly-based host intrusion detection system.
∗to whom correspondence should be addressed.
it was forrest  (1996) who first started to use system-call traces as the raw data for hostbased anomaly intrusion detection systems, and system-call traces have been widely used for ids research and development since their seminal work (forrest , 2008). recently, creech & hu (2014) proposed to use neural networks on top of a sequence of system calls in the context of hids. system calls represent low-level interactions between programs and the kernel in the system, and many researchers consider system-call traces as the most accurate source useful for detecting intrusion in an anomaly-based hids. from a data acquisition point of view, system-call traces are easy to collect in a large quantity in real-time. our approach described in this paper also utilizes system-call traces as input data.
for nearly two decades, various research has been conducted based on analyzing system-call traces. most of the existing anomaly-based host intrusion detection methods typically aim to identify meaningful features using the frequency of individual calls and/or windowed patterns of calls from sequences of system calls. however, such methods have limited ability to capture call-level features and phrase-level features simultaneously. as will be detailed shortly, our approach tries to address this limitation by generating a language model of system calls that can jointly learn the semantics of individual system calls and their interactions (that can collectively represent a new meaning) appearing in call sequences.
in natural language processing (nlp), a language model represents a probability distribution over sequences of words, and language modeling has been a very important component of many nlp applications, including machine translation (cho , 2014; bahdanau , 2014), speech recognition (graves , 2013), question answering (hermann , 2015), and summarization (rush , 2015). recently, deep recurrent neural network (rnn)-based language models are showing remarkable performance in various tasks (zaremba , 2014; jozefowicz , 2016). it is expected that such neural language models will be applicable to not only nlp applications but also signal processing, bioinformatics, economic forecasting, and other tasks that require effective temporal modeling.
motivated by this performance advantage and versatility of deep rnn-based language modeling, we propose an application of neural language modeling to host-based introduction detection. we consider system-call sequences as a language used for communication between users (or programs) and the system. in this view, system calls and system-call sequences correspond to words and sentences in natural languages, respectively. based on this system-call language model, we can perform various tasks that comprise our algorithm to detect anomalous system-call sequences: e.g., estimation of the relative likelihood of different words (i.e., system calls) and phrases (i.e., a window of system calls) in different contexts.
the idea of using artificial neural networks for idss has been popular (debar , 1992; ryan , 1998; mukkamala , 2002; wang , 2010; creech & hu, 2014). for more recent deep learning-based techniques, there exists an example that utilized lstm for improving intrusion detection performance (staudemeyer & omlin, 2013; staudemeyer, 2015). however, the work by staudemeyer & omlin (2013); staudemeyer (2015) was in essence a feature-based supervised classifier (rather than an anomaly detector) requiring heavy annotation efforts to create labels. as such, their work required explicitly labeled attack data and possessed an inherent limitation that it could not detect new types of attacks. in addition, their approach was not an end-to-end framework and needed careful feature engineering to extract salient features for the classification task. only one binary label was given per sequence to train their model, unlike our proposed method that is trained to predict the next call, effectively capturing contextual information needed for classification.
our specific contributions can be summarized as follows: first, to model sequences of system calls, we propose a neural language modeling technique that utilizes long short-term memory (lstm) (hochreiter & schmidhuber, 1997) units for enhanced long-range dependence learning. the present work is one of the first end-to-end frameworks to model system-call sequences as a natural language for effectively detecting anomalous patterns therefrom. second, to reduce false-alarm rates of anomaly-based intrusion detection, we propose a leaky rectified linear units (relu) (maas , 2013) based ensemble method that constructs an integrative classifier using multiple (relatively weak) thresholding classifiers. each of the component classifiers is trained to detect different types of ‘highly normal’ sequences (i.e., system call sequences with very high probability of being normal), and our ensemble method blends them to produce a robust classifier that delivers significantly lower false-alarm rates than other commonly used ensemble methods. as shown in figure 1, these
two aspects of our contributions can seamlessly be combined into a single framework. note that the ensemble method we propose is not limited to our language-model based front-end but also applicable to other types of front-ends.
in the rest of this paper, we will explain more details of our approach and then present our experimental results that demonstrate the effectiveness of our proposed method.figure 1 shows the overview of our proposed approach to designing an intrusion detection system. our method consists of two parts: the front-end is for language modeling of system calls in various settings, and the back-end is for anomaly prediction based on an ensemble of thresholding classifiers derived from the front-end. in this section, we describe details of each component in our pipeline.figure 2 illustrates the architecture of our system-call language model. the system call language model estimates the probability distribution of the next call in a sequence given the sequence of previous calls. we assume that the host system generates a finite number of system calls. we index each system call by using an integer starting from 1 and denote the fixed set of all possible system calls in the system as s = {1, · · · ,k}. let x = x1x2 · · ·xl(xi ∈ s) denote a sequence of l system calls.
at the input layer, the call at each time step xi is fed into the model in the form of one-hot encoding, in other words, a k dimensional vector with all elements zero except position xi. at the embedding layer, incoming calls are embedded to continuous space by multiplying embedding matrix w , which should be learned. at the hidden layer, the lstm unit has an internal state, and this state is updated recurrently at each time step. at the output layer, a softmax activation function is used to produce the estimation of normalized probability values of possible calls coming next in the sequence, p (xi|x1:i−1). according to the chain rule, we can estimate the sequence probability by the following formula:
p (x) = l∏ i=1 p (xi|x1:i−1) (1)
given normal training system call sequence data, we can train this lstm-based system call language model using the back-propagation through time (bptt) algorithm. the training criterion minimizes the cross-entropy loss, which is equivalent to maximizing the likelihood of the system call sequence. a standard rnn often suffers from the vanishing/exploding gradient problem, and when training with bptt, gradient values tend to blow up or vanish exponentially. this makes it difficult to learn long-term dependency in rnns (bengio , 1994). lstm, a well-designed rnn architecture component, is equipped with an explicit memory cell and tends to be more effective to cope with this problem, resulting in numerous successes in recent rnn applications.
(a) language model architecture (b) estimation of sequence probability
embedding layer
hidden layer
output layer
input layer 𝟎 ∙ ∙ ∙ 𝟎 𝟏 𝟎 ∙ ∙ ∙ 𝟎
⋯
𝑃(𝑥1) 𝑃(𝑥2|𝑥1) 𝑃(𝑥3|𝑥1:2) 𝑃(𝑥𝑛|𝑥1:𝑛−1)
𝑥1
fork
𝑥2
setgid
𝑥𝑛−1
ioctl
𝑥𝑛
close
[go]
figure 2: system-call language model.
because typical processes in the system execute a long chain of system calls, the number of system calls required to fully understand the meaning of a system-call sequence is quite large. in addition, the system calls comprising a process are intertwined with each other in a complicated way. the boundaries between system-call sequences are also vague. in this regard, learning long-term dependence is crucial for devising effective intrusion detection systems.
markov chains and hidden markov models are widely used probabilistic models that can estimate the probability of the next call given a sequence of previous calls. there has been previous work on using markov models in intrusion detection systems (hofmeyr , 1998; hoang , 2003; hu , 2009; yolacan , 2014). however, these methods have an inherent limitation in that the probability of the next call is decided by only a finite number of previous calls. moreover, lstm can model exponentially more complex functions than markov models by using continuous space representations. this property alleviates the data sparsity issue that occurs when a large number of previous states are used in markov models. in short, the advantages of lstm models compared to markov models are two folds: the ability to capture long-term dependency and enhanced expressive power.
given a new query system-call sequence, on the assumption that abnormal call patterns deviate from learned normal patterns, yielding significantly lower probabilities than those of normal call patterns, a sequence with an average negative log-likelihood above a threshold is classified as abnormal, while a sequence with an average negative log-likelihood below the threshold is classified as normal. by changing the threshold value, we can draw a receiver operating characteristic (roc) curve, which is the most widely used measure to evaluate intrusion detection systems.
commonly, ids is evaluated by the roc curve rather than a single point corresponding to a specific threshold on the curve. sensitivity to the threshold is shown on the curve. the x-axis of the curve represents false alarm rates, and the y-axis of the curve represents detection rates.1 if the threshold is too low, the ids is able to detect attacks well, but users would be annoyed due to false alarms. conversely, if the threshold is too high, false alarm rates becomes lower, but it is easy for ids to miss attacks. roc curves closer to (0, 1) means a better classifier (i.e., a better intrusion detection system). the area under curve (auc) summarizes the roc curve into a single value in the range [0, 1] (bradley, 1997).building a ‘strong normal’ model (a model representing system-call sequences with high probabilities of being normal) is challenging because of over-fitting issues. in other words, a lower training loss does not necessarily imply better generalization performance. we can consider two reasons for encountering this issue.
first, it is possible that only normal data were used for training the ids without any attack data. learning discriminative features that can separate normal call sequences from abnormal sequences is thus hard without seeing any abnormal sequences beforehand. this is a common obstacle for a false alarm rate is the ratio of validation normal data classified as abnormal. a detection rate is the ratio of detected attacks in the real attack data.
almost every anomaly detection problem. in particular, malicious behaviors are frequently hidden and account for only a small part of all the system call sequences.
second, in theory, we need a huge amount of data to cover all possible normal patterns to train the model satisfactorily. however, doing so is often impossible in a realistic situation because of the diverse and dynamic nature of system call patterns. gathering live system-call data is harder than generating synthetic system-call data. the generation of normal training data in an off-line setting can create artifacts, because these data are made in fixed conditions for the sake of convenience in data generation. this setting may cause normal patterns to have some bias.
all these situations make it more difficult to choose a good set of hyper-parameters for lstm architecture. to cope with this challenge, we propose a new ensemble method. due to the lack of data, different models with different parameters capture slightly different normal patterns. if function f ∈ s∗ 7→ r, which maps a system call sequence to a real value, is given, we can define a thresholding classifier as follows:
cf (x; θ) = { normal forf(x) ≤ θ; abnormal otherwise.
(2)
most of the intrusion detection algorithms, including our proposed method, employ a thresholding classifier. for the sake of explanation, we define a term ‘highly normal’ sequence for the classifier cf as a system call sequence having an extremely low f value so it will be classified as normal even when the threshold θ is sufficiently low to discriminate true abnormals. highly normal sequences are represented as a flat horizontal line near (1, 1) in the roc curve. the more the classifier finds highly normal sequences, the longer this line is. note that a highly normal sequence is closely related to the false alarm rate.
our goal is to minimize the false alarm rate through the composition of multiple classifiers cf1 , cf2 , . . . , cfm into a single classifier cf , resulting in accumulated ‘highly normal’ data (here m is the number of classifiers used in the ensemble). this is due to the fact that a low false alarm rate is an important requisite in computer security, especially in intrusion detection systems. our ensemble method can be represented by a simple formula:
f(x) = m∑ i=1 wiσ(fi(x)− bi). (3)
as activation function σ, we used a leaky relu function, namely σ(x) = max(x, 0.001x). intuitively, the activation function forces potential ‘highly normal’ sequences having f values lower than bi to keep their low f values to the final f value. if we use the regular relu function instead, the degree of ‘highly normal’ sequences could not be differentiated. we set the bias term bi to the median of f values of the normal training data. in (3), wi indicates the importance of each classifier fi. because we do not know the performance of each classifier before evaluation, we set wi to 1/m. mathematically, this appears to be a degenerated version of a one-layer neural network. the basic philosophy of the ensemble method is that when the classification results from various classifiers are slightly different, we can make a better decision by composing them well. still, including bad classifiers could degrade the overall performance. by choosing classifiers carefully, we can achieve satisfactory results in practice, as will be shown in section 3.2.deep neural networks are an excellent representation learning method. we exploit the sequence representation learned from the final state vector of the lstm layer after feeding all the sequences of calls. for comparison with our main classifier, we use two baseline classifiers that are commonly used for anomaly detection exploiting vectors corresponding to each sequence: k-nearest neighbor (knn) and k-means clustering (kmc). examples of previous work for mapping sequences into vectors of fixed-dimensional hand-crafted features include normalized frequency and tf-idf (liao & vemuri, 2002; xie , 2014).
let t be a normal training set, and let lstm(x) denotes a learned representation of call sequence x from the lstm layer. knn classifiers search for k nearest neighbors in t of query sequence x
on the embedded space and measure the minimum radius to cover them all. the minimum radius g(x; k) is used to classify query sequence x. alternatively, we can count the number of vectors within the fixed radius, g(x; r). in this paper, we used the former. because the computational cost of a knn classifier is proportional to the size of t , using a knn classifier would be intolerable when the normal training dataset becomes larger.
g(x; k) = min r s.t. ∑ y∈t [ d(lstm(x), lstm(y)) ≤ r ] ≥ k (4)
g(x; r) = 1− 1 |t | ∑ y∈t [ d(lstm(x), lstm(y)) ≤ r ] (5)
the kmc algorithm partitions t on the new vector space into k clusters g1, g2, . . . , gk in which each vector belongs to the cluster with the nearest mean so as to minimize the within-cluster sum of squares. they are computed by lloyd’s algorithm and converge quickly to a local optimum. the minimum distance from each center of clusters µi, h(x; k), is used to classify the new query sequence.
h(x; k) = min i=1,··· ,k d(lstm(x), µi) (6)
the two classifiers cg and ch are closely related in that the kmc classifier is equivalent to the 1-nearest neighbor classifier on the set of centers. in both cases of knn and kmc, we need to choose parameter k empirically, depending on the distribution of vectors. in addition, we need to choose a distance metric on the embedding space; we used the euclidean distance measure in our experiments.though system call traces themselves might be easy to acquire, collecting or generating a sufficient amount of meaningful traces for the evaluation of intrusion detection systems is a nontrivial task. in order to aid researchers in this regard, the following datasets were made publicly available from prior work: adfa-ld (creech & hu, 2013), kdd98 (lippmann , 2000) and unm (of new mexico, 2012). the kdd98 and unm datasets were released in 1998 and 2004, respectively. although these two received continued criticism about their applicability to modern systems (brown , 2009; mchugh, 2000; tan & maxion, 2003), we include them as the results would show how our model fares against early works in the field, which were mostly evaluated on these datasets. as the adfald dataset was generated around 2012 to reflect contemporary systems and attacks, we have done our evaluation mainly on this dataset.
the adfa-ld dataset was captured on an x86 machine running ubuntu 11.04 and consists of three groups: normal training traces, normal validation traces, and attack traces. the kdd98 dataset was audited on a solaris 2.5.1 server. we processed the audit data into system call traces per session. each session trace was marked as normal or attack depending on the information provided in the accompanied bsm.list file, which is available alongside the dataset. among the unm process set, we tested our model with lpr that was collected from sunos 4.1.4 machines. we merged the live lpr set and the synthetic lpr set. this combined dataset is further categorized into two groups: normal traces and attack traces. to maintain consistency with adfa-ld, we divided the normal data of kdd98 and unm into training and validation data in a ratio of 1:5, which is the ratio of the adfa-ld dataset. the numbers of system-call sequences in each dataset we used are summarized in table 1.we used adfa-ld and built three independent system-call language models by changing the hyperparameters of the lstm layer: (1) one layer with 200 cells, (2) one layer with 400 cells, and (3) two layers with 400 cells. we matched the number of cells and the dimension of the embedding
vector. our parameters were uniformly initialized in [−0.1, 0.1]. for computational efficiency, we adjusted all system-call sequences in a mini-batch to be of similar lengths. we used the adam optimizer (kingma & ba, 2014) for stochastic gradient descent with a learning rate of 0.0001. the normalized gradient was rescaled whenever its norm exceeded 5 (pascanu , 2013), and we used dropout (srivastava , 2014) with probability 0.5. we show the roc curves obtained from the experiment in figure 3.
for the two baseline classifiers, we used the euclidean distance measure. changing the distance measure to another metric did not perform well on average. in case of knn, using k = 11 achieved the best performance empirically. for kmc, using k = 1 gave the best performance. increasing the value of k produced similar but poorer results. we speculate the reason why a single cluster suffices as follows: learned representation vectors of normal training sequence are symmetrically distributed. the knn classifier cg and the kmc classifier ch achieved similar performance. compared to liao & vemuri (2002); xie  (2014), our baseline classifiers easily returned ‘highly normal’ calls. this result was leveraged by the better representation obtained from the proposed system-call language modeling.
as shown in the left plot of figure 3, three lstm classifiers performed better than cg and ch. we assume that the three lstm classifiers we trained are strong enough by themselves, and their classification results would be different from each other. by applying ensemble methods, we would expect to improve the performance. the first one was averaging, the second one was voting, and lastly we used our ensemble method as we explained in section 2.2. the proposed ensemble method gave a better auc value (0.928) with a large margin than that of the averaging ensemble method (0.890) and the voting ensemble method (0.859). moreover, the curve obtained from the proposed ensemble method was placed above individual single curves, while other ensemble methods did not show this property.
in the setting of anomaly detection where attack data are unavailable, learning ensemble parameters is infeasible. if we exploit partial attack data, the assumption breaks down and the zero-day attack issue remains. our ensemble method is appealing in that it performs remarkably well without learning.
to be clear, we applied ensemble methods to three lstm classifiers learned independently using different hyper-parameters, not with the baseline classifiers, cg or ch. applying ensemble methods to each type of baseline classifier gave unsatisfactory results since changing parameters or initialization did not result in complementary and reasonable classifiers that were essential for ensemble methods. alternatively, we could do ensemble our lstm classifiers and baseline classifiers together. however, this would also be a wrong idea because their f values differ in scale. the value of f in our lstm classifier is an average negative log-likelihood, whereas g and h indicate distances in a continuous space.
according to creech & hu (2014), the extreme learning machine (elm) model, sequence timedelay embedding (stide), and the hidden markov model (hmm) (forrest , 1996; warrender , 1999) achieved about 13%, 23%, and 42% false alarm rates (far) for 90% detection rate (dr), respectively. we achieved 16% far for 90% dr, which is comparable to the result of elm and outperforms those of stide and hmm. the roc curves for elm, hmm, and stide can be found, but we could not draw those curves on the same plot with ours because the authors provided no specific details of their results. creech & hu (2014) classified elm as a semantic approach and other two as syntactic approaches which treat each call as a basic unit. to be fair, our proposed method should be compared with those approaches that use system calls only as a basic unit in that we watch the sequence call-by-call. furthermore, our method is end-to-end while elm relies on hand-crafted features.
in creech & hu (2014), the authors reported that there was significant overhead for training the models mentioned above, and the overhead would inevitably increase for handling larger data. longer phrases tend to be more informative, but handling them typically requires larger dictionaries. for this reason, creech & hu (2014) had to put an empirical upper bound to limit the lengths of phrases, which then might lower the performance of the models to handle various attacks. by contrast, our approach can learn in continuous space semantically meaningful representations of calls, phrases, and sequences of arbitrary lengths. moreover, our method can relieve the burden of preprocessing (potentially massive) logging data. we expect that incorporating prior knowledge into our model can further boost its performance.we carried out experiments similar to those presented in section 3.2 using the kdd98 dataset and the unm dataset. first, we trained our system-call language model with lstm having one layer of 200 cells and built our classifier using the normal training traces of the kdd98 dataset. the same model was used to evaluate the unm dataset to examine the portability of the lstm models trained with data from a different but similar system. the results of our experiments are represented in figure 4. for comparison, we display the roc curve of the unm dataset by using the model from training the normal traces therein. to examine portability, the system calls in test datasets need to be included or matched to those of training datasets. unm was generated using an earlier version of os than that of kdd98, but adfa-ld was audited on a fairly different os. this made our experiments with other combinations difficult.
through a quantitative analysis, for the kdd98 dataset, we earned an almost perfect roc curve with an auc value of 0.994 and achieved 2.3% far for 100% dr. with the same model, we tested the unm datset and obtained a roc curve with an auc value of 0.969 and 5.5% far for 99.8% dr. this result was close to the result earned by using the model trained on normal training traces of the unm dataset itself, as shown in the right plot of figure 4.
this result is intriguing because it indicates that system-call language models have a strong portability. in other words, after training one robust and extensive model, the model can then be deployed to other similar host systems. by doing so, we can mitigate the burden of training cost. this paradigm is closely related to the concept of transfer learning, or zero-shot learning. it is well known that neural networks can learn abstract features and that they can be used successfully for unseen data.it is well-known that neural network based-language models can learn semantically meaningful embeddings to continuous space (bengio , 2003; mikolov , 2013; cho , 2014). we
expected to see a similar characteristic with the proposed system-call language model. the 2d projection of the calls using the embedding matrix w learned from the system-call language model was done by t-sne (van der maaten & hinton, 2008) and shown in figure 5. just as the natural language model, we can expect that calls having similar co-occurrence patterns are positioned in similar locations in the embedded space after training the system call language model. we can clearly see that calls having alike functionality are clustered with each other.
the first obvious cluster would be the read-write call pair and the open-close pair. the calls of each pair were located in close proximity in the space, meaning that our model learned to associate them together. at the same time, the difference between the calls of each pair appears to be almost the same in the space, which in turn would mean our model learned that the relationship of each pair somewhat resembles.
another notable cluster would be the group of select, pselect6, ppoll, epoll wait and nanosleep. the calls select, pselect6 and ppoll all have nearly identical functions in that they wait for some file descriptors to become ready for some class of i/o operation or for signals. the other two calls also have similar characteristics in that they wait for a certain event or signal as well. this could be interpreted as our model learning that these ‘waiting’ calls share similar characteristics.
other interesting groups would be: readlink and lstat64 which are calls related to symbolic links; fstatat64 and fstat64 which are calls related to stat calls using file descriptors; pipe and pipe2 which are nearly identical and appear almost as one on the embedding layer. these cases show that our model is capable of learning similar characteristics among the great many system calls.
similarly to the call representations, we expected that attack sequences with the same type would cluster to each other, and we tried to visualize them. however, for various reasons including the lack of data, we were not able to observe this phenomenon. taking the fact that detecting abnormal patterns from normal patterns well would be sufficiently hard into consideration, learning representation to separate different abnormal patterns with only seen normal patterns would also be an extremely difficult task.our main contributions for designing intrusion detection systems as described in this paper have two parts: the introduction of a system-call language modeling approach and a new ensemble method. to the best of the authors’ knowledge, our method is the first to introduce the concept of a language model, especially using lstm, to anomaly-based ids. the system-call language model can capture the semantic meaning of each call and its relation to other system calls. moreover, we proposed an innovative and simple ensemble method that can better fit to ids design by focusing on lowering false alarm rates. we showed its outstanding performance by comparing it with existing state-of-theart methods and demonstrated its robustness and generality by experiments on diverse benchmarks.
as discussed earlier, the proposed method also has excellent portability. in contrast to alternative methods, our proposed method incurs significant smaller training overhead because it does not need to build databases or dictionaries to keep a potentially exponential amount of patterns. our method is compact and light in that the size of the space required to save parameters is small. the overall training and inference processes are also efficient and fast, as our methods can be implemented using efficient sequential matrix multiplications.
as part of our future work, we are planning to tackle the task of detecting elaborate contemporary attacks including mimicry attacks (wagner & soto, 2002; shu , 2015) by more advanced methods. our proposed method allows us to estimate the likelihood of arbitrary sections in a given system-call sequence, which may be helpful for analyzing the capability of handling mimicry attacks. for instance, it is possible to determine if there exists a sufficiently long section (rather than the whole sequence) with the average log-likelihood below the threshold. in addition, we are considering designing a new framework to build a robust model in on-line settings by collecting large-scale data generated from distributed environments. for optimization of the present work, we would be able to alter the structure of rnns used in our system-call language model and ensemble algorithm. finally, we anticipate that a hybrid method that combines signature-based approaches and feature engineering will allow us to create more accurate intrusion detection systems.this work was supported by bk21 plus project in 2016 (electrical and computer engineering, seoul national university).",0
734.pdf.json,DEEP VARIATIONAL CANONICAL CORRELATION ANALYSIS,"in the multi-view representation learning setting, we have multiple views/measurements of the same underlying signal, and the goal is to learn useful features of each view using complementary information contained in the views. the intuition underlying this setting is that the learned features can help uncover the common sources of variation in the views, which can be helpful for exploratory analysis or for downstream tasks.
a classical approach in this setting is canonical correlation analysis (cca, hotelling, 1936) and its nonlinear extensions, including the kernel extension (lai and fyfe, 2000; akaho, 2001; melzer , 2001; bach and jordan, 2002) and the deep neural network (dnn) extension (andrew , 2013; wang , 2015b). cca projects two random vectors x ∈ rdx and y ∈ rdy into a lowerdimensional subspace so that the projections are maximally correlated. there is a probabilistic latent variable model interpretation of linear cca (bach and jordan, 2005) as shown in figure 1 (left). assume that x and y are linear functions of some lower-dimensional random variable z ∈ rdz , where dz ≤ min(dx, dy). when the prior distribution of the latent variable p(z) and the conditional distributions p(x|z) and p(y|z) are gaussian, bach and jordan (2005) showed that e[z|x] (resp. e[z|y]) lives in the same space as the linear cca projection for x (resp. y). this generative interpretation of cca is often lost in nonlinear extensions of cca. for example, in deep cca (dcca, (andrew , 2013)), to extend cca to nonlinear mappings with greater representation power, one extracts nonlinear features from the original inputs of each view using two dnns, f for x and g for y, so that the canonical correlation of the dnn outputs (measured by a linear cca with projection matrices u and v) is maximized. formally, given a dataset of n pairs of observations (x1,y1), . . . , (xn ,yn ) of the random vectors (x,y), dcca optimizes
max wf ,wg
u,v
tr ( u>f(x)g(y)>v ) s.t. u> ( f(x)f(x)> ) u = v> ( g(y)g(y)> ) v = ni, (1)
where f(x) = [f(x1), . . . , f(xn )] and g(y) = [g(y1), . . . ,g(yn )], and wf denotes all weight parameters of the dnn f (and similarly for g).
dcca has achieved good performance in the multi-view representation learning setting across different domains (wang , 2015b,a; lu , 2015; yan and mikolajczyk, 2015). however, a disadvantage of dcca is that it directly looks for dnns that can map inputs into the low-dimensional space, without a model for generating samples from the latent space. although wang  (2015b)’s deep canonically correlated autoencoders (dccae) model optimizes the combination of the autoencoder objective (reconstruction errors) and the canonical correlation objective, the authors found that in practice, the canonical correlation term tends to dominate the reconstruction error terms in the dccae objective when tuning performance for a downstream task (especially when the inputs are noisy), and as a result the inputs are not reconstructed well. at the same time, optimization of the dcca and dccae objectives is challenging due to the constraints that couple all training samples.
the main contribution of this paper is the proposal of a new deep multi-view learning model named deep variational cca (vcca), which extends the latent variable model interpretation of linear cca to nonlinear observation models parameterized by dnns. computing the marginal data likelihood, as well as inference of the latent variables, are intractable under this model. inspired by variational autoencoders (vae, kingma and welling, 2014), we parameterize the posterior distribution of the latent variables with another dnn, and derive a variational lower bound of the data likelihood as the objective of vcca, which is further approximated by monte carlo sampling. with the reparameterization trick, sampling for the monte carlo approximation is trivial and all dnn weights in vcca can be optimized jointly via stochastic gradient descent, using unbiased gradient estimates from small minibatches. interestingly, vcca is related to multi-view autoencoders (ngiam , 2011), with the key distinctions of additional regularization on the posterior distribution and the sampling procedure at the bottleneck layer.
we also propose a variant of vcca called vcca-private that can, in addition to the “common variables” underlying both views, extract the “private variables” within each view. we demonstrate that vcca-private is able to disentangle the shared and private information for multi-view data without hard supervision. last but not least, as generative models, vcca and vcca-private enable us to obtain high-quality samples for the input of each view.the probabilistic latent variable model of cca (bach and jordan, 2005) defines the following joint distribution over the random variables (x,y):
p(x,y, z) = p(z)p(x|z)p(y|z), p(x,y) = ∫ p(x,y, z)dz. (2)
the assumption underlying this model is that, conditioned on the latent variables z ∈ rdz , the two views x and y are independent. however, linear observation models (p(x|z) and p(y|z) as shown in figure 1 (left)) have limited representation power. in this paper, we consider nonlinear
observation models pθ(x|z;θx) and pθ(y|z;θy), parameterized by θx and θy respectively, which can be the collections of weights of dnns. in this case, the marginal likelihood pθ(x,y) does not have a closed form. in addition, the inference problem pθ(z|x)—the problem of inferring the latent variables given one of the views—is also intractable.
inspired by kingma and welling (2014)’s work on variational autoencoders (vae), we approximate pθ(z|x) with the conditional density qφ(z|x;φz), where φz is the collection of parameters of another dnn.1 we can derive a lower bound on the marginal data likelihood using qφ(z|x):
log pθ(x,y) = log pθ(x,y) ∫ qφ(z|x)dz = ∫ log pθ(x,y)qφ(z|x)dz
= ∫ qφ(z|x) ( log
qφ(z|x) pθ(z|x,y) + log pθ(x,y, z) qφ(z|x)
) dz
= dkl(qφ(z|x)||pθ(z|x,y)) + eqφ(z|x) [ log pθ(x,y, z)
qφ(z|x) ] ≥ eqφ(z|x) [ log pθ(x,y, z)
qφ(z|x)
] =: l(x,y;θ,φ) (3)
where we used the fact that kl divergence is nonnegative in the last step. as a result, l(x,y;θ,φ) is a lower bound on the data log-likelihood logθ p(x,y). substituting (2) into (3), we have
l(x,y;θ,φ) = ∫ qφ(z|x) ( log p(z)
qφ(z|x) + log pθ(x|z) + log pθ(y|z)
) dz
= −dkl(qφ(z|x)||p(z)) + eqφ(z|x) [log pθ(x|z) + log pθ(y|z)] . (4) vcca maximizes this variational lower bound on the data likelihood on the training set:
max θ,φ 
n n∑ i=1 l(xi,yi;θ,φ). (5)
the first term in (4) measures the kl divergence between the approximate posterior distribution and the prior distribution of the latent variables z. when the parameterization qφ(z|x) is chosen properly, this term can be computed exactly in closed form. as a concrete example, let the variational approximate posterior be a multivariate gaussian with diagonal covariance. that is, for a sample pair (xi,yi), we have
log qφ(zi|xi) = logn (zi;µi,σi), σi = diag ( σ2i1, . . . , σ 2 idz ) , (6)
where the mean µi and covariance σi are outputs of an encoding dnn f (and thus [µi,σi] = f(xi;φz) are deterministic nonlinear functions of xi). in this case, we have
dkl(qφ(zi|xi)||p(zi)) = − 1  dz∑ j=1 ( 1 + log σ2ij − σ2ij − µ2ij ) .
the second term of (4) corresponds to the expected complete data likelihood under the approximate posterior distribution. though still intractable, this term can be approximated by monte carlo sampling. in particular, we draw l samples z(l)i ∼ qφ(zi|xi):
z (l) i = µi + σi (l), where (l) ∼ n (0, i), for l = 1, . . . , l, (7) and have
eqφ(zi|xi) [log pθ(xi|zi) + log pθ(yi|zi)] ≈ 1
l l∑ l=1 log pθ ( xi|z(l)i ) + log pθ ( yi|z(l)i ) . (8)
notice that we parameterized qφ(zi|xi) above to obtain the vcca objective; this is useful when the first view is available for downstream tasks, in which case we can directly apply qφ(zi|xi) to obtain its projection (as features). one could also derive likelihood lower bounds by parameterizing the approximate posteriors qφ(zi|yi) and qφ(zi|xi,yi), and optimize their convex combinations for training. we give a sketch of vcca in figure 1 (right). for notational simplicity, we denote by θ the collection of parameters associated with the model probabilities pθ(·), and φ the collection of parameters associated with the variational approximate probabilities qφ(·), and often omit specific parameters inside the probabilities.
connection to multi-view autoencoder (mvae) if we use the gaussian observation models
log pθ(x|z) = logn (gx(z;θx), i), log pθ(y|z) = logn (gy(z;θy), i), we observe that log pθ ( xi|z(l)i ) and log pθ ( yi|z(l)i ) measure the reconstruction errors of each
view’s inputs from samples z(l)i using the two dnns gx and gy respectively. in this case, maximizing l(x,y;θ,φ) is equivalent to
min θ,φ 
n n∑ i=1 dkl(qφ(zi|xi)||p(zi)) + 1 2nl n∑ i=1 l∑ l=1 ∥∥∥xi − gx (z(l)i ;θx)∥∥∥2 + ∥∥∥yi − gy (z(l)i ;θy)∥∥∥2 (9)
s.t. z(l)i = µi + σi (l), where (l) ∼ n (0, i), l = 1, . . . , l.
now, consider the case of σi → 0, for i = 1, . . . , n , and we have z(l)i → µi which is a deterministic function of x (and there is no need for sampling). in the limit, the second term of (9) reduces to  n n∑ i=1 ‖xi − gx(f(xi;φz);θx)‖ 2 + ‖yi − gy(f(xi;φz);θy)‖ 2 , (10)
which is the objective of the multi-view autoencoder (mvae, ngiam , 2011). note, however, that σi → 0 is prevented by the vcca objective as it results in a large penalty in dkl(qφ(zi|xi)||p(zi)). compared with the mvae objective, in the vcca objective we are creating l different “noisy” versions of the latent representation and enforce that these versions reconstruct the original inputs well. the “noise” distribution (the variances σi) are also learned and regularized by the kl divergence dkl(qφ(zi|xi)||p(zi)). using the vcca objective, we expect to learn different representations from those of mvae, due to these regularization effects.so far, vcca aims at extracting only the latent variables z that are common to both views. a potential disadvantage of this model is that it assumes the common variables are sufficient by themselves to generate the views, which can be too restrictive in practice. consider the example of audio and articulatory measurements as two views for speech. although the transcription is a common variable behind the views, it combines with the physical environment and the vocal tract anatomy to generate the individual views. in other words, there might be large variations in the input space that can not be explained by the common variables, making the objective (4) hard to optimize. it may then be beneficial to explicitly model the private variables within each view.
we therefore propose a new probabilistic graphical model, shown in figure 2, that we refer to as vcca-private. we introduce two sets of hidden variables hx ∈ rdhx and hy ∈ rdhy to explain the aspects of x and y not captured by the common variables z. under this model, the data likelihood
is defined by
pθ(x,y, z,hx,hy) = p(z)p(hx)p(hy)pθ(x|z,hx;θx)pθ(y|z,hy;θy), (11)
pθ(x,y) = ∫ ∫ ∫ pθ(x,y, z,hx,hy)dz dhx dhy.
to obtain tractable inference, we introduce the following factored variational posterior
qφ(z,hx,hy|x,y) = qφ(z|x;φz)qφ(hx|x;φx)qφ(hy|y;φy), (12)
where each factor is parameterized by a different dnn. similarly to vcca, we can derive a variational lower bound on the data likelihood for vcca-private as
log pθ(x,y) ≥ ∫ ∫ ∫ qφ(z,hx,hy|x,y) log pθ(x,y, z,hx,hy)
qφ(z,hx,hy|x,y) dz dhx dhy
= ∫ ∫ ∫ qφ(z,hx,hy|x,y) [ log p(z)
qφ(z|x) + log
p(hx)
qφ(hx|x) + log
p(hy)
qφ(hy|y) + log pθ(x|z,hx) + log pθ(y|z,hy) ] dz dhx dhy
= −dkl(qφ(z|x)||p(z))−dkl(qφ(hx|x)||p(hx))−dkl(qφ(hy|y)||p(hy))
+ ∫ ∫ qφ(z|x)qφ(hx|x) log pθ(x|z,hx)dz dhx + ∫ ∫ qφ(z|x)qφ(hy|y) log pθ(y|z,hy)dz dhy
=: lprivate(x,y;θ,φ). (13)
as in vcca, the last two terms of (14) can be approximated by monte carlo sampling. for example, we draw samples of z and hx from their corresponding approximate posteriors, and concatenate their samples as inputs to the dnn parameterizing pθ(x|z,hx). in this paper, we use simple gaussian prior distributions for the private variables, i.e., hx ∼ n (0, i) and hy ∼ n (0, i). we leave to future work to examine the effect of more sophisticated prior distributions for the latent variables.
vcca-private maximizes this lower bound on the training set, i.e.,
max θ,φ 
n n∑ i=1 lprivate(xi,yi;θ,φ). (14)
optimization the objectives (5) and (14) decouple over the training samples and can be trained efficiently using stochastic gradient descent. enabled by the reparameterization trick, unbiased gradient estimates are obtained by monte carlo sampling and the standard backpropagation procedure on minibatches of training samples. we apply the adam algorithm (kingma and ba, 2015) for optimizing our objectives.recently, there has been much interest in unsupervised deep generative models (kingma and welling, 2014; rezende , 2014; goodfellow , 2014; gregor , 2015; makhzani , 2016; burda , 2016; alain , 2016). a common motivation behind these models is that, with the expressive power of dnns, the generative models can capture distributions for complex inputs. additionally, if we are able to generate realistic samples from the learned distribution, we can infer that we have discovered the underlying structure of the data, which may allow us to reduce the sample complexity for learning for downstream tasks. these previous models have mostly focused on single-view data. here we focus on the multi-view setting where multiple views of the data are present for feature extraction but only one view is available at test time (in downstream tasks).
some recent work has explored deep generative models for (semi-)supervised learning. kingma  (2014) built a generative model based on variational autoencoders (vaes) for semi-supervised classification, where the authors model the input distribution with two set of latent variables: the class label (if it is missing) and another set that models the intra-class variabilities (styles). sohn
 (2015) proposed a conditional generative model for structured output prediction, where the authors explicitly model the uncertainty in the input/output using gaussian latent variables. while there are two set of observations (input and output labels) in these work, their graphical models are different from that of vcca.
our work is also related to the deep multi-view probabilistic models based on restricted boltzmann machines (srivastava and salakhutdinov, 2014; sohn , 2014). we note that these are undirected graphical models for which both inference and learning are difficult, and one typically resorts to carefully designed variational approximation and gibbs sampling procedures for training such models. in contrast, our models only require sampling from simple, standard distributions (such as gaussians), and all parameters can be learned end-to-end by standard stochastic gradient methods. therefore, our models are more scalable than the previous multi-view probabilistic models.
on the other hand, there is a rich literature in modeling multi-view data using the same or similar graphical models behind vcca/vcca-private (wang, 2007; jia , 2010; salzmann , 2010; virtanen , 2011; memisevic , 2012; klami , 2013). our methods differ from previous work in parameterizing the probability distributions using dnns. this makes the model more powerful, while still having tractable objectives and efficient end-to-end training using the local reparameterization technique. we note that, unlike earlier work on probabilistic models of linear cca (bach and jordan, 2005), vcca does not optimize the same criterion, nor produce the same solution, as any linear or nonlinear cca. however, we retain the terminology in order to clarify the connection with earlier work on probabilistic models for cca, which we are extending with dnn models for the observations and for the variational posterior distribution approximation.in this section, we compare different multi-view representation learning algorithms on three tasks involving several domains: image-image, speech-articulation, and image-text. the algorithms we choose to compare below are closely related to the proposed model or have been shown to have strong empirical performance under similar settings.
• linear cca: its probabilistic interpretation motivates this work.
• deep cca (dcca) (andrew , 2013): see its objective in (1).
• deep canonically correlated autoencoders (dccae) (wang , 2015b): combination of the dcca objective and the reconstruction errors of each view.
• multi-view autoencoder (mvae) (ngiam , 2011): see its objective in (10).
• multi-view contrastive loss (hermann and blunsom, 2014): based on the intuition that the distance between embeddings of paired examples x+ and y+ should be smaller than the distance between embeddings of x+ and an unmatched negative example y− by a margin:
min f,g lcontrast := 
n n∑ i max ( 0, m+ dis ( f(x+i ), g(y + i ) ) − dis ( f(x+i ), g(y − i ) )) ,
where y−i is a randomly sampled view 2 example, and m is a margin hyperparameter. we use the cosine distance dis (a,b) = 1− 〈
a ‖a‖ , b ‖b‖
〉 .we first demonstrate our algorithms on the noisy mnist dataset used by wang  (2015b). the dataset is generated using the mnist dataset (lecun , 1998), which consists of 28 × 28 grayscale digit images, with 60k/10k images for training/testing. we first linearly rescale the pixel values to the range [0, 1]. then, we randomly rotate the images at angles uniformly sampled from [−π/4, π/4] and the resulting images are used as view 1 inputs. for each view 1 image, we randomly select an image of the same identity (0-9) from the original dataset, add independent random noise uniformly sampled from [0, 1] to each pixel, and truncate the pixel final values to [0, 1] to obtain the corresponding view 2 sample. selection of input images are given in figure 3 (left). the original
training set is further split into training/tuning sets of size 50k/10k. the data generation process ensures that the digit identity is the only common variable underlying both views.
to evaluate the amount of class information extracted by different methods, after unsupervised learning of latent representations, we reveal the labels and train a linear svm on the projected view 1 training data (using the one-versus-all scheme), and use it to classify the projected test set. this experiment simulates the typical usage of multi-view learning methods, which is to extract useful representations for downstream discriminative tasks.
note that this synthetic dataset perfectly satisfies the multi-view assumption that the two views are independent given the class label, so the latent representation should contain precisely the class information. this is indeed achieved by cca-based and contrastive loss-based multi-view approaches. in figure 3 (right), we show 2d t-sne (van der maaten and hinton, 2008) visualizations of the original view 1 inputs and view 1 projections by various deep multi-view methods.
we use dnns with 3 hidden layers of 1024 rectified linear units (relus, nair and hinton, 2010) each to parameterize the distributions: qφ(z|x), pθ(x|z), pθ(y|z) in vcca, and additionally qφ(hx|x) and qφ(hy|y) in vcca-private. the capacities of these networks are the same as those of their counterparts in dcca and dccae from wang  (2015b). the reconstruction networks pθ(x|z) or pθ(x|z,hx) model each pixel of x as an independent bernoulli variable and parameterize its mean (using a sigmoid activation); pθ(y|z) and pθ(y|z,hy) model y with diagonal gaussians and parameterize the mean (using a sigmoid activation) and standard deviation for each pixel dimension. we tune the dimensionality dz over {10, 20, 30, 40, 50}, and fix dhx = dhy = 30 for vcca-private. we select the hyperparameter combination that yields the best svm classification accuracy on the projected tuning set, and report the corresponding accuracy on the projected test set.
the effect of dropout we add dropout (srivastava , 2014) to all intermediate layers and the input layers and find it to be very useful in our models, with most of the gain coming from dropout applied to the samples of z, hx and hy . this is because dropout encourages each latent dimension to reconstruct the inputs well in the absence of other dimensions, and therefore avoids learning coadapted features. intuitively, in vcca-private dropout also helps to prevent the degenerate situation where the pathways x → hx → x and y → hy → y achieve good reconstruction while ignoring z (e.g., by setting it to a constant). we use the same dropout rate for all layers and tune it over {0, 0.1, 0.2, 0.3, 0.4}. we show the 2d t-sne embeddings of the common variables z learned by vcca and vcca-private on test set in figure 4. we observe that in general, vcca/vcca-private tend to separate the classes
in the projection well; dropout significantly improves the performance of both vcca and vccaprivate, with the latter slightly outperforming the former. while such class separation can also be achieved by dcca/contrastive loss as well, these methods can not naturally generate samples in the input space. on the other hand, such separation is not achieved by multi-view autoencoders.
the effect of private variables on reconstructions we show sample reconstructions (mean and standard deviation) by vcca for the view 2 images from the test set in figure 5 (columns 2 and 3). we observe that for each input, the mean reconstruction of yi by vcca is a prototypical image of the same digit, regardless of the individual style in yi. this is to be expected, as yi contains an arbitrary image of the same digit as xi, and the variation in background noise in yi does not appear in xi and can not be reflected in qφ(z|x); thus the best way for pθ(y|z) to model yi is to output a prototypical image of that class to achieve on average small reconstruction error. on the other hand, since yi contains little rotation of the digits, this variation is suppressed to a large extent in qφ(z|x) (it is no longer the major variation in z as in the original inputs).
we show sample reconstructions by vcca-private for the same set of view 2 images in figure 5 (columns 4 and 5). with the help of private variables hy (as part of the input to pθ(y|z,hy)), the model does a much better job in reconstructing the styles of y. and by disentangling the private variables from the shared variables, qφ(z|x) achieves even better class separation than vcca does.
we also note that the standard deviation of the reconstruction is low within the digit and high outside the digit, implying that pθ(y|z,hy) is able to separate the background noise from the digit image.
disentanglement of private/shared variables in figure 6 (in appendix) we provide the 2d tsne embeddings of the shared variables z (top row) and the private variables hx (bottom row) learned by vcca-private. in the embedding of hx, digits with different identities but the same rotation are mapped close together, and the rotation varies smoothly from left to right, confirming that the private variables contain little class information but mainly style information.
finally, we give the test error rates of linear svms applied to the features learned with different models in table 1. vcca-private is comparable in performance to the best previous approach (dccae), while having the advantage that it can also generate.we now consider the task of learning acoustic features for speech recognition. we use data from the wisconsin x-ray microbeam (xrmb) corpus (westbury, 1994), which contains simultaneously recorded speech and articulatory measurements from 47 american english speakers. we follow the setup of wang  (2015a,b) and use the learned features for speaker-independent phonetic recognition.2 the two input views are standard 39d acoustic features (13 mel frequency cepstral coefficients (mfccs) and their first and second derivatives) and 16d articulatory features (horizontal/vertical displacement of 8 pellets attached to several parts of the vocal tract), each then concatenated over a 7-frame window around each frame to incorporate context. the speakers are split into disjoint sets of 35/8/2/2 speakers for feature learning/recognizer training/tuning/testing. the 35 speakers for feature learning are fixed; the remaining 12 are used in a 6-fold experiment (recognizer training on 8 speakers, tuning on 2 speakers, and testing on the remaining 2 speakers). each speaker has roughly 50k frames. we remove the per-speaker mean and variance of the articulatory measurements for each training speaker, and remove the mean of the acoustic measurements for each utterance. all learned feature types are used in a “tandem” speech recognizer (hermansky , 2000), i.e., they are appended to the original 39d features and used in a standard hidden markov model (hmm)-based recognizer with gaussian mixture observation distributions.
each algorithm uses up to 3 relu hidden layers, each of 1500 units, for the projection and reconstruction mappings. for vcca/vcca-private, we use gaussian observation models as the inputs are real-valued. in contrast to the mnist experiments, we do not learn the standard deviations of each output dimension on training data, as this leads to poor downstream task performance. instead, we use isotropic covariances for each view, and tune the standard deviations by grid search. the best model uses a smaller standard deviation (0.1) for the view 2 than for view 1 (1.0), effectively putting more emphasis on the reconstruction of articulatory measurements. our best performing vcca model uses dz = 70, while the best performing vcca-private model uses dz = 70 and dhx = dhy = 10. as in wang and livescu (2016), we use the kaldi toolkit (povey , 2011) for feature extraction and recognition with hidden markov models. our results do not match wang  (2015a,b) (who instead used the htk toolkit (young , 1999)) for the same types of features, but the relative results are consistent.
the mean phone error rates (per) over 6 folds obtained by different algorithms are given in table 1. our methods achieve competitive performance in comparison to previous deep multi-view methods.finally, we consider the task of learning cross-modality features for topic classification on the mirflickr database (huiskes and lew, 2008). the flickr database contains 1 million images accompanied by user tags, among which 25000 images are labeled with 38 topic classes (each image may be categorized as multiple topics). we use the same image and text features as in previous work (srivastava and salakhutdinov, 2014; sohn , 2014): the image feature is 3857 dimensional real-valued vector, composed of pyramid histogram of words (phow) (bosch , 2007), gist (oliva and torralba, 2001), and mpeg-7 descriptors (manjunath , 2001), while the text feature is a 2000-dimensional binary vector of frequent tags.
following the same protocol as sohn  (2014), we train multi-view representations using the unlabelled data,3 and use projected image features of the labeled data (further divided into splits of 10000/5000/10000 samples for training/tuning/testing) for training and evaluating a classifier that predicts the topic labels, corresponding to the unimodal query task in srivastava and salakhutdinov (2014); sohn  (2014). for each algorithm, we select the model which achieves the highest mean average precision (map) on the validation set, and report its performance on the test set.
each algorithm uses up to 4 relu hidden layers, each of 1024 units, for the projection and reconstruction mappings. for vcca/vcca-private, we use gaussian observation models with isotropic covariance for image features, with standard deviation tuned by grid search, and a bernoulli model for text features. in this experiment, we also found it helpful to tune an additional trade-off parameter for the text-view likelihood (cross-entropy); the best vcca/vcca-private models prefer a large trade-off parameter of the level 104, emphasizing the reconstruction of the sparse text-view inputs. our best performing vcca model uses dz = 1024, while the best performing vcca-private model uses dz = 1024 and dhx = dhy = 16.
as shown in table 1, vcca/vcca-private achieve significantly higher maps than other methods considered here. being much easier to train, the performance of our methods are competitive with the previous state-of-the-art map result of 0.607 achieved by the multi-view rbms of sohn  (2014) under the same setting.we have proposed variational canonical correlation analysis (vcca), a deep generative method for multi-view representation learning. our method embodies a natural idea for multi-view learning: the multiple views can be generated from a small set of shared latent variables. vcca is parameterized by dnns and can be trained efficiently by backpropagation, and is therefore scalable. we have also shown that, by modeling the private variables that are specific to each view, the vcca-private variant can disentangle shared/private variables and provide higher-quality reconstructions.
in the future, we will explore other prior distributions such as mixtures of gaussians or discrete random variables, which may enforce clustering in the latent space and in turn work better for discriminative tasks. we will also explore other observation models, including replacing the autoencoder objective with that of adversarial networks (goodfellow , 2014; makhzani , 2016; chen , 2016). another direction is to explicitly incorporate the structure of the inputs, such as the sequence structure of speech and text and the spatial structure of images.
ackowledgements
this research was supported by nsf grant iis-1321015. the opinions expressed in this work are those of the authors and do not necessarily reflect the views of the funding agency. this research used gpus donated by nvidia corporation. as in sohn  (2014), we exclude about 250000 samples which contain fewer than two tags.",0
738.pdf.json,,"deep neural networks have achieved state-of-the-art performance in many different tasks, such as computer vision (krizhevsky , 2012) (simonyan & zisserman, 2015), speech recognition, and natural language processing (karpathy , 2016). the underlying representational power of these neural networks comes from the huge parameter space, which results in an extremely large amount of computation operations and memory footprint. to reduce the memory usage and accelerate the training process, the research community has strived to eliminate the redundancy in the deep neural networks (han , 2016b). exploiting the sparsity in both weights and activations of convolutional neural networks (cnns), sparsity-centric optimization techniques (han , 2016a) (albericio , 2016) have been proposed to improve the speed and energy efficiency of cnn accelerators.
these sparsity-centric approaches can be classified into two categories: (1) pruning unimportant weight parameters and (2) skipping zero values in activations to eliminate multiply-accumulate (mac) operations with zero operands. although both categories have achieved promising results for cnns, it remains unclear if they are applicable to training other neural networks, such as lstmbased rnns. the network pruning approach is not suitable for training because it only benefits the inference phase of neural networks by iteratively pruning and re-training. the approach that exploits the sparsity in the activations can be used for training because the activations are involved in both
the forward propagation and the backward propagation. but there are still some issues if we directly apply it to lstm-based rnns.
the sparsity in cnn activations mostly comes from the rectified linear unit (relu) activation function, which sets all negative values to zero. however, long short-term memory, one of the most popular rnn cells, does not adopt the relu function. therefore, lstm should exhibit much less sparsity in activations than cnns, intuitively. furthermore, the structure of an lstm cell is much more complicated than neurons in convolutional layers or fully connected layers of a cnn.
to explore additional opportunities to apply sparsity-centric optimization to lstm-based rnns, we conducted an application characterization on several lstm-based rnn applications, including character-based language model, image captioning, and machine translation. although the experimental results of the application characterization show that there is little sparsity in the activations, we observed potential sparsity in backward propagation of the lstm training process. the activation values of the gates (input gate, forget gate, and output gate) and the new cell state exhibit a skewed distribution due to their functionality. that is, a large fraction of the activation values of these sigmoid-based gates are either close to 1 or close to 0 (for the tanh-based new cell activations, values are close to -1 or 1). this skewed distribution will lead to a considerable amount of very small values in the lstm backward propagation since there is a term σ(x)(1− σ(x)) in the gradients of the sigmoid-based gates (tanh(x)(1− tanh(x)) for the gradients of the new cell gradients), which will be zero given σ(x) = 0 or σ(x) = 1 (tanh(x) = −1 or tanh(x) = 1 for the new cell gradients). in real-world implementations, these very small values might be clamped to zero as they are in the form of floating-point numbers, of which the precision is limited. therefore, there is potential sparsity in the gradients of the backward propagation of lstm training.
to ensure that there is non-trivial amount of sparsity for hardware designers to exploit, we propose “sparsified” sgd, a rounding to zero technique to induce more sparsity in the gradients. this approach can be seen as a stochastic gradient descent (sgd) learning algorithm with sparsifying, which strips the precision of floating point numbers for unimportant small gradients. experiment results show that with proper thresholds, we can make 80% of the gradients of the gate inputs to zero without performance loss for all applications and datasets we tested so far. as the sparse gradients of the gate inputs are involved in 67% matrix multiplications, more than 50% mac operations are redundant in the entire lstm training process. eliminating these ineffectual mac operations with hardware techniques, the energy efficiency and training speed of lstm-based rnns will be improved significantly.in this section, we first review some of the prior work on sparsity-centric optimization techniques for neural networks, and then illustrate the application characterization example as the motivation for our research.it has been demonstrated that there is significant redundancy in the parameterization of deep neural networks (denil , 2013). consequently, the over-sized parameter space results in sparsity in the weight parameters of a neural network. besides the parameters, there is also sparsity in the activations of each layer in a network, which comes from two sources: (1) the sparsity in weight parameters and (2) the activation function of neurons, such as relu.
as the sparsity in weight parameters do not depend on the input data, it is often referred to as static sparsity. on the other hand, the sparsity in the activations depend on not only the weight values but also the input data. therefore, we refer to the sparsity in the activations as dynamic sparsity.
exploiting sparsity can dramatically reduce the network size and thus improve the computing performance and energy efficiency. for example, deep compression (han , 2016b) applied network pruning to cnns to significantly reduce the footprint of the weights, which enables us to store all the weights on sram. however, the static sparsity can only help the inference phase but not training because weight parameters are adjusted during training. fortunately, leveraging the dynamic sparsity can benefit both inference and training of neural networks. recent publications (han , 6a) (albericio , 2016) have proposed various approaches to eliminate ineffectual mac operations with zero operands. although these sparsity-centric optimization approaches have achieved promising results on cnns, much less attention has been paid to lstm-based rnns, because there is a common belief that the major source of sparsity is the relu function, which is widely used in the convolutional layers but not in lstm-based rnns. to accelerate lstm-based rnns and improve the energy efficiency, we investigate opportunities to exploit sparsity in the lstm-based rnn training process. as an initial step, in this paper we focus on the basic lstm cell without peephole or other advanced features, as shown in figure 1.to reveal if there is sparsity in lstm training, we conduct an application characterization study. we start with a character-based language model as described in (karpathy , 2016). this characterbased language model takes a sequence of characters as input and predicts the next character of this sequence. the characters are represented in one-hot vectors, which are transformed into distributed vectors by a word2vec layer. then the distributed vectors feed into an rnn model based on lstm cells, followed by a linear classifier.
the lstm cells used in this character-based language model are all basic lstm cells. for each cell, the forward propagation flow is as below:
it = σ(w ixt + u iht−1 + b i)
ft = σ(w fxt + u fht−1 + b f )
ot = σ(w oxt + u oht−1 + b o)
gt = tanh(w gxt + u ght−1 + b g)
ct = ft ◦ ct−1 + it ◦ gt ht = ot ◦ tanh(ct)
as shown in figure 1, it, ft, and ot stand for input gate, forget gate, and output gate, respectively. these sigmoid-based gates (σ stands for sigmoid) are used to prevent irrelevant input from affecting the memory cell (ct). the new cell state (gt) is a preliminary summary of the current input from the previous layer and the previous status of current layer. the final hidden status ht is the output of the lstm cell if it is seen as a black box.
since the gates are introduced to prevent irrelevant inputs from affecting the memory cell ct, we have a hypothesis that a large fraction of the activations of these gates should be either close to 1 or close to 0, representing the control signal on or off, respectively. similarly, the tanh-based new cell status is active if its activation is 1 or inactive if it is -1. there should also be a considerable portion of the activations close to 1 or -1.
to validate our hypothesis, we extracted the activations of the sigmoid-based gates and tanh-based new cell state from several model snapshots during training the character-based language model. figure 2 shows the histogram of the activation values of the gates and the new cell. the red curves represent the activation values generated by a snapshot model which is 0.5% trained (in terms of total number of iterations) while the bars represent the activation values generated by a fully trained
model. we can observe skewed distributions from each gate (and new cell) for both the 0.5% trained snapshot model and the fully trained model. furthermore, the fully trained model shows a distribution that is more skewed to the leftmost and the rightmost. additionally, other un-shown snapshots demonstrate that the distribution becomes consistently more skewed as the training process goes on. we also observed that after 10% of the training process, the distribution becomes steady, almost the same as the fully trained model.
besides the character-based language model, we also conducted the same characterization to the image captioning task described in (karpathy & li, 2015). the activation values of the rnn layer in the image captioning task exhibit the skewed distribution too. even though we did not observe sparsity in the gate activations, the skewed distribution indicates potential sparsity in the lstmbased rnn backward propagation, which will be shown in the next section.in this section, we first show how the skewed distribution of gate values leads to potential sparsity in the lstm backward propagation, and then we propose the “sparsified” sgd to induce more sparsity in lstm training.to show how the skewed distribution in the gate activations results in potential sparsity in the lstmbased rnn backward propagation, we need to review the forward and backward propagation at first. we can re-write the forward propagation equations as
net(i)t =w ixt + u iht−1 + b i
net(f)t =w fxt + u fht−1 + b f
net(o)t =w oxt + u oht−1 + b o
net(g)t =w gxt + u ght−1 + b g
it = σ(net(i)t)
ft = σ(net(f)t)
ot = σ(net(o)t)
gt = tanh(net(g)t)
ct = ft ◦ ct−1 + it ◦ gt ht = ot ◦ tanh(ct)
here we introduce variables net(i), net(f), net(o) and net(g) to represent the linear part of the gates and the new cell state. in gpu implementations such as cudnn v5 (appleyard , 2016), these linear gates (including new cell state from now on) are usually calculated in one step since they share the same input vectors xt and ht−1. therefore we can use a uniform representation for the four linear gates, that is
nett =wxt + uht−1 + b
the matrix w here stands for the combination of the matrices w i, w f , w o and w g and the matrix u stands for the combination of the matrices u i, uf , uo and ug .
with these denotations, we can express the backward propagation as
dot = dht ◦ tanh(ct)
dct = dht ◦ (1− tanh2(ct)) ◦ ot + ft ◦ ct+1 dnet(g)t = dct ◦ it ◦ (1− g2t )
dnet(o)t = dht ◦ tanh(ct) ◦ (1− ot) ◦ ot dnet(f)t = dct ◦ ct−1 ◦ (1− ft) ◦ ft dnet(i)t = dct ◦ gt ◦ (1− it) ◦ it
dxt = dnettw t
dht−1 = dnettu t
dw+ = xtdnett
du+ = ht−1dnett
in the equations of the backward propagation, we use dnet to denote the gradient of the linear gates.
from these equations we can see that for each linear gate gradient there is one term introduced by the sigmoid function or the tanh function, e.g. (1−g2t ) in dnet(g)t and (1−ot)◦ot in dnet(o)t. as we observed in the application characterization results, the activation values of these gates exhibit skewed distribution, which means a large fraction of ot, ft and it are close to 0 or 1 (gt close to -1 or 1). the skewed distribution makes a large fraction of the linear gate gradients close to zero because (1 − g2t ), (1 − ot) ◦ ot, (1 − ft) ◦ ft and (1 − it) ◦ it are mostly close to zero given the skewed distribution of the gate activations.
when implementing the lstm-based rnns, we usually use 32-bit floating point numbers to represent the gradients. due to the precision limit, floating point numbers will round extremely small values to zero. therefore, there is potential sparsity in dnet since a large fraction of the linear gate gradients are close to zero.in the previous section we showed how the skewed distribution in gate activations results in potential sparsity in linear gate gradients theoretically. however, from mathematical perspective, there will be no sparsity in linear gate gradients if the floating point numbers in computers have infinite precision since they are only close to zero rather than be zero. even the precision of 32-bit floating point numbers is not infinite, the 8-bit exponential part can still accommodate an extremely large dynamic range, which makes the sparsity less interesting to hardware accelerator designers. fortunately, recent attempts to train neural networks with 16-bit floating points (gupta , 2015) and fixed points (lin , 2015) have shown acceptable performance with smaller dynamic range. this inspires us to induce more sparsity by rounding very small linear gate gradients to zero, which is similar to replace 32-bit floating points with 16-bit floating points or fixed points.
the intuition behind this “rounding to zero” approach is that pruning cnns will not affect the overall training performance. similarly, thresholding very small gradient (dnet) values to zero is likely not to affect the overall training accuracy. therefore, we propose a simple static thresholding approach which sets small dnet values below a threshold t to zero. by doing this, we can increase the sparsity in dnet even further than the original sparsity caused by limited dynamic range of floating
point numbers. with our static thresholding technique, the backward propagation of lstm training becomes as below:
dot = dht ◦ tanh(ct) dct = dht ◦ (1− tanh2(ct)) ◦ ot + ft ◦ ct+1
dnet(g)t = dct ◦ it ◦ (1− g2t ) dnet(o)t = dht ◦ tanh(ct) ◦ (1− ot) ◦ ot dnet(f)t = dct ◦ ct−1 ◦ (1− ft) ◦ ft dnet(i)t = dct ◦ gt ◦ (1− it) ◦ it dnett = (dnett > t)?dnett : 0
dxt = dnettw t
dht−1 = dnettu t
dw+ = xtdnett
du+ = ht−1dnett
in this “sparsified” sgd backward propagation, a new hyper-parameter t is introduced to control the sparsity we would like to induce in dnet. clearly, the optimal threshold t is the highest one that has no impact on the training performance since it can induce the highest sparsity in dnet. therefore, to select the threshold, we need to monitor the impact on the gradients. as the sgd only uses the gradients of the weights (dw ) to update the weights, dw is the only gradients we need to care about. from the equations of the backward propagation we can see that dw is computed based on dnet, which is sparsified by our approach. although sparsifying dnet affects dw , we can control the change of dw by setting the threshold. to determine the largest acceptable threshold, we conducted an evaluation of the impact caused by different thresholds on one single step in lstm training. the application here is the same as the one in the application characterization.
figure 3 shows the evaluation result. we measure the change of dw by the normalized inner product of sparsified dw and the original dw without sparisifying (the baseline shown in figure 3). if we denote the original weight gradient as dw0, the correlation between sparsified dw and dw0 can be measured by normalized inner product
correlation = dw · dw0
||dw || · ||dw0||
if the correlation is 1, it means dw is exactly the same to dw0. if the correlation is 0, it means dw is orthogonal to dw0. the higher the correlation is, the less impact the sparsification has on this single step backward propagation. from figure 3 we can see that even without our thresholding technique, the dnet still exhibits approximately 10% sparsity. these zero values are resulted from the limited dynamic range of floating point numbers, in which extremely small values are rounded to zero. by applying the thresholds to dnet, we can induce more sparsity shown by the bars. even with a low threshold (10−8), the sparsity in dnet is increased to about 45%. with a relatively high threshold (10−6), the sparsity can be increased to around 80%. although the sparsity is high, the correlation between the sparsified dw and dw0 is close to 1 even with the high threshold. therefore, we can hypothesize that we can safely induce a considerable amount of sparsity with an appropriate threshold. it is straightforward to understand that the threshold cannot be arbitrarily large since we need to contain the information of the gradients. for example, if we increase the threshold even further to 10−5, the correlation will drop to 0.26, which is far from the original dw0 and not acceptable.
we have demonstrated that we can induce more sparsity by rounding small dnet to zero while maintaining the information in dw . however, this is only an evaluation on one single iteration of training. to show the generality of our static thresholding approach, we applied the thresholds to the entire training process.in this section, we first present the sparsity induced by applying our sprsified sgd to an entire training process, and then discuss the generality of our approach.to validate our proposed static thresholding approach, we apply it to the entire lstm-based rnn training process. we first conducted an experiment on training a character-based language model. the language model consists of one word2vec layer, three lstm-based rnn layers, and one linear classifier layer. the number of lstm cells per rnn layer is 256. we feed the network with sequences of 100 characters each. the training dataset is a truncated wikipedia dataset. we apply a fixed threshold to all dnet gradients for every iteration during the whole training process.
figure 4 shows the sparsity of the linear gate gradients (dnet) of each layer during the whole training process. in the baseline configuration, the training method is standard sgd without sparsifying (zero
threshold). the baseline configuration exhibits about 20% sparsity in dnet. by applying only a low threshold (10−7), the sparsity is increased to around 70%. and we can consistently increase the sparsity further by raising the threshold. however, we have to monitor the impact of the threshold on the overall training performance to check if the threshold is too large to use.
figure 5 shows the validation loss of each iteration. we observe that up to the medium threshold (10−6), the validation loss of the model trained with sparsified sgd keeps close to the baseline. however, if we continues raising the threshold to 10−5, the validation loss becomes unacceptably higher than the baseline. although the validation loss with the 10−5 threshold is consistently decreasing as the training goes on, we conservatively do not pick this configuration to train the lstm network. so combining figure 4 with figure 5, we can choose the threshold 10−6 to train the character-based language model to achieve about 80% sparsity in dnet.
since the linear gate gradients dnet are involved in all the four matrix multiplications in the backward propagation, there are 80% mac operations in these matrix multiplications have zero operands. furthermore, there are six matrix multiplications (all of them are of the same amount of computation) in one lstm training iteration and four out of them (67%) are sparse. so there are more than 50% mac operations will have zero operands introduced by our sparsified sgd in one lstm training iteration. the mac operations with zero operands produce zero output and thus make no contribution to the final results. these redundant mac operations can be eliminated by hardware techniques similar to (han , 2016a) (albericio , 2016) to improve the energy efficiency of lstm training.our static thresholding approach can induce more than 80% sparsity in linear gate gradients of the character-based language model training. to demonstrate the generality of our approach, we then changed the topology of the rnn layers in the character-based language model with several different lstm-based rnns for a sensitivity test. the network topologies used in the sensitivity test are shown below.
• number of layers: 2, 3, 6, 9; • number of lstm cells per layer: 128, 256, 512; • sequence length: 25, 50, 100.
we also trained the network with other datasets, such as the tiny-shakespear dataset and the novel war and peace. for all the data points we collected from the sensitivity test, we can always achieve
more than 80% sparsity in dnet with less than 1% loss of performance in terms of validation loss with respect to the baseline.
moreover, we also validated our approach by training an image captioning application (karpathy & li, 2015) with mscoco dataset (lin , 2014) and a machine translation application known as seq2seq (sutskever , 2014) with wmt15 dataset. as both the two applications are implemented based on graph model (torch and tensorflow, respectively), we plugged a custom operation in the automatically generated backward propagation subgraph to implement our proposed sparsified sgd. the experiment results show that the conclusion for the character-based language model still holds for the two applications.so far all our experiment results show promising results and we believe our sparsified sgd is a general approach to induce sparsity for lstm-based rnn training. from the computer hardware perspective, the sparsified sgd is similar to reduced precision implementation while the impact of sparsified sgd is much less since we still use full 32-bit floating point numbers. from the theory perspective, sgd itself is a gradient descent with noise and thresholding very small gradients to zero is nothing more than an additional noise source. since training with sgd is robust to noise, the thresholding approach will likely not affect the overall training performance. additionally, the weight gradients dw are aggregated through many time steps, which makes the lstm more robust to the noise introduce by sparsifying the linear gate gradients.in this paper, we conducted an application characterization to an lstm-based rnn application and observe skewed distribution in the sigmoid-based gates and the tanh-based new cell state, which indicates potential sparsity in the linear gate gradients during backward propagation with sgd. the linear gate gradients are involved with 67% mac operations in an entire lstm training process so that we can improve the energy efficiency of hardware implementations if the linear gate gradients are sparse. we propose a simple yet effective rounding to zero technique, which can make the sparsity of the linear gate gradients higher than 80% without loss of performance. therefore, more than 50% mac operations are redundant in an entire sparsified lstm training.
obviously, the static-threshold approach is not optimal. in future, we will design a dynamicthreshold approach based on the learning rate, l2-norm of the gradients and the network topology. hardware techniques will also be introduced to exploit the sparsity to improve the energy efficiency and training speed of lstm-based rnns for gpu and other hardware accelerators.",0
775.pdf.json,LEARNING LOCOMOTION SKILLS USING DEEPRL: DOES,"the introduction of deep learning models to reinforcement learning (rl) has enabled policies to operate directly on high-dimensional, low-level state features. as a result, deep reinforcement learning (deeprl) has demonstrated impressive capabilities, such as developing control policies that can map from input image pixels to output joint torques (lillicrap , 2015). however, the quality and robustness often falls short of what has been achieved with hand-crafted action abstractions, e.g., coros  (2011); geijtenbeek  (2013). while much is known about the learning of state representations, the choice of action parameterization is a design decision whose impact is not yet well understood.
joint torques can be thought of as the most basic and generic representation for driving the movement of articulated figures, given that muscles and other actuation models eventually result in joint torques. however this ignores the intrinsic embodied nature of biological systems, particularly the synergy between control and biomechanics. passive-dynamics, such as elasticity and damping from muscles and tendons, play an integral role in shaping motions: they provide mechanisms for energy storage, and mechanical impedance which generates instantaneous feedback without requiring any explicit computation. loeb coins the term preflexes (loeb, 1995) to describe these effects, and their impact on motion control has been described as providing intelligence by mechanics (blickhan , 2007). this can also be thought of as a kind of partitioning of the computations between the control and physical system.
in this paper we explore the impact of four different actuation models on learning to control dynamic articulated figure locomotion: (1) torques (tor); (2) activations for musculotendon units (mtu); (3) target joint angles for proportional-derivative controllers (pd); and (4) target joint velocities (vel). because deep rl methods are capable of learning control policies for all these models, it now becomes possible to directly assess how the choice of actuation model affects the learning difficulty. we also assess the learned policies with respect to robustness, motion quality, and policy query rates. we show that action spaces which incorporate local feedback can significantly improve learning speed and performance, while still preserving the generality afforded by torque-level control. such parameterizations also allow for more complex body structures and subjective improvements in motion quality.
our specific contributions are: (1) we introduce a deeprl framework for motion imitation tasks; (2) we evaluate the impact of four different actuation models on learned control policies according to four criteria; and (3) we propose an optimization approach that combines policy learning and actuator optimization, allowing neural networks to effective control complex muscle models.our task will be structured as a standard reinforcement problem where an agent interacts with its environment according to a policy in order to maximize a reward signal. the policy π(s, a) = p(a|s) represents the conditional probability density function of selecting action a ∈ a in state s ∈ s. at each control step t, the agent observes a state st and samples an action at from π. the environment in turn responds with a scalar reward rt, and a new state s′t = st+1 sampled from its dynamics p(s′|s, a). for a parameterized policy πθ(s, a), the goal of the agent is learn the parameters θ which maximizes the expected cumulative reward
j(πθ) = e [ t∑ t=0 γtrt ∣∣∣∣∣πθ ]
with γ ∈ [0, 1] as the discount factor, and t as the horizon. the gradient of the expected reward oθj(πθ) can be determined according to the policy gradient theorem (sutton , 2001), which provides a direction of improvement to adjust the policy parameters θ.
oθj(πθ) = ∫ s dθ(s) ∫ a oθlog(πθ(s, a))a(s, a)da ds
where dθ(s) = ∫ s ∑t t=0 γ
tp0(s0)p(s0 → s|t, πθ)ds0 is the discounted state distribution, where p0(s) represents the initial state distribution, and p(s0 → s|t, πθ) models the likelihood of reaching state s by starting at s0 and following the policy πθ(s, a) for t steps (silver , 2014). a(s, a) represents a generalized advantage function. the choice of advantage function gives rise to a family of policy gradient algorithms, but in this work, we will focus on the one-step temporal difference advantage function (schulman , 2015)
a(st, at) = rt + γv (s ′ t)− v (st) where v (s) = e [∑t
t=0 γ trt ∣∣∣s0 = s, πθ] is the state-value function, and can be defined recursively via the bellman equation
v (st) = e rt,s′t
[rt + γv (s ′ t)|st, πθ]
a parameterized value function vφ(s), with parameters φ, can be learned iteratively in a manner similar to q-learning by minimizing the bellman loss,
l(φ) = e st,rt,s′t
[ 1  (yt − vφ(st))2
] , yt = rt + γvφ(s ′ t)
πθ and vφ can be trained in tandem using an actor-critic framework (konda & tsitsiklis, 2000).
in this work, each policy will be represented as a gaussian distribution with a parameterized mean µθ(s) and fixed covariance matrix σ = diag{σ2i }, where σi is manually specified for each action parameter. actions can be sampled from the distribution by applying gaussian noise to the mean action at = µθ(st) +n (0,σ) the corresponding policy gradient will assume the form
oθj(πθ) = ∫ s dθ(s) ∫ a oθµθ(s)σ −1 (a− µθ(s))a(s, a)da ds
which can be interpreted as shifting the mean of the action distribution towards actions that lead to higher than expected rewards, while moving away from actions that lead to lower than expected rewards.in our task, the goal of a policy is to imitate a given reference motion {q∗t } which consists of a sequence of kinematic poses q∗t in reduced coordinates. the reference velocity q̇∗t at a given time t is approximated by finite-difference q̇∗t ≈ q∗t+4t−q ∗ t t . reference motions are generated via either using a recorded simulation result from a preexisting controller (“sim”), or via manually-authored keyframes. since hand-crafted reference motions may not be physically realizable, the goal is to closely reproduce a motion while satisfying physical constraints.to define the state of the agent, a feature transformation φ(q, q̇) is used to extract a set of features from the reduced-coordinate pose q and velocity q̇. the features consist of the height of the root (pelvis) from the ground, the position of each link with respect to the root, and the center of mass velocity of each link. when training a policy to imitate a cyclic reference motion {q∗t }, knowledge of the motion phase can help simplify learning. therefore, we augment the state features with a set of target features φ(q∗t , q̇t ∗), resulting in a combined state represented by st = (φ(qt, q̇t),φ(q∗t , q̇t ∗)). similar results can also be achieved by providing a single motion phase variable as a state feature, as we show in figure 15 (supplemental material).we train separate policies for each of the four actuation models, as described below. each actuation model also has related actuation parameters, such as feedback gains for pd-controllers and musculotendon properties for mtus. these parameters can be manually specified, as we do for the pd and vel models, or they can be optimized for the task at hand, as for the mtu models. table 1 provides a list of actuator parameters for each actuation model.
target joint angles (pd): each action represents a set of target angles q̂, where q̂i specifies the target angles for joint i. q̂ is applied to pd-controllers which compute torques according to τ i = kip(q̂ i − qi) + kid(ˆ̇qi − q̇i), where ˆ̇qi = 0, and kip and kid are manually-specified gains.
target joint velocities (vel): each action specifies a set of target velocities ˆ̇q which are used to compute torques according to τ i = kid(ˆ̇q
i − q̇i), where the gains kid are specified to be the same as those used for target angles.
torques (tor): each action directly specifies torques for every joint, and constant torques are applied for the duration of a control step. due to torque limits, actions are bounded by manually specified limits for each joint. unlike the other actuation models, the torque model does not require additional actuator parameters, and can thus be regarded as requiring the least amount of domain knowledge. torque limits are excluded from the actuator parameter set as they are common for all parameterizations.
muscle activations (mtu): each action specifies activations for a set of musculotendon units (mtu). detailed modeling and implementation information are available in wang  (2012). each mtu is modeled as a contractile element (ce) attached to a serial elastic element (se) and parallel elastic element (pe). the force exerted by the mtu can be calculated according to fmtu = fse = fce + fpe . both fse and fpe are modeled as passive springs, while fce is actively controlled according to fce = amtuf0fl(lce)fv(vce), with amtu being the muscle activation, f0 the maximum isometric force, lce and vce being the length and velocity of the contractile element. the functions fl(lce) and fv(vce) represent the force-length and force-velocity relationships, modeling the variations in the maximum force that can be exerted by a muscle as a function of its length and contraction velocity. analytic forms are available in geyer  (2003). activations are bounded between [0, 1]. the length of each contractile element lce are included as state features. to simplify control and reduce the number of internal state parameters per mtu, the policies directly control muscle activations instead of indirectly through excitations (wang , 2012).the reward function consists of a weighted sum of terms that encourage the policy to track a reference motion.
r = wposerpose + wvelrvel + wendrend + wrootrroot + wcomrcom
wpose = 0.5, wvel = 0.05, wend = 0.15, wroot = 0.1, wcom = 0.2
details of each term are available in the supplemental material. rpose penalizes deviation of the character pose from the reference pose, and rvel penalizes deviation of the joint velocities. rend and rroot accounts for the position error of the end-effectors and root. rcom penalizes deviations in the center of mass velocity from that of the reference motion.we design the initial state distribution, p0(s), to sample states uniformly along the reference trajectory. at the start of each episode, q∗ and q̇∗ are sampled from the reference trajectory, and used to initialize the pose and velocity of the agent. this helps guide the agent to explore states near the target trajectory.instead of directly using the temporal difference advantage function, we adapt a positive temporal difference (ptd) update as proposed by van hasselt (2012).
a(s, a) = i [δ > 0] =
{ 1, δ > 0 , otherwise
δ = r + γv (s′)− v (s) unlike more conventional policy gradient methods, ptd is less sensitive to the scale of the advantage function and avoids instabilities that can result from negative td updates. for a gaussian policy, a negative td update moves the mean of the distribution away from an observed action, effectively shifting the mean towards an unknown action that may be no better than the current mean action (van hasselt, 2012). in expectation, these updates converges to the true policy gradient, but for stochastic estimates of the policy gradient, these updates can cause the agent to adopt undesirable behaviours which affect subsequent experiences collected by the agent. furthermore, we incorporate experience replay, which has been demonstrated to improve stability when training neural network policies with q-learning in discrete action spaces. experience replay often requires off-policy methods, such as importance weighting, to account for differences between the policy being trained and the behavior policy used to generate experiences (wawrzyński & tanwani, 2013). however, we have not found importance weighting to be beneficial for ptd.
stochastic policies are used during training for exploration, while deterministic policy are deployed for evaluation at runtime. the choice between a stochastic and deterministic policy can be specified by the addition of a binary indicator variable λ ∈ [0, 1]
at = µθ(st) + λn (0,σ)
where λ = 1 corresponds to a stochastic policy with exploration noise, and λ = 0 corresponds to a deterministic policy that always selects the mean of the distribution. noise from a stochastic policy will result in a state distribution that differs from that of the deterministic policy at runtime. to imitate this discrepancy, we incorporate -greedy exploration in addition to the original gaussian exploration. during training, λ is determined by a bernoulli random variable λ ∼ ber( ), where λ = 1 with probability ∈ [0, 1]. the exploration rate is annealed linearly from 1 to 0.2 over 500k iterations, which slowly adjusts the state distribution encountered during training to better resemble the distribution at runtime. since the policy gradient is defined for stochastic policies, only tuples recorded with exploration noise (i.e. λ = 1) can be used to update the actor, while the critic can be updated using all tuples.
training proceeds episodically, where the initial state of each episode is sampled from p0(s), and the episode duration is drawn from an exponential distribution with a mean of 2s. to discourage falling, an episode will also terminate if any part of the character’s trunk makes contact with the ground for an extended period of time, leaving the agent with zero reward for all subsequent steps. algorithm 1 in the supplemental material summarizes the complete learning process.
mtu actuator optimization: actuation models such as mtus are defined by further parameters whose values impact performance (geijtenbeek , 2013). geyer  (2003) uses existing anatomical estimates for humans to determine mtu parameters, but such data is not be available for more arbitrary creatures. alternatively, geijtenbeek  (2013) uses covariance matrix adaptation (cma), a derivative-free evolutionary search strategy, to simultaneously optimize mtu and policy parameters. this approach is limited to policies with reasonably low dimensional parameter spaces, and is thus ill-suited for neural network models with hundreds of thousands of parameters. to avoid manual-tuning of actuator parameters, we propose a heuristic approach that alternates between policy learning and actuator optimization, as detailed in the supplemental material.the motions are best seen in the supplemental video https://youtu.be/l3vdo3nli98. we evaluate the action parameterizations by training policies for a simulated 2d biped, dog, and raptor as shown in figure 1. depending on the agent and the actuation model, our systems have 58–214 state dimensions, 6–44 action dimensions, and 0–282 actuator parameters, as summarized in table 3 (supplemental materials). the mtu models have at least double the number of action parameters because they come in antagonistic pairs. as well, additional mtus are used for the legs to more accurately reflect bipedal biomechanics. this includes mtus that span multiple joints.
each policy is represented by a three layer neural network, as illustrated in figure 8 (supplemental material) with 512 and 256 fully-connected units, followed by a linear output layer where the number of output units vary according to the number of action parameters for each character and actuation model. relu activation functions are used for both hidden layers. each network has approximately 200k parameters. the value function is represented by a similar network, except having a single linear output unit. the policies are queried at 60hz for a control step of about 0.0167s. each network is randomly initialized and trained for about 1 million iterations, requiring 32 million tuples, the equivalent of approximately 6 days of simulated time. each policy requires about 10 hours for the biped, and 20 hours for the raptor and dog on an 8-core intel xeon e5-2687w.
only the actuator parameters for mtus are optimized with algorithm 2, since the parameters for the other actuation models are few and reasonably intuitive to determine. the initial actuator parameters ψ0 are manually specified, while the initial policy parameters θ0 are randomly initialized. each pass optimizes ψ using cma for 250 generations with 16 samples per generation, and θ is trained for 250k iterations. parameters are initialized with values from the previous pass. the expected value of each cma sample of ψ is estimated using the average cumulative reward over 16 rollouts with a duration of 10s each. separate mtu parameters are optimized for each character and motion. each set of parameters is optimized for 6 passes following algorithm 2, requiring approximately 50 hours. figure 5 illustrates the performance improvement per pass. figure 6 compares the performance of mtus before and after optimization. for most examples, the optimized actuator parameters significantly improve learning speed and final performance. for the sake of comparison, after a set of actuator parameters has been optimized, a new policy is retrained with the new actuator parameters and its performance compared to the other actuation models.
policy performance and learning speed: figure 2 shows learning curves for the policies and the performance of the final policies are summarized in table 4. performance is evaluated using the normalized cumulative reward (ncr), calculated from the average cumulative reward over 32 episodes with lengths of 10s, and normalized by the maximum and minimum cumulative reward possible for each episode. no discounting is applied when calculating the ncr. the initial state of each episode is sampled from the reference motion according to p(s0). to compare learning speeds, we use the normalized area under each learning curve (auc) as a proxy for the learning speed of a particular actuation model, where 0 represents the worst possible performance and no progress during training, and 1 represents the best possible performance without requiring training.
pd performs well across all examples, achieving comparable-to-the-best performance for all motions. pd also learns faster than the other parameterizations for 5 of the 7 motions. the final performance of tor is among the poorest for all the motions. differences in performance appear more pronounced as characters become more complex. for the simple 7-link biped, most parameterizations achieve similar performance. however, for the more complex dog and raptor, the performance of tor policies deteriorate with respect to other policies such as pd and vel. mtu policies often exhibited the slowest learning speed, which may be a consequence of the higher dimensional action spaces, i.e., requiring antagonistic muscle pairs, and complex muscle dynamics. nonetheless, once optimized, the mtu policies produce more natural motions and responsive behaviors as compared to other parameterizations. we note that the naturalness of motions is not well captured by the reward, since it primarily gauges similarity to the reference motion, which may not be representative of natural responses when perturbed from the nominal trajectory. a sensitivity analysis of the policies’ performance to variations in network architecture and hyperparameters are available in the supplemental material.
policy robustness: to evaluate robustness, we recorded the ncr achieved by each policy when subjected to external perturbations. the perturbations assume the form of random forces applied
to the trunk of the characters. figure 3 illustrates the performance of the policies when subjected to perturbations of different magnitudes. the magnitude of the forces are constant, but direction varies randomly. each force is applied for 0.1 to 0.4s, with 1 to 4s between each perturbation. performance is estimated using the average over 128 episodes of length 20s each. for the biped walk, the tor policy is significantly less robust than those for the other types of actions, while the mtu policy is the least robust for the raptor run. overall, the pd policies are among the most robust for all the motions. in addition to external forces, we also evaluate robustness over randomly generated terrain consisting of bumps with varying heights and slopes with varying steepness. we evaluate the performance on irregular terrain (figure 12, supplemental material). there are few discernible patterns for this test. the vel and mtu policies are significantly worse than the tor and pd policies for the dog bound on the bumpy terrain. the unnatural jittery behavior of the dog tor policy proves to be surprisingly robust for this scenario. we suspect that the behavior prevents the trunk from contacting the ground for extended periods for time, and thereby escaping our system’s fall detection.
query rate: figure 4 compares the performance of different parameterizations for different policy query rates. separate policies are trained with queries of 15hz, 30hz, 60hz, and 120hz. actuation models that incorporate low-level feedback such as pd and vel, appear to cope more effectively to lower query rates, while the tor degrades more rapidly at lower query rates. it is not yet obvious to us why mtu policies appear to perform better at lower query rates and worse at higher rates. lastly, figure 14 shows the policy outputs as a function of time for the four actuation models, for a particular joint, as well as showing the resulting joint torque. interestingly, the mtu action is visibly smoother than the other actions and results in joint torques profiles that are smoother than those seen for pd and vel.deeprl has driven impressive recent advances in learning motion control, i.e., solving for continuous-action control problems using reinforcement learning. all four of the actions types that we explore have seen previous use in the machine learning literature. wawrzyński & tanwani (2013) use an actor-critic approach with experience replay to learn skills for an octopus arm (actuated by a simple muscle model) and a planar half cheetah (actuated by joint-based pd-controllers).
recent work on deterministic policy gradients (lillicrap , 2015) and on rl benchmarks, e.g., openai gym, generally use joint torques as the action space, as do the test suites in recent work (schulman , 2015) on using generalized advantage estimation. other recent work uses: the pr2 effort control interface as a proxy for torque control (levine , 2015); joint velocities (gu , 2016); velocities under an implicit control policy (mordatch , 2015); or provide abstract actions (hausknecht & stone, 2015). our learning procedures are based on prior work using actorcritic approaches with positive temporal difference updates (van hasselt, 2012).
work in biomechanics has long recognized the embodied nature of the control problem and the view that musculotendon systems provide “preflexes” (loeb, 1995) that effectively provide a form intelligence by mechanics (blickhan , 2007), as well as allowing for energy storage. the control strategies for physics-based character simulations in computer animation also use all the forms of actuation that we evaluate in this paper. representative examples include quadratic programs that solve for joint torques (de lasa , 2010), joint velocities for skilled bicycle stunts (tan , 2014), muscle models for locomotion (wang , 2012; geijtenbeek , 2013), mixed use of feed-forward torques and joint target angles (coros , 2011), and joint target angles computed by learned linear (time-indexed) feedback strategies (liu , 2016). lastly, control methods in robotics use a mix of actuation types, including direct-drive torques (or their virtualized equivalents), series elastic actuators, pd control, and velocity control. these methods often rely heavily on modelbased solutions and thus we do not describe these in further detail here.our experiments suggest that action parameterizations that include basic local feedback, such as pd target angles, mtu activations, or target velocities, can improve policy performance and learning speed across different motions and character morphologies. such models more accurately reflect the embodied nature of control in biomechanical systems, and the role of mechanical components in shaping the overall dynamics of motions and their control. the difference between low-level and high-level action parameterizations grow with the complexity of the characters, with high-level parameterizations scaling more gracefully to complex characters. as a caveat, there may well be tasks, such as impedance control, where lower-level action parameterizations such as tor may prove advantageous. we believe that no single action parameterization will be the best for all problems. however, since objectives for motion control problems are often naturally expressed in terms of kinematic properties, higher-level actions such as target joint angles and velocities may be effective for a wide variety of motion control problems. we hope that our work will help open discussions around the choice of action parameterizations.
our results have only been demonstrated on planar articulated figure simulations; the extension to 3d currently remains as future work. furthermore, our current torque limits are still large as compared to what might be physically realizable. tuning actuator parameters for complex actuation models such as mtus remains challenging. though our actuator optimization technique is able to improve performance as compared to manual tuning, the resulting parameters may still not be optimal for the desired task. therefore, our comparisons of mtus to other action parameterizations may not be reflective of the full potential of mtus with more optimal actuator parameters. furthermore, our actuator optimization currently tunes parameters for a specific motion, rather than a larger suite of motions, as might be expected in nature.
since the reward terms are mainly calculated according to joint positions and velocities, it may seem that it is inherently biased in favour of pd and vel. however, the real challenges for the control policies lie elsewhere, such as learning to compensate for gravity and ground-reaction forces, and learning foot-placement strategies that are needed to maintain balance for the locomotion gaits. the reference pose terms provide little information on how to achieve these hidden aspects of motion control that will ultimately determine the success of the locomotion policy. while we have yet to provide a concrete answer for the generalization of our results to different reward functions, we believe that the choice of action parameterization is a design decision that deserves greater attention regardless of the choice of reward function.
finally, it is reasonable to expect that evolutionary processes would result in the effective co-design of actuation mechanics and control capabilities. developing optimization and learning algorithms to allow for this kind of co-design is a fascinating possibility for future work.",0
791.pdf.json,DEEP UNSUPERVISED LEARNING THROUGH SPATIAL CONTRASTING,"for the past few years convolutional networks (convnets, cnns) lecun  (1998) have proven themselves as a successful model for vision related tasks krizhevsky  (2012) mnih  (2015) pinheiro  (2015) razavian  (2014). a convolutional network is composed of multiple convolutional and pooling layers, followed by a fully-connected affine transformations. as with other neural network models, each layer is typically followed by a non-linearity transformation such as a rectified-linear unit (relu). a convolutional layer is applied by cross correlating an image with a trainable weight filter. this stems from the assumption of stationarity in natural images, which means that parameters learned for one local region in an image can be shared for other regions and images.
deep learning models, including convolutional networks, are usually trained in a supervised manner, requiring large amounts of labeled data (ranging between thousands to millions of examples per-class for classification tasks) in almost all modern applications. these models are optimized using a variant of stochastic-gradient-descent (sgd) over batches of images sampled from the whole training dataset and their ground truth-labels. gradient estimation for each one of the optimized parameters is done by back propagating the objective error from the final layer towards the input. this is commonly known as ”backpropagation” rumelhart .
in early works, unsupervised training was used as a part of pre-training procedure to obtain an effective initial state of the model. the network was later fine-tuned in a supervised manner as displayed by hinton (2007). such unsupervised pre-training procedures were later abandoned, since they provided no apparent benefit over other initialization heuristics in more careful fully supervised training regimes. this led to the de-facto almost exclusive usage of neural networks in supervised environments.
in this work we will present a novel unsupervised learning criterion for convolutional network based on comparison of features extracted from regions within images. our experiments indicate that by
using this criterion to pre-train networks we can improve their performance and achieve state-ofthe-art results.using unsupervised methods to improve performance have been the holy grail of deep learning for the last couple of years and vast research efforts have been focused on that. we hereby give a short overview of the most popular and recent methods that tried to tackle this problem.
autoencoders and reconstruction loss these are probably the most popular models for unsupervised learning using neural networks, and convnets in particular. autoencoders are nns which aim to transform inputs into outputs with the least possible amount of distortion. an autoencoder is constructed using an encoder g(x;w1) that maps an input to a hidden compressed representation, followed by a decoder f (y;w2), that maps the representation back into the input space. mathematically, this can be written in the following general form:
x̂ = f (g(x;w1);w2)
the underlying encoder and decoder contain a set of trainable parameters that can be tied together and optimized for a predefined criterion. the encoder and decoder can have different architectures, including fully-connected neural networks, convnets and others. the criterion used for training is the reconstruction loss, usually the mean squared error (mse) between the original input and its reconstruction zeiler  (2010)
min‖x− x̂‖2
this allows an efficient training procedure using the aforementioned backpropagation and sgd techniques. over the years autoencoders gained fundamental role in unsupervised learning and many modification to the classic architecture were made. ng (2011) regularized the latent representation to be sparse, vincent  (2008) substituted the input with a noisy version thereof, requiring the model to denoise while reconstructing. kingma  (2014) obtained very promising results with variational autoencoders (vae). a variational autoencoder model inherits typical autoencoder architecture, but makes strong assumptions concerning the distribution of latent variables. they use variational approach for latent representation learning, which results in an additional loss component which required a new training algorithm called stochastic gradient variational bayes (sgvb). vae assumes that the data is generated by a directed graphical model p(x|z) and require the encoder to learn an approximation qw1(z|x) to the posterior distribution pw2(z|x) where w1 and w2 denote the parameters of the encoder and decoder. the objective of the variational autoencoder in that case has the following form:
l(w1, w2, x) = −dkl(qw1(z|x)||pw2(z)) + eqw1 (z|x) ( log pw2(x|z) ) recently, a stacked set of denoising autoencoders architectures showed promising results in both semi-supervised and unsupervised tasks. a stacked what-where autoencoder by zhao  (2015) computes a set of complementary variables that enable reconstruction whenever a layer implements a many-to-one mapping. ladder networks by rasmus  (2015) - use lateral connections and layer-wise cost functions to allow the higher levels of an autoencoder to focus on invariant abstract features.
exemplar networks: the unsupervised method introduced bydosovitskiy  (2014) takes a different approach to this task and trains the network to discriminate between a set of pseudo-classes. each pseudo-class is formed by applying multiple transformations to a randomly sampled image patch. the number of pseudo-classes can be as big as the size of the input samples. this criterion ensures that different input samples would be distinguished while providing robustness to the applied transformations. in this work we will explore an alternative method with a similar motivation.
context prediction another method for unsupervised learning by context was introduced by doersch  (2015). this method uses an auxiliary criterion of predicting the location of an image patch given another from the same image. this is done by classification to 1 of 9 possible locations. although the work of doersch  (2015) and ours both use patches from an image to perform unsupervised learning, the methods are quite different. whereas the former used a classification criterion over the spatial location of each patch within a single image, our work is concerned with comparing patches from several images to each other. we claim that this encourages discriminability between images (which we feel to be important aspect of feature learning), and was not an explicit goal in previous work.
adversarial generative models: this a recently introduced model that can be used in an unsupervised fashion goodfellow  (2014). adversarial generative models uses a set of networks, one trained to discriminate between data sampled from the true underlying distribution (e.g., a set of images), and a separate generative network trained to be an adversary trying to confuse the first network. by propagating the gradient through the paired networks, the model learns to generate samples that are distributed similarly to the source data. as shown by radford  (2015),this model can create useful latent representations for subsequent classification tasks.
sampling methods: methods for training models to discriminate between a very large number of classes often use a noise contrasting criterion. in these methods, roughly speaking, the posterior probability p (t|yt) of the ground-truth target t given the model output on an input sampled from the true distribution yt = f (x) is maximized, while the probability p (t|yn) given a noise measurement y = f (n) is minimized. this was successfully used in a language domain to learn unsupervised representation of words. the most noteworthy case is the word2vec model introduced by mikolov  (2013). when using this setting in language applications, a natural contrasting noise is a smooth approximation of the unigram distribution. a suitable contrasting distribution is less obvious when data points are sampled from a high dimensional continuous space, such as the case of image patches.only recently the potential of convnets in an unsupervised environment began to bear fruit, still we believe it is not fully uncovered.
the majority of unsupervised optimization criteria currently used are based on variations of reconstruction losses. one limitation of this fact is that a pixel level reconstruction is non-compliant with the idea of a discriminative objective, which is expected to be agnostic to low level information in the input. in addition, it is evident that mse is not best suited as a measurement to compare images, for example, viewing the possibly large square-error between an image and a single pixel shifted copy of it. another problem with recent approaches such as rasmus  (2015); zeiler  (2010) is their need to extensively modify the original convolutional network model. this leads to a gap between unsupervised method and the state-of-the-art, supervised, models for classification - which can hurt future attempt to reconcile them in a unified framework, as well as efficiently leverage unlabeled data with otherwise supervised regimes.the most common way to train nn is by defining a loss function between the target values and the network output. learning by comparison approaches the supervised task from a different angle. the main idea is to use distance comparisons between samples to learn useful representations. for example, we consider relative and qualitative examples of the form x1 is closer to x2 than x1 is to x3. using a comparative measure with neural network to learn embedding space was introduced in the “siamese network” framework by bromley  (1993) and later used in the works of chopra  (2005). one use for this methods is when the number of classes is too large or expected to vary over time, as in the case of face verification, where a face contained in an image has to compared against another image of a face. this problem was recently tackled by schroff  (2015) for training a convolutional network model on triplets of examples. there, one image served as an anchor x, and an additional pair of images served as a positive example x+ (containing an instance
of the face of the same person) together with a negative example x−, containing a face of a different person. the training objective was on the embedded distance of the input faces, where the distance between the anchor and positive example is adjusted to be smaller by at least some constant α from the negative distance. more precisely, the loss function used in this case was defined as
l(x, x+, x−) = max {‖f (x)− f (x+)‖2 − ‖f (x)− f (x−)‖2 + α, 0} (1)
where f (x) is the embedding (the output of a convolutional neural network), and α is a predefined margin constant. another similar model used by hoffer & ailon (2015) with triplets comparisons for classification, where examples from the same class were trained to have a lower embedded distance than that of two images from distinct classes. this work introduced a concept of a distance ratio loss, where the defined measure amounted to:
l(x, x+, x−) = e−‖f (x)−f (x+)‖2
e−‖f (x)−f (x+)‖2 + e−‖f (x)−f (x−)‖2 (2)
this loss has a flavor of a probability of a biased coin flip. by ‘pushing’ this probability to zero, we express the objective that pairs of samples coming from distinct classes should be less similar to each other, compared to pairs of samples coming from the same class. it was shown empirical by balntas  (2016) to provide better feature embeddings than the margin based distance loss 1one implicit assumption in convolutional networks, is that features are gradually learned hierarchically, each level in the hierarchy corresponding to a layer in the network. each spatial location within a layer corresponds to a region in the original image. it is empirically observed that deeper layers tend to contain more ‘abstract’ information from the image. intuitively, features describing different regions within the same image are likely to be semantically similar (e.g. different parts of an animal), and indeed the corresponding deep representations tend to be similar. conversely, regions from two probably unrelated images (say, two images chosen at random) tend to be far from each other in the deep representation. this logic is commonly used in modern deep networks such as szegedy  (2015) lin  (2013) he  (2015), where a global average pooling is used to aggregate spatial features in the final layer used for classification.
our suggestion is that this property, often observed as a side effect of supervised applications, can be used as a desired objective when learning deep representations in an unsupervised task. later, the resulting representation can be used, as typically done, as a starting point or a supervised learning task. we call this idea which we formalize below spatial contrasting. the spatial contrasting criterion is similar to noise contrasting estimation gutmann & hyvärinen (2010) mnih & kavukcuoglu (2013), in trying to train a model by maximizing the expected probability on desired inputs, while minimizing it on contrasting sampled measurements.we will concern ourselves with samples of images patches x̃(m) taken from an image x. our convolutional network model, denoted by f (x), extracts spatial features f so that f (m) = f (x̃(m)) for an image patch x̃(m). we will also define p (f1|f2) as the probability for two features f1, f2 to occur together in the same image. we wish to optimize our model such that for two features representing patches taken from the same image x̃(1)i , x̃ (2) i ∈ xi for which f (1) i = f (x̃ (1) i ) and f (2) i = f (x̃ (2) i ), p (f (1) i |f (2) i ) will be maximized. this means that features from a patch taken from a specific image can effectively predict, under our model, features extracted from other patches in the same image. conversely, we want our model to minimize p (fi|fj) for i, j being two patches taken from distinct images. following the logic presented before, we will need to sample contrasting patch x̃(1)j from a different image xj such that p (f (1) i |f (2) i ) > p (f (1) j |f (2) i ), where f (1) j = f (x̃ (1) j ). in order to obtain contrasting samples, we use regions from two random images in the training set. we will use a distance ratio, described earlier
in eq. (2) for the supervised case, to represent the probability two feature vectors were taken from the same image. the resulting training loss for a pair of images will be defined as
lsc(x1, x2) = − log e−‖f (1) 1 −f (2) 1 ‖2
e−‖f (1) 1 −f (2) 1 ‖2 + e−‖f (1) 1 −f (1) 2 ‖2
(3)
effectively minimizing a log-probability under the softmax measure. this formulation is portrayed in figure 4.1. since we sample our contrasting sample from the same underlying distribution, we can evaluate this loss considering the image patch as both patch compared (anchor) and contrast symmetrically. the final loss will be the average between these estimations:
l̂sc(x1, x2) = 1  [lsc(x1, x2) + lsc(x2, x1)]convolutional network are usually trained using sgd over mini-batch of samples, therefore we can extract patches and contrasting patches without changing the network architecture. each image serves as both anchor and positive patches, for which the corresponding features should be closer, as well as contrasting samples for other images in that batch. for a batch of n images, two samples from each image are taken, and n2 different distance comparisons are made. the final loss is defined as the average distance ratio for all images in the batch:
lsc({x}ni=1) = 1
n n∑ i=1 lsc(xi, {x}j 6=i) = − 1 n n∑ i=1 log e−‖f (1) i −f (2) i ‖2∑n j=1 e −‖f(1)i −f (2) j ‖2
(4)
since the criterion is differentiable with respect to its inputs, it is fully compliant with standard methods for training convolutional network and specifically using backpropagation and gradient descent. furthermore, sc can be applied to any layer in the network hierarchy. in fact, sc can be used at multiple layers within the same convolutional network. the spatial properties of the
features means that we can sample directly from feature space f̃ (m) ∈ f instead of from the original image. therefore sc has a simple implementation which doesn’t require substation amount of computation. the complete algorithm for batch training is described in algorithm (1). similar to the batch normalization (bn) layer ioffe & szegedy (2015), a recent usage for batch statistics in neural networks, sc also uses the batch statistics. while bn normalize the input based on the batch statistics, sc sample from it. this can be viewed as a simple sampling from the space of possible features describing a patch of image.
algorithm 1 calculation the spatial contrasting loss require: x = {x}ni=1 # training on batches of images
# get the spatial features for the whole batch of images # size: n ×wf ×hf × c {f}ni=1 ← convnet(x)
# sample spatial features and calculate embedded distance between all pairs of images for i = 1 to n do f̃ (1) i ← sample(fi)
for j = 1 to n do f̃ (2) j ← sample(fj) dist(i, j)← ‖f̃ (1)i − f̃ (2) j ‖2
end for end for
# calculate log softmax normalized distances di ← − log e
−dist(i,i)∑n k=1 e −dist(i,k)
# spatial contrasting loss is the mean of distance ratios return 1n ∑n i=1 diin this section we report empirical results showing that using sc loss as an unsupervised pretraining procedure can improve state-of-the-art performance on subsequent classification. we experimented with mnist, cifar-10 and stl10 datasets. we used modified versions of well studied networks such as those of lin  (2013) and rasmus  (2015). a detailed description of our architecture can be found in 4.
in each one of the experiments, we used the spatial contrasting criterion to train the network on the unlabeled images. in each usage of sc criterion, patch features were sampled from the preceding layer in uniform. we note that spatial size of sampled patches ranged between datasets, where on stl10 and cifar10 it covered about 30% of the image, mnist required the use of larger patches covering almost the entire image.training was done by using sgd with an initial learning rate of 0.1 that was decreased by a factor of 10 whenever the measured loss stopped decreasing. after convergence, we used the trained model as an initialization for a supervised training on the complete labeled dataset. the supervised training was done following the same regime, only starting with a lower initial learning rate of 0.01. we used mild data augmentations, such as small translations and horizontal mirroring. the datasets we used are:
• stl10 (coates  (2011)). this dataset consists of 100, 000 96× 96 colored, unlabeled images, together with another set of 5, 000 labeled training images and 8, 000 test images . the label space consists of 10 object classes.
• cifar10 (krizhevsky & hinton (2009)). the well known cifar-10 is an image classification benchmark dataset containing 50, 000 training images and 10, 000 test images. the
all experiments were conducted using the torch7 framework by collobert  (2011). code reproducing these results will by available at https://github.com/eladhoffer/ spatialcontrasting.since stl10 dataset is comprised of mostly unlabeled data, it is most suitable to highlight the benefits of the spatial contrasting criterion. the initial training was unsupervised, as described earlier, using the entire set of 105, 000 samples (union of the original unlabeled set and labeled training set). the representation outputted by the training, was used to initialize supervised training on the 5, 000 labeled images. evaluation was done on a separate test set of 8, 000 samples. comparing with state of the art results, we see an improvement of 7% in test accuracy over the best model by zhao  (2015), setting the sc as best model at 81.3% test classification accuracy (see table (1)). we note that the results of dosovitskiy  (2014) are achieved with no fine-tuning over labeled examples, which may be unfair to this work. we also compare with the same network, but without sc initialization, which achieves a lower classification of 72.6%. this is an indication that indeed sc managed to leverage unlabeled examples to provide a better initialization point for the supervised model.for cifar10 dataset, we use the same setting as coates & ng (2012) and hui (2013) to test a model’s ability to learn from unlabeled images. here, only 4, 000 samples out of 50, 000 are used with their label annotation, and the rest of the samples can be used only in an unsupervised manner. the final test accuracy is measured on the entire 10, 000 test set. in our experiments, we trained our model using sc criterion on the entire dataset, and then used only 400 labeled samples per class (for a total of 4000) in a supervised regime over the initialized network. the results are compared with previous efforts in table (2). using the sc criterion allowed an improvement of 6.8% over a non-initialized model, and achieved a final test accuracy of 79.2%. this is a competitive result with current state-of-the-art models.the mnist dataset is very different in nature from the cifar10 and stl10 datasets, we experimented earlier. the biggest difference, relevant to this work, is that spatial regions sampled from mnist images usually provide very little, or no information. thus, sc is much less suited for mnist dataset, and was conjured to have little benefit. we still, however, experimented with initializing a model with sc criterion and continuing with a fully-supervised regime over all labeled
examples. we found again that this provided benefit over training the same network without preinitialization, improving results from 0.63% to 0.34% error on test set. as mentioned previously, the effective compared patches of mnist covered almost the entire image area. this can be attributed to the fact that mnist requires global features to differentiate between digits. the results, compared with previous attempts are included in table (3).in this work we presented spatial contrasting - a novel unsupervised criterion for training convolutional networks on unlabeled data. its is based on comparison between spatial features sampled from a number of images. we’ve shown empirically that using spatial contrasting as a pretraining technique to initialize a convnet, can improve its performance on a subsequent supervised training. in cases where a lot of unlabeled data is available, such as the stl10 dataset, this translates to state-of-the-art classification accuracy in the final model.
since the spatial contrasting loss is a differentiable estimation that can be computed within a network parallel to supervised losses, in future work we plan to embed it as a semi-supervised model. this usage will allow to create models that can leverage both labeled an unlabeled data, and can be compared to similar semi-supervised models such as the ladder network rasmus  (2015). it is is also apparent that contrasting can occur in dimensions other than the spatial, the most straightforward is the temporal dimension. this suggests that similar training procedure can be applied on segments of sequences to learn useful representation without explicit supervision.",0
