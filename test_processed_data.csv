File_id,Paper_text,Status
330.pdf.json,"text understanding starts with the challenge of finding machine-understandable representation that captures the semantics of texts. bag-of-words (bow) and its n-gram extensions are arguably the most commonly used document representations. despite its simplicity, bow works surprisingly well for many tasks (wang & manning, 2012). however, by treating words and phrases as unique and discrete symbols, bow often fails to capture the similarity between words or phrases and also suffers from sparsity and high dimensionality.
recent works on using neural networks to learn distributed vector representations of words have gained great popularity. the well celebrated word2vec (mikolov , 2013a), by learning to predict the target word using its neighboring words, maps words of similar meanings to nearby points in the continuous vector space. the surprisingly simple model has succeeded in generating high-quality word embeddings for tasks such as language modeling, text understanding and machine translation. word2vec naturally scales to large datasets thanks to its simple model architecture. it can be trained on billions of words per hour on a single machine.
paragraph vectors (le & mikolov, 2014) generalize the idea to learn vector representation for documents. a target word is predicted by the word embeddings of its neighbors in together with a unique document vector learned for each document. it outperforms established document representations, such as bow and latent dirichlocation (blei , 2003), on various text understanding tasks (dai , 2015). however, two caveats come with this approach: 1) the number of parameters grows with the size of the training corpus, which can easily go to billions; and 2) it is expensive to generate vector representations for unseen documents at test time.
we propose an efficient model architecture, referred to as document vector through corruption (doc2vecc), to learn vector representations for documents. it is motivated by the observation that linear operations on the word embeddings learned by word2vec can sustain substantial amount of syntactic and semantic meanings of a phrase or a sentence (mikolov , 2013b). for example, vec(“russia”) + vec(“river”) is close to vec(“volga river”) (mikolov & dean, 2013), and
vec(“king”) - vec(“man”) + vec(“women”) is close to vec(“queen”) (mikolov , 2013b). in doc2vecc, we represent each document as a simple average of the word embeddings of all the words in the document. in contrast to existing approaches which post-process learned word embeddings to form document representation (socher , 2013; mesnil , 2014), doc2vecc enforces a meaningful document representation can be formed by averaging the word embeddings during learning. furthermore, we include a corruption model that randomly remove words from a document during learning, a mechanism that is critical to the performance and learning speed of our algorithm.
doc2vecc has several desirable properties: 1. the model complexity of doc2vecc is decoupled from the size of the training corpus, depending only on the size of the vocabulary; 2. the model architecture of doc2vecc resembles that of word2vec, and can be trained very efficiently; 3. the new framework implicitly introduces a data-dependent regularization, which favors rare or informative words and suppresses words that are common but not discriminative; 4. vector representation of a document can be generated by simply averaging the learned word embeddings of all the words in the document, which significantly boost test efficiency; 5. the vector representation generated by doc2vecc matches or beats the state-of-the-art for sentiment analysis, document classification as well as semantic relatedness tasks.text representation learning has been extensively studied. popular representations range from the simplest bow and its term-frequency based variants (salton & buckley, 1988), language model based methods (croft & lafferty, 2013; mikolov , 2010; kim , 2015), topic models (deerwester , 1990; blei , 2003), denoising autoencoders and its variants (vincent , 2008; chen , 2012), and distributed vector representations (mesnil , 2014; le & mikolov, 2014; kiros , 2015). another prominent line of work includes learning task-specific document representation with deep neural networks, such as cnn (zhang & lecun, 2015) or lstm based approaches (tai , 2015; dai & le, 2015).
in this section, we briefly introduce word2vec and paragraph vectors, the two approaches that are most similar to ours. there are two well-know model architectures used for both methods, referred to as continuous bag-of-words (cbow) and skipgram models (mikolov , 2013a). in this work, we focus on cbow. extending to skipgram is straightforward. here are the notations we are going to use throughout the paper:
d = {d1, · · · , dn}: a training corpus of size n, in which each document di contains a variablelength sequence of words w1i , · · · , w ti i ;
v : the vocabulary used in the training corpus, of sizes v;
x ∈ rv×1: bow of a document, where xj = 1 iff word j does appear in the document. ct ∈ rv×1: bow of the local context wt−k, · · · , wt−1, wt+1, · · · , wt+k at the target position t. ctj = 1 iff word j appears within the sliding window of the target;
u ∈ rh×v: the projection matrix from the input space to a hidden space of size h. we use uw to denote the column in u for word w, i.e., the “input“ vector of word w;
v> ∈ rv×h: the projection matrix from the hidden space to output. similarly, we use vw to denote the column in v for word w, i.e., the “output“ vector of word w.
word2vec. word2vec proposed a neural network architecture of an input layer, a projection layer parameterized by the matrix u and an output layer by v>. it defines the probability of observing the target word wt in a document d given its local context ct as
p (wt|ct) = exp(v>wtuc t)∑ w′∈v exp(v > w′uc t)
the word vectors are then learned to maximize the log likelihood of observing the target word at each position of the document. various techniques (mitchell & lapata, 2010; zanzotto , 2010; yessenalina & cardie, 2011; grefenstette , 2013; socher , 2013; kusner , 2015)
have been studied to generate vector representations of documents from word embeddings, among which the simplest approach is to use weighted average of word embeddings. similarly, our method forms document representation by averaging word embeddings of all the words in the document. differently, as our model encodes the compositionality of words in the learned word embeddings, heuristic weighting at test time is not required.
paragraph vectors. paragraph vectors, on the other hands, explicitly learns a document vector with the word embeddings. it introduces another projection matrix d ∈ rh×n. each column of d acts as a memory of the global topic of the corresponding document. it then defines the probability of observing the target word wt in a document d given its local context ct as
p (wt|ct,d) = exp(v>wt(uc t + d))∑ w′∈v exp(v > w′(uc t + d))
where d ∈ d is the vector representation of the document. as we can see from this formula, the complexity of paragraph vectors grows with not only the size of the vocabulary, but also the size of the training corpus. while we can reasonably limit the size of a vocabulary to be within a million for most datasets, the size of a training corpus can easily go to billions. what is more concerning is that, in order to come up with the vector representations of unseen documents, we need to perform an expensive inference by appending more columns to d and gradient descent on d while fixing other parameters of the learned model.several works (mikolov & dean, 2013; mikolov , 2013b) showcased that syntactic and semantic regularities of phrases and sentences are reasonably well preserved by adding or subtracting word embeddings learned through word2vec. it prompts us to explore the option of simply representing a document as an average of word embeddings. figure 1 illustrates the new model architecture.
similar to word2vec or paragraph vectors, doc2vecc consists of an input layer, a projection layer as well as an output layer to predict the target word, “ceremony” in this example. the embeddings of neighboring words (“opening”, “for”, “the”) provide local context while the vector representation of the entire document (shown in grey) serves as the global context. in contrast to paragraph vectors, which directly learns a unique vector for each document, doc2vecc represents each document as an average of the embeddings of words randomly sampled from the document (“performance” at position p, “praised” at position q, and “brazil” at position r).
huang  (2012) also proposed the idea of using average of word embeddings to represent the global context of a document. different from their work, we choose to corrupt the original document by randomly removing significant portion of words, and represent the document using only the embeddings of the words remained. this corruption mechanism offers us great speedup during training as it significantly reduces the number of parameters to update in back propagation. at the same time, as we are going to detail in the next section, it introduces a special form of regularization, which brings great performance improvement.
here we describe the stochastic process we used to generate a global context at each update. the global context, which we denote as x̃, is generated through a unbiased mask-out/drop-out corruption, in which we randomly overwrites each dimension of the original document x with probability q. to make the corruption unbiased, we set the uncorrupted dimensions to 1/(1 − q) times its original value. formally,
x̃d = { 0, with probability q xd 1−q , otherwise
(1)
doc2vecc then defines the probability of observing a target word wt given its local context ct as well as the global context x̃ as
p (wt|ct, x̃) = exp(v>wt(
local context︷︸︸︷ uct + global context︷ ︸︸ ︷ 1
t ux̃ ))∑
w′∈v exp(v > w′ ( uct + 1t ux̃) ) (2) here t is the length of the document. exactly computing the probability is impractical, instead we approximate it with negative sampling (mikolov , 2013a).
f(w, c, x̃) ≡ logp (wt|ct, x̃) ≈ log σ ( v>w(uc + 1
t ux̃)
) + ∑
w′∼pv
log σ ( −v>w′(uc + 1
t ux̃)
) (3)
here pv stands for a uniform distribution over the terms in the vocabulary. the two projection matrices u and v are then learned to minimize the loss:
` = − n∑
i=1 ti∑ t=1 f(wti , c t i, x̃ t i) (4)
given the learned projection matrix u, we then represent each document simply as an average of the embeddings of the words in the document,
d = 1
t ∑ w∈d uw. (5)
we are going to elaborate next why we choose to corrupt the original document with the corruption model in eq.(1) during learning, and how it enables us to simply use the average word embeddings as the vector representation for documents at test time.we approximate the log likelihood for each instance f(w, c, x̃) in eq.(4) with its taylor expansion with respect to x̃ up to the second-order (van der maaten , 2013; wager , 2013; chen , 2014). concretely, we choose to expand at the mean of the corruption µx = ep(x̃|x)[x̃]:
f(w, c, x̃) ≈ f(w, c, µx) + (x̃− µx)>∇x̃f + 1  (x̃− µx)>∇2x̃f(x̃− µx)
where ∇x̃f and ∇2x̃f are the first-order (i.e., gradient) and second-order (i.e., hessian) of the log likelihood with respect to x̃. expansion at the mean µx is crucial as shown in the following steps. let us assume that for each instance, we are going to sample the global context x̃ infinitely many times, and thus compute the expected log likelihood with respect to the corrupted x̃.
ep(x̃|x)[f(w, c, x̃)] ≈ f(w, c, µx) + 1 2 tr ( e[(x̃− x)(x̃− x)>]∇2x̃f ) the linear term disappears as ep(x̃|x)[x̃ − µx] = 0. we substitute in x for the mean µx of the corrupting distribution (unbiased corruption) and the matrix σx = e[(x̃ − µx)(x̃ − µx)>] for the variance, and obtain
ep(x̃|x)[f(w, c, x̃)] ≈ f(w, c,x) + 1 2 tr ( σx∇2x̃f ) (6)
as each word in a document is corrupted independently of others, the variance matrix σx is simplified to a diagonal matrix with jth element equals q1−qx 2 j . as a result, we only need to compute the diagonal terms of the hessian matrix∇2x̃f .
the jth dimension of the hessian’s diagonal evaluated at the mean x is given by
∂2f ∂x2j = −σw,c,x(1− σw,c,x)( 1 t v>wuj)  − ∑
w′∼pv
σw′,c,x(1− σw′,c,x)( 1
t v>w′uj) 2
plug the hessian matrix and the variance matrix back into eq.(6), and then back to the loss defined in eq.(4), we can see that doc2vecc intrinsically minimizes
` = − n∑
i=1 ti∑ t=1 f(wti , c t i,xi) + q 1− q v∑ j=1 r(uj) (7)
each f(wti , c t i,xi) in the first term measures the log likelihood of observing the target word w t i given its local context cti and the document vector di = 1 t uxi. as such, doc2vecc enforces that a document vector generated by averaging word embeddings can capture the global semantics of the document, and fill in information missed in the local context.
the second term here is a data-dependent regularization. the regularization on the embedding uj of each word j takes the following form, r(uj) ∝ n∑
i=1 ti∑ t=1 x2ij [ σwti ,cti,xi(1− σwti ,cti,xi)( 1 t v>wti uj) 2 + ∑ w′∼pv σw′,cti,xi(1− σw′,cti,xi)( 1 t v>w′uj) 2 ] where σw,c,x = σ(v>w(uc+ 1 t ux)) prescribes the confidence of predicting the target wordw given its neighboring context c as well as the document vector d = 1t ux.
closely examining r(uj) leads to several interesting findings: 1. the regularizer penalizes more on the embeddings of common words. a word j that frequently appears across the training corpus, i.e, xij = 1 often, will have a bigger regularization than a rare word; 2. on the other hand, the regularization is modulated by σw,c,x(1 − σw,c,x), which is small if σw,c,x → 1 or 0. in other words, if uj is critical to a confident prediction σw,c,x when it is active, then the regularization is diminished. similar effect was observed for dropout training for logistic regression model (wager , 2013) and denoising autoencoders (chen , 2014).we evaluate doc2vecc on a sentiment analysis task, a document classification task and a semantic relatedness task, along with several document representation learning algorithms. all experiments can be reproduced using the code available at https://github.com/mchen24/iclr2017we compare against the following document representation baselines: bag-of-words (bow); denoising autoencoders (dea) (vincent , 2008), a representation learned from reconstructing original document x using corrupted one x̃. sdas have been shown to be the state-of-the-art for sentiment analysis tasks (glorot , 2011). we used kullback-liebler divergence as the reconstruction error and an affine encoder. to scale up the algorithm to large vocabulary, we only take into account the non-zero elements of x in the reconstruction error and employed negative sampling for the remainings; word2vec (mikolov , 2013a)+idf, a representation generated through weighted average of word vectors learned using word2vec; doc2vec (le & mikolov, 2014); skip-thought vectors(kiros , 2015), a generic, distributed sentence encoder that extends the word2vec skipgram model to sentence level. it has been shown to produce highly generic sentence representations that apply to various natural language processing tasks. we also include rnnlm (mikolov , 2010), a recurrent neural network based language model in the comparison. in the semantic relatedness task, we further compare to lstm-based methods (tai , 2015) that have been reported on this dataset.for sentiment analysis, we use the imdb movie review dataset. it contains 100,000 movies reviews categorized as either positive or negative. it comes with predefined train/test split (maas , 2011): 25,000 reviews are used for training, 25,000 for testing, and the rest as unlabeled data. the two classes are balanced in the training and testing sets. we remove words that appear less than 10 times in the training set, resulting in a vocabulary of 43,375 distinct words and symbols.
setup. we test the various representation learning algorithms under two settings: one follows the same protocol proposed in (mesnil , 2014), where representation is learned using all the available data, including the test set; another one where the representation is learned using training and unlabeled set only. for both settings, a linear support vector machine (svm) (fan , 2008) is trained afterwards on the learned representation for classification. for skip-thought vectors, we used the generic model1 trained on a much bigger book corpus to encode the documents. a vector of 4800 dimensions, first 2400 from the uni-skip model, and the last 2400 from the bi-skip model, are generated for each document. in comparison, all the other algorithms produce a vector representation of size 100. the supervised rnn-lm is learned on the training set only. the hyper-parameters are tuned on a validation set subsampled from the training set.
accuracy. comparing the two columns in table 1, we can see that all the representation learning algorithms benefits from including the testing data during the representation learning phrase. doc2vecc achieved similar or even better performance than paragraph vectors. both methods outperforms the other baselines, beating the bow representation by 15%. in comparison with word2vec+idf, which applies post-processing on learned word embeddings to form document representation, doc2vecc naturally enforces document semantics to be captured by averaged word embeddings during training. this leads to better performance. doc2vecc reduces to denoising autoencoders (dea) if the local context words are removed from the paradigm shown in figure 1. by including the context words, doc2vecc allows the document vector to focus more on capturing the global context. skip-thought vectors perform surprisingly poor on this dataset comparing to other methods. we hypothesized that it is due to the length of paragraphs in this dataset. the average length of paragraphs in the imdb movie review dataset is 296.5, much longer than the ones used for training and testing in the original paper, which is in the order of 10. as noted in (tai , 2015), the performance of lstm based method (similarly, the gated rnn used in skip-thought vectors) drops significantly with increasing paragraph length, as it is hard to preserve state over long sequences of words.
time. table 2 summarizes the time required by these algorithms to learn and generate the document representation. word2vec is the fastest one to train. denoising autoencoders and doc2vecc second that. the number of parameters that needs to be back-propagated in each update was increased by the number of surviving words in x̃. we found that both models are not sensitive to the corruption rate q in the noise model. since the learning time decreases with higher corruption rate, we used q = 0.9 throughout the experiments. paragraph vectors takes longer time to train as there are more parameters (linear to the number of document in the learning set) to learn. at test time, word2vec+idf, dea and doc2vecc all use (weighted) averaging of word embeddings as document available at https://github.com/ryankiros/skip-thoughts
representation. paragraph vectors, on the other hand, requires another round of inference to produce the vector representation of unseen test documents. it takes paragraph vectors 4 minutes and 17 seconds to infer the vector representations for the 25,000 test documents, in comparison to 7 seconds for the other methods. as we did not re-train the skip-thought vector models on this dataset, the training time2 reported in the table is the time it takes to generate the embeddings for the 25,000 training documents. due to repeated high-dimensional matrix operations required for encoding long paragraphs, it takes fairly long time to generate the representations for these documents. similarly for testing. the experiments were conducted on a desktop with intel i7 2.2ghz cpu.
data dependent regularization. as explained in section 3.1, the corruption introduced in doc2vecc acts as a data-dependent regularization that suppresses the embeddings of frequent but uninformative words. here we conduct an experiment to exam the effect. we used a cutoff of 100 in this experiment. table 3 lists the words having the smallest l2 norm of embeddings found by different algorithms. the number inside the parenthesis after each word is the number of times this word appears in the learning set. in word2vec or paragraph vectors, the least frequent words have embeddings that are close to zero, despite some of them being indicative of sentiment such as debacle, bliss and shabby. in contrast, doc2vecc manages to clamp down the representation of words frequently appear in the training set, but are uninformative, such as symbols and stop words.
subsampling frequent words. note that for all the numbers reported, we applied the trick of subsampling of frequent words introduced in (mikolov & dean, 2013) to counter the imbalance between frequent and rare words. it is critical to the performance of simple word2vec+avg as the sole remedy to diminish the contribution of common words in the final document representation. if we were to remove this step, the error rate of word2vec+avg will increases from 12.1% to 13.2%. doc2vecc on the other hand naturally exerts a stronger regularization toward embeddings of words that are frequent but uninformative, therefore does not rely on this trick.in table 3, we demonstrated that the corruption model introduced in doc2vecc dampens the embeddings of words which are common and non-discriminative (stop words). in this experiment, we are going to quantatively compare the word embeddings generated by doc2vecc to the ones generated by word2vec, or paragraph vectors on the word analogy task introduced by mikolov  (2013a). the dataset contains five types of semantic questions, and nine types of syntactic questions, with a total of 8,869 semantic and 10,675 syntactic questions. the questions are answered through simple linear algebraic operations on the word embeddings generated by different methods. please refer to the original paper for more details on the evaluation protocol. as reported in the original paper, training of the skip-thought vector model on the book corpus dataset takes around 2 weeks on gpu.
we trained the word embeddings of different methods using the english news dataset released under the acl workshop on statistical machine translation. the training set includes close to 15m paragraphs with 355m tokens. we compare the performance of word embeddings trained by different methods with increasing embedding dimensionality as well as increasing training data.
we observe similar trends as in mikolov  (2013a). increasing embedding dimensionality as well as training data size improves performance of the word embeddings on this task. however, the improvement is diminishing. doc2vecc produces word embeddings which performs significantly better than the ones generated by word2vec. we observe close to 20% uplift when we train on the full training corpus. paragraph vectors on the other hand performs surprisingly bad on this dataset. our hypothesis is that due to the large capacity of the model architecture, paragraph vectors relies mostly on the unique document vectors to capture the information in a text document instead of learning the word semantic or syntactic similarities. this also explains why the pv-dbow le & mikolov (2014) model architecture proposed in the original work, which completely removes word embedding layers, performs comparable to the distributed memory version.
in table 5, we list a detailed comparison of the performance of word embeddings generated by word2vec and doc2vecc on the 14 subtasks, when trained on the full dataset with embedding of size 100. we can see that doc2vecc significantly outperforms the word embeddings produced by word2vec across almost all the subtasks.for the document classification task, we use a subset of the wikipedia dump, which contains over 300,000 wikipedia pages in 100 categories. the 100 categories includes categories under sports,
table 5: classification error (%) of a linear classifier trained on various document representations on the wikipedia dataset.
model bow dea word2vec + avg word2vec + idf paragraphvectors doc2vecc h = 100 36.03 32.30 33.2 33.16 35.78 31.92 h = 200 36.03 31.36 32.46 32.48 34.92 30.84 h = 500 36.03 31.10 32.02 32.13 33.93 30.43 h = 1000 36.03 31.13 31.78 32.06 33.02 30.24
(a) doc2vec (b) doc2vecc
figure 3: visualization of document vectors on wikipedia dataset using t-sne.
entertainment, literature, and politics etc. examples of categories include american drama films, directorial debut films, major league baseball pitchers and sydney swans players. body texts (the second paragraph) were extracted for each page as a document. for each category, we select 1,000 documents with unique category label, and 100 documents were used for training and 900 documents for testing. the remaining documents are used as unlabeled data. the 100 classes are balanced in the training and testing sets. for this data set, we learn the word embedding and document representation for all the algorithms using all the available data. we apply a cutoff of 10, resulting in a vocabulary of size 107, 691.
table 5 summarizes the classification error of a linear svm trained on representations of different sizes. we can see that most of the algorithms are not sensitive to the size of the vector representation. doc2vec benefits most from increasing representation size. across all sizes of representations, doc2vecc outperform the existing algorithms by a significant margin. in fact, doc2vecc can achieve same or better performance with a much smaller representation vector.
figure 3 visualizes the document representations learned by doc2vec (left) and doc2vecc (right) using t-sne (maaten & hinton, 2008). we can see that documents from the same category are nicely clustered using the representation generated by doc2vecc. doc2vec, on the other hand, does not produce a clear separation between different categories, which explains its worse performance reported in table 5.
figure 4 visualizes the vector representation generated by doc2vecc w.r.t. coarser categorization. we manually grouped the 100 categories into 7 coarse categories, television, albums, writers, musicians, athletes, species and actors. categories that do no belong to any of these 7 groups are not included in the figure.
we can see that documents belonging to a coarser category are grouped together. this subset includes is a wide range of sports descriptions, ranging from football, crickets, baseball, and cycling etc., which explains why the athletes category are less concentrated. in the projection, we can see documents belonging to the musician category are closer to those belonging to albums category than those of athletes or species.we test doc2vecc on the semeval 2014 task 1: semantic relatedness sick dataset (marelli , 2014). given two sentences, the task is to determine how closely they are semantically related. the set contains 9,927 pairs of sentences with human annotated relatedness score, ranging from 1 to 5. a score of 1 indicates that the two sentences are not related, while 5 indicates high relatedness. the set is splitted into a training set of 4,500 instances, a validation set of 500, and a test set of 4,927.
we compare doc2vecc with several winning solutions of the competition as well as several more recent techniques reported on this dataset, including bi-directional lstm and tree-lstm3 trained from scratch on this dataset, skip-thought vectors learned a large book corpus 4 (zhu , 2015) and produced sentence embeddings of 4,800 dimensions on this dataset. we follow the same protocol as in skip-thought vectors, and train doc2vecc on the larger book corpus dataset. contrary to the vocabulary expansion technique used in (kiros , 2015) to handle out-of-vocabulary words, we extend the vocabulary of the learned model directly on the target dataset in the following way: we use the pre-trained word embedding as an initialization, and fine-tune the word and sentence representation on the sick dataset. notice that the fine-tuning is done for sentence representation learning only, and we did not use the relatedness score in the learning. this step brings small improvement to the performance of our algorithm. given the sentence embeddings, we used the exact same training and testing protocol as in (kiros , 2015) to score each pair of sentences: with two sentence embedding u1 and u2, we concatenate their component-wise product, u1 ·u2 and their absolute difference, |u1 − u2| as the feature representation. table 6 summarizes the performance of various algorithms on this dataset. despite its simplicity, doc2vecc significantly out-performs the winning solutions of the competition, which are heavily feature engineered toward this dataset and several baseline methods, noticeably the dependency-tree rnns introduced in (socher , 2014), which relies on expensive dependency parsers to compose sentence vectors from word embeddings. the performance of doc2vecc is slightly worse than the lstm based methods or skip-thought vectors on this dataset, while it significantly outperforms skip-thought vectors on the imdb movie review dataset (11.70% error rate vs 17.42%). as we hypothesized in previous section, while doc2vecc is better at handling longer paragraphs, lstmbased methods are superior for relatively short sentences (of length in the order of 10s). we would like to point out that doc2vecc is much faster to train and test comparing to skip-thought vectors. it takes less than 2 hours to learn the embeddings on the large book corpus for doc2vecc on a desktop with intel i7 2.2ghz cpu, in comparison to the 2 weeks on gpu required by skip-thought vectors.we introduce a new model architecture doc2vecc for document representation learning. it is very efficient to train and test thanks to its simple model architecture. doc2vecc intrinsically makes sure document representation generated by averaging word embeddings capture semantics of document during learning. it also introduces a data-dependent regularization which favors informative or rare words while dampening the embeddings of common and non-discriminative words. as such, each document can be efficiently represented as a simple average of the learned word embeddings. in comparison to several existing document representation learning algorithms, doc2vecc outperforms not only in testing efficiency, but also in the expressiveness of the generated representations. the word representation was initialized using publicly available 300-dimensional glove vectors trained on 840 billion tokens of common crawl data the dataset contains 11,038 books with over one billion words",1
333.pdf.json,"during the last two years several different approaches towards natural image generation have been suggested, among them generative adversarial networks (goodfellow , 2014; chen , 2016), probabilistic generative models like the conditional pixelcnn (van den oord , 2016b;a) or maximum entropy models that rely on the representations of deep neural networks (e.g. gatys , 2015b; johnson , 2016; ulyanov , 2016). the latter approach has been particularly groundbreaking for artistic style transfer and natural texture generation (e.g. gatys , 2015a;b) and has the potential to uncover the regularities that supervisedly trained deep neural networks infer from natural images.
for the sake of clarity and concreteness, this paper will focus on natural texture synthesis. parametric texture models aim to uniquely describe each texture by a set of statistical measurements that are taken over the spatial extent of the image. each image with the same spatial summary statistics should be perceived as the same texture. consequently, synthesizing a texture corresponds to finding a new image that reproduces the summary statistics inferred from the reference texture. starting from nth-order joint histograms of the pixels by julesz (1962), many different statistical measures have been proposed (see e.g. heeger & bergen, 1995; portilla & simoncelli, 2000). the quality of the synthesized textures is usually determined by human inspection; the synthesis is successful if a human observer cannot tell the reference texture from the synthesized ones.
the current state of the art in parametric texture modeling (gatys , 2015a) employs the hierarchical image representation in a deep 19-layer convolutional network (simonyan & zisserman (2014); in the following referred to as vgg network) that was trained on object recognition in natural images(russakovsky  (2015)). in this model textures are described by the raw correlations between feature activations in response to the texture image from a collection of network layers (see section 5 for details). since its initial reception several papers explored which additional elements or constraints can further increase the perceptual quality of the generated textures (berger & memisevic, 2016; liu , 2016; aittala , 2016). in this work we go the opposite way and ask which elements of the original texture synthesis algorithm (gatys , 2015a) are absolutely indispensable.
in particular two aspects have been deemed critical for natural texture synthesis: the hierarchical multi-layer representation of the textures, and the supervised training of the feature spaces. here we show that neither aspect is imperative for texture modeling and that in fact a single convolutional layer with random features can synthesize textures that often rival the perceptual quality of gatys  (2015a). this is in contrast to earlier reports (gatys , 2015a) that suggested that networks with random weights fail to generate perceptually interesting images. we suggest that this discrepancy originates from a more elaborate tuning of the optimization procedure (see section 4).
our main contributions are:
• we present a strong minimal baseline for parametric texture synthesis that solely relies on a single-layer network and random, data-independent filters. • we show that textures synthesized from the baseline are of high quality and often rival
state-of-the-art approaches, suggesting that the depth and the pre-training of multi-layer image representations are not as indispensable for natural image generation as has previously been thought. • we test and compare a wide range of single-layer architectures with different filter-sizes and
different types of filters (random, hand-crafted and unsupervisedly learnt filters) against the state-of-the-art texture model by gatys  (2015a). • we utilize a quantitative texture quality measure based on the synthesis loss in the vggbased model (gatys , 2015a) to replace the common-place evaluation of texture models through qualitative human inspection. • we discuss a formal generalization of maximum entropy models to account for the natural
variability of textures with limited spatial extent.if not mentioned otherwise, all our models employ single-layer cnns with standard rectified linear units (relus) and convolutions with stride one, no bias and padding (f − 1)/2 where f is the filter-size. this choice ensures that the spatial dimension of the output feature maps is the same as the input. all networks except the last one employ filters of size 11× 11× 3 (filter width × filter height × no. of input channels), but the number of feature maps as well as the selection of the filters differ:
• fourier-363: each color channel (r, g, b) is filtered separately by each element bi ∈ r11×11 of the 2d fourier basis (11×11 = 121 feature maps/channel), yielding 3·121 = 363 feature maps in total. more concretely, each filter can be described as the tensor product bi ⊗ ek where the elements of the unit-norm ek ∈ r3 are all zero except one. • fourier-3267: all color channels (r, g, b) are filtered simultaneously by each element bi of the 2d fourier basis but with different weighting terms wr, wg, wb ∈ [1, 0,−1], yielding 3 · 3 · 3 · 121 = 3267 feature maps in total. more concretely, each filter can be described by the tensor product bi ⊗ [wr, wg, wb ]. • kmeans-363: we randomly sample and whiten 1e7 patches of size 11 × 11 from the
imagenet dataset (russakovsky , 2015), partition the patches into 363 clusters using k-means (rubinstein , 2009), and use the cluster means as convolutional filters. • kmeans-3267: same as kmeans-363 but with 3267 clusters. • kmeans-nonwhite-363/3267: same as kmeans-363/3267 but without whitening of the
patches. • kmeans-sample-363/3267: same as kmeans-363/3267, but patches are only sampled
from the target texture. • pca-363: we randomly sample 1e7 patches of size 11 × 11 from the imagenet dataset
(russakovsky , 2015), vectorize each patch, perform pca and use the set of principal axes as convolutional filters. • random-363: filters are drawn from a uniform distribution according to (glorot & bengio, 0), 363 feature maps in total. • random-3267: same as random-363 but with 3267 feature maps.
original fourier-363, 11x11 k-means-363, 11x11 k-samples-363, 11x11 k-nw-363, 11x11 random-363, 11x11 pca-363, 11x11
gatys  fourier-3267, 11x11 k-means-3267, 11x11 k-samples-3267, 11x11 k-nw-3267, 11x11 random-3267, 11x11 random multi-scale
the networks were implemented in lasagne (dieleman , 2015; theano development team, 2016). we remove the dc component of the inputs by subtracting the mean intensity in each color channel (estimated over the imagenet dataset (russakovsky , 2015)).the texture model closely follows (gatys , 2015a). in essence, to characterise a given vectorised texture x ∈ rm , we first pass x through the convolutional layer and compute the output activations. the output can be understood as a non-linear filter bank, and thus its activations form a set of filtered images (so-called feature maps). for n distinct feature maps, the rectified output activations can be
described by a matrix f ∈ rn×m . to capture the stationary structure of the textures, we compute the covariances (or, more precisely, the gramian matrix) g ∈ rn×n between the feature activations f by averaging the outer product of the point-wise feature vectors,
gij = 1
m m∑ m=1 fimfjm. (1)
we will denote g(x) as the gram matrix of the feature activations for the input x. to determine the relative distance between two textures x and y we compute the euclidean distance of the normalized gram matrices,
d(x,y) = 1√∑
m,n gmn(x)2 √∑ m,n gmn(y)2 n∑ i,j=1 (gij(x)−gij(y))2 . (2)
to compare with the distance in the raw pixel values, we compute
dp(x,y) = 1√∑ m x2m √∑ m y2m n∑ i=1 (xi − yi)2 . (3)to generate a new texture we start from a uniform noise image (in the range [0, 1]) and iteratively optimize it to match the gram matrix of the reference texture. more precisely, let g(x) be the gram matrix of the reference texture. the goal is to find a synthesised image x̃ such that the squared distance between g(x) and the gram matrix g(x̃) of the synthesized image is minimized, i.e.
x̃ = argmin y∈rm e(y), (4)
e(y) = 1∑n
i,j=1gij(x) 2 n∑ i,j=1 ( gij(x)−gij(y) )2 . (5)
the gradient ∂e(y)/∂y of the reconstruction error with respect to the image can readily be computed using standard backpropagation, which we then use in conjunction with the l-bfgs-b algorithm (jones , 2001–) to solve (4). we leave all parameters of the optimization algorithm at their default value except for the maximum number of iterations (2000), and add a box constraints with range [0, 1]. in addition, we scale the loss and the gradients by a factor of 107 in order to avoid early stopping of the optimization algorithm.evaluating the quality of the synthesized textures is traditionally performed by human inspection. optimal texture synthesis should generate samples that humans perceive as being the same texture as the reference. the high quality of the synthesized textures by (gatys , 2015a) suggests that the summary statistics from multiple layers of vgg can approximate the perceptual metric of humans. even though the vgg texture representation is not perfect, this allows us to utilize these statistics as a more objective quantification of texture quality.
for all details of the vgg-based texture model see (gatys , 2015a). here we use the standard 19-layer vgg network (simonyan & zisserman, 2014) with pretrained weights and average- instead of max-pooling1. we compute a gram matrix on the output of each convolutional layer that follows a pooling layer. let g`(.) be the gram matrix on the activations of the `-th layer and
e`(y) = 1∑n
i,j=1g ` ij(x) 2 n∑ i,j=1 ( g`ij(x)−g`ij(y) )2 . (6)
the corresponding relative reconstruction cost. the total reconstruction cost is then defined as the average distance between the reference gram matrices and the synthesized ones, i.e.
e(y) = 1  5∑ `=1 e`(y). (7)
this cost is reported on top of each synthesised texture in figures 4. to visually evaluate samples from our single- and multi-scale model against the vgg-based model (gatys , 2015a), we additionally synthesize textures from vgg by minimizing (7) using l-bfgs-b as in section 4.in fig. 1 we show textures synthesised from two random single- and multi-scale models, as well as eight other non-random single-layer models for three different source images (top left). for https://github.com/lasagne/recipes/blob/master/modelzoo/vgg19.py as accessed on 12.05.2016.
comparison, we also plot samples generated from the vgg model by gatys  (gatys , 2015a) (bottom left). there are roughly two groups of models: those with a small number of feature maps (363, top row), and those with a large number of feature maps (3267, bottom row). only the multi-scale model employs 1024 feature maps. within each group, we can differentiate models for which the filters are unsupervisedly trained on natural images (e.g. sparse coding filters from k-means), principally devised filter banks (e.g. 2d fourier basis) and completely random filters (see sec. 2 for all details). all single-layer networks, except for multi-scale, feature 11× 11 filters. remarkably, despite the small spatial size of the filters, all models capture much of the small- and mid-scale structure of the textures, in particular if the number of feature maps is large. notably, the scale of these structures extends far beyond the receptive fields of the single units (see e.g. the pebble texture). we further observe that a larger number of feature maps generally increases the perceptual quality of the generated textures. surprisingly, however, completely random filters perform on par or better then filters that have been trained on the statistics of natural images. this is particularly true for the multi-scale model that clearly outperforms the single-scale models on all textures. the captured structures in the multi-scale model are generally much larger and often reach the full size of the texture (see e.g. the wall).
while the above results show that for natural texture synthesis one neither needs a hierarchical deep network architecture with spatial pooling nor filters that are adapted to the statistics of natural images, we now focus on the aspects that are crucial for high quality texture synthesis. first, we evaluate whether the success of the random multi-scale network arises from the combination of filters on multiple scales or whether it is simply the increased size of its largest receptive fields (55× 55 vs. 11× 11) that leads to the improvement compared to the single-scale model. thus, to investigate the influence of the spatial extend of the filters and the importance of combining multiple filter sizes in one model, we generate textures from multiple single-scale models, where each model has the same number of random filters as the multi-scale model (1024) but only uses filters from a single scale of the multi-scale model (fig. 2). we find that while 3× 3 filters mainly capture the marginal distribution of the color channels, larger filters like 11 × 11 model small- to mid-scale structures (like small stones) but miss more long-range structures (larger stones are not well separated). very large filters like 55× 55, on the other hand, are capable of modeling long-range structures but then miss much of the small- to midscale statistics (like the texture of the stone). therefore we conclude that the combination of different scales in the multi-scale network is important for good texture synthesis since it allows to simultaneously model small-, mid- and long-range correlations of the textures. finally we note that a further indispensable component for good texture models are the non-linearities: textures synthesised the multi-scale model without relu (fig. 2, right column) are unable to capture the statistical dependencies of the texture.
the perceptual quality of the textures generated from models with only a single layer and random filters is quite remarkable and surpasses parametric methods like portilla & simoncelli (2000) that have been state-of-the-art two years ago (before the use of dnns). the multi-scale model often rivals the current state of the art (gatys , 2015a) as we show in fig. 4 where we compare samples synthesized from 20 different textures for the random single- and multi-scale model, as well as vgg. the multi-scale model generates very competitive samples in particular for textures with extremely regular structures across the whole image (e.g. for the brick wall, the grids or the scales). in part, this effect can be attributed to the more robust optimization of the single-layer model that is less prone to local minima then the optimization in deeper models. this can be seen by initializing the vgg-based synthesis with textures from the single-layer model, which consistently yields superior synthesis results (see appendix a, fig. 5). in addition, for a few textures such as the grid structures, the vgg-based loss is paradoxically lower for samples from the multi-scale model then for the vgg-based model (which directly optimized the vgg-based loss). this suggests that the naive synthesis performed here favors images that are perceptually similar to the reference texture and thus looses variability (see sec. 7 for further discussion). nonetheless, samples from the single-layer model still exhibit large perceptual differences, see fig. 3. the vgg-based loss (7) appears to generally be an acceptable approximation of the perceptual differences between the reference and the synthesized texture. only for a few textures, especially those with very regular men-made structures (e.g. the wall or the grids), the vgg-based loss fails to capture the perceptual advantage of the multi-scale synthesis.we proposed a generative model of natural textures based on a single-layer convolutional neural network with completely random filters and showed that the model is able to qualitatively capture the perceptual differences between natural textures. samples from the model often rival the current state-of-the-art (gatys , 2015a) (fig. 4, third vs fourth row), even though the latter relies on a high-performance deep neural network with features that are tuned to the statistics of natural images. seen more broadly, this finding suggests that natural image generation does not necessarily depend on deep hierarchical representations or on the training of the feature maps. instead, for texture synthesis, both aspects rather seem to serve as fine-tuning of the image representation.
one concern about the proposed single-layer multi-scale model is its computational inefficiency since it involves convolutions with spatially large filters (up to 55× 55). a more efficient way to achieve receptive fields of similar size would be to use a hierarchical multi-layer net. we conducted extensive experiments with various hierarchical architectures and while the synthesis is indeed significantly faster, the quality of the synthesized textures does not improve compared to a single-layer model. thus for a minimal model of natural textures, deep hierarchical representations are not necessary but they can improve the efficiency of the texture synthesis.
our results clearly demonstrate that gram matrices computed from the feature maps of convolutional neural networks generically lead to useful summary statistics for texture synthesis. the gram matrix on the feature maps transforms the representations from the convolutional neural network into a stationary feature space that captures the pairwise correlations between different features. if the number of feature maps is large, then the local structures in the image are well preserved in the projected space and the overlaps of the convolutional filtering add additional constraints. at the same time, averaging out the spatial dimensions yields sufficient flexibility to generate entirely new textures that differ from the reference on a patch by patch level, but still share much of the small- and long-range statistics.
the success of shallow convolutional networks with random filters in reproducing the structure of the reference texture is remarkable and indicates that they can be useful for parametric texture synthesis. besides reproducing the stationary correlation structure of the reference image (""perceptual similarity"") another desideratum of a texture synthesis is to exhibit a large variety between different samples generated from the same given image (""variability""). hence, synthesis algorithms need to balance perceptual similarity and variability. this balance is determined by a complex interplay between the choice of summary statistics and the optimization algorithm used. for example the stopping criterion of the optimization algorithm can be adjusted to trade perceptual similarity for larger variability.
finding the right balance between perceptual similarity and variability is challenging because we are currently lacking robust measures of these quantities. in this work we introduced vgg-loss as a measure of perceptual similarity, and, even though, it works much better than other common measures such as structural similarity index (ssim, wang , 2004, see appendix a, figure 6) or euclidean distance in the pixel space (not shown), it is still not perfect (figure 4). measuring variability is probably even more difficult: in principle it requires measuring the entropy of generated samples, which is intractable in a high-dimensional space. a different approach could be based on a psychophysical assessment of generated samples. for example, we could use an inpainting task (illustrated in appendix a, figure 7) to make human observers decide between actual texture patches and inpaited ones. performance close to a chance-level would indicate that the texture model produces variable enough samples to capture the diversity of actual patches. the further exploration of variability measures lies, however, beyond the scope of this work.
in this paper we focused on maximizing perceptual similarity only, and it is worth pointing out that additional efforts will be necessary to find an optimal trade-off between perceptual similarity and variability. for the synthesis of textures from the random models considered here, the trade-off leans more towards perceptual similarity in comparison to gatys  (2015a)(due to the simpler optimization) which also explains the superior performance on some samples. in fact, we found some anecdotal evidence (not shown) in deeper multi-layer random cnns where the reference texture was exactly reconstructed during the synthesis. from a theoretical point of view this is likely a finite size effect which does not necessarily constitute a failure of the chosen summary statistics: for finite size images it is well possible that only the reference image can exactly reproduce all the summary
statistics. therefore, in practice, the gram matrices are not treated as hard constraints but as soft constraints only. more generally, we do not expect a perceptual distance metric to assign exactly zero to a random pair of patches from the same texture. instead, we expect it to assign small values for pairs from the same texture, and large values for patches from different textures. therefore, the selection of constraints is not sufficient to characterize a texture synthesis model but only determines the exact minima of the objective function (which are sought for by the synthesis). if we additionally consider images with small but non-zero distance to the reference statistics, then the set of equivalent textures increases substantially, and the precise composition of this set becomes critically dependent on the perceptual distance metric.
mathematically, parametric texture synthesis models are described as ergodic random fields that have maximum entropy subject to certain constraints zhu  (1997); bruna & mallat (2013); zhu  (2000) (maxent framework). practical texture synthesis algorithms, however, always deal with finite size images. as discussed above, two finite-size patches from the same ergodic random field will almost never feature the exact same summary statistics. this additional uncertainty in estimating the constraints on finite length processes is not thoroughly accounted for by the maxent framework (see discussion on its “ad hockeries” by jaynes (jaynes (1982))). thus, a critical difference of practical implementations of texture synthesis algorithms from the conceptual maxent texture modeling framework is that they genuinely allow a small mismatch in the constraints. accordingly, specifying the summary statistics is not sufficient but a comprehensive definition of a texture synthesis model should specify: . a metric d(x,y) that determines the distance between any two arbitrary textures x,y. . a bipartition px of the image space that determines which images are considered perceptually equivalent to a reference texture x. a simple example for such a partition is the -environment u (y) := {y : d(y,x) < } and its complement.
this definition is relevant for both under- as well as over-constrained models, but its importance becomes particularly obvious for the latter. according to the minimax entropy principle for texture modeling suggested by zhu zhu  (1997), as many constraints as possible should be used to reduce the (kullback-leibler) divergence between the true texture model and its estimate. however, for finite spatial size, the synthetic samples become exactly equivalent to the reference texture (up to shifts) in the limit of sufficiently many independent constraints. in contrast, if we explicitly allow for a small mismatch between the summary statistics of the reference image and the synthesized textures, then the set of possible textures does not constitute a low-dimensional manifold but rather a small volume within the pixel space. alternatively, instead of introducing an -environment it is also possible to extent the maxent framework to allow for variability in the summary statistics (joan bruna, personal communication). it will be interesting to compare in the future to what extent the difference between the two approaches can lead to differences in the perceptual appearance of the textures.
taken together we have shown that simple single-layer cnns with random filters can serve as the basis for excellent texture synthesis models that outperform previous hand-crafted synthesis models and sometimes even rivals the current state-of-the-art. this finding repeals previous observations that suggested a critical role for the multi-layer representations in trained deep networks for natural texture generation. on the other hand, it is not enough to just use sufficiently many constraints as one would predict from the maxent framework. instead, for the design of good texture synthesis algorithms it will be crucial to find distance measures for which the -environment around the reference texture leads to perceptually satisfying results. in this way, building better texture synthesis models is inherently related to better quantitative models of human perception.",1
358.pdf.json,"the machine learning community is well-practised at learning representations of data-points and sequences. a middle-ground between these two is representing, or summarizing, datasets - unordered collections of vectors, such as photos of a particular person, recordings of a given speaker or a document as a bag-of-words. where these sets take the form of i.i.d samples from some distribution, such summaries are called statistics. we explore the idea of using neural networks to learn statistics and we refer to our approach as a neural statistician.
the key result of our approach is a statistic network that takes as input a set of vectors and outputs a vector of summary statistics specifying a generative model of that set - a mean and variance specifying a gaussian distribution in a latent space we term the context. the advantages of our approach are that it is:
• unsupervised: it provides principled and unsupervised way to learn summary statistics as the output of a variational encoder of a generative model.
• data efficient: if one has a large number of small but related datasets, modelling the datasets jointly enables us to gain statistical strength.
• parameter efficient: by using summary statistics instead of say categorical labellings of each dataset, we decouple the number of parameters of the model from the number of datasets.
• capable of few-shot learning: if the datasets correspond to examples from different classes, class embeddings (summary statistics associated with examples from a class), allow us to handle new classes at test time.we are given datasets di for i ∈ i. each dataset di = {x1, . . . , xki} consists of a number of i.i.d samples from an associated distribution pi over rn. the task can be split into learning and inference components. the learning component is to produce a generative model p̂i for each dataset di. we assume there is a common underlying generative process p such that pi = p(·|ci) for ci ∈ rl drawn
from p(c). we refer to c as the context. the inference component is to give an approximate posterior over the context q(c|d) for a given dataset produced by a statistic network.in order to exploit the assumption of a hierarchical generative process over datasets we will use a ‘parameter-transfer approach’ (see pan & yang, 2010) to extend the variational autoencoder model of kingma & welling (2013).the variational autoencoder is a latent variable model p(x|z; θ) (often called the decoder) with parameters θ. for each observed x, a corresponding latent variable z is drawn from p(z) so that
p(x) = ∫ p(x|z; θ)p(z) dz. (1)
the generative parameters θ are learned by introducing a recognition network (also called an encoder) q(z|x;φ) with parameters φ. the recognition network gives an approximate posterior over the latent variables that can then be used to give the standard variational lower bound (saul & jordan, 1996) on the single-datum log-likelihood. i.e. logp (x|θ) ≥ lx, where
lx = eq(z|x,φ) [log p(x|z; θ)]−dkl (q(z|x;φ)‖p(z)) . (2)
likewise the full-data log likelihood is lower bounded by the sum of the lx terms over the whole dataset. we can then optimize this lower bound with respect to φ and θ using the reparameterization trick introduced by kingma & welling (2013) and rezende  (2014) to get a monte-carlo estimate of the gradient.we extend the variational autoencoder to the model depicted on the left in figure 1. this includes a latent variable c, the context, that varies between different datasets but is constant, a priori, for items within the same dataset. now, the likelihood of the parameters θ for one single particular dataset d is given by
p(d) = ∫ p(c) [∏ x∈d ∫ p(x|z; θ)p(z|c; θ) dz ] dc. (3)
the prior p(c) is chosen to be a spherical gaussian with zero mean and unit variance. the conditional p(z|c; θ) is gaussian with diagonal covariance, where all the mean and variance parameters depend on c through a neural network. similarly the observation model p(x|z; θ) will be a simple likelihood function appropriate to the data modality with dependence on z parameterized by a neural network. for example, with real valued data, a diagonal gaussian likelihood could be used where the mean and log variance of x are created from z via a neural network.
we use approximate inference networks q(z|x, c;φ), q(c|d;φ), with parameters collected into φ, to once again enable the calculation and optimization of a variational lower bound on the loglikelihood. the single dataset log likelihood lower bound is given by
ld = eq(c|d;φ) [∑ x∈d eq(z|c,x;φ) [log p(x|z; θ)]−dkl (q(z|c, x;φ)‖p(z|c; θ)) ] −dkl (q(c|d;φ)‖p(c)) . (4)
as with the generative distributions, the likelihood forms for q(z|x, c;φ) and q(c|d;φ) are diagonal gaussian distributions, where all the mean and log variance parameters in each distribution are produced by a neural network taking the conditioning variables as inputs. note that q(c|d;φ) accepts as input a dataset d and we refer to this as the statistic network. we describe this in subsection 3.4.
the full-data variational bound is given by summing the variational bound for each dataset in our collection of datasets. it is by learning the difference of the within-dataset and between-dataset distributions that we are able to discover an appropriate statistic network.the basic model works well for modelling simple datasets, but struggles when the datasets have complex internal structure. to increase the sophistication of the model we use multiple stochastic layers z1, . . . , zk and introduce skip-connections for both the inference and generative networks. the generative model is shown graphically in figure 1 in the center. the probability of a dataset d is then given by
p(d) = ∫ p(c) ∏ x∈d ∫ p(x|c, z1:l; θ)p(zl|c; θ) l−1∏ i=1 p(zi|zi+1, c; θ) dz1:l dc (5)
where the p(zi|zi+1, c, θ) are again gaussian distributions where the mean and log variance are given as the output of neural networks. the generative process for the full model is described in algorithm 1.
the full approximate posterior factorizes analogously as
q(c, z1:l|d;φ) = q(c|d;φ) ∏ x∈d q(zl|x, c;φ) l−1∏ i=1 q(zi|zi+1, x, c;φ). (6)
for convenience we give the variational lower bound as sum of a three parts, a reconstruction term rd, a context divergence cd and a latent divergence ld:
ld = rd + cd + ld with (7) rd = eq(c|d;φ) ∑ x∈d eq(z1:l|c,x;φ) log p(x|z1:l, c; θ) (8)
cd = dkl (q(c|d;φ)‖p(c)) (9)
ld = eq(c,z1:l|d;φ) [∑ x∈d dkl (q(zl|c, x;φ)‖p(zl|c; θ))
+ l−1∑ i=1 dkl (q(zi|zi+1, c, x;φ)‖p(zi|zi+1, c; θ))
] . (10)
the skip-connections p(zi|zi+1, c; θ) and q(zi|zi+1, x;φ) allow the context to specify a more precise distribution for each latent variable by explaining-away more generic aspects of the dataset at each stochastic layer. this architecture was inspired by recent work on probabilistic ladder networks in kaae sønderby  (2016). complementing these are the skip-connections from each latent variable to the observation p(x|z1:l, c; θ), the intuition here is that each stochastic layer can focus on representing a certain level of abstraction, since its information does not need to be copied into the next layer, a similar approach was used in maaløe  (2016).
once again, note that we are maximizing the lower bound to the log likelihood over many datasets d: we want to maximize the expectation of ld over all datasets. we do this optimization using stochastic gradient descent. in contrast to a variational autoencoder where a minibatch would consist of a subsample of datapoints from the dataset, we use minibatches consisting of a subsample of datasets - tensors of shape (batch size, sample size, number of features).in addition to the standard inference networks we require a statistic network q(c|d;φ) to give an approximate posterior over the context c given a datasetd = {x1, . . . , xk} . this inference network must capture the exchangeability of the data in d.
we use a feedforward neural network consisting of three main elements:
• an instance encoder e that takes each individual datapoint xi to a vector ei = e(xi). • an exchangeable instance pooling layer that collapses the matrix (e1, . . . , ek) to a single
pre-statistic vector v. examples include elementwise means, sums, products, geometric means and maximum. we use the sample mean for all experiments. • a final post-pooling network that takes v to a parameterization of a diagonal gaussian.
the graphical model for this is given at the right of figure 1.
we note that the humble sample mean already gives the statistic network a great deal of representational power due to the fact that the instance encoder can learn a representation where averaging makes sense. for example since the instance encoder can approximate a polynomial on a compact domain, and so can the post-pooling network, a statistic network can approximate any moment of a distribution.due to the general nature of the problem considered, our work touches on many different topics which we now attempt to summarize.
topic models and graphical models the form of the graphical model in figure 1 on the left is equivalent to that of a standard topic model. in contrast to traditional topic models we do not use discrete latent variables, or restrict to discrete data. work such as that by ranganath  (2014) has extended topic models in various directions, but importantly we use flexible conditional distributions and dependency structures parameterized by deep neural networks. recent work has explored neural networks for document models (see e.g. miao , 2015) but has been limited to modelling datapoints with little internal structure. along related lines are ‘structured variational autoencoders’ (see johnson , 2016), where they treat the general problem of integrating graphical models with variational autoencoders.
transfer learning there is a considerable literature on transfer learning, for a survey see pan & yang (2010). there they discuss ‘parameter-transfer’ approaches whereby parameters or priors are shared across datasets, and our work fits into that paradigm. for examples see lawrence & platt (2004) where share they priors between gaussian processes, and evgeniou & pontil (2004) where they take an svm-like approach to share kernels.
one-shot learning learning quickly from small amounts of data is a topic of great interest. lake  (2015) use bayesian program induction for one-shot generation and classification, and koch (2015) train a siamese (chopra  (2005)) convolutional network for one-shot image classification. we note the relation to the recent work (rezende , 2016) in which the authors use a conditional recurrent variational autoencoder capable of one-shot generalization by taking as extra input a conditioning data point. the important differences here are that we jointly model datasets and datapoints and consider datasets of any size. recent approaches to one-shot classification are matching networks (vinyals , 2016b) (which was concurrent with the initial preprint of this work), and related previous work (santoro , 2016). the former can be considered a kind of differentiable nearest neighbour classifier, and the latter augments their network with memory to store information about the classification problem. both are trained end-to-end for the classification problem, whereas the present work is a general approach to learning representations of datasets. probably the closest previous work is by salakhutdinov  (2012) where the authors learn a topic
model over the activations of a dbm for one-shot learning. compared with their work we use modern architectures and easier to train vaes, in particular we have fast and amortized feedforward inference for test (and training) datasets, avoiding the need for mcmc.
multiple-instance learning there is previous work on classifying sets in multiple-instance learning, for a useful survey see cheplygina  (2015). typical approaches involve adapting kernel based methods such as support measure machines (muandet , 2012), support distribution machines (póczos , 2012) and multiple-instance-kernels (gartner , 2002). we do not consider applications to multiple-instance learning type problems here, but it may be fruitful to do so in the future.
set2seq in very related work, vinyals  (2016a) explore architectures for mapping sets to sequences. there they use an lstm to repeatedly compute weighted-averages of the datapoints and use this to tackle problems such as sorting a list of numbers. the main difference between their work and ours is that they primarily consider supervised problems, whereas we present a general unsupervised method for learning representations of sets of i.i.d instances. in future work we may also explore recurrently computing statistics.
abc there has also been work on learning summary statistics for approximate bayesian computation by either learning to predict the parameters generating a sample as a supervised problem, or by using kernel embeddings as infinite dimensional summary statistics. see the work by fukumizu  (2013) for an example of kernel-based approaches. more recently jiang  (2015) used deep neural networks to predict the parameters generating the data. the crucial differences are that their problem is supervised, they do not leverage any exchangeability properties the data may have, nor can it deal with varying sample sizes.given an input set x1, . . . xk we can use the statistic network to calculate an approximate posterior over contexts q(c|x1, . . . , xk;φ). under the generative model, each context c specifies a conditional model p(x|c; θ). to get samples from the model corresponding to the most likely posterior value of c, we set c to the mean of the approximate posterior and then sample directly from the conditional distributions. this is described in algorithm 2. we use this process in our experiments to show samples. in all experiments, we use the adam optimization algorithm (kingma & ba, 2014) to optimize the parameters of the generative models and variational approximations. batch normalization (ioffe & szegedy, 2015) is implemented for convolutional layers and we always use a batch size of 16. we primarily use the theano (theano development team, 2016) framework with the lasagne (dieleman , 2015) library, but the final experiments with face data were done using tensorflow (abadi , 2015). in all cases experiments were terminated after a given number of epochs when training appeared to have sufficiently converged (300 epochs for omniglot, youtube and spatial mnist examples, and 50 epochs for the synthetic experiment).in our first experiment we wanted to know if the neural statistician will learn to cluster synthetic 1-d datasets by distribution family. we generated a collection of synthetic 1-d datasets each containing 200 samples. datasets consist of samples from either an exponential, gaussian, uniform or laplacian distribution with equal probability. means and variances are sampled from u [−1, 1] and u [0.5, 2] respectively. the training data contains 10k sets.
the architecture for this experiment contains a single stochastic layer with 32 units for z and 3 units for c, . the model p(x|z, c; θ) and variational approximation q(z|x, c;φ) are each a diagonal gaussian distribution with all mean and log variance parameters given by a network composed of three dense layers with relu activations and 128 units. the statistic network determining the mean and log variance parameters of posterior over context variables is composed of three dense layers before and after pooling, each with 128 units with rectified linear unit (relu) activations.
figure 2 shows 3-d scatter plots of the summary statistics learned. notice that the different families of distribution cluster. it is interesting to observe that the exponential cluster is differently orientated to the others, perhaps reflecting the fact that it is the only non-symmetric distribution. we also see that between the gaussian and laplacian clusters there is an area of ambiguity which is as one
might expect. we also see that within each cluster the mean and variance are mapped to orthogonal directions. .2 spatial mnist
building on the previous experiments we investigate 2-d datasets that have complex structure, but the datapoints contain little information by themselves, making it a good test of the statistic network. we created a dataset called spatial mnist. in spatial mnist each image from mnist (lecun , 1998) is turned into a dataset by interpreting the normalized pixel intensities as a probability density and sampling coordinate values. an example is shown in figure 3. this creates two-dimensional spatial datasets. we used a sample size of 50. note that since the pixel coordinates are discrete, it is necessary to dequantize them by adding uniform noise u ∼ u [0, 1] to the coordinates if one models them as real numbers, else you can get arbitrarily high densities (see theis  (2016) for a discussion of this point).
the generative architecture for this experiment contains 3 stochastic z layers, each with 2 units, and a single c layer with 64 units. the means and log variances of the gaussian likelihood for p(x|z1:3, c; θ), and each subnetwork for z in both the encoder and decoder contained 3 dense layers with 256 relu units each. the statistic network also contained 3 dense layers pre-pooling and 3 dense layers post pooling with 256 relu units.
in addition to being able to sample from the model conditioned on a set of inputs, we can also summarize a dataset by choosing a subset s ⊆ d to minimise the kl divergence of q(c|d;φ) from q(c|s;φ). we do this greedily by iteratively discarding points from the full sample. pseudocode for this process is given in algorithm 3. the results are shown in figure 4. we see that the model is capable of handling complex arrangements of datapoints. we also see that it can select sensible subsets of a dataset as a summary.next we work with the omniglot data (lake , 2015). this contains 1628 classes of handwritten characters but with just 20 examples per class. this makes it an excellent test-bed for transfer / few-shot learning. we constructed datasets by splitting each class into datasets of size 5. we train
on datasets drawn from 1200 classes and reserve the remaining classes to test few-shot sampling and classification. we created new classes by rotating and reflecting characters. we resized the images to 28 × 28. we sampled a binarization of each image for each epoch. we also randomly applied the dilation operator from computer vision as further data augmentation since we observed that the stroke widths are quite uniform in the omniglot data, whereas there is substantial variation in mnist, this augmentation improved the visual quality of the few-shot mnist samples considerably and increased the few-shot classification accuracy by about 3 percent. finally we used ‘sample dropout’ whereby a random subset of each dataset was removed from the pooling in the statistic network, and then included the number of samples remaining as an extra feature. this was beneficial since it reduced overfitting and also allowed the statistic network to learn to adjust the approximate posterior over c based on the number of samples.
we used a single stochastic layer with 16 units for z, and 512 units for c. we used a shared convolutional encoder between the inference and statistic networks and a deconvolutional decoder network. full details of the networks are given in appendix b.1. the decoder used a bernoulli likelihood.
in figure 5 we show two examples of few-shot learning by conditioning on samples of unseen characters from omniglot, and conditioning on samples of digits from mnist. the samples are mostly of a high-quality, and this shows that the neural statistician can generalize even to new datasets.
as a further test we considered few-shot classification of both unseen omniglot characters and mnist digits. given a sets of labelled examples of each class d0, . . . , d9 (for mnist say), we computed the approximate posteriors q(c|di;φ) using the statistic network. then for each test image x we also computed the posterior q(c|x;φ) and classified it according to the training dataset di minimizing the kl divergence from the test context to the training context. this process is described in algorithm 4. we tried this with either 1 or 5 labelled examples per class and either 5 or 20 classes. for each trial we randomly select k classes, randomly select training examples for each class, and test on the remaining examples. this process is repeated 100 times and the results averaged. the results are shown in table 1. we compare to a number of results reported in vinyals  (2016b) including santoro  (2016) and koch (2015). overall we see that
the neural statistician model can be used as a strong classifier, particularly for the 5-way tasks, but performs worse than matching networks for the 20-way tasks. one important advantage that matching networks have is that, whilst each class is processed independently in our model, the representation in matching networks is conditioned on all of the classes in the few-shot problem. this means that it can exaggerate differences between similar classes, which are more likely to appear in a 20-way problem than a 5-way problem.finally, we provide a proof of concept for generating faces of a particular person. we use the youtube faces database from wolf  (2011). it contains 3, 245 videos of 1, 595 different people. we use the aligned and cropped to face version, resized to 64 × 64. the validation and test sets contain 100 unique people each, and there is no overlap of persons between data splits. the sets were created by sampling frames randomly without replacement from each video, we use a set size of 5 frames. we resample the sets for the training data each epoch.
our architecture for this problem is based on one presented in lamb  (2016). we used a single stochastic layer with 500 dimensional latent c and 16 dimensional z variable. the statistic network and the inference network q(z|x, c;φ) share a common convolutional encoder, and the deocder uses deconvolutional layers. for full details see appendix b.2. the likelihood function is a gaussian, but where the variance parameters are shared across all datapoints, this was found to make training faster and more stable.
the results are shown in figure 6. whilst there is room for improvement, we see that it is possible to specify a complex distribution on-the-fly with a set of photos of a previously unseen person. the samples conditioned on an input set have a reasonable likeness of the input faces. we also show the ability of the model to generate new datasets and see that the samples have a consistent identity and varied poses.we have demonstrated a highly flexible model on a variety of tasks. going forward our approach will naturally benefit from advances in generative models as we can simply upgrade our base generative model, and so future work will pursue this. compared with some other approaches in the literature for few-shot learning, our requirement for supervision is weaker: we only ask at training time that we are given datasets, but we do not need labels for the datasets, nor even information on whether two datasets represent the same or different classes. it would be interesting then to explore application areas where only this weaker form of supervision is available. there are two important limitations to this work, firstly that the method is dataset hungry: it will likely not learn useful representations of datasets given only a small number of them. secondly at test time the few-shot fit of the generative model will not be greatly improved by using larger datasets unless the model was also trained on similarly large datasets. the latter limitation seems like a promising future research direction - bridging the gap between fast adaptation and slow training.this work was supported in part by the epsrc centre for doctoral training in data science, funded by the uk engineering and physical sciences research council (grant ep/l016427/1) and the university of edinburgh.algorithm 1 sampling a dataset of size k sample c ∼ p(c) for i = 1 to k do
sample zi,l ∼ p(zl|c; θ) for j = l− 1 to 1 do
sample zi,j ∼ p(zj |zi,j+1, c; θ) end for sample xi ∼ p(x|zi,1, . . . , zi,l, c; θ)
end for
algorithm 2 sampling a dataset of size k conditioned on a dataset of size m µc, σ 2 c ← q(c|x1, . . . , xm;φ) {calculate approximate posterior over c using statistic network.}
c← µc {set c to be the mean of the approximate posterior.} for i = 1 to k do
sample zi,l ∼ p(zl|c; θ) for j = l− 1 to 1 do
sample zi,j ∼ p(zj |zi,j+1, c; θ) end for sample xi ∼ p(x|zi,1, . . . , zi,l, c; θ)
end for
algorithm 3 selecting a representative sample of size k s ← {x1, . . . , xm} i ← {1, . . . ,m} si = {xi ∈ s : i ∈ i} nsi ← q(c|si ;φ) {calculate approximate posterior over c using statistic network.} for i = 1 to k do t← argminj∈idkl ( ns‖nsi−j
) i ← i − t
end for
algorithm 4 k-way few-shot classification d0, . . . , dk ← sets of labelled examples for each class x← datapoint to be classified nx ← q(c|x;φ) {approximate posterior over c given query point} for i = 1 to k do ni ← q(c|di;φ)
end for ŷ ← argminidkl (ni‖nx)b.1 omniglot
shared encoder x→ h 2× { conv2d 64 feature maps with 3× 3 kernels and elu activations } conv2d 64 feature maps with 3× 3 kernels, stride 2 and elu activations 2× {conv2d 128 feature maps with 3× 3 kernels and elu activations } conv2d 128 feature maps with 3× 3 kernels, stride 2 and elu activations 2× { conv2d 256 feature maps with 3× 3 kernels and elu activations } conv2d 256 feature maps with 3× 3 kernels, stride 2 and elu activations
statistic network q(c|d;φ) : h1, . . . , hk → µc, σ2c fully-connected layer with 256 units and elu activations sample-dropout and concatenation with number of samples average pooling within each dataset 2× {fully-connected layer with 256 units and elu activations } fully-connected linear layers to µc and log σ2c
inference network q(z|x, c;φ) : h, c→ µz, σ2z concatenate c and h 3× {fully-connected layer with 256 units and elu activations } fully-connected linear layers to µz and log σ2z
latent decoder network p(z|c; θ) : c→ µz, σ2z 3× {fully-connected layer with 256 units and elu activations } fully-connected linear layers to µz and log σ2z
observation decoder network p(x|c, z; θ) : c, z → µx concatenate z and c fully-connected linear layers with 4 · 4 · 256 units 2× { conv2d 256 feature maps with 3× 3 kernels and elu activations } deconv2d 256 feature maps with 2× 2 kernels, stride 2, elu activations 2× { conv2d 128 feature maps with 3× 3 kernels and elu activations } deconv2d 128 feature maps with 2× 2 kernels, stride 2, elu activations 2× { conv2d 64 feature maps with 3× 3 kernels and elu activations } deconv2d 64 feature maps with 2× 2 kernels, stride 2, elu activations conv2d 1 feature map with 1× 1 kernels, sigmoid activations
b.2 youtube faces
shared encoder x→ h 2× { conv2d 32 feature maps with 3× 3 kernels and elu activations } conv2d 32 feature maps with 3× 3 kernels, stride 2 and elu activations 2× {conv2d 64 feature maps with 3× 3 kernels and elu activations } conv2d 64 feature maps with 3× 3 kernels, stride 2 and elu activations 2× { conv2d 128 feature maps with 3× 3 kernels and elu activations } conv2d 128 feature maps with 3× 3 kernels, stride 2 and elu activations 2× { conv2d 256 feature maps with 3× 3 kernels and elu activations } conv2d 256 feature maps with 3× 3 kernels, stride 2 and elu activations
statistic network q(c|d,φ) : h1, . . . , hk → µc, σ2c fully-connected layer with 1000 units and elu activations average pooling within each dataset fully-connected linear layers to µc and log σ2c
inference network q(z|x, c, φ) : h, c→ µz, σ2z concatenate c and h fully-connected layer with 1000 units and elu activations fully-connected linear layers to µz and log σ2z
latent decoder network p(z|c, ; θ) : c→ µz, σ2z fully-connected layer with 1000 units and elu activations fully-connected linear layers to µz and log σ2z
observation decoder network p(x|c, z; θ) : c, z → µx concatenate z and c fully-connected layer with 1000 units and elu activations fully-connected linear layer with 8 · 8 · 256 units 2× { conv2d 256 feature maps with 3× 3 kernels and elu activations } deconv2d 256 feature maps with 2× 2 kernels, stride 2, elu activations 2× { conv2d 128 feature maps with 3× 3 kernels and elu activations } deconv2d 128 feature maps with 2× 2 kernels, stride 2, elu activations 2× { conv2d 64 feature maps with 3× 3 kernels and elu activations } deconv2d 64 feature maps with 2× 2 kernels, stride 2, elu activations 2× { conv2d 32 feature maps with 3× 3 kernels and elu activations } deconv2d 32 feature maps with 2× 2 kernels, stride 2, elu activations conv2d 3 feature maps with 1× 1 kernels, sigmoid activations",1
363.pdf.json,"many natural language processing problems involve matching two or more sequences to make a decision. for example, in textual entailment, one needs to determine whether a hypothesis sentence can be inferred from a premise sentence (bowman , 2015). in machine comprehension, given a passage, a question needs to be matched against it in order to find the correct answer (richardson , 2013; tapaswi , 2016). table 1 gives two example sequence matching problems. in the first example, a passage, a question and four candidate answers are given. we can see that to get the correct answer, we need to match the question against the passage and identify the last sentence to be the answer-bearing sentence. in the second example, given a question and a set of candidate answers, we need to find the answer that best matches the question. because of the fundamental importance of comparing two sequences of text to judge their semantic similarity or relatedness, sequence matching has been well studied in natural language processing.
with recent advances of neural network models in natural language processing, a standard practice for sequence modeling now is to encode a sequence of text as an embedding vector using models such as rnn and cnn. to match two sequences, a straightforward approach is to encode each sequence as a vector and then to combine the two vectors to make a decision (bowman , 2015; feng , 2015). however, it has been found that using a single vector to encode an entire sequence is not sufficient to capture all the important information from the sequence, and therefore advanced techniques such as attention mechanisms and memory networks have been applied to sequence matching problems (hermann , 2015; hill , 2016; rocktäschel , 2015).
a common trait of a number of these recent studies on sequence matching problems is the use of a “compare-aggregate” framework (wang & jiang, 2016b; he & lin, 2016; parikh , 2016). in such a framework, comparison of two sequences is not done by comparing two vectors each representing an entire sequence. instead, these models first compare vector representations of smaller units such as words from these sequences and then aggregate these comparison results to make the final decision. for example, the match-lstm model proposed by wang & jiang (2016b) for textual entailment first compares each word in the hypothesis with an attention-weighted version of the premise. the comparison results are then aggregated through an lstm. he & lin (2016) proposed a pairwise word interaction model that first takes each pair of words from two sequences and applies a comparison unit on the two words. it then combines the results of these word interactions using a similarity focus layer followed by a multi-layer cnn. parikh  (2016) proposed a decomposable attention model for textual entailment, in which words from each sequence are compared with an
attention-weighted version of the other sequence to produce a series of comparison vectors. the comparison vectors are then aggregated and fed into a feed forward network for final classification.
although these studies have shown the effectiveness of such a “compare-aggregate” framework for sequence matching, there are at least two limitations with these previous studies: (1) each of the models proposed in these studies is tested on one or two tasks only, but we hypothesize that this general framework is effective on many sequence matching problems. there has not been any study that empirically verifies this. (2) more importantly, these studies did not pay much attention to the comparison function that is used to compare two small textual units. usually a standard feedforward network is used (hu , 2014; wang & jiang, 2016b) to combine two vectors representing two units that need to be compared, e.g., two words. however, based on the nature of these sequence matching problems, we essentially need to measure how semantically similar the two sequences are. presumably, this property of these sequence matching problems should guide us in choosing more appropriate comparison functions. indeed he & lin (2016) used cosine similarity, euclidean distance and dot product to define the comparison function, which seem to be better justifiable. but they did not systematically evaluate these similarity or distance functions or compare them with a standard feedforward network.
in this paper, we argue that the general “compare-aggregate” framework is effective for a wide range of sequence matching problems. we present a model that follows this general framework and test it on four different datasets, namely, movieqa, insuranceqa, wikiqa and snli. the first three datasets are for question answering, but the setups of the tasks are quite different. the last dataset is for textual entailment. more importantly, we systematically present and test six different comparison functions. we find that overall a comparison function based on element-wise subtraction and multiplication works the best on the four datasets.
the contributions of this work are twofold: (1) using four different datasets, we show that our model following the “compare-aggregate” framework is very effective when compared with the state-ofthe-art performance on these datasets. (2) we conduct systematic evaluation of different comparison functions and show that a comparison function based on element-wise operations, which is not widely used for word-level matching, works the best across the different datasets. we believe that these findings will be useful for future research on sequence matching problems. we have also made our code available online.1in this section, we propose a general model following the “compare-aggregate” framework for matching two sequences. this general model can be applied to different tasks. we focus our discussion on six different comparison functions that can be plugged into this general “compare-aggregate” model. in particular, we hypothesize that two comparison functions based on element-wise operations, sub and mult, are good middle ground between highly flexible functions using standard neural network models and highly restrictive functions based on cosine similarity and/or euclidean https://github.com/shuohangwang/seqmatchseq
distance. as we will show in the experiment section, these comparison functions based on elementwise operations can indeed perform very well on a number of sequence matching problems.the general setup of the sequence matching problem we consider is the following. we assume there are two sequences to be matched. we use two matrices q ∈ rd×q and a ∈ rd×a to represent the word embeddings of the two sequences, where q and a are the lengths of the two sequences, respectively, and d is the dimensionality of the word embeddings. in other words, each column vector of q or a is an embedding vector representing a single word. given a pair of q and a, the goal is to predict a label y. for example, in textual entailment, q may represent a premise and a a hypothesis, and y indicates whether q entails a or contradicts a. in question answering, q may be a question and a a candidate answer, and y indicates whether a is the correct answer to q.
we treat the problem as a supervised learning task. we assume that a set of training examples in the form of (q,a, y) is given and we aim to learn a model that maps any pair of (q,a) to a y.
an overview of our model is shown in figure 1. the model can be divided into the following four layers: . preprocessing: we use a preprocessing layer (not shown in the figure) to process q and a to obtain two new matrices q ∈ rl×q and a ∈ rl×a. the purpose here is to use some gate values to control the importance of different words in making the predictions on the sequence pair. for example, qi ∈ rl, which is the ith column vector of q, encodes the ith word in q. . attention: we apply a standard attention mechanism on q and a to obtain attention weights over the column vectors in q for each column vector in a. with these attention weights, for each column vector aj in a, we obtain a corresponding vector hj , which is an attention-weighted sum of the column vectors of q. . comparison: we use a comparison function f to combine each pair of aj and hj into a vector tj . . aggregation: we use a cnn layer to aggregate the sequence of vectors tj for the final classification.
although this model follows more or less the same framework as the model proposed by parikh  (2016), our work has some notable differences. first, we will pay much attention to the comparison function f and compare a number of options, including some uncommon ones based on elementwise operations. second, we apply our model to four different datasets representing four different tasks to evaluate its general effectiveness for sequence matching problems. there are also some other differences from the work by parikh  (2016). for example, we use a cnn layer instead of summation and concatenation for aggregation. our attention mechanism is one-directional instead of two-directional.
in the rest of this section we will present the model in detail. we will focus mostly on the comparison functions we consider.inspired by the use of gates in lstm and gru, we preprocess q and a with the following formulas:
q = σ(wiq+ bi ⊗ eq) tanh(wuq+ bu ⊗ eq), a = σ(wia+ bi ⊗ ea) tanh(wua+ bu ⊗ ea), (1)
where is element-wise multiplication, and wi,wu ∈ rl×d and bi,bu ∈ rl are parameters to be learned. the outer product (· ⊗ ex) produces a matrix or row vector by repeating the vector or scalar on the left for x times. here σ(wiq + bi ⊗ eq) and σ(wia + bi ⊗ ea) act as gate values to control the degree to which the original values of q and a are preserved in q and a. for example, for stop words, their gate values would likely be low for tasks where stop words make little difference to the final predictions.
in this preprocessing step, the word order does not matter. although a better way would be to use rnn such as lstm and gru to chain up the words such that we can capture some contextual information, this could be computationally expensive for long sequences. in our experiments, we only incorporated lstm into the formulas above for the snli task.
the general attention (luong , 2015) layer is built on top of the resulting q and a as follows: g = softmax ( (wgq+ bg ⊗ eq)ta ) ,
h = qg, (2)
where wg ∈ rl×l and bg ∈ rl are parameters to be learned, g ∈ rq×a is the attention weight matrix, and h ∈ rl×a are the attention-weighted vectors. specifically, hj , which is the jth column vector of h, is a weighted sum of the column vectors of q and represents the part of q that best matches the jth word in a. next we will combine hj and aj using a comparison function.the goal of the comparison layer is to match each aj , which represents the jth word and its context in a, with hj , which represents a weighted version of q that best matches aj . let f denote a comparison function that transforms aj and hj into a vector tj to represent the comparison result.
a natural choice of f is a standard neural network layer that consists of a linear transformation followed by a non-linear activation function. for example, we can consider the following choice:
neuralnet (nn): tj = f(aj ,hj) = relu(w [ aj hj ] + b), (3)
where matrix w ∈ rl×2l and vector b ∈ rl are parameters to be learned. alternatively, another natural choice is a neural tensor network (socher , 2013) as follows:
neuraltensornet (ntn): tj = f(aj ,hj) = relu(atjt [1...l]hj + b), (4)
where tensor t[1...l] ∈ rl×l×l and vector b ∈ rl are parameters to be learned.
however, we note that for many sequence matching problems, we intend to measure the semantic similarity or relatedness of the two sequences. so at the word level, we also intend to check how similar or related aj is to hj . for this reason, a more natural choice used in some previous work is euclidean distance or cosine similarity between aj and hj . we therefore consider the following definition of f :
euclidean+cosine (euccos): tj = f(aj ,hj) = [ ‖aj − hj‖2 cos(aj ,hj) ] . (5)
note that with euccos, the resulting vector tj is only a 2-dimensional vector. although euccos is a well-justified comparison function, we suspect that it may lose some useful information from the original vectors aj and hj . on the other hand, nn and ntn are too general and thus do not capture the intuition that we care mostly about the similarity between aj and hj .
to use something that is a good compromise between the two extreme cases, we consider the following two new comparison functions, which operate on the two vectors in an element-wise manner. these functions have been used previously by mou  (2016).
subtraction (sub): tj = f(aj ,hj) = (aj − hj) (aj − hj), (6) multiplication (mult): tj = f(aj ,hj) = aj hj . (7)
note that the operator is element-wise multiplication. for both comparison functions, the resulting vector tj has the same dimensionality as aj and hj .
we can see that sub is closely related to euclidean distance in that euclidean distance is the sum of all the entries of the vector tj produced by sub. but by not summing up these entries, sub preserves some information about the different dimensions of the original two vectors. similarly, mult is closely related to cosine similarity but preserves some information about the original two vectors.
finally, we consider combining sub and mult followed by an nn layer as follows: submult+nn: tj = f(aj ,hj) = relu(w [ (aj − hj) (aj − hj)
aj hj
] + b). (8)
in summary, we consider six different comparison functions: nn, ntn, euccos, sub, mult and submult+nn. among these functions, the last three (sub, mult and submult+nn) have not been widely used in previous work for word-level matching.after we apply the comparison function to each pair of aj and hj to obtain a series of vectors tj , finally we aggregate these vectors using a one-layer cnn (kim, 2014):
r = cnn([t1, . . . , ta]). (9)
r ∈ rnl is then used for the final classification, where n is the number of windows in cnn.in this section, we evaluate our model on four different datasets representing different tasks. the first three datasets are question answering tasks while the last one is on textual entailment. the statistics of the four datasets are shown in table 2. we will fist introduce the task settings and the way we customize the “compare-aggregate” structure to each task. then we will show the baselines for the different datasets. finally, we discuss the experiment results shown in table 3 and the ablation study shown in table 4.in all these tasks, we use matrix q ∈ rd×q to represent the question or premise and matrix ak ∈ rd×ak (k ∈ [1,k]) to represent the kth answer or the hypothesis. for the machine comprehension task movieqa (tapaswi , 2016), there is also a matrix p ∈ rd×p that represents the plot of a movie. here q is the length of the question or premise, ak the length of the kth answer, and p the length of the plot.
for the snli (bowman , 2015) dataset, the task is text entailment, which identifies the relationship (entailment, contradiction or neutral) between a premise sentence and a hypothesis sentence. here k = 1, and there are exactly two sequences to match. the actual model structure is what we have described before.
for the insuranceqa (feng , 2015) dataset, the task is an answer selection task which needs to select the correct answer for a question from a candidate pool. for the wikiqa (yang , 2015) datasets, we need to rank the candidate answers according to a question. for both tasks,
there are k candidate answers for each question. let us use rk to represent the resulting vector produced by eqn. 9 for the kth answer. in order to select one of the k answers, we first define r = [r1, r2, . . . , rk ]. we then compute the probability of the kth answer to be the correct one as follows:
p(k|r) = softmax(wt tanh(wsr+ bs ⊗ ek) + b⊗ ek), (10) where ws ∈ rl×nl, w ∈ rl, bs ∈ rl, b ∈ r are parameters to be learned. for the machine comprehension task movieqa, each question is related to plot synopses written by fans after watching the movie and each question has five candidate answers. so for each candidate answer there are three sequences to be matched: the plot p, the question q and the answer ak. for each k, we first match q and p and refer to the matching result at position j as tqj , as generated by one of the comparison functions f . similarly, we also match ak with p and refer to the matching result at position j as tak,j . we then define
tk,j = [ tqj tak,j ] ,
and
rk = cnn([tk,1, . . . , tk,p ]).
to select an answer from the k candidate answers, again we use eqn. 10 to compute the probabilities.
the implementation details of the modes are as follows. the word embeddings are initialized from glove (pennington , 2014). during training, they are not updated. the word embeddings not found in glove are initialized with zero.
the dimensionality l of the hidden layers is set to be 150. we use adamax (kingma & ba, 2015) with the coefficients β1 = 0.9 and β2 = 0.999 to optimize the model. we do not use l2regularization. the main parameter we tuned is the dropout on the embedding layer. for wikiqa, which is a relatively small dataset, we also tune the learning rate and the batch size. for the others, we set the batch size to be 30 and the learning rate 0.002.here, we will introduce the baselines for each dataset. we did not re-implement these models but simply took the reported performance for the purpose of comparison.
snli: •w-by-w attention: the model by rocktäschel  (2015), who first introduced attention mechanism into text entailment. • match-lstm: the model by wang & jiang (2016b), which concatenates the matched words as the inputs of an lstm. • lstmn: long short-term memorynetworks proposed by cheng  (2016). • decomp attention: another “compare-aggregate” model proposed by parikh  (2016). • ebim+treelstm: the state-of-the-art model proposed by chen  (2016) on the snli dataset.
insuranceqa: • ir model: this model by bendersky  (2010) learns the concept information to help rank the candidates. • cnn with gesd: this model by feng  (2015) uses euclidean distance and dot product between sequence representations built through convolutional neural networks to select the answer. • attentive lstm: tan  (2016) used soft-attention mechanism to select the most important information from the candidates according to the representation of the questions. • iarnn-occam: this model by wang  (2016) adds regularization on the attention weights. • iarnn-gate: this model by wang  (2016) uses the representation of the question to build the gru gates for each candidate answer.
wikiqa: • iarnn-occam and iarnn-gate as introduced before. • cnn-cnt: this model by yang  (2015) combines sentence representations built by a convolutional neural network with logistic regression. • abcnn: this model is attention-based convolutional neural network proposed by yin  (2015). • cubecnn proposed by he & lin (2016) builds a cnn on all pairs of word similarity.
movieqa: all the baselines we consider come from tapaswi  (2016)’s work: • cosine word2vec: a sliding window is used to select the answer according to the similarities computed
through word2vec between the sentences in plot and the question/answer. • cosine tfidf: this model is similar to the previous method but uses bag-of-word with tf-idf scores to compute similarity. • sscb tfidf: instead of using the sliding window method, a convolutional neural network is built on the sentence level similarities.we use accuracy as the evaluation metric for the datasets movieqa, insuranceqa and snli, as there is only one correct answer or one label for each instance. for wikiqa, there may be multiple correct answers, so evaluation metrics we use are mean average precision (map) and mean reciprocal rank (mrr).
we observe the following from the results. (1) overall, we can find that our general “compareaggregate” structure achieves the best performance on movieqa, insuranceqa, wikiqa datasets and very competitive performance on the snli dataset. especially for the insuranceqa dataset, with any comparison function we use, our model can outperform all the previous models. (2) the comparison method submult+nn is the best in general. (3) some simple comparison functions can achieve better performance than the neural networks or neural tensor network comparison functions. for example, the simplest comparison function euccos achieves nearly the best performance in the movieqa dataset, and the element-wise comparison functions, which do not need parameters can achieve the best performance on the wikiqa dataset. (4) we find the preprocessing layer and the attention layer for word selection to be important in the “compare-aggregate” structure through the experiments of removing these two layers separately. we also see that for sequence matching with big difference in length, such as the movieqa and insuranceqa tasks, the attention layer plays a more important role. for sequence matching with smaller difference in length, such as the wikiqa and snli tasks, the pre-processing layer plays a more important role. (5) for the movieqa, insuranceqa and wikiqa tasks, our preprocessing layer is order-insensitive so that it will not take the context information into consideration during the comparison, but our model can still outperform the previous work with order-sensitive preprocessing layer. with this finding, we believe the word-by-word comparison part plays a very important role in these tasks. we will further explore the preprocessing layer in the future.to further explain how our model works, we visualize the max values in each dimension of the convolutional layer. we use two examples shown in table 1 from movieqa and insuranceqa datasets respectively. in the top of figure 2, we can see that the plot words that also appear in either the question or the answer will draw more attention by the cnn. we hypothesize that if the nearby words in the plot can match both the words in question and the words in one answer, then this answer is more likely to be the correct one. similarly, the bottom one of figure 2 also shows that the cnn will focus more on the matched word representations. if the words in one answer continuously match the words in the question, this answer is more likely to be the correct one.we review related work in three types of general structures for matching sequences.
siamense network: these kinds of models use the same structure, such as rnn or cnn, to build the representations for the sequences separately and then use them for classification. then cosine similarity (feng , 2015; yang , 2015), element-wise operation (tai , 2015; mou , 2016) or neural network-based combination bowman  (2015) are used for sequence matching.
attentive network: soft-attention mechanism (bahdanau , 2014; luong , 2015) has been widely used for sequence matching in machine comprehension (hermann , 2015), text entailment (rocktäschel , 2015) and question answering (tan , 2016). instead of using the final state of rnn to represent a sequence, these studies use weighted sum of all the states for the sequence representation.
compare-aggregate network: this kind of framework is to perform the word level matching (wang & jiang, 2016a; parikh , 2016; he & lin, 2016; trischler , 2016; wan , 6). our work is under this framework. but our structure is different from previous models and our model can be applied on different tasks. besides, we analyzed different word-level comparison functions separately.in this paper, we systematically analyzed the effectiveness of a “compare-aggregate” model on four different datasets representing different tasks. moreover, we compared and tested different kinds of word-level comparison functions and found that some element-wise comparison functions can outperform the others. according to our experiment results, many different tasks can share the same “compare-aggregate” structure. in the future work, we would like to test its effectiveness on multi-task learning.this research is supported by the national research foundation, prime ministers office, singapore under its international research centres in singapore funding initiative.",1
398.pdf.json,"gated recurrent neural networks, such as the long short term memory network (lstm) introduced by hochreiter & schmidhuber (1997) and the gated recurrent unit (gru) proposed by cho  (2014), prove highly effective for machine learning tasks that involve sequential data. we propose an exceptionally simple variant of these gated architectures. the basic model takes the form
ht = θt tanh(ht−1) + ηt tanh(wxt), (1)
where stands for the hadamard product. the horizontal/forget gate (i.e. θt) and the vertical/input gate (i.e. ηt) take the usual form used in most gated rnn architectures. specifically
θt := σ (uθht−1 + vθxt + bθ) and ηt := σ (uηht−1 + vηxt + bη) (2)
where σ(x) := (1 + e−x)−1 denotes the logistic sigmoid function. the network (1)–(2) has quite intuitive dynamics. suppose the data xt present the model with a sequence
(wxt)(i) = { 10 if t = t 0 otherwise,
(3)
where (wxt)(i) stands for the ith component of the vector wxt. in other words we consider an input sequence xt for which the learned ith feature (wxt)(i) remains off except at time t . when initialized from h0 = 0, the corresponding response of the network to this “impulse” in the ith feature is
ht(i) ≈  0 if t < t ηt if t = t αt if t > t
(4)
with αt a sequence that relaxes toward zero. the forget gate θt control the rate of this relaxation. thus ht(i) activates when presented with a strong ith feature, and then relaxes toward zero until the data present the network once again with strong ith feature. overall this leads to a dynamically simple model, in which the activation patterns in the hidden states of the network have a clear cause and predictable subsequent behavior.
dynamics of this sort do not occur in other rnn models. instead, the three most popular recurrent neural network architectures, namely the vanilla rnn, the lstm and the gru, have complex, irregular, and unpredictable dynamics. even in the absence of input data, these networks can give rise to chaotic dynamical systems. in other words, when presented with null input data the activation patterns in their hidden states do not necessarily follow a predictable path. the proposed network (1)–(2) has rather dull and minimalist dynamics in comparison; its only attractor is the zero state,
and so it stands at the polar-opposite end of the spectrum from chaotic systems. perhaps surprisingly, at least in the light of this comparison, the proposed network (1) performs as well as lstms and grus on the word level language modeling task. we therefore conclude that the ability of an rnn to form chaotic temporal dynamics, in the sense we describe in section 2, cannot explain its success on word-level language modeling tasks.
in the next section, we review the phenomenon of chaos in rnns via both synthetic examples and trained models. we also prove a precise, quantified description of the dynamical picture (3)–(4) for the proposed network. in particular, we show that the dynamical system induced by the proposed network is never chaotic, and for this reason we refer to it as a chaos-free network (cfn). the final section provides a series of experiments that demonstrate that cfn achieve results comparable to lstm on the word-level language modeling task. all together, these observations show that an architecture as simple as (1)–(2) can achieve performance comparable to the more dynamically complex lstm.the study of rnns from a dynamical systems point-of-view has brought fruitful insights into generic features of rnns (sussillo & barak, 2013; pascanu , 2013). we shall pursue a brief investigation of cfn, lstm and gru networks using this formalism, as it allows us to identify key distinctions between them. recall that for a given mapping φ : rd 7→ rd, a given initial time t0 ∈ n and a given initial state u0 ∈ rd, a simple repeated iteration of the mapping φ
ut+1 = φ(ut) t > t0,
ut0 = u0 t = t0,
defines a discrete-time dynamical system. the index t ∈ n represents the current time, while the point ut ∈ rd represents the current state of the system. the set of all visited states o+(u0) := {ut0 , ut0+1, . . . , ut0+n, . . .} defines the forward trajectory or forward orbit through u0. an attractor for the dynamical system is a set that is invariant (any trajectory that starts in the set remains in the set) and that attracts all trajectories that start sufficiently close to it. the attractors of chaotic dynamical systems are often fractal sets, and for this reason they are referred to as strange attractors.
most rnns generically take the functional form
ut = ψ(ut−1,w1xt,w2xt, . . . ,wkxt), (5)
where xt denotes the tth input data point. for example, in the case of the cfn (1)–(2), we have w1 = w , w2 = vθ and w3 = vη . to gain insight into the underlying design of the architecture of an rnn, it proves usefull to consider how trajectories behave when they are not influenced by any external input. this lead us to consider the dynamical system
ut = φ(ut−1) φ(u) := ψ(u, 0, 0, . . . , 0), (6)
which we refer to as the dynamical system induced by the recurrent neural network. the timeinvariant system (6) is much more tractable than (5), and it offers a mean to investigate the inner working of a given architecture; it separates the influence of input data xt, which can produce essentially any possible response, from the model itself. studying trajectories that are not influenced by external data will give us an indication on the ability of a given rnn to generate complex and sophisticated trajectories by its own. as we shall see shortly, the dynamical system induced by a cfn has excessively simple and predictable trajectories: all of them converge to the zero state. in other words, its only attractor is the zero state. this is in sharp contrast with the dynamical systems induced by lstm or gru, who can exhibit chaotic behaviors and have strange attractors.
the learned parameters wj in (5) describe how data influence the evolution of hidden states at each time step. from a modeling perspective, (6) would occur in the scenario where a trained rnn has learned a weak coupling between a specific data point xt0 and the hidden state at that time, in the sense that the data influence is small and so all wjxt0 ≈ 0 nearly vanish. the hidden state then transitions according to ut0 ≈ ψ(ut0−1, 0, 0, . . . , 0) = φ(ut0−1). we refer to bertschinger & natschläger (2004) for a study of the chaotic behavior of a simplified vanilla rnn with a specific statistical model, namely an i.i.d. bernoulli process, for the input data as well as a specific statistical model, namely i.i.d. gaussian, for the weights of the recurrence matrix.in this subsection we briefly show that lstm and gru, in the absence of input data, can lead to dynamical systems ut = φ(ut−1) that are chaotic in the classical sense of the term (strogatz, 2014). figure 1 depicts the strange attractor of the dynamical system:
ut = [ ht ct ] u 7→ φ(u) = [ o tanh (f c+ i g) f c+ i g ] (7)
i := σ(wih+ bi) f := σ(wfh+ bf ) o := σ(woh+ bo) g := tanh(wgh+ bg) (8)
induced by a two-unit lstm with weight matrices
wi = [ −1 −4 −3 −2 ] wo = [ 4 1 −9 −7 ] wf = [ −2 6 0 −6 ] wg = [ −1 −6 6 −9 ] (9)
and zero bias for the model parameters. these weights were randomly generated from a normal distribution with standard deviation 5 and then rounded to the nearest integer. figure 1(a) was obtained by choosing an initial state u0 = (h0, c0) uniformly at random in [0, 1]2 × [0, 1]2 and plotting the h-component of the iterates ut = (ht, ct) for t between 103 and 105 (so this figure should be regarded as a two dimensional projection of a four dimensional attractor, which explain its tangled appearance). most trajectories starting in [0, 1]2 × [0, 1]2 converge toward the depicted attractor. the resemblance between this attractor and classical strange attractors such as the hénon attractor is striking (see figure 5 in the appendix for a depiction of the hénon attractor). successive zooms on the branch of the lstm attractor from figure 1(a) reveal its fractal nature. figure 1(b) is an enlargement of the red box in figure 1(a), and figure 1(c) is an enlargement of the magenta box in figure 1(b). we see that the structure repeats itself as we zoom in.
the most practical consequence of chaos is that the long-term behavior of their forward orbits can exhibit a high degree of sensitivity to the initial states u0. figure 2 provides an example of such behavior for the dynamical system (7)–(9). an initial condition u0 was drawn uniformly at random in [0, 1]2 × [0, 1]2. we then computed 100, 000 small amplitude perturbations û0 of u0 by adding a small random number drawn uniformly from [−10−7, 10−7] to each component. we then iterated (7)–(9) for 200 steps and plotted the h-component of the final state û200 for each of the 100, 000 trials on figure 2(a). the collection of these 100, 000 final states essentially fills out the entire attractor, despite the fact that their initial conditions are highly localized (i.e. at distance of no more than 10−7) around a fixed point. in other words, the time t = 200 map of the dynamical system will map a small neighborhood around a fixed initial condition u0 to the entire attractor. figure 2(b) additionally illustrates this sensitivity to initial conditions for points on the attractor itself. we take an initial condition u0 on the attractor and perturb it by 10−7 to a nearby initial condition û0. we then plot the distance ‖ût − ut‖ between the two corresponding trajectories for the first 200 time steps. after an initial phase of agreement, the trajectories strongly diverge.
the synthetic example (7)–(9) illustrates the potentially chaotic nature of the lstm architecture. we now show that chaotic behavior occurs for trained models as well, and not just for synthetically generated instances. we take the parameter values of an lstm with 228 hidden units trained on the
penn treebank corpus without dropout (c.f. the experimental section for the precise procedure). we then s data inputs xt to zero and run the corresponding induced dynamical system. two trajectories starting from nearby initial conditions u0 and û0 were computed (as before û0 was obtained by adding to each components of u0 a small random number drawn uniformly from [−10−7, 10−7]). figure 3(a) plots the first component h(1) of the hidden state for both trajectories over the first 1600 time steps. after an initial phase of agreement, the forward trajectories o+(u0) and o+(û0) strongly diverge. we also see that both trajectories exhibit the typical aperiodic behavior that characterizes chaotic systems. if the inputs xt do not vanish, but come from actual word-level data, then the behavior is very different. the lstm is now no longer an autonomous system whose dynamics are driven by its hidden states, but a time dependent system whose dynamics are mostly driven by the external inputs. figure 3(b) shows the first component h(1) of the hidden states of two trajectories that start with initial conditions u0 and û0 that are far apart. the sensitivity to initial condition disappears, and instead the trajectories converge toward each other after about 70 steps. the memory of this initial difference is lost. overall these experiments indicate that a trained lstm, when it is not driven by external inputs, can be chaotic. in the presence of input data, the lstm becomes a forced system whose dynamics are dominated by external forcing.
like lstm networks, gru can also lead to dynamical systems that are chaotic and they can also have strange attractors. the depiction of such an attractor, in the case of a two-unit gru, is provided in figure 6 of the appendix.the dynamical behavior of the cfn is dramatically different from that of the lstm. in this subsection we start by showing that the hidden states of the cfn activate and relax toward zero in a predictable fashion in response to input data. on one hand, this shows that the cfn cannot produce non-trivial dynamics without some influence from data. on the other, this leads to an interpretable model; any non-trivial activations in the hidden states of a cfn have a clear cause emanating from
data-driven activation. this follows from a precise, quantified description of the intuitive picture (3)–(4) sketched in the introduction.
we begin with the following simple estimate that sheds light on how the hidden states of the cfn activate and then relax toward the origin. lemma 1. for any t, k > 0 we have
|ht+k(i)| ≤ θk |ht (i)|+ h −θ
( max
t≤t≤t+k |(wxt)(i)| ) where θ and h are the maximum values of the ith components of the θ and η gate in the time interval [t, t + k], that is:
θ = max t≤t≤t+k θt(i) and h = max t≤t≤t+k ηt(i).
this estimate shows that if during a time interval [t1, t2] one of
(i) the embedded inputs wxt have weak ith feature (i.e. maxt≤t≤t+k |(wxt)(i)| is small), (ii) or the input gates ηt have their ith component close to zero (i.e. h is small),
occurs then the ith component of the hidden state ht will relaxes toward zero at a rate that depends on the value of the ith component the the forget gate. overall this leads to the following simple picture: ht(i) activates when presented with an embedded input wxt with strong ith feature, and then relaxes toward zero until the data present the network once again with strong ith feature. the strength of the activation and the decay rate are controlled by the ith component of the input and forget gates. the proof of lemma 1 is elementary —
proof of lemma 1. using the non-expansivity of the hyperbolic tangent, i.e. | tanh(x)| ≤ |x|, and the triangle inequality, we obtain from (1)
|ht(i)| ≤ θ |ht−1(i)|+h max t≤t≤t+k |(wxt)(i)|
whenever t is in the interval [t, t + k]. iterating this inequality and summing the geometric series then gives |ht+k(i)| ≤ θk|ht (i)|+ ( 1−θk −θ
) h max
t≤t≤t+k |(wxt)(i)|
from which we easily conclude.
we now turn toward the analysis of the long-term behavior of the the dynamical system
ut = ht, u 7→ φ(u) := σ (uθu + bθ) tanh(u). (10) induced by a cfn. the following lemma shows that the only attractor of this dynamical system is the zero state. lemma 2. starting from any initial state u0, the trajectory o+(u0) will eventually converge to the zero state. that is, limt→+∞ ut = 0 regardless of the the initial state u0.
proof. from the definition of φ we clearly have that the sequence defined by ut+1 = φ(ut) satisfies −1 < ut(i) < 1 for all t and all i. since the sequence ut is bounded, so is the sequence vt := uθut + bθ. that is there exists a finite c > 0 such that (uθut)(i) + bθ(i) < c for all t and i. using the non-expansivity of the hyperbolic tangent, we then obtain that |ut(i)| ≤ σ(c)|ut−1(i)|, for all t and all i. we conclude by noting that 0 < σ(c) < 1.
lemma 2 remains true for a multi-layer cfn, that is, a cfn in which the first layer is defined by (1) and the subsequent layers 2 ≤ ` ≤ l are defined by:
h (`) t = θ (`) t tanh(h (`) t−1) + η (`) t tanh(w (`)h (`−1) t ).
assume that wxt = 0 for all t > t , then an extension of the arguments contained in the proof of the two previous lemmas shows that
|h(`)t+k| ≤ c(1 + k) (`−1)θk (11)
where 0 < θ < 1 is the maximal values for the input gates involved in layer 1 to ` of the network, and c > 0 is some constant depending only on the norms ‖w (j)‖∞ of the matrices and the sizes |h(j)t | of the initial conditions at all previous 1 ≤ j ≤ ` levels. estimate (11) shows that lemma 2 remains true for multi-layer architectures.
inequality (11) shows that higher levels (i.e. larger `) decay more slowly, and remain non-trivial, while earlier levels (i.e. smaller `) decay more quickly. we illustrate this behavior computationally with a simple experiment. we take a 2-layer, 224-unit cfn network trained on penn treebank and feed it the following input data: the first 1000 inputs xt are the first 1000 words of the test set of penn treebank; all subsequent inputs are zero. in other words, xt = 0 if t > 1000. for each of the two layers we then select the 10 units that decay the slowest after t > 1000 and plot them on figure 4. the figure illustrates that the second layer retains information for much longer than the first layer. to quantify this observation we define the relaxation time (or half-life) of the ith unit as the smallest t such that |h1000+t (i)| < 0.5|h1000(i)|. using this definition yields average relaxation times of 2.2 time steps for the first layer and 23.2 time steps for the second layer. the first layer has a standard deviations of approximately 5 steps while the second layer has a standard deviation of approximately 75 time steps. a more fine-grained analysis reveals that some units in the second layer have relaxation times of several hundred steps. for instance, if instead of averaging the relaxation times over the whole layer we average them over the top quartile (i.e. the 25% units that decay the most slowly) we get 4.8 time steps and 85.6 time steps for the first and second layers, respectively. in other words, by restricting attention to long-term units the difference between the first and second layers becomes much more striking.
overall, this experiment conforms with the analysis (11), and indicates that adding a third or fourth layer would potentially allow a multi-layer cfn architecture to retain information for even longer.in this section we show that despite its simplicity, the cfn network achieves performance comparable to the much more complex lstm network on the word level language modeling task. we use two datasets for these experiments, namely the penn treebank corpus (marcus , 1993) and the text8 corpus (mikolov , 2014). we consider both one-layer and two-layer cfns and lstms for our experiments. we train both cfn and lstm networks in a similar fashion and always compare models that use the same number of parameters. we compare their performance with and without dropout, and show that in both cases they obtain similar results. we also provide results published in mikolov  (2014), jozefowicz  (2015) and sukhbaatar  (2015) for the sake of comparison.
for concreteness, the exact implementation for the two-layer architecture of our model is
h (0) t = w (0)xt
ĥ (0) t = drop(h (0) t , p)
h (1) t = θ (1) t tanh(h (1) t−1) + η (1) t tanh(w (1)ĥ (0) t )
ĥ (1) t = drop(h (1) t , p)
h (2) t = θ (2) t tanh(h (2) t−1) + η (2) t tanh(w (2)ĥ (1) t )
ĥ (2) t = drop(h (2) t , p)
yt = logsoftmax(w (3)ĥ (2) t + b)
where drop(z, p) denotes the dropout operator with a probability p of setting components in z to zero. we compute the gates according to
θ (`) t := σ
( u
(`) θ h̃ (`) t−1 + v (`) θ h̃ (`−1) t + bθ ) and η(`)t := σ ( u (`)η h̃ (`) t−1 + v (`) η h̃ (`−1) t + bη ) where h̃(`)t−1 = drop(h (`) t−1, q) and h̃ (`−1) t = drop(h (`−1) t , q),
and thus the model has two dropout hyperparameters. the parameter p controls the amount of dropout between layers; the parameter q controls the amount of dropout inside each gate. we use a similar dropout strategy for the lstm, in that all sigmoid gates f, o and i receive the same amount q of dropout.
to train the cfn and lstm networks, we use a simple online steepest descent algorithm. we update the weights w via w(k+1) = w(k) − lr · ~p where ~p = ∇wl‖∇wl‖2 , (12) where lr is the learning rate and ∇wl denotes the approximate gradient of the loss with respect to the weights as estimated from a certain number of presented examples. we use the usual backpropagation through time approximation when estimating the gradient: we unroll the net t steps in the past and neglect longer dependencies. in all experiments, the cfn and lstm networks are unrolled for t = 35 steps and we take minibatches of size 20. as all search directions ~p have euclidean norm ‖~p‖2 = 1, we perform no gradient clipping during training. we initialize all the weights in the cfn, except for the bias of the gates, uniformly at random in [−0.07, 0.07]. we initialize the bias bθ and bη of the gates to 1 and −1, respectively, so that at the beginning of the training θt ≈ σ(1) ≈ 0.73 and ηt ≈ σ(−1) ≈ 0.23. we initialize the weights of the lstm in exactly the same way; the bias for the forget and input gate are initialized to 1 and −1, and all the other weights are initialized uniformly in [−0.07, 0.07]. this initialization scheme favors
the flow of information in the horizontal direction. the importance of a careful initialization of the forget gate was pointed out in gers  (2000) and jozefowicz  (2015). finally, we initialize all hidden states to zero for both models.
dataset construction. the penn treebank corpus has 1 million words and a vocabulary size of 10,000. we used the code from zaremba  (2014) to construct and split the dataset into a training set (929k words), a validation set (73k words) and a test set (82k words). the text8 corpus has 100 million characters and a vocabulary size of 44,000. we used the script from mikolov  (2014) to construct and split the dataset into a training set (first 99m characters) and a development set (last 1m characters).
experiments without dropout. tables 1 and 2 provide a comparison of various recurrent network architectures without dropout evaluated on the penn treebank corpus and the text8 corpus. the last two rows of each table provide results for lstm and cfn networks trained and initialized in the manner described above. we have tried both one and two layer architectures, and reported only the best result. the learning rate schedules used for each network are described in the appendix.
we also report results published in jozefowicz  (2015) were a vanilla rnn, a gru and an lstm network were trained on penn treebank, each of them having 5 million parameters (only the test perplexity was reported). finally we report results published in mikolov  (2014) and sukhbaatar  (2015) where various networks are trained on text8. of these four networks, only the lstm network from mikolov  (2014) has the same number of parameters than the cfn and lstm networks we trained (46.4m parameters). the vanilla rnn, structurally constrained recurrent network (scrn) and end-to-end memory network (memn2n) all have 500 units, but less than 46.4m parameters. we nonetheless indicate their performance in table 2 to provide some context.
experiments with dropout. table 3 provides a comparison of various recurrent network architectures with dropout evaluated on the penn treebank corpus. the first three rows report results published in (jozefowicz , 2015) and the last four rows provide results for lstm and cfn networks trained and initialized with the strategy previously described. the dropout rate p and q are chosen as follows: for the experiments with 20m parameters, we set p = 55% and q = 45% for the cfn and p = 60% and q = 40% for the lstm; for the experiments with 50m parameters, we set p = 65% and q = 55% for the cfn and p = 70% and q = 50% for the lstm.despite its simple dynamics, the cfn obtains results that compare well against lstm networks and grus on word-level language modeling. this indicates that it might be possible, in general, to build rnns that perform well while avoiding the intricate, uninterpretable and potentially chaotic dynamics that can occur in lstms and grus. of course, it remains to be seen if dynamically simple rnns such as the proposed cfn can perform well on a wide variety of tasks, potentially requiring longer term dependencies than the one needed for word level language modeling. the experiments presented in section 2 indicate a plausible path forward — activations in the higher layers of a multi-layer cfn decay at a slower rate than the activations in the lower layers. in theory, complexity and long-term dependencies can therefore be captured using a more “feed-forward” approach (i.e. stacking layers) rather than relying on the intricate and hard to interpret dynamics of an lstm or a gru.
overall, the cfn is a simple model and it therefore has the potential of being mathematically wellunderstood. in particular, section 2 reveals that the dynamics of its hidden states are inherently more interpretable than those of an lstm. the mathematical analysis here provides a few key insights into the network, in both the presence and absence of input data, but obviously more work is needed before a complete picture can emerge. we hope that this investigation opens up new avenues of inquiry, and that such an understanding will drive subsequent improvements.",1
400.pdf.json,"recurrent neural networks have become extremely popular for modeling structured data. key to their success is their ability to learn long-range temporal dependencies, their flexibility, and ease of customization. these architectures are naturally suited for modeling sequences since the underlying state evolution resulting from successive operations follows an inherently linear order (williams & zipser, 1995; hochreiter & schmidhuber, 1997). indeed, they have been successfully adapted to language modeling (zaremba , 2015), machine translation (sutskever , 2014) and conversational agents (vinyals & le, 2015), among other applications.
although sequences arise frequently in practice, other structures such as trees or graphs do not naturally conform to a linear ordering. for example, natural language sentences or associated parse trees, programs, hierarchical structures in biology, or molecules are not inherently linear structures. while sentences in natural language can be modeled as if they were linear sequences, the underlying process is compositional (frege, 1892). models that construct sentences compositionally should derive an advantage from adopting a more appropriate inductive bias.
the flexibility and success of recurrent neural networks in modeling and generating sequential data has prompted efforts to adapt them to non-sequential data too. recent work has focused on the application of neural architectures to hierarchical structures, albeit in limited ways. much of this work has assumed that either the full tree structure is given (socher , 2012; tai , 2015) or at least the nodes are (socher & lin, 2011; chen & manning, 2014; kiperwasser & goldberg, 2016). in the former scenario, the network aggregates the node information in a manner that is coherent with a given tree structure while, in the latter, generation is reduced to an attachment problem, i.e., sequentially deciding which pairs of nodes to join with an edge until a tree is formed.
the full problem of decoding with structure, i.e., generating a tree-structured object with node labels from a given vector representation, has remained largely unexplored until recently. recent efforts to adapt rnns to this context have so far remained relatively close to their sequential counterparts. for example, in order to capture depth and branching in the tree, one can introduce special tokens (dong & lapata, 2016) or use alternating rnns coupled with external classifiers to predict branching (zhang , 2016).
in this work, we propose a novel architecture tailored specifically to tree-structured decoding. at the heart of our approach is a doubly-recurrent (breadth and depth-wise recurrent) neural network which separately models the flow of information between parent and children nodes, and between siblings. each of these relationships is modeled with a recurrent module whose hidden states are updated upon observing node labels. every node in the tree receives two hidden states, which are then combined and used to predict a label for that node. besides maintaining separate but simultaneous fraternal and paternal recurrences, the proposed architecture departs from previous methods in that it explicitly models tree topology. each node in the network has modules that predict, based on the cell state, whether the node is terminal, both in terms of depth and width. decoupling these decisions from the label prediction allows for a more concise formulation, which does not require artificial tokens to be added to the tree to simulate branching.
we test this novel architecture in various encoder-decoder frameworks, coupling it with sequential encoders to predict tree structure from encoded vector representations of sequences. the experimental results show the effectiveness of this approach at recovering latent structure in flattened string representations of trees (section 4.1) and at mapping from natural language descriptions of simple programs to abstract syntax trees (section 4.2). in addition, we show that even for sequence-tosequence tasks such as machine translation, the proposed architecture exhibits desirable properties, such as invariance to structural changes and coarse-to-fine generation (section 4.3).
to summarize, the main contributions of this paper are as follows:
• we propose a novel neural network architecture specifically tailored to tree-structured decoding, which maintains separate depth and width recurrent states and combines them to obtain hidden states for every node in the tree.
• we equip this novel architecture with a mechanism to predict tree topology explicitly (as opposed to implicitly by adding nodes with special tokens).
• we show experimentally that the proposed method is capable of recovering trees from encoded representations and that it outperforms state-of-the-art methods in a task consisting of mapping sentences to simple functional programs.recursive neural networks. recursive neural networks (socher & lin, 2011; socher , 2012) were proposed to model data with hierarchical structures, such as parsed scenes and natural language sentences. though they have been most successfully applied to encoding objects when their treestructured representation is given (socher , 2013), the original formulation by socher & lin (2011) also considered using them to predict the structure (edges), albeit for the case where nodes are given. thus, besides their limited applicability due to their assumption of binary trees, recursive neural networks are not useful for fully generating trees from scratch.
tree-structured encoders. the tree-lstm of tai  (2015) is a generalization of long shortterm memory networks (hochreiter & schmidhuber, 1997) to tree-structured inputs. their model constructs a sentence representation bottom-up, obtaining at every step the representation of a node in the tree from those of its children. in this sense, this model can be seen as a generalization of recursive neural networks to trees with degree potentially greater than two, with the additional longrange dependency modeling provided by lstms. they propose two methods for aggregating the states of the children, depending on the type of underlying tree: n-ary trees or trees with unknown and potentially unbounded branching factor. treelstms have shown promising results for compositional encoding of structured data, though by construction they cannot be used for decoding, since they operate on a given tree structure.
tree-structured decoders. proposed only very recently, most tree-structured decoders rely on stacked on intertwined rnns, and use heuristic methods for topological decisions during generation. closest to our method is the top-down tree lstm of zhang  (2016), which generates a tree from an encoded representation. their method relies on 4 independent lstms, which act in alternation—as opposed to simultaneously in our approach—yielding essentially a standard lstm that changes the weights it uses based on the position of the current node. in addition, their method
provides children with asymmetric parent input: “younger” children receive information from the parent state only through the previous sibling’s state. though most of their experiments focus on the case where the nodes are given, they mention how to use their method for full prediction by introducing additional binary classifiers which predict which of the four lstms is to be used. these classifiers are trained in isolation after the main architecture has been trained. contrary to this approach, our method can be trained end-to-end in only one pass, has a simpler formulation and explicitly incorporates topological prediction as part of the functioning of each neuron.
a similar approach is proposed by dong & lapata (2016). they propose seq2tree, an encoderdecoder architecture that maps sentences to tree structures. for the decoder, they rely on hierarchical use of an lstm, similar to tai  (2015), but in the opposite direction: working top-down from the root of the tree. to decide when to change levels in the hierarchy, they augment the training trees with nonterminal nodes labeled with a special token <n>, which when generated during decoding trigger the branching out into a lower level in the tree. similar to our method, they feed nodes with hidden representations of their parent and sibling, but they do so by concatenating both states and running them through a single recurrent unit, as opposed to our method, where these two sources of information are handled separately. a further difference is that our approach does not require artificial nodes with special tokens to be added to the tree, resulting in smaller trees.
hierarchical neural networks for parsing. neural networks have also been recently introduced to the problem of natural language parsing (chen & manning, 2014; kiperwasser & goldberg, 2016). in this problem, the task is to predict a parse tree over a given sentence. for this, kiperwasser & goldberg (2016) use recurrent neural networks as a building block, and compose them recursively to obtain a tree-structured encoder. starting from the leaves (words) they predict a parse tree with a projective bottom-up strategy, which sequentially updates the encoded vector representation of the tree and uses it to guide edge-attaching decisions. though conceptually similar to our approach, their method relies on having access to the nodes of the tree (words) and only predicts its topology, so—similar to recursive neural networks—it cannot be used for a fully generative decoding.generating a tree-structured object from scratch using only an encoded representation poses several design challenges. first, one must decide in which order to generate the tree. if the nodes on the decoder side were given (such as in parsing), it would be possible to generate a tree bottom-up from these nodes (e.g. as kiperwasser & goldberg 2016 do). in the setting we are interested in, however, not even the nodes are known when decoding, so the natural choice is a top-down decoder, which starting from an encoded representation generates the root of the tree and then recursively generates the children (if any) of every node.
the second challenge arises from the asymmetric hierarchical nature of trees. unlike the sequenceto-sequence setting where encoding and decoding can be achieved with analogous procedures, when dealing with tree-structured data these two involve significantly different operations. for example, an encoder that processes a tree bottom-up using information of a node’s children to obtain its representation cannot be simply reversed and used as a decoder, since when generating the tree top-down, nodes have to be generated before their children are.
an additional design constraint comes from deciding what information to feed to each node. for sequences, the choice is obvious: a node should receive information from the node preceding or succeeding it (or both), i.e. there is a one-dimensional flow of information. in trees, there is an evident flow of information from parent to children (or vice-versa), but when generating nodes in a top-down order it seems unnatural to generate children in isolation: the label of one of them will likely influence what the states of the other children might be. for example, in the case of parse trees, generating a verb will reduce the chances of other verbs occurring in that branch.
with these considerations in mind, we propose an architecture tailored to tree decoding from scratch: top-down, recursive and doubly-recurrent, i.e. where both the ancestral (parent-to-children) and fraternal (sibling-to-sibling) flows of information are modeled with recurrent modules. thus, the building block of a doubly recurrent neural network (drnn) is a cell with two types of input states, one coming from its parent, updated and passed on to its descendants, and another one received from
its previous sibling,1 updated and passed on to the next one. we model the flow of information in the two directions with separate recurrent modules.
formally, let t = {v, e ,x} be a connected labeled tree, where v is the set of nodes, e the set of edges and x are node labels.2 let ga and gf be functions which apply one step of the two separate rnns. for a node i ∈ v with parent p(i) and previous sibling s(i), the ancestral and fraternal hidden states are updated via
hai = g a(hap(i),xp(i)) (1)
hfi = g f (hfs(i),xs(i)) (2)
where xs(j),xp(i) are the vectors representing the previous sibling’s and parent’s values, respectively. once the hidden depth and width states have been updated with these observed labels, they are combined to obtain a predictive hidden state:
h (pred) i = tanh ( ufhfi +u ahai ) (3)
where uf ∈ rn×df and ua ∈ rn×da are learnable parameters. this state contains combined information of the node’s neighborhood in the tree, and is used to predict a label for it. in its simplest form, the network could compute the output of node i by sampling from distribution
oi = softmax(wh (pred) i ) (4)
in the next section, we propose a slight modification to (4) whereby topological information is included in the computation of cell outputs. after the node’s output symbol xi has been obtained by sampling from oi, the cell passes hai to all its children and h f i to the next sibling (if any), enabling them to apply eqs (1) and (2) to realize their states. this procedure continues recursively, until termination conditions (explained in the next section) cause it to halt.as mentioned before, the central issue with free-form tree construction is to predict the topology of the tree. when constructing the tree top-down, for each node we need to decide: (i) whether it is a leaf node (and thus it should not produce offspring) and (ii) whether there should be additional siblings produced after it. answering these two questions for every node allows us to construct a tree from scratch and eventual stop growing it.
sequence decoders typically rely on special tokens to terminate generation (sutskever , 2014). the token is added to the vocabulary and treated as a regular word. during training, the examples are padded with this token at the end of the sequence, and during testing, generation of this token signals termination. these ideas has been adopted by most tree decoders (dong & lapata, 2016). there are two important downsides of using a padding strategy for topology prediction in trees. first, the size of the tree can grow considerably. while in the sequence framework only one stopping token is needed, a tree with n nodes might need up to o(n) padding nodes to be added. this can have important effects in training speed. the second reason is that a single stopping token selected competitively with other tokens requires one to continually update the associated parameters in response to any changes in the distribution over ordinary tokens so as to maintain topological control.
based on these observations, we propose an alternative approach to stopping, in which topological decisions are made explicitly (as opposed to implicitly, with stopping tokens). for this, we use the predictive hidden state of the node h(pred) with a projection and sigmoid activation:
pai = σ(u a · h(pred)i ) (5)
the value pai ∈ [0, 1] is interpreted as the probability that node i has children. analogously, we can obtain a probability of stopping fraternal branch growth after the current node as follows:
pfi = σ(u f · h(pred)i ) (6) unlike the “ancestral” line, the order within sibling nodes is ambiguous. while in abstract trees it is assumed that the there is no such ordering, we assume that for the structures were are interested in learning there is always one: either chronological (the temporal order in which the nodes were generated) or latent (e.g. the grammatical order of the words in a parse tree with respect to their sentence representation). we assume throughout that these values are given as class indicators xi ∈ {1, . . . , n}.
note that these stopping strategies depart from the usual padding methods in a fundamental property: the decision to stop is made before instead of in conjunction with the label prediction. the rationale behind this is that the label of a node will likely be influenced not only by its context, but also by the type of node (terminal or non-terminal) where it is to be assigned. this is the case in language, for example, where syntactic constraints restrict the type of words that can be found in terminal nodes. for this purpose, we include the topological information as inputs to the label prediction layer. thus, (4) takes the form
oi = softmax(wh (pred) i + αiv a + ϕiv f ) (7)
where αi, ϕi ∈ {0, 1} are binary variables indicating the topological decisions and va,vf are learnable offset parameters. during training, we use gold-truth values in (7), i.e. αi = 1 if node i has children and ϕi = 1 if it has a succeeding sibling. during testing, these values are obtained from pa, pf by sampling or beam-search. a schematic representation of the internal structure of a drnn cell and the flow of information in a tree are shown in figure 1.we train drnns with (reverse) back-propagation through structure (bpts) (goller & kuechler, 1996). in the forward pass, node outputs are computed in a top-down fashion on the structureunrolled version of the network, following the natural3 dependencies of the tree. we obtain error signal at the node level from the two types of prediction: label and topology. for the former, we compute cross-entropy loss of oi with respect to the true label of the node xi. for the topological values pai and p f i we compute binary cross entropy loss with respect to gold topological indicators αi, ϕi ∈ {0, 1}. in the backward pass, we proceed in the reverse (bottom-up) direction, feeding into every node the gradients received from child and sibling nodes and computing internally gradients with respect to both topology and label prediction. further details on the backpropagation flow are provided in the appendix.
note that the way bpts is computed implies and underlying decoupled loss function l(x̂) = ∑ i∈v llabel(xi, x̂i) + ltopo(pi, p̂i) (8)
the decoupled nature of this loss allows us to weigh these two objectives differently, to emphasize either topology or label prediction accuracy. investigating the effect of this is left for future work. the traversal is always breadth-first starting from the root, but the order in which sibling nodes are visited might depend on the specific problem. if the nodes of the tree have an underlying order (such as in dependency parse trees), it is usually desirable to preserve this order.
as is common with sequence generation, during training we perform teacher forcing: after predicting the label of a node and its corresponding loss, we replace it with its gold value, so that children and siblings receive the correct label for that node. analogously, we obtain the probabilities pa and pf , compute their loss, and replace them for ground truth variables αi, ϕi for all downstream computations. addressing this exposure bias by mixing ground truth labels with model predictions during training (venkatraman , 2015) or by incremental hybrid losses (ranzato , 2016) is left as an avenue for future work.in our first set of experiments we evaluate the effectiveness of the proposed architecture to recover trees from flattened string representations. for this, we first generate a toy dataset consisting of simple labeled trees. to isolate the effect of label content from topological prediction, we take a small vocabulary consisting of the 26 letters of the english alphabet. we generate trees in a top-down fashion, conditioning the label and topology of every node on the state of its ancestors and siblings. for simplicity, we use a markovian assumption on these dependencies, modeling the probability of a node’s label as depending only on the label of its parent and the last sibling generated before it (if any). conditioned on these two inputs, we model the label of the node as coming from a multinomial distribution over the alphabet with a dirichlet prior. to generate the topology of the tree, we model the probability of a node having children and a next-sibling as depending only on its label and the depth of the tree. for each tree we generate a string representation by traversing it in breadth-first preorder, starting from the root. the labels of the nodes are concatenated into a string in the order in which they were visited, resulting in a string of |t | symbols. we create a dataset of 5,000 trees with this procedure, and split it randomly into train, validation and test sets (with a 80%,10%,10% split). further details on the construction of this dataset are provided in the appendix.
the task consists of learning a mapping from strings to trees, and using this learned mapping to recover the tree structure of the test set examples, given only their flattened representation. to do so, we use an encoder-decoder framework, where the strings are mapped to a fixed-size vector representation using a recurrent neural network. for the decoder, we use a drnn with lstm modules, which given the encoded representation generates a tree. we choose hyper-parameters with cross-validation. full training details are provided in the appendix.
measuring performance only in terms of exact recovery would likely yield near-zero accuracies for most trees. instead, we opt for a finer-grained metric of tree similarity that gives partial credit for correctly predicted subtrees. treating tree generation as a retrieval problem, we evaluate the quality of the predicted tree in terms of the precision and recall of recovering nodes and edges present in the gold tree. thus, we penalize both missing and superfluous components. as baseline, we induce a probabilistic context-free grammar (pcfg) on the full training data and use it to parse the test sentences. note that unlike the drnn, this parser has direct access to the sentence representation and thus its task is only to infer the tree structure on top of it, so this is indeed a strong baseline.
figure 3 shows the results on the test set. training on the full data yields node and edge retrieval f1-scores of 75% and 71%, respectively, the latter considerably above the baseline.4 this 4% gap can be explained by correct nodes being generated in the wrong part of the tree, as in the example in since the pcfg parser has access to the nodes by construction, node accuracy for the baseline method is irrelevant and thus omitted from the analysis.
figure 2. the second plot in figure 3 shows that although small trees are recovered more accurately, precision decays slowly with tree size, with depth accounting for the largest effect (figure 4).tree structures arise naturally in the context of programs. a typical compiler takes human-readable source code (expressed as sequences of characters) and transforms it into an executable abstract syntax tree (ast). source code, however, is already semi-structured. mapping natural language sentences directly into executable programs is an open problem, which has received considerable interest in the natural language processing community (kate , 2005; branavan , 2009).
the ifttt dataset (quirk , 2015) is a simple testbed for language-to-program mapping. it consists of if-this-then-that programs (called recipes) crawled from the ifttt website5, paired with natural language descriptions of their purpose. the recipes consist of a trigger and an action, each defined in terms of a channel (e.g. “facebook”), a function (e.g. “post a status update”) and potentially arguments and parameters. an example of a recipe and its description are shown in figure 5. the data is user-generated and extremely noisy, which makes the task significantly challenging. www.ifttt.com
we approach this task using an encoder-decoder framework. we use a standard rnn encoder, either an lstm or a gru (cho , 2014), to map the sentence to a vector representation, and we use a drnn decoder to generate the ast representation of the recipe. we use the original data split, which consists of 77,495 training, 5,171 development and 4,294 test examples. for evaluation, we use the same metrics as quirk  (2015), who note that computing exact accuracy on such a noisy dataset is problematic, and instead propose to evaluate the generated ast in terms of f1-score on the set of recovered productions. in addition, they compute accuracy at the channel level (i.e. when both channels are predicted correctly) and at the function level (both channels and both functions predicted correctly).
we compare our methods against the various extraction and phrased-based machine translation baselines of quirk  (2015) and the the methods of dong & lapata (2016): seq2seq, a sequenceto-sequence model trained on flattened representations of the ast, and seq2tree, a token-driven hierarchical rnn. following these two works, we report results on two noise-filtered subsets of the data: one with all non-english and unintelligible recipes removed and the other one with recipes for which at least three humans agreed with the gold ast. the results are shown in table 1. in both subsets, drnns perform on par or above previous approaches, with lstm-drnn achieving significantly better results. the improvement is particularly evident in terms of f1-score, which is the only metric used by previous approaches that measures global tree reconstruction accuracy. to better understand the quality of the predicted trees beyond the function level (i.e. (b) in figure 5), we computed node accuracy on the arguments level. our best performing model, lstm-drnn, achieves a macro f1 score of 51% (0.71 precision, 0.40 recall) over argument nodes, which shows that the model is reasonably successful at predicting structure even beyond depth three. the best performing alternative model, seq2tree, achieves a corresponding f1 score of 46%.in our last set of experiments, we offer a qualitative evaluation drnns in the context of machine translation. obtaining state-of-the-art results in machine translation requires highly-optimized architectures and large parallel corpora. this is not our goal. instead, we investigate whether decoding with structure can bring benefits to a task traditionally approached as a sequence-to-sequence problem. for this reason, we consider a setting with limited data: a subset of the wmt14 dataset consisting of about 50k english↔ french sentence pairs (see the appendix for details) along with dependency parses of the target (english) side.
we train a sequence-to-tree model using an lstm encoder and a drnn decoder as in the previous experiments. a slight modification here is that we distinguish left and right children in the tree, using two symmetric width-modules gfl, g f r that produce children from the parent outwards. with this, children are lexically ordered, and therefore trees can be easily and un-ambiguously projected back into sentences. we compare our model against a sequence-to-sequence architecture of similar complexity (in terms of number of parameters) trained on the same data using the optimized opennmt library (klein , 2017). for decoding, we use a simple best-of-k sampling scheme for our model, and beam search for the seq2seq models.
source “ produit différentes réponses qui changent avec le temps selon nos expériences et nos relations ”
“je ne sais jamais quoi dire dans ces cas là”
seq2seq: l = 1 a i l = 4 with the different actions i do l = 8 with the different actions who change with i do not know what to say
drnn: d = 1 answers know d = 2 different answers change but i do not know d = 3 product the different answers change . but i do not know to say
table 2: translations at different resolutions (size constraints imposed during decoding) for two example sentences.
first, we analyze the quality of translations as a function of the maximum allowed target sentence “size”. the notion of size for a sequence decoder is simply the length while for drnn we use depth instead so as to tap into the inherent granularity at which sentences can be generated from this architecture. two such examples are shown in table 2. since drnn topology has been trained to mimic dependency parses top-down, the decoder tends to first generate the fundamental aspects of the sentence (verb, nouns), leaving less important refinements for deeper structures down in the tree. the sequence decoder, in contrast, is trained for left-to-right sequential generation, and thus produces less informative translations under max-length restrictions.
in our second experiment we investigate the decoders’ ability to entertain natural paraphrases of sentences. if we keep the semantic content of a sentence fixed and only change its grammatical structure, it is desirable that the decoder would assign nearly the same likelihood to the new sentence. one way to assess this invariance is to compare the relative likelihood that the model assigns to the gold sentence in comparison to its paraphrase. to test this, we take 50 examples from the wmt test split and manually generate paraphrases with various types of structural alterations (see details in the appendix). for each type of decoder, we measure the relative change (in absolute value) of the log-likelihood resulting from the perturbation. all the models we compare have similar standard deviation (40 ± 20) of log-likelihood scores over these examples, so the relative changes in the log-likelihood remain directly comparable. for each architecture we train two versions of different sizes, where the sizes are balanced in terms of the number of parameters across the architectures. the results in figure 6 show that drnn’s exhibit significantly lower log-likelihood change, suggesting that, as language models, they are more robust to natural structural variation than their seq2seq counterparts.we have presented doubly recurrent neural networks, a natural extension of (sequential) recurrent architectures to tree-structured objects. this architecture models the information flow in a tree with two separate recurrent modules: one carrying ancestral information (received from parent and passed on to offspring) and the other carrying fraternal information (passed from sibling to sibling). the topology of the tree is modeled explicitly and separately from the label prediction, with modules that given the state of a node predict whether it has children and siblings.
the experimental results show that the proposed method is able to predict reasonable tree structures from encoded vector representations. despite the simple structure of the ifttt trees, the results on that task suggest a promising direction of using drnns for generating programs or executable queries from natural language. on the other hand, the results on the toy machine translation task show that even when used to generate sequences, drnn’s exhibit desirable properties, such as invariance over structural modifications and the ability to perform coarse-to-fine decoding. in order to truly use this architecture for machine translation, the approach must be scaled by resorting to batch processing in gpu. this is possible since forward and backward propagation are computed sequentially along tree traversal paths so that inputs and hidden states of parents and siblings can be grouped into tensors and operated in batch. we leave this as an avenue for future work.da-m acknowledges support from a conacyt fellowship. the authors would like to thank the anonymous reviewers for their constructive comments.b.1 backpropagation with drnn’s
during training, we do the forward pass over the trees in breadth-first preorder, feeding into every node an ancestral and a fraternal state. for computational efficiency, before passing on the ancestral state to the offspring, we update it through the rnn using the current node’s label, so as to avoid repeating this step for every child node. after the forward pass is complete, we compute label (cross-entropy) and topological (binary cross-entropy) loss for every node. in the backward pass, we compute in this order: . gradient of the current node’s label prediction loss with respect to softmax layer parameters w,va,vf : ∇θl(xi, x̂i). . gradients of topological prediction variable loss with respect to sigmoid layer parameters: ∇θl(pai , tai ) and ∇θl(pfi , tfi ). . gradient of predictive state layer parameters with respect to h(pred). 4. gradient of predicted ancestral and fraternal hidden states with respect to gf and ga’s parameters.
the gradients of the input ancestral and fraternal hidden states are then passed on to the previous sibling and parent. when nodes have more than one child, we combine gradients from multiple children by averaging them. this procedure is repeated until the root note is reached, after which a single (ancestral state) gradient is passed to the encoder.
b.2 model specification and training parameters
the best parameters for all tasks are chosen by performance on the validation sets. we perform early stopping based on the validation loss. for the ifttt task, we initialize word embeddings with pretrained glove vectors (pennington , 2014). for both tasks we clip gradients when the absolute value of any element exceeds 5. we regularize with a small penalty ρ on the l2 norm of the parameters. we train all methods with adam (kingma & ba, 2014), with initial learning rate chosen by cross-validation. the parameter configurations that yielded the best results and were used for the final models are shown in table 3. details about the four models used for the machine translation task are shown in table 4.c.1 synthetic tree dataset generation
we generate trees in a top-down fashion, conditioning the label and topology of every node on the state of its ancestors and siblings. for simplicity, we use a markovian assumption on these dependencies, modeling the probability of a node’s label as depending only on the label of its parent p(i) and the last sibling s(i) generated before it (if any). conditioned on these two inputs, we model the label of the node as coming from a multinomial distribution over the alphabet:
p (wi | t ) = p (w | wp(i), ws(i)) ∼ multi(θwp(i),ws(i)) (9) where θwp(i),ws(i) are class probabilities drawn from a dirichlet prior with parameter αv . on the other hand, we denote by bai the binary variable indicating whether node i has descendants, and by bfi that indicating whether it has an ensuing sibling. we model these variables as depending only on the label of the current node and its position in the tree:
p (bai | t ) = p (bai | wi, di) = bernoulli(pawi · ga(di)) p (bfi | t ) = p (bfi | wi,wi) = bernoulli(pfwi · gf (wi))
wheredi is the depth of node i andwi its width, defined as its position among the children of its parent p(i). intuitively, we want to make p (bai = 1 | t ) decrease as we go deeper and further along the branches of the tree, so as to control its growth. thus, we model ga and gf as decreasing functions with geometric decay, namely ga(d) = (γa)d and gf (w ) = (γf )w , with γa, γf ∈ (0, 1). for the label-conditioned branching probabilities p (bai | wi) and p (bfi | wi), we use bernoulli distributions with probabilities drawn from beta priors with parameters (αa, βa) and (αf , βf ), respectively.
in summary, we use the following generative procedure to grow the trees: . for each wi ∈ v , draw pawi ∼ beta(αa, βa) and pfwi ∼ beta(αf , βf ) 2. for each pair (wi, wj) draw θwi,wj ∼ dir(αv ) 3. while there is an unlabeled non-terminal node i do:
• sample a label for i from w∗ ∼ p (w|wp(i), ws(i)) = multi(θwp(i),ws(i)). • draw ba ∼ p (ba|w∗, d) = bernoulli(γda · paw(i)), where d is the current depth. if ba = 1, generate an node k, set p(k) = i, and add it to the queue.
• draw ba ∼ p (bf |w∗, d) = bernoulli(γwf · pfw(i)), where w is the current width. if bf = 1, generate an node k, set s(k) = i, and add it to the queue.
note that this generative process does create a dependence between the topology and content of the trees (since the variables ba and bf depend on the content of the tree via their dependence on the label of their corresponding node). however, the actual process by which labels and topological decision is generated relies on separate mechanisms. this is natural assumption which is reasonable to expect in practice.
the choice of prior parameters is done drawing inspiration from natural language parse trees. we want nodes to have low but diverse probabilities of generating children, so we seek a slow-decaying distribution with most mass allocated in values close to 0. for this, we use (αa, βa) = (0.25, 1). for sibling generation, we use (αf , βf ) = (7, 2), which yields a distribution concentrated in values close to 1, so that nodes have on average a high and similar probability of producing siblings. since we seek trees that are wider than they are deep, we use decay parameters γa = 0.6, γf = 0.9. finally, we use a αv = 10 · 1 for the parent-sibling probability prior, favoring non-uniform interactions. using this configuration, we generate 5000 sentence-tree pairs, which we split into training (4000 examples), validation (500) and test (500) sets. the characteristics of the trees in the dataset are summarized in table 5.
the ifttt dataset comes with a script to generate the data by crawling and parsing the recipes. unfortunately, by the time we ran the script many recipes had been removed or changed. we therefore resorted to the original dataset used by quirk  (2015). we converted these recipes into our tree format, assigning a node to each element in the first three levels (channels, functions and arguments, see figure 5). for the parameters level, many recipes have sentences instead of single tokens, so we broke these up creating one node per word. the last two layers are therefore the most topologically diverse, whereas the structure of the first two layers is constant (all trees have channels and functions). a very small fraction (< 1%) of trees that could not by parsed into our format was excluded from the dataset.
table 6 shows various statistics about the topological characteristics of the recipes in the ifttt dataset. the middle columns show percentage of trees that contain nonempty arguments and parameters in trigger (if) and action (then) branches. almost all recipes have none empty arguments and parameters (and thus depth 4, excluding the root), and a lower percentage—but still a majority—has arguments and parameters on the trigger side too. the last two columns show tree statistics pertaining to the complexity of trees after conversion to our format. the distribution of tree sizes is mostly concentrated between 4 and 30 nodes, with a slow-decaying tail of examples above this range (see figure 8).
regarding the content of the trees, the labels of the nodes in the first two levels (channels and functions) come from somewhat reduced vocabularies: 111 and 434 unique symbols for the trigger branch, respectively, and 157 and 85 for the action branch. the lower layers of the tree have a much more diverse vocabulary, with about 60k unique tokens in total. on the source side, the vocabulary over the sentence descriptions is large too, with about 30k unique tokens. the average sentence size is 6.07 tokens, with 80% of the sentences having at most 12 tokens.
c.3 machine translation
starting from a preprocessed6 2% sub-selection of the english-french section of the wmt14 dataset, we further prune down the data by keeping only sentences of length between 5 and 20 words, and for which every word is within the 20k most frequent. the reason for this is to simplify the task by keeping only common words and avoiding out-of-vocabulary tokens. after this filtering, we are left with 53,607, 918 and 371 sentences for train, validation and test sets. after tokenizing, we obtain dependency parses for the target (english) sentences using the stanford corenlp toolkit (manning , 2014).
for the perturbation experiments, we randomly selected 50 sentences from among those in the test that could be easily restructured without significantly altering their meaning. the type of alterations we perform are: subordinate clause swapping, alternative construction substitution, passive/active voice change. in doing this, we try to keep the number of added/deleted words to a minimum, to minimize vocabulary-induced likelihood variations. when inserting new words, be verify that they are contained in the original vocabulary of 20k words. in table 7 we show a few examples of the source, original target and perturbed target sentences. http://www-lium.univ-lemans.fr/ schwenk/cslm joint paper/",1
412.pdf.json,"the backpropagation algorithm is commonly employed to estimate the parameters of a convolutional neural network (cnn) using a supervised training data set (rumelhart , 1986). part of the appeal of backpropagation comes from the fact that it is applicable to a wide variety of networks, namely those that have (sub-)differentiable non-linearities and employ a (sub-)differentiable learning objective. however, the generality of backpropagation comes at the cost of a high sensitivity to its hyperparameters such as the learning rate and momentum. standard line-search algorithms cannot be used on the primal objective function in this setting, as (i) there may not exist a step-size guaranteeing a monotonic decrease because of the use of sub-gradients, and (ii) even in the smooth case, each function evaluation requires a forward pass over the entire data set without any update, making the approach computationally unfeasible. choosing the learning rate thus remains an open issue, with the state-of-the-art algorithms suggesting adaptive learning rates (duchi , 2011; zeiler, 2012; kingma & ba, 2015). in addition, techniques such as batch normalization (ioffe & szegedy, 2015) and dropout (srivastava , 2014) have been introduced to respectively reduce the sensitivity to the learning rate and to prevent from overfitting.
with this work, we open a different line of inquiry, namely, is it possible to design more robust optimization algorithms for special but useful classes of cnns? to this end, we focus on the networks that are commonly used in computer vision. specifically, we consider cnns with convolutional and dense layers that apply a set of piecewise linear (pl) non-linear operations to obtain a discriminative representation of an input image. while this assumption may sound restrictive at first, we show that commonly used non-linear operations such as relu and max-pool fall under the category of pl functions. the representation obtained in this way is used to classify the image via a multi-class svm, which forms the final layer of the network. we refer to this class of networks as pl-cnn.
we design a novel, principled algorithm to optimize the learning objective of a pl-cnn. our algorithm is a layerwise method, that is, it iteratively updates the parameters of one layer while keeping the other layers fixed. for this work, we use a simple schedule over the
layers, namely, repeated passes from the output layer to the input one. however, it may be possible to further improve the accuracy and efficiency of our algorithm by designing more sophisticated scheduling strategies. the key observation of our approach is that the parameter estimation of one layer of pl-cnn can be formulated as a difference-of-convex (dc) program that can be viewed as a latent structured svm problem (yu & joachims, 2009). this allows us to solve the dc program using the concave-convex procedure (cccp) (yuille & rangarajan, 2002). each iteration of cccp requires us to solve a convex structured svm problem. to this end, we use the powerful block-coordinate frank-wolfe (bcfw) algorithm (lacoste-julien , 2013), which solves the dual of the convex program iteratively by computing the conditional gradients corresponding to a subset of training samples. in order to further improve bcfw for pl-cnns, we extend it in three important ways. first, we introduce a trust-region term that allows us to initialize the bcfw algorithm using the current estimate of the layer parameters. second, we reduce the memory requirement of bcfw by an order of magnitude, via an efficient representation of the feature vectors corresponding to the dense layers. third, we show that, empirically, the number of constraints of the structural svm problem can be reduced substantially without any loss in accuracy, which allows us to significantly reduce its time complexity.
compared to backpropagation (rumelhart , 1986) or its variants (duchi , 2011; zeiler, 2012; kingma & ba, 2015), our algorithm offers three advantages. first, the cccp algorithm provides a monotonic decrease in the learning objective at each layer. since layerwise optimization itself can be viewed as a block-coordinate method, our algorithm guarantees a monotonic decrease of the overall objective function after each layer’s parameters have been updated. second, since the dual of the svm problem is a smooth convex quadratic program, each step of the bcfw algorithm (in the inner iteration of the cccp) provides a monotonic increase in its dual objective. third, since the only step-size required in our approach comes while solving the svm dual, we can use the optimal step-size that is computed analytically during each iteration of bcfw (lacoste-julien , 2013). in other words, our algorithm has no learning rate, initial or not, that requires tuning.
using standard network architectures and publicly available data sets, we show that our algorithm provides a boost over the state of the art variants of backpropagation for learning pl-cnns and we demonstrate scalability of the method.while some of the early successful approaches for the optimization of deep neural networks relied on greedy layer-wise training (hinton , 2006; bengio , 2007), most currently used methods are variants of backpropagation (rumelhart , 1986) with adaptive learning rates, as discussed in the introduction.
at every iteration, backpropagation performs a forward pass and a backward pass on the network, and updates the parameters of each layer by stochastic or mini-batch gradient descent. this makes the choice of the learning rate critical for efficient optimization. duchi  (2011) have proposed the adagrad convex solver, which adapts the learning rate for every direction and takes into account past updates. adagrad changes the learning rate to favor steps in gradient directions that have not been observed frequently in past updates. when applied to the non-convex cnn optimization problem, adagrad may converge prematurely due to a rapid decrease in the learning rate (goodfellow , 2016). in order to prevent this behavior, the adadelta algorithm (zeiler, 2012) makes the decay of the learning rate slower. it is worth noting that this fix is empirical, and to the best of our knowledge, provides no theoretical guarantees. kingma & ba (2015) propose a different scheme for the learning rate, called adam, which uses an online estimation of the first and second moments of the gradients to provide centered and normalized updates. however all these methods still require the tuning of the initial learning rate to perform well.
second-order and natural gradient optimization methods have also been a subject of attention. the focus in this line of work has been to come up with appropriate approximations to make the updates cheaper. martens & sutskever (2012) suggested a hessian-free second order optimization using finite differences to approximate the hessian and conjugate gradient to
compute the update. martens & grosse (2015) derive an approximation of the fisher matrix inverse, which provides a more efficient method for natural gradient descent. ollivier (2013) explore a set of riemannian methods based on natural gradient descent and quasi-newton methods to guarantee reparametrization invariance of the problem. desjardins  (2015) demonstrate a scaled up natural gradient descent method by training on the imagenet data set (russakovsky , 2015). though providing more informative updates and solid theoretical support than sgd-based approaches, these methods do not take into account the structure of the problem offered by the commonly used non-linear operations.
our work is also related to some of the recent developments in optimization for deep learning. for example, taylor  (2016) use admm for massive distribution of computation in a layer-wise fashion, and in particular their method will yield closed-form updates for any plcnn. lee  (2015) propose to use targets instead of gradients to propagate information through the network, which could help to extend our algorithm. zhang  (2016) derive a convex relaxation for the learning objective for a restricted class of cnns, which also relies on solving an approximate convex problem. in (amos , 2016), the authors identify convex problems for the inference task, when the neural network is a convex function of some of its inputs.
with a more theoretical approach, goel  (2016) propose an algorithm to learn shallow relu nets with guarantees of time convergence and generalization error. heinemann  (2016) show that a subclass of neural networks can be modeled as an improper kernel, which then reduces the learning problem to a simple svm with the constructed kernel.
more generally, we believe that our hitherto unknown observation regarding the relationship between pl-cnns and latent svms can (i) allow the progress made in one field to be transferred to the other and (ii) help design a new generation of principled algorithms for deep learning optimization.a piecewise linear convolutional neural network (pl-cnn) consists of a series of convolutional layers, followed by a series of dense layers, which provides a concise representation of an input image. each layer of the network performs two operations: a linear transformation (that is, a convolution or a matrix multiplication), followed by a piecewise linear non-linear operation such as relu or max-pool. the resulting representation of the image is used for classification via an svm. in the remainder of this section, we provide a formal description of pl-cnn.
piecewise linear functions. a piecewise linear (pl) function f(u) is a function of the following form (melzer, 1986):
f(u) = max i∈[m] {a>i u} −max j∈[n] {b>j u}, (1)
where [m] = {1, · · · ,m}, and [n] = {1, · · · , n}. each of the two maxima above is a convex function, therefore such a function f is not generally convex, but it is rather a difference of two convex functions. importantly, many commonly used non-linear operations such as relu or max-pool are pl functions of their input. for example, relu corresponds to the function r(v) = max{v, 0} where v is a scalar. similarly, max-pool for a d-dimensional vector u corresponds to m(u) = maxi∈[d]{e>i u}, where ei is a vector whose i-th element is 1 and all other elements are 0. given a value of u, we say that (i∗, j∗) is the activation of the pl function at u if i∗ = argmaxi∈[m]{a>i u} and j∗ = argmaxj∈[n]{b>j u}.
pl-cnn parameters. we denote the parameters of an l layer pl-cnn by w = {w l; l ∈ [l]}. in other words, the parameters of the l-th layer is defined as w l. the cnn defines a composite function, that is, the output zl−1 of layer l− 1 is the input to the layer l. given the input zl−1 to layer l, the output is computed as zl = σl(w l · zl−1), where “·” is either a convolution or a matrix multiplication, and σl is a pl non-linear function, such as relu or max-pool. the input to the first layer is an image x, that is, z0 = x. we denote
the input to the final layer by zl = φ(x;w) ∈ rd. in other words, given an image x, the convolutional and dense layers of a pl-cnn provide a d-dimensional representation of x to the final classification layer. the final layer of a pl-cnn is a c class svm w svm, which specifies one parameter w svmy ∈ rd for each class y ∈ y.
prediction. given an image x, a pl-cnn predicts its class using the following rule:
y∗ = argmax y∈y w svmy φ(x;w). (2)
in other words, the dot product of the d-dimensional representation of x with the svm parameter for a class y provides the score for the class. the desired prediction is obtained by maximizing the score over all possible classes.
learning objective. given a training data set d = {(xi, yi), i ∈ [n ]}, where xi is the input image and yi is its ground-truth class, we wish to estimate the parameters w ∪w svm of the pl-cnn. to this end, we minimize a regularized upper bound on the empirical risk. the risk of a prediction y∗i given the ground-truth yi is measured with a user-specified loss function ∆(y∗i , yi). for example, the standard 0− 1 loss has a value of 0 for a correct prediction and 1 for an incorrect prediction. formally, the parameters of a pl-cnn are estimated using the following learning objective:
min w,w svm
λ  ∑ l∈[l]∪{svm} ‖w l‖2f + 1 n n∑ i=1 max ȳi∈y ( ∆(ȳi, yi) + ( w svmȳi −w svm yi )t φ(xi;w) ) . (3)
the hyperparameter λ denotes the relative weight of the regularization compared to the upper bound of the empirical risk. note that, due to the presence of piecewise linear non-linearities, the representation φ(·;w) (and hence, the above objective) is highly non-convex in the pl-cnn parameters.in order to enable layerwise optimization of pl-cnns, we show that parameter estimation of a layer can be formulated as a difference-of-convex (dc) program (subsection 4.1). this allows us to use the concave-convex procedure, which solves a series of convex optimization problems (subsection 4.2). we show that each convex problem closely resembles a structured svm objective, which can be addressed by the powerful block-coordinate frank-wolfe (bcfw) algorithm. we extend bcfw to improve its initialization, time complexity and memory requirements, thereby enabling its use in learning pl-cnns (subsection 4.3). for the sake of clarity, we only provide sketches of the proofs for those propositions that are necessary for understanding the paper. the detailed proofs of the remaining propositions are provided in the appendix.given the values of the parameters for the convolutional and the dense layers (that is, w), the learning objective (3) is the standard svm problem in parameters w svm. in other words, it is a convex optimization problem with several efficient solvers (tsochantaridis , 2004; joachims , 2009; shalev-shwartz , 2009), including the bcfw algorithm (lacostejulien , 2013). hence, the optimization of the final layer is a computationally easy problem. in contrast, the optimization of the parameters of a convolutional or a dense layer l does not result in a convex program. in general, this problem can be arbitrarily hard to solve. however, in the case of pl-cnn, we show that the problem can be formulated as a specific type of dc program, which enables efficient optimization via the iterative use of bcfw. the key property that enables our approach is the following proposition that shows that the composition of pl functions is also a pl function.
proposition 1. consider pl functions g : rm → r and gi : rn → r, for all i ∈ [m]. define a function f : rn → r as f(u) = g([g1(u), g2(u), · · · , gm(u)]>). then f is also a pl function (proof in appendix a).
using the above proposition, we can reformulate the problem of optimizing the parameters of one layer of the network as a dc program. specifically, the following proposition shows that the problem can be formulated as a latent structured svm objective (yu & joachims, 2009).
proposition 2. the learning objective of a pl-cnn with respect to the parameters of the l-th layer can be specified as follows:
min w l
λ 2 ‖w l‖2f + 1 n n∑ i=1
max hi∈h ȳi∈y
( ∆(ȳi, yi) + (w l)>ψ(xi, ȳi,hi) ) − max
hi∈h
( (w l)>ψ(xi, yi,hi) ) ,
(4)
for an appropriate choice of the latent space h and joint feature vectors ψ(x, y,h) of the input x, the output y and the latent variables h. in other words, parameter estimation for the l-th layer corresponds to minimizing the sum of its frobenius norm plus a pl function for each training sample.
sketch of the proof. for a given image x with the ground-truth class y, consider the input to the layer l, which we denote by zl−1. since all the layers except the l-th one are fixed, the input zl−1 is a constant vector, which only depends on the image x (that is, its value does not depend on the variables w l). in other words, we can write zl−1 = ϕ(x).
given the input zl−1, all the elements of the output of the l-th layer, denoted by zl, are a pl function of w l since the layer performs a linear transformation of zl−1 according to the parameters w l, followed by an application of pl operations such as relu or max-pool. the vector zl is then fed to the (l + 1)-th layer. the output zl+1 of the (l + 1)-th layer is a vector whose elements are pl functions of zl. therefore, by proposition (1), the elements of zl+1 are a pl function of w l. by applying the same argument until we reach the layer l, we can conclude that the representation φ(x;w) is a pl function of w l. next, consider the upper bound of the empirical risk, which is specified as follows:
max ȳ∈y
( ∆(ȳ, y) + ( w svmȳ −w svmy )t φ(x;w) ) . (5)
once again, since w svm is fixed, the above upper bound can be interpreted as a pl function of φ(x;w), and thus, by proposition (1), the upper bound is a pl function of w l. it only remains to observe that the learning objective (3) also contains the frobenius norm of w l. thus, it follows that the estimation of the parameters of layer l can be reformulated as minimizing the sum of its frobenius norm and the pl upper bound of the empirical risk over all training samples, as shown in problem (4). note that we have ignored the constants corresponding to the frobenius norm of the parameters of all the fixed layers. this constitutes an existential proof of proposition 2. in the next paragraph, we give an intuition about the feature vectors ψ(xi, ȳi,hi) and the latent space h.
feature vectors & latent space. the exact form of the joint feature vectors depends on the explicit dc decomposition of the objective function. in appendix b, we detail the practical computations and give an example: we construct two interleaved neural networks whose outputs define the convex and concave parts of the dc objective function. given the explicit dc objective function, the feature vectors are given by a subgradient and can therefore be obtained by automatic differentiation.
we now give an intuition of what the latent space h represents. consider an input image x and a corresponding latent variable h ∈ h. the latent variable can be viewed as a set of variables hk, k ∈ {l + 1, · · · , l}. in other words, each subset hk of the latent variable corresponds to one of the layers of the network that follow the layer l. intuitively, hk represents the choice of activation at layer k when going through the pl activation: for each neuron j of layer k, hkj takes value i if and only if the i-th piece of the piecewise linear activation is selected. for instance, i is the index of the selected input in the case of a max-pooling unit.
note that the latent space only depends on the layers that follow the current layer being optimized. this is due to the fact that the input zl−1 to the l-th layer is a constant vector
that does not depend on the value of w l. however, the activations of all subsequent layers following the l-th one depend on the value of the parameters w l. as a consequence, the greater the number of following layers, the greater the size of the latent space, and this growth happens to be exponential. however, as will be seen shortly, it is still possible to efficiently optimize problem (4) for all the layers of the network despite this exponential increase.the optimization problem (4) is a dc program in the parameters w l. this follows from the fact that the upper bound of the empirical risk is a pl function, and can therefore be expressed as the difference of two convex pl functions (melzer, 1986). furthermore, the frobenius norm of w l is also a convex function of w l. this observation allows us to obtain an approximate solution of problem (4) using the iterative concave-convex procedure (cccp) (yuille & rangarajan, 2002).
algorithm 1 describes the main steps of cccp. in step 3, we impute the best value of the latent variable corresponding to the ground-truth class yi for each training sample. this imputation corresponds to the linearization step of the cccp. the selected latent variable corresponds to a choice of activations at each non-linear layer of the network, and therefore defines a path of activations to the ground truth. next, in step 4, we update the parameters by solving a convex optimization problem. this convex problem amounts to finding the path of activations which minimizes the maximum margin violations given the path to the ground truth defined in step 3.
the cccp algorithm has the desirable property of providing a monotonic decrease in the objective function at each iteration. in other words, the objective function value of problem (4) at w lt is greater than or equal to its value at w l t+1. since layerwise optimization itself can be viewed as a block-coordinate algorithm for minimizing the learning objective (3), our overall algorithm provides guarantees of monotonic decrease until convergence. this is one of the main advantages of our approach compared to backpropagation and its variants, which fail to provide similar guarantees on the value of the objective function from one iteration to the next.
algorithm 1 cccp for parameter estimation of the l-th layer of the pl-cnn.
require: data set d = {(xi, yi), i ∈ [n ]}, fixed parameters {w ∪ w svm}\w l, initial estimate w l0. : t = 0 2: repeat 3: for each sample (xi, yi), find the best latent variable value by solving the following
problem: h∗i = argmax
h∈h (w lt ) >ψ(xi, yi,h). (6) : update the parameters by solving the following convex optimization problem:
w lt+1 = argmin w l
λ 2 ‖w l‖2f + 1 n n∑ i=1
max ȳi∈y hi∈h
( ∆(ȳi, yi) + (w l)>ψ(xi, ȳi,hi) ) −
( (w l)>ψ(xi, yi,h ∗ i ) ) . (7) : t = t+1 6: until objective function of problem (4) cannot be improved beyond a specified tolerance.
in order to solve the convex program (7), which corresponds to a structured svm problem, we make use of the powerful bcfw algorithm (lacoste-julien , 2013) that solves its dual via conditional gradients. this has two main advantages: (i) as the dual is a smooth quadratic program, each iteration of bcfw provides a monotonic increase in its
objective; and (ii) the optimal step-size at each iteration can be computed analytically. this is once again in stark contrast to backpropagation, where the estimation of the step-size is still an active area of research (duchi , 2011; zeiler, 2012; kingma & ba, 2015). as shown by lacoste-julien  (2013), given the current estimate of the parameters w l, the conditional gradient of the dual of program (7) with respect to a training sample (xi, yi) can be obtained by solving the following problem:
(ŷi, ĥi) = argmax ȳ∈y,h∈h
(w l)>ψ(xi, ȳ,h) + ∆(ȳ, yi). (8)
we refer the interested reader to (lacoste-julien , 2013) for further details.
the overall efficiency of the cccp algorithm relies on our ability to solve problems (6) and (8). at first glance, these problems may appear to be computationally intractable as the latent space h can be very large, especially for layers close to the input (of the order of millions of dimensions for a typical network). however, the following proposition shows that both the problems can be solved efficiently using the forward and backward passes that are employed in backpropagation.
proposition 3. given the current estimate w l of the parameters for the l-th layer, as well as the parameter values of all the other fixed layers, problems (6) and (8) can be solved
using a forward pass on the network. furthermore, the joint feature vectors ψ(xi, ŷi, ĥi) and ψ(xi, yi,h ∗ i ) can be computed using a backward pass on the network.
sketch of the proof. recall that the latent space consists of the putative activations for each pl operation in the layers following the current one. thus, intuitively, the maximization over the latent variables corresponds to finding the exact activations of all such pl operations. in other words, we need to identify the indices of the linear pieces that are used to compute the value of the pl function in the current state of the network. for a relu operation, this corresponds to estimating max{0, v}, where the input to the relu is a scalar v. similarly, for a max-pool operation, this corresponds to estimating maxi{e>i u}, where u is the input vector to the max-pool. this is precisely the computation that the forward pass of backpropagation performs. given the activations, the joint feature vector is the subgradient of the sample with respect to the current layer. once again, this is precisely what is computed during the backward pass of the backpropagation algorithm.
an example is constructed in appendix b to illustrate how to compute the feature vectors in practice.as the bcfw algorithm was originally designed to solve a structured svm problem, it requires further extensions to be suitable for training a pl-cnn. in what follows, we present three such extensions that improve the initialization, memory requirements and time complexity of the bcfw algorithm respectively.
trust-region for initialization. the original bcfw algorithm starts with an initial parameter w l = 0 (that is, all the parameters are set to 0). the reason for this initialization is that it is possible to compute the dual variables that correspond to the 0 primal variable. however, since our algorithm visits each layer of the network several times, it would be desirable to initialize its parameters using its current value w tl . to this end, we introduce a trust-region in the constraints of problem (7), or equivalently, an `2 norm based proximal term in its objective function (parikh & boyd, 2014). the following proposition shows that this has the desired effect of initializing the bcfw algorithm close to the current parameter values.
proposition 4. by adding a proximal term µ2 ‖w l −w lt‖2f to the objective function in (7), we can compute a feasible dual solution whose corresponding primal solution is equal to µ λ+µw l t . furthermore, the addition of the proximal term still allows us to efficiently compute the conditional gradient using a forward-backward pass (proof in appendix d).
in practice, we always choose a value of µ = 10λ: this yields an initialization of ' 0.9w lt which does not significantly change the value of the objective function.
efficient representation of joint feature vectors. the bcfw algorithm requires us to store a linear combination of the feature vectors for each mini-batch. while this requirement is not too stringent for convolutional and multi-class svm layers, where the dimensionality of the feature vectors is small, it becomes prohibitively expensive for dense layers. the following proposition prevents a blow-up in the memory requirements of bcfw.
proposition 5. when optimizing dense layer l, if w l ∈ rp×q, we can store a representation of the joint feature vectors ψ(x, y,h) with vectors of size p in problems (6) and (7). this is in contrast to the näıve approach that requires them to be of size p× q.
sketch of the proof. by proposition (3), the feature vectors are subgradients of the hinge loss function, which we loosely denote by η for this proof. then by the chain rule: ∂η ∂w l
= ∂η ∂zl ∂zl ∂w l = ∂η ∂zl · ( zl−1 )t . noting that zl−1 ∈ rq is a forward pass up until layer l (independent of w l), we can store only ∂η ∂zl ∈ rp and still reconstruct the full feature vector ∂η ∂w l by a forward pass and an outer product.
reducing the number of constraints. in order to reduce the amount of time required for the bcfw algorithm to converge, we use the structure of h to simplify problem (7) to a much simpler problem. specifically, since h represents the activations of the network for a given sample, it has a natural decomposition over the layers: h = h1 × ...×hl. we use this structure in the following observation.
observation 1. problem (7) can be approximately solved by optimizing the dual problem on increasingly large search spaces. in other words, we start with constraints of y, followed by y ×hl, then y ×hl ×hl−1 and so on. the algorithm converges when the primal-dual gap is below tolerance.
the latent variables which are not optimized over are set to be the same as the ones selected for the ground truth. experimentally, we observe that for convolutional layers (architectures in section 5), restricting the search space to y yields a dual gap low enough to consider the problem has converged. this means that in practice for these layers, problem (7) can be solved by searching directions over the search space y instead of the much larger y × h. the intuition is that the norm of the difference-of-convex decomposition grows with the number of activations selected differently in the convex and concave parts (see appendix a for the decomposition of piecewise linear functions). this compels the path of activations to be the same in the convex and the concave part to avoid large margin violations, especially for convolutional layers which are followed by numerous non-linearities at the max-pooling layers.our experiments are designed to assess the ability of lw-svm (layer-wise svm, our method) and the sgd baselines to optimize problem (3). to compare lw-svm with the state-of-the-art variants of backpropagation, we look at the training and testing accuracies as well as the training objective value. unlike dropout, which effectively learns an ensemble model, we learn a single model using each baseline optimization algorithm. all experiments are conducted on a gpu (nvidia titan x) and use theano (bergstra , 2010; bastien , 2012). we compare lw-svm with adagrad, adadelta and adam. for all data sets, we start at a good solution provided by these solvers and fine-tune it with lw-svm. we then check whether a longer run of the sgd solver reaches the same level of performance.
the practical use of the lw-svm algorithm needs choices at the three following levels: how to select the layer to optimize (i), when to stop the cccp on each layer (ii) and when to stop the convex optimization at each inner iteration of the cccp (iii). these choices are detailed in the next paragraph.
the layer-wise schedule of lw-svm is as follows: as long as the validation accuracy increases, we perform passes from the end of the network (svm) to the first layer (i). at each pass, each layer is optimized with one outer iteration of the cccp (ii). the inner iterations are stopped when the dual objective function does not increase by more than 1% over an epoch (iii). we point out that the dual objective function is cheap to compute since we are maintaining its value at all time. by contrast, to compute the exact primal objective function requires a forward pass over the data set without any update.data set & architecture the training data set consists in 60,000 gray scale images of size 28× 28 with 10 classes, which we split into 50,000 samples for training and 10,000 for validating. the images are normalized, and we do not use any data augmentation. the architecture used for this experiment is shown in figure 1.
method the number of epochs is set to 200, 100 and 100 for adagrad, adadelta and adam - adagrad is given more epochs as we observed it took a longer time to converge. we then use lw-svm and compare the results on training objective, training accuracy and testing accuracy. we also let the solvers run to up to 500 epochs to verify that we have not stopped the optimization prematurely. the regularization hyperparameter λ and the initial learning rate are chosen by cross-validation. λ is set to 0.001 for all solvers, and the initial learning rates can be found in appendix c. for lw-svm, λ is set to the same value as the baseline, and the proximal term µ to µ = 10λ = 0.01.
results as table 1 shows, lw-svm systematically improves on all training objective, training accuracy and testing accuracy. in particular, it obtains the best testing accuracy when combined with adadelta. because each convex sub-problem is run up to sufficient convergence, the objective function of lw-svm features of monotonic decrease at each iteration of the cccp (blue curves in first row of figure 2).data sets & architectures the cifar-10/100 data sets are comprised of 60,000 rgb natural images of size 32× 32 with 10/100 classes (krizhevsky, 2009)). we split the training set into 45,000 training samples and 5,000 validation samples in both cases. the images are centered and normalized, and we do not use any data augmentation. to obtain a strong enough baseline, we employ (i) a pre-training with a softmax and cross-entropy loss and (ii) batch-normalization (bn) layers before each non-linearity.
we have experimentally found out that pre-training with a softmax layer followed by a cross-entropy loss led to better behavior and results than using an svm loss alone. the baselines are trained with batch normalization. once they have converged, the estimated mean and standard deviation are fixed like they would be at test time. then batch normalization becomes a linear transformation, which can be handled by the lw-svm algorithm. this allows us to compare lw-svm with a baseline benefiting from batch normalization. specifically, we use the architecture shown in figure 3:
method again, the initial learning rates and regularization weight λ are obtained by cross-validation, and a value of 0.001 is obtained for λ for all solvers on both datasets. as before, µ is set to 10λ. the initial learning rates are reported in appendix c. the layer schedule and convergence criteria are as described at the beginning of the section. for each sgd optimizer, we train the network for 10 epochs with a cross-entropy loss (preceded by a softmax layer). then it is trained with an svm loss (without softmax) for respectively 1000, 100 and 100 epochs for adagrad, adadelta and adam. this amount is doubled to verify that the baselines are not harmed by a premature stopping. results are presented in tables 2 and 3.
results it can be seen from this set of results that lw-svm always improves over the solution of the sgd algorithm, for example on cifar-100, decreasing the objective value of adam from 0.22 to 0.06, or improving the test accuracy of adadelta from 84.4% to 86.6% on
cifar-10. the automatic step-size allows for a precise fine-tuning to optimize the training objective, while the regularization of the proximal term helps for better generalization.network top-1 accuracy top-5 accuracy vgg-16 (pt) 73.30% 91.33% vgg-16 (pt + lw-svm) 73.81% 91.61%
since the objective function penalizes the top-1 error, it is logical to observe that the improvement is most important on the top-1 accuracy. importantly, having an efficient representation of feature vectors proves to be essential for such large networks: for instance, in the optimization of the first fully connected layer with a batch-size of 100, the use of our representation lowers the memory requirements of the bcfw algorithm from 7,600gb to 20gb, which can then fit in the memory of a powerful computer.we presented a novel layerwise optimization algorithm for a large and useful class of convolutional neural networks, which we term pl-cnns. our key observation is that the optimization of the parameters of one layer of a pl-cnn is equivalent to solving a latent structured svm problem. as the problem is a dc program, it naturally lends itself to the iterative cccp approach, which optimizes a convex structured svm objective at each iteration. this allows us to leverage the advancements made in structured svm optimization over the past decade to design a computationally feasible approach for learning pl-cnns. specifically, we use the bcfw algorithm and extend it to improve its initialization, memory requirements and time complexity. in particular, this allows our method to not require the tuning of any learning rate. using the publicly available mnist, cifar-10 and cifar-100 data sets, we show that our approach provides a boost for learning pl-cnns over the state of the art backpropagation algorithms. furthermore, we demonstrate scalability of the method with results on the imagenet data set with a large network.
when the mean and standard deviation estimations of batch normalization are not fixed (unlike in our experiments with lw-svm), batch normalization is not a piecewise linear transformation, and therefore cannot be used in conjunction with the bcfw algorithm for svms. however, it is difference-of-convex as it is a c2 function (horst & thoai, 1999). incorporating a normalization scheme into our framework will be the object of future work. with our current methodology, lw-svm algorithm can already be used on most standard architectures like vgg, inception and resnet-type architectures.
it is worth noting that other approaches for solving structured svm problems, such as cutting-plane algorithms (tsochantaridis , 2004; joachims , 2009) and stochastic subgradient descent (shalev-shwartz , 2009), also rely on the efficiency of estimating the conditional gradient of the dual. hence, all these methods are equally applicable to our setting. indeed, the main strength of our approach is the establishment of a hitherto unknown connection between cnns and latent structured svms. we believe that our observation will allow researchers to transfer the substantial existing knowledge of dc programs in general, and latent svms specifically, to produce the next generation of principled optimization algorithms for deep learning. in fact, there are already several such improvements that can be readily applied in our setting, which were not explored only due to a lack of time. this includes multi-plane variants of bcfw (shah , 2015; osokin , 2016), as well as generalizations of frank-wolfe such as partial linearization (mohapatra , 2016).this work was supported by the epsrc aims cdt grant ep/l015987/1, the epsrc programme grant seebibyte ep/m013774/1 and yougov. many thanks to a. desmaison, r. bunel and d. bouchacourt for the helpful discussions.proof of proposition (1) by the definition from (melzer, 1986), we can write each function as the difference of two point-wise maxima of linear functions:
g(v) = max j∈[m+] {a>i v} − max k∈[m−] {b>j v} and ∀i ∈ [n], gi(u) = g+i (u)− g − i (u)
where all the g+i , g − i are linear point-wise maxima of linear functions. then:
f(u) = g([g1(u), · · · , gn(u)]>) = max j∈[m+] {a>j [g1(u), · · · , gn(u)]>} − max k∈[m−] {b>k [g1(u), · · · , gn(u)]>}
= max j∈[m+] { n∑ i=1 aj,igi(u) } − max k∈[m−] { n∑ i=1 bk,igi(u) }
= max j∈[m+] { n∑ i=1 aj,ig + i (u)− n∑ i=1 aj,ig − i (u) } − max k∈[m−] { n∑ i=1 bk,ig + i (u)− n∑ i=1 bk,ig − i (u) }
= max j∈[m+]  n∑ i=1 aj,ig + i (u) + ∑ j′∈[m+]\{j} n∑ i=1 aj,ig − i (u) − ∑ j′∈[m+] n∑ i=1 aj,ig − i (u)
− max k∈[m−]  n∑ i=1 bk,ig + i (u) + ∑ k′∈[m−]\{k} n∑ i=1 bk,ig − i (u) + ∑ k′∈[m−] n∑ i=1 bk,ig − i (u)
= max j∈[m+]  n∑ i=1 aj,ig + i (u) + ∑ j′∈[m+]\{j} n∑ i=1 aj,ig − i (u) + ∑ k′∈[m−] n∑ i=1 bk,ig − i (u)
−  max k∈[m−]  n∑ i=1 bk,ig + i (u) + ∑ k′∈[m−]\{k} n∑ i=1 bk,ig − i (u) + ∑ j′∈[m+] n∑ i=1 aj,ig − i (u)  = max j∈[m+]  n∑ i=1 aj,ig + i (u) + ∑ j′∈[m+]\{j} n∑ i=1 aj,ig − i (u) + ∑ k′∈[m−] n∑ i=1 bk,ig − i (u)
 − max k∈[m−]  n∑ i=1 bk,ig + i (u) + ∑ k′∈[m−]\{k} n∑ i=1 bk,ig − i (u) + ∑ j′∈[m+] n∑ i=1 aj,ig − i (u)
 in each line of the last equality, we recognize a pointwise maximum of a linear combination of pointwise maxima of linear functions. this constitutes a pointwise maximum of linear functions.
this derivation also extends equation (10) to the multi-dimensional case by showing an explicit dc decomposition of the output.we describe here how to compute the feature vectors in practice. to this end, we show how to construct two (intertwined) neural networks that decompose the objective function into a convex and a concave part. we call these difference of convex (dc) networks. once the dc networks are defined, a standard forward and backward pass in the two networks yields the feature vectors for the convex and concave contribution to the objective function. first, we derive how to perform a dc decomposition in linear and non-linear layers, and then we construct an example of dc networks.
dc decomposition in a linear layer let w be the weights of a fixed linear layer. we introduce w+ = 12 (|w |+w ) and w − = 12 (|w | −w ). we can note that w + and w− have exclusively non-negative weights, and that w = w+ −w−. say we have an input u with the dc decomposition (ucvx, uccv), that is: u = ucvx − uccv, where both ucvx and uccv are convex. then we can decompose the output of the layer as:
w · u = (w+ · ucvx +w− · uccv)︸ ︷︷ ︸ convex − (w− · ucvx +w+ · uccv)︸ ︷︷ ︸ convex
(9)
dc decomposition in a piecewise linear activation layer for simplicity purposes, we consider that the non-linear layer is a point-wise maximum across [k] scalar inputs, that is, for an input (uk)k∈[k] ∈ rk , the output is maxk∈[k] uk (the general multi-dimensional case can be found in appendix a). we suppose that we have a dc decomposition (ucvxk , u ccv k ) for each input k. then we can write the following decomposition for the output of the layer:
max k∈[k] uk = max k∈[k]
(ucvxk − uccvk )
= max k∈[k] ucvxk + ∑ i∈[k],i6=k uccvi  ︸ ︷︷ ︸
convex
− ∑ k∈[k]
uccvk︸ ︷︷ ︸ convex
(10)
in particular, for a relu, we can write:
max(ucvx − uccv, 0) = max(ucvx, uccv)︸ ︷︷ ︸ convex − uccv︸︷︷︸ convex
(11)
and for a max-pooling layer, one can easily verify that equation (10) is equivalent to:
maxpool(ucvx − uccv) = maxpool(ucvx − uccv) + sumpool(uccv)︸ ︷︷ ︸ convex −sumpool(uccv)︸ ︷︷ ︸ convex (12)
an example of dc networks we use the previous observations to obtain a dc decomposition in any layer. we now take the example of the neural network used for the experiments on the mnist data set, and we show how to construct the two neural networks when optimizing w 1, the weights of the first convolutional layer. first let us recall the architecture without decomposition:
we want to optimize the first convolutional layer, therefore we fix all other parameters. then we apply all operations as described in the previous paragraphs, which yields the dc networks in figure 7.
the network graph in figure 7 illustrates proposition 3 for the optimization of w 1: suppose we are interested in f cvx(x,w 1), the convex part of the objective function for a given sample x, and we wish to obtain the feature vector needed to perform an update of bcfw. with a
forward pass, the oracle for the latent and label variables (ĥ, ŷ) is efficiently computed; and
with a backward pass, we obtain the corresponding feature vector ψ(x, ŷ, ĥ). indeed, we recall from problem (8) that (ĥ, ŷ) are the latent and label variables maximizing f cvx(x,w 1). then given x, the forward pass in the dc networks sequentially solves the nested maximization: it maximizes the activation of the relu and maxpooling units at each layer, thereby selecting
the best latent variable ĥ at each non-linear layer, and maximizes the output of the svm
concave network convex network
non-decomposed corresponding
network
layer, thereby selecting the best label ŷ. at the end of the forward pass, f cvx(x,w 1) is
therefore available as the output of the convex network, and the feature vector ψ(x, ŷ, ĥ) can be computed as a subgradient of f cvx(x,w 1) with respect to w 1.
linearizing the concave part is equivalent to fixing the activations of the dc networks, which can be done by using a fixed copy of w 1 at the linearization point (all other weights being fixed anyway). then one can re-use the above reasoning to obtain the feature vectors for the linearized concave part. altogether, this methodology allows our algorithm to be implemented in any standard deep learning library (our implementation is available at http://github.com/oval-group/pl-cnn).hyper-parameters the hyper-parameters are obtained by cross-validation with a search on powers of 10. in this section, η will denote the initial learning rate. we denote the softmax + cross-entropy loss by sce, while svm stands for the usual support vector machines loss.
one may note that the hyper-parameters are the same for both cifar-10 and cifar-100 for each combination of solver and loss. this makes sense since the initial learning rate mainly depends on the architecture of the network (and not so much on which particular images are fed to this network), which is very similar for the experiments on the cifar-10 and cifar-100 data sets.multi-class svm suppose we are given a data set of n samples, for which every sample i has a feature vector φi ∈ rd and a ground truth label yi ∈ y. for every possible label ȳi ∈ y, we introduce the augmented feature vector ψi(ȳi) ∈ r|y|×d containing φi at index ȳi, −φi at index yi, and zeros everywhere else (then ψi(yi) is just a vector of zeros). we also define ∆(ȳi, yi) as the loss by choosing the output ȳi instead of the ground truth yi in our task. for classification, this is the zero-one loss for example.
the svm optimization problem is formulated as:
min w,ξi
λ 2 ‖w‖2 + 1 n n∑ i=1 ξi
subject to: ∀i ∈ [n ], ∀ȳi ∈ y, ξi ≥ wtψi(ȳi) + ∆(yi, ȳi)
where λ is the regularization hyperparameter. we now add a proximal term to a given starting point w0:
min w,ξi
λ 2 ‖w‖2 + µ 2 ‖w − w0‖2 + 1 n n∑ i=1 ξi
subject to: ∀i ∈ [n ], ∀ȳi ∈ y, ξi ≥ wtψi(ȳi) + ∆(yi, ȳi)
factorizing the second-order polynomial in w, we obtain the equivalent problem (changed by a constant):
min w,ξi
λ+ µ 2 ‖w − µ λ+ µ w0‖2 + 1 n n∑ i=1 ξi
subject to: ∀i ∈ [n ], ∀ȳi ∈ y, ξi ≥ wtψi(ȳi) + ∆(yi, ȳi)
for simplicity, we introduce the ratio ρ = µ
λ+ µ .
dual objective function the primal problem is:
min w,ξi
λ+ µ  ‖w − ρw0‖2 + 
n n∑ i=1 ξi
subject to: ∀i ∈ [n ], ∀ȳi ∈ y, ξi ≥ wtψi(ȳi) + ∆(yi, ȳi)
the dual problem can be written as:
max α≥0 min w,ξi
λ+ µ  ‖w − ρw0‖2 + 
n n∑ i=1 ξi + 1 n n∑ i=1 ∑ ȳi∈y αi(ȳi) ( ∆(yi, ȳi) + w tψi(ȳi)− ξi )
then we obtain the following kkt conditions:
∀i ∈ [n ], ∂· ∂ξi = 0 −→ ∑ ȳi∈y αi(ȳi) = 1
∂· ∂w = 0 −→ w = ρw0 − 1 n 1 λ+ µ n∑ i=1 ∑ ȳi∈y
αi(ȳi)ψi(ȳi)︸ ︷︷ ︸ aα
we also introduce b = 1n (∆(yi, ȳi))i,ȳi . we define pn(y) as the sample-wise probability simplex:
u ∈ pn(y) if: ∀i ∈ [n ], ∀ȳi ∈ y, ui(ȳi) ≥ 0 ∀i ∈ [n ], ∑ ȳi∈y ui(ȳi) = 1
we inject back and simplify to:
max α∈pn(y) −(λ+ µ) 2 ‖aα‖2 + µwt0 (aα) + αt b
finally:
min α∈pn(y) f(α)
where:
f(α) , λ+ µ  ‖aα‖2 − µwt0 (aα)− αt b
bcfw derivation we write ∇(i)f the gradient of f w.r.t. the block (i) of variables in α, padded with zeros on blocks (j) for j 6= i. similarly, a(i) and b(i) contain the rows of a and the elements of b for the block of coordinates (i) and zeros elsewhere. we can write:
∇(i)f(α) = (λ+ µ)at(i)aα− µa(i)w0 − b(i)
then the search corner for the block of coordinates (i) is given by:
si = argmin s′i
( < s′i,∇(i)f(α) > ) = argmin
s′i
( (λ+ µ)αtata(i)s ′ i − µwt0 a(i)s′i − bt(i)s ′ i ) we replace:
aα = ρw0 − w
a(i)s ′ i = 
n 
λ+ µ ∑ ȳi∈y s′i(ȳi)ψi(ȳi)
bt(i)s ′ i = 
n ∑ ȳi∈y s′i(ȳi)∆(ȳi, yi)
we then obtain:
si = argmin s′i −(w − ρw0)t ∑ ȳi∈y s′i(ȳi)ψi(ȳi)− wt0 ρ ∑ ȳi∈y s′i(ȳi)ψi(ȳi)− ∑ ȳi∈y s′i(ȳi)∆(ȳi, yi)  = argmax
s′i wt ∑ ȳi∈y s′i(ȳi)ψi(ȳi) + ∑ ȳi∈y s′i(ȳi)∆(ȳi, yi)  as expected, this maximum is obtained by setting si to one at y ∗ i = argmax ȳi∈y ( wtψi(ȳi) + ∆(ȳi, yi) ) and zeros elsewhere. we introduce the notation:
wi = −a(i)α(i) li = b t (i)α(i)
ws = −a(i)si ls = b t (i)si
then we have:
ws = − 1
n 
λ+ µ ψ(y∗i ) = − 
n 
λ+ µ
∂hi(y ∗ i )
∂w
ls = 1
n ∆(yi, y
∗ i )
the optimal step size in the direction of the block of coordinates (i) is given by :
γ∗ = argmin γ f(α+ γ(si − αi))
the optimal step-size is given by:
γ∗ = < ∇(i)f(α), si − αi > (λ+ µ)‖a(si − αi)‖2
we introduce wd = −aα = w − ρw0. then we obtain:
γ∗ = (wi − ws)t (w − ρw0) + ρwt0 (wi − ws)− 1λ+µ (li − ls)
‖wi − ws‖2
= (wi − ws)tw − 1λ+µ (li − ls)
‖wi − ws‖2
and the updates are the same as in standard bcfw:
algorithm 2 bcfw with warm start : let w(0) = w0, ∀i ∈ [n ], w(0)i = 0 2: let l(0) = 0, ∀i ∈ [n ], l(0)i = 0 3: for k=0...k do 4: pick i randomly in {1, .., n} : get y∗i = argmax ȳi∈y hi(ȳi, w (k)) and ws = − 
n 
λ+ µ
∂hi(y ∗ i , w (k))
∂w(k) : ls = 1 n∆(y ∗ i , yi) 7: γ = (wi − ws)tw − 1λ+µ (li − ls)
‖wi − ws‖2 clipped to [0, 1] : w (k+1) i = (1− γ)w (k) i + γws 9: l (k+1) i = (1− γ)l (k) i + γls 10: w(k+1) = w(k) + w (k+1) i − w (k) i = w (k) + γ(w (k) s − w(k)i ) 11: l(k+1) = l(k) + l (k+1) i − l (k) i 12: end for
in particular, we have proved proposition (4) in this section: w is initialized to ρw0 (kkt conditions), and the direction of the conditional gradient, ws, is given by ∂hi(y ∗ i )
∂w , which is
independent of w0.
note that the derivation of the lagrangian dual has introduced a dual variable αi(ȳi) for each linear constraint of the svm problem (this can be replaced by αi(hi, (ȳi)) if we consider latent variables). these dual variables indicate the complementary slackness not only for the output class ȳi, but also for each of the activation which defines a piece of the piecewise linear hinge loss. therefore a choice of α defines a path of activations.here we discuss some weaknesses of the sgd-based algorithms that we have encountered in practice for our learning objective function. these behaviors have been observed in the case of pl-cnns, and generally may not appear in different architectures (in particular the failure to learn with high regularization goes away with the use of batch normalization layers).
e.1 initial learning rate
as mentioned in the experiments section, the choice of the initial learning rate is critical for good performance of all adagrad, adadelta and adam. when the learning rate is too high, the network does not learn anything and the training and validating accuracies are stuck at random level. when it is too low, the network may take a considerably greater number of epochs to converge.
e.2 failures to learn
regularization when the regularization hyper-parameter λ is set to a value of 0.01 or higher on cifar-10, sgd solvers get trapped in a local minimum and fail to learn. the sgd solvers indeed fall in the local minimum of shutting down all activations on relus, which provide zero-valued feature vector to the svm loss layer (and a hinge loss of one). as a consequence, no information can be back-propagated. we plot this behavior below:
in this situation, the network is at a bad saddle point (note that the training and validation accuracies are stuck at random levels). our algorithm does not fall into such bad situations, however it is not able to get out of it either: each layer is at a pathological critical point of its own objective function, which makes our algorithm unable to escape from it.
with a lower initial learning rate, the evolution is slower, but eventually the solver goes back to the bad situation presented above.
biases the same failing behavior as above has been observed when not using the biases in the network. again our algorithm is robust to this change.",1
438.pdf.json,"the ability to navigate efficiently within an environment is fundamental to intelligent behavior. whilst conventional robotics methods, such as simultaneous localisation and mapping (slam), tackle navigation through an explicit focus on position inference and mapping (dissanayake , 2001), here we follow recent work in deep reinforcement learning (mnih , 2015; 2016) and propose that navigational abilities could emerge as the by-product of an agent learning a policy that maximizes reward. one advantage of an intrinsic, end-to-end approach is that actions are not divorced from representation, but rather learnt together, thus ensuring that task-relevant features are present in the representation. learning to navigate from reinforcement learning in partially observable environments, however, poses several challenges.
first, rewards are often sparsely distributed in the environment, where there may be only one goal location. second, environments often comprise dynamic elements, requiring the agent to use memory at different timescales: rapid one-shot memory for the goal location, together with short term memory subserving temporal integration of velocity signals and visual observations, and longer term memory for constant aspects of the environment (e.g. boundaries, cues).
to improve statistical efficiency we bootstrap the reinforcement learning procedure by augmenting our loss with auxiliary tasks that provide denser training signals that support navigation-relevant representation learning. we consider two additional losses: the first one involves reconstruction of a low-dimensional depth map at each time step by predicting one input modality (the depth channel) from others (the colour channels). this auxiliary task concerns the 3d geometry of the environment, and is aimed to encourage the learning of representations that aid obstacle avoidance and short-term trajectory planning. the second task directly invokes loop closure from slam: the agent is trained to predict if the current location has been previously visited within a local trajectory. ∗denotes equal contribution 1a video illustrating the navigation agents is available at: https://youtu.be/lnoatymzswi
to address the memory requirements of the task we rely on a stacked lstm architecture (graves , 2013; pascanu , 2013). we evaluate our approach using five 3d maze environments and demonstrate the accelerated learning and increased performance of the proposed agent architecture. these environments feature complex geometry, random start position and orientation, dynamic goal locations, and long episodes that require thousands of agent steps (see figure 1). we also provide detailed analysis of the trained agent to show that critical navigation skills are acquired. this is important as neither position inference nor mapping are directly part of the loss; therefore, raw performance on the goal finding task is not necessarily a good indication that these skills are acquired. in particular, we show that the proposed agent resolves ambiguous observations and quickly localizes itself in a complex maze, and that this localization capability is correlated with higher task reward.we rely on a end-to-end learning framework that incorporates multiple objectives. firstly it tries to maximize cumulative reward using an actor-critic approach. secondly it minimizes an auxiliary loss of inferring the depth map from the rgb observation. finally, the agent is trained to detect loop closures as an additional auxiliary task that encourages implicit velocity integration.
the reinforcement learning problem is addressed with the asynchronous advantage actor-critic (a3c) algorithm (mnih , 2016) that relies on learning both a policy π(at|st; θ) and value function v (st; θv ) given a state observation st. both the policy and value function share all intermediate representations, both being computed using a separate linear layer from the topmost layer of the model. the agent setup closely follows the work of (mnih , 2016) and we refer to this work for the details (e.g. the use of a convolutional encoder followed by either an mlp or an lstm, the use of action repetition, entropy regularization to prevent the policy saturation, etc.). these details can also be found in the appendix b.
the baseline that we consider in this work is an a3c agent (mnih , 2016) that receives only rgb input from the environment, using either a recurrent or a purely feed-forward model (see figure 2a,b). the encoder for the rgb input (used in all other considered architectures) is a 3 layer convolutional network. to support the navigation capability of our approach, we also rely on the nav a3c agent (figure 2c) which employs a two-layer stacked lstm after the convolutional encoder. we expand the observations of the agents to include agent-relative velocity, the action sampled from the stochastic policy and the immediate reward, from the previous time step. we opt to feed the velocity and previously selected action directly to the second recurrent layer, with the first layer only receiving the reward. we postulate that the first layer might be able to make associations between reward and visual observations that are provided as context to the second layer from which the policy is computed. thus, the observation st may include an image xt ∈ r3×w×h (where w and h are the width and
height of the image), the agent-relative lateral and rotational velocity vt ∈ r6, the previous action at−1 ∈ rna , and the previous reward rt−1 ∈ r. figure 2d shows the augmentation of the nav a3c with the different possible auxiliary losses. in particular we consider predicting depth from the convolutional layer (we will refer to this choice as d1), or from the top lstm layer (d2) or predicting loop closure (l). the auxiliary losses are computed on the current frame via a single layer mlp. the agent is trained by applying a weighted sum of the gradients coming from a3c, the gradients from depth prediction (multiplied with βd1 , βd2 ) and the gradients from the loop closure (scaled by βl). more details of the online learning algorithm are given in appendix b.the primary input to the agent is in the form of rgb images. however, depth information, covering the central field of view of the agent, might supply valuable information about the 3d structure of the environment. while depth could be directly used as an input, we argue that if presented as an additional loss it is actually more valuable to the learning process. in particular if the prediction loss shares representation with the policy, it could help build useful features for rl much faster, bootstrapping learning. since we know from (eigen , 2014) that a single frame can be enough to predict depth, we know this auxiliary task can be learnt. a comparison between having depth as input versus as an additional loss is given in appendix c, which shows significant gain for depth as a loss.
since the role of the auxiliary loss is just to build up the representation of the model, we do not necessarily care about the specific performance obtained or nature of the prediction. we do care about the data efficiency aspect of the problem and also computational complexity. if the loss is to be useful for the main task, we should converge faster on it compared to solving the rl problem (using less data samples), and the additional computational cost should be minimal. to achieve this we use a low resolution variant of the depth map, reducing the screen resolution to 4x16 pixels2.
we explore two different variants for the loss. the first choice is to phrase it as a regression task, the most natural choice. while this formulation, combined with a higher depth resolution, extracts the most information, mean square error imposes a unimodal distribution (van den oord , 2016). to address this possible issue, we also consider a classification loss, where depth at each position is discretised into 8 different bands. the bands are non-uniformally distributed such that we pay more attention to far-away objects (details in appendix b). the motivation for the classification formulation is that while it greatly reduces the resolution of depth, it is more flexible from a learning perspective and can result in faster convergence (hence faster bootstrapping). the image is cropped before being subsampled to lessen the floor and ceiling which have little relevant depth information.loop closure, like depth, is valuable for a navigating agent, since can be used for efficient exploration and spatial reasoning. to produce the training targets, we detect loop closures based on the similarity of local position information during an episode, which is obtained by integrating 2d velocity over time. specifically, in a trajectory noted {p0, p1, . . . , pt }, where pt is the position of the agent at time t, we define a loop closure label lt that is equal to 1 if the position pt of the agent is close to the position pt′ at an earlier time t′. in order to avoid trivial loop closures on consecutive points of the trajectory, we add an extra condition on an intermediary position pt′′ being far from pt. thresholds η1 and η2 provide these two limits. learning to predict the binary loop label is done by minimizing the bernoulli loss ll between lt and the output of a single-layer output from the hidden representation ht of the last hidden layer of the model, followed by a sigmoid activation.there is a rich literature on navigation, primarily in the robotics literature. however, here we focus on related work in deep rl. deep q-networks (dqn) have had breakthroughs in extremely challenging domains such as atari (mnih , 2015). recent work has developed on-policy rl methods such as advantage actor-critic that use asynchronous training of multiple agents in parallel (mnih , 2016). recurrent networks have also been successfully incorporated to enable state disambiguation in partially observable environments (koutnik , 2013; hausknecht & stone, 2015; mnih , 2016; narasimhan , 2015).
deep rl has recently been used in the navigation domain. kulkarni  (2016) used a feedforward architecture to learn deep successor representations that enabled behavioral flexibility to reward changes in the mazebase gridworld, and provided a means to detect bottlenecks in 3d vizdoom. zhu  (2016) used a feedforward siamese actor-critic architecture incorporating a pretrained resnet to support navigation to a target in a discretised 3d environment. oh  (2016) investigated the performance of a variety of networks with external memory (weston , 2014) on simple navigation tasks in the minecraft 3d block world environment. tessler  (2016) also used the minecraft domain to show the benefit of combining feedforward deep-q networks with the learning of resuable skill modules (cf options: (sutton , 1999)) to transfer between navigation tasks. tai & liu (2016) trained a convnet dqn-based agent using depth channel inputs for obstacle avoidance in 3d environments. barron  (2016) investigated how well a convnet can predict the depth channel from rgb in the minecraft environment, but did not use depth for training the agent.
auxiliary tasks have often been used to facilitate representation learning (suddarth & kergosien, 1990). recently, the incorporation of additional objectives, designed to augment representation learning through auxiliary reconstructive decoding pathways (zhang , 2016; rasmus , 2015; zhao , 2015; mirowski , 2010), has yielded benefits in large scale classification tasks. in deep rl settings, however, only two previous papers have examined the benefit of auxiliary tasks. specifically, li  (2016) consider a supervised loss for fitting a recurrent model on the hidden representations to predict the next observed state, in the context of imitation learning of sequences provided by experts, and lample & chaplot (2016) show that the performance of a dqn agent in a first-person shooter game in the vizdoom environment can be substantially enhanced by the addition of a supervised auxiliary task, whereby the convolutional network was trained on an enemy-detection task, with information about the presence of enemies, weapons, etc., provided by the game engine.
in contrast, our contribution addresses fundamental questions of how to learn an intrinsic representation of space, geometry, and movement while simultaneously maximising rewards through reinforcement learning. our method is validated in challenging maze domains with random start and goal locations.we consider a set of first-person 3d mazes from the deepmind lab environment (beattie , 2016) (see fig. 1) that are visually rich, with additional observations available to the agent such as inertial
information and local depth information.3 the action space is discrete, yows finegrained control, comprising 8 actions: the agent can rotate in small increments, accelerate forward or backward or sideways, or induce rotational acceleration while moving. reward is achieved in these environments by reaching a goal from a random start location and orientation. if the goal is reached, the agent is respawned to a new start location and must return to the goal. the episode terminates when a fixed amount of time expires, affording the agent enough time to find the goal several times. there are sparse ‘fruit’ rewards which serve to encourage exploration. apples are worth 1 point, strawberries 2 points and goals are 10 points. videos of the agent solving the maze are linked in appendix a.
in the static variant of the maze, the goal and fruit locations are fixed and only the agent’s start location changes. in the dynamic (random goal) variant, the goal and fruits are randomly placed on every episode. within an episode, the goal and apple locations stay fixed until the episode ends. this encourages an explore-exploit strategy, where the agent should initially explore the maze, then retain the goal location and quickly refind it after each respawn. for both variants (static and random goal) we consider a small and large map. the small mazes are 5× 10 and episodes last for 3600 timesteps, and the large mazes are 9× 15 with 10800 steps (see figure 1). the rgb observation is 84× 84. the i-maze environment (see figure 1, right) is inspired by the classic t-maze used to investigate navigation in rodents (olton , 1979): the layout remains fixed throughout, the agent spawns in the central corridor where there are apple rewards and has to locate the goal which is placed in the alcove of one of the four arms. because the goal is hidden in the alcove, the optimal agent behaviour must rely on memory of the goal location in order to return to the goal using the most direct route. goal location is constant within an episode but varies randomly across episodes.
the different agent architectures described in section 2 are evaluated by training on the five mazes. figure 3 shows learning curves (averaged over the 5 top performing agents). the agents are a feedforward model (ff a3c), a recurrent model (lstm a3c), the stacked lstm version with velocity, previous action and reward as input (nav a3c), and nav a3c with depth prediction from the convolution layer (nav a3c+d1), nav a3c with depth prediction from the last lstm layer (nav a3c+d2), nav a3c with loop closure prediction (nav a3c+l) as well as the nav a3c with the environments used in this paper are publicly available at https://github.com/deepmind/lab.
all auxiliary losses considered together (nav a3c+d1d2l). in each case we ran 64 experiments with randomly sampled hyper-parameters (for ranges and details please see the appendix). the mean over the top 5 runs as well as the top 5 curves are plotted. expert human scores, established by a professional game player, are compared to these results. the nav a3c+d2 agents reach human-level performance on static 1 and 2, and attain about 91% and 59% of human scores on random goal 1 and 2.
in mnih  (2015) reward clipping is used to stabilize learning, technique which we employed in this work as well. unfortunately, for these particular tasks, this yields slightly suboptimal policies because the agent does not distinguish apples (1 point) from goals (10 points). removing the reward clipping results in unstable behaviour for the base a3c agent (see appendix c). however it seems that the auxiliary signal from depth prediction mediates this problem to some extent, resulting in stable learning dynamics (e.g. figure 3f, nav a3c+d1 vs nav a3c*+d1). we clearly indicate whether reward clipping is used by adding an asterisk to the agent name.
figure 3f also explores the difference between the two formulations of depth prediction, as a regression task or a classification task. we can see that the regression agent (nav a3c*+d1[mse]) performs worse than one that does classification (nav a3c*+d1). this result extends to other maps, and we therefore only use the classification formulation in all our other results4. also we see that predicting depth from the last lstm layer (hence providing structure to the recurrent layer, not just the convolutional ones) performs better.
we note some particular results from these learning curves. in figure 3 (a and b), consider the feedforward a3c model (red curve) versus the lstm version (pink curve). even though navigation seems to intrinsically require memory, as single observations could often be ambiguous, the feedforward model achieves competitive performance on static mazes. this suggest that there might be good strategies that do not involve temporal memory and give good results, namely a reactive policy held by the weights of the encoder, or learning a wall-following strategy. this motivates the dynamic environments that encourage the use of memory and more general navigation strategies.
figure 3 also shows the advantage of adding velocity, reward and action as an input, as well as the impact of using a two layer lstm (orange curve vs red and pink). though this agent (nav a3c) is better than the simple architectures, it is still relatively slow to train on all of the mazes. we believe that this is mainly due to the slower, data inefficient learning that is generally seen in pure rl approaches. supporting this we see that adding the auxiliary prediction targets of depth and loop closure (nav a3c+d1d2l, black curve) speeds up learning dramatically on most of the mazes (see table 1: auc metric). it has the strongest effect on the static mazes because of the accelerated learning, but also gives a substantial and lasting performance increase on the random goal mazes.
although we place more value on the task performance than on the auxiliary losses, we report the results from the loop closure prediction task. over 100 test episodes of 2250 steps each, within a large maze (random goal 2), the nav a3c*+d1l agent demonstrated very successful loop detection, reaching an f-1 score of 0.83. a sample trajectory can be seen in figure 4 (right). an exception is the nav a3c*+d1l agent on the i-maze (figure 3c), which uses depth regression and reward clipping. while it does worse, we include it because some analysis is based on this agent.in order to evaluate the internal representation of location within the agent (either in the hidden units ht of the last lstm, or, in the case of the ff a3c agent, in the features ft on the last layer of the conv-net), we train a position decoder that takes that representation as input, consisting of a linear classifier with multinomial probability distribution over the discretized maze locations. small mazes (5× 10) have 50 locations, large mazes (9× 15) have 135 locations, and the i-maze has 77 locations. note that we do not backpropagate the gradients from the position decoder through the rest of the network. the position decoder can only see the representation exposed by the model, not change it.
an example of position decoding by the nav a3c+d2 agent is shown in figure 6, where the initial uncertainty in position is improved to near perfect position prediction as more observations are acquired by the agent. we observe that position entropy spikes after a respawn, then decreases once the agent acquires certainty about its location. additionally, videos of the agent’s position decoding are linked in appendix a. in these complex mazes, where localization is important for the purpose of reaching the goal, it seems that position accuracy and final score are correlated, as shown in table 1. a pure feed-forward architecture still achieves 64.3% accuracy in a static maze with static goal, suggesting that the encoder memorizes the position in the weights and that this small maze is solvable by all the agents, with sufficient training time. in random goal 1, it is nav a3c+d2 that achieves the best position decoding performance (85.5% accuracy), whereas the ff a3c and the lstm a3c architectures are at approximately 50%.
in the i-maze, the opposite branches of the maze are nearly identical, with the exception of very sparse visual cues. we observe that once the goal is first found, the nav a3c*+d1l agent is capable of directly returning to the correct branch in order to achieve the maximal score. however, the linear position decoder for this agent is only 68.5% accurate, whereas it is 87.8% in the plain lstm a3c agent. we hypothesize that the symmetry of the i-maze will induce a symmetric policy that need not be sensitive to the exact position of the agent (see analysis below).
a desired property of navigation agents in our random goal tasks is to be able to first find the goal, and reliably return to the goal via an efficient route after subsequent re-spawns. the latency column in table 1 shows that the nav a3c+d2 agents achieve the lowest latency to goal once the goal has been discovered (the first number shows the time in seconds to find the goal the first time, and the second number is the average time for subsequent finds). figure 5 shows clearly how the agent finds the goal, and directly returns to that goal for the rest of the episode. for random goal 2, none of the agents achieve lower latency after initial goal acquisition; this is presumably due to the larger, more challenging environment.figure 7(a) shows shows the trajectories traversed by an agent for each of the four goal locations. after an initial exploratory phase to find the goal, the agent consistently returns to the goal location. we visualize the agent’s policy by applying tsne dimension reduction (maaten & hinton, 2008) to the cell activations at each step of the agent for each of the four goal locations. whilst clusters corresponding to each of the four goal locations are clearly distinct in the lstm a3c agent, there are 2 main clusters in the nav a3c agent – with trajectories to diagonally opposite arms of the maze represented similarly. given that the action sequence to opposite arms is equivalent (e.g. straight, turn left twice for top left and bottom right goal locations), this suggests that the nav a3c policy-dictating lstm maintains an efficient representation of 2 sub-policies (i.e. rather than 4 independent policies) – with critical information about the currently relevant goal provided by the additional lstm.our results suggest that depth prediction from the policy lstm yields optimal results. however, several other auxiliary tasks have been concurrently introduced in (jaderberg , 2017), and thus we provide a comparison of reward prediction against depth prediction. following that paper, we implemented two additional agent architectures, one performing reward prediction from the convnet using a replay buffer, called nav a3c*+r, and one combining reward prediction from the convnet and depth prediction from the lstm (nav a3c+rd2). table 2 suggests that reward prediction (nav a3c*+r) improves upon the plain stacked lstm architecture (nav a3c*) but not as much as depth prediction from the policy lstm (nav a3c+d2). combining reward prediction and depth prediction (nav a3c+rd2) yields comparable results to depth prediction alone (nav a3c+d2); normalised average auc values are respectively 0.995 vs. 0.981. future work will explore other auxiliary tasks.we proposed a deep rl method, augmented with memory and auxiliary learning targets, for training agents to navigate within large and visually rich environments that include frequently changing start and goal locations. our results and analysis highlight the utility of un/self-supervised auxiliary objectives, namely depth prediction and loop closure, in providing richer training signals that bootstrap learning and enhance data efficiency. further, we examine the behavior of trained agents, their ability to localise, and their network activity dynamics, in order to analyse their navigational abilities.
our approach of augmenting deep rl with auxiliary objectives allows end-end learning and may encourage the development of more general navigation strategies. notably, our work with auxiliary losses is related to (jaderberg , 2017) which independently looks at data efficiency when exploiting auxiliary losses. one difference between the two works is that our auxiliary losses are online (for the current frame) and do not rely on any form of replay. also the explored losses are very different in nature. finally our focus is on the navigation domain and understanding if navigation emerges as a bi-product of solving an rl problem, while jaderberg  (2017) is concerned with data efficiency for any rl-task.
whilst our best performing agents are relatively successful at navigation, their abilities would be stretched if larger demands were placed on rapid memory (e.g. in procedurally generated mazes), due to the limited capacity of the stacked lstm in this regard. it will be important in the future to combine visually complex environments with architectures that make use of external memory (graves , 2016; weston , 2014; olton , 1979) to enhance the navigational abilities of agents. further, whilst this work has focused on investigating the benefits of auxiliary tasks for developing the ability to navigate through end-to-end deep reinforcement learning, it would be interesting for future work to compare these techniques with slam-based approaches.
acknowledgements
we would like to thank alexander pritzel, thomas degris and joseph modayil for useful discussions, charles beattie, julian schrittwieser, marcus wainwright, and stig petersen for environment design and development, and amir sadik and sarah york for expert human game testing.a videos of trained navigation agents
we show the behaviour of nav a3c*+d1l agent in 5 videos, corresponding to the 5 navigation environments: i-maze5, (small) static maze6, (large) static maze7, (small) random goal maze8 and (large) random goal maze9. each video shows a high-resolution video (the actual inputs to the agent are down-sampled to 84×84 rgb images), the value function over time (with fruit reward and goal acquisitions), the layout of the mazes with consecutive trajectories of the agent marked in different colours and the output of the trained position decoder, overlayed on top of the maze layout.we introduce a class of neural network-based agents that have modular structures and that are trained on multiple tasks, with inputs coming from different modalities (vision, depth, past rewards and past actions). implementing our agent architecture is simplified by its modular nature. essentially, we construct multiple networks, one per task, using shared building blocks, and optimise these networks jointly. some modules, such as the conv-net used for perceiving visual inputs, or the lstms used for learning the navigation policy, are shared among multiple tasks, while other modules, such as depth predictor gd or loop closure predictor gl, are task-specific. the navigation network that outputs the policy and the value function is trained using reinforcement learning, while the depth prediction and loop closure prediction networks are trained using self-supervised learning.
within each thread of the asynchronous training environment, the agent plays on its own episode of the game environment, and therefore sees observation and reward pairs {(st, rt)} and takes actions that are different from those experienced by agents from the other, parallel threads. within a thread, the multiple tasks (navigation, depth and loop closure prediction) can be trained at their own schedule, and they add gradients to the shared parameter vector as they arrive. within each thread, we use a flag-based system to subordinate gradient updates to the a3c reinforcement learning procedure.for all the experiments we use an encoder model with 2 convolutional layers followed by a fully connected layer, or recurrent layer(s), from which we predict the policy and value function. the architecture is similar to the one in (mnih , 2016). the convolutional layers are as follows. the first convolutional layer has a kernel of size 8x8 and a stride of 4x4, and 16 feature maps. the second layer has a kernel of size 4x4 and a stride of 2x2, and 32 feature maps. the fully connected layer, in the ff a3c architecture in figure 2a has 256 hidden units (and outputs visual features ft). the lstm in the lstm a3c architecture has 256 hidden units (and outputs lstm hidden activations ht). the lstms in figure 2c and 2d are fed extra inputs (past reward rt−1, previous action at expressed as a one-hot vector of dimension 8 and agent-relative lateral and rotational velocity vt encoded by a 6-dimensional vector), which are all concatenated to vector ft. the nav a3c architectures (figure 2c,d) have a first lstm with 64 or 128 hiddens and a second lstm with 256 hiddens. the depth predictor modules gd, g′d and the loop closure detection module gl are all single-layer mlps with 128 hidden units. the depth mlps are followed by 64 independent 8-dimensional softmax outputs (one per depth pixel). the loop closure mlp is followed by a 2-dimensional softmax output. we illustrate on figure 8 the architecture of the nav a3c+d+l+dr agent.
depth is taken as the z-buffer from the labyrinth environment (with values between 0 and 255), divided by 255 and taken to power 10 to spread the values in interval [0, 1]. we empirically decided to use the following quantization: {0, 0.05, 0.175, 0.3, 0.425, 0.55, 0.675, 0.8, 1} to ensure a uniform video of the nav a3c*+d1l agent on the i-maze: https://youtu.be/ps4ij7hk_bu 6video of the nav a3c*+d1l agent on static maze 1: https://youtu.be/-hsjqoiou_c 7video of the nav a3c*+d1l agent on static maze 2: https://youtu.be/kh1avraykbi 8video of the nav a3c*+d1l agent on random goal maze 1: https://youtu.be/5ibt2uadjy0 9video of the nav a3c*+d1l agent on random goal maze 2: https://youtu.be/e10mxgbg9yo
binning across 8 classes. the previous version of the agent had a single depth prediction mlp gd for regressing 8× 16 = 128 depth pixels from the convnet outputs ft. the parameters of each of the modules point to a subset of a common vector of parameters. we optimise these parameters using an asynchronous version of rmsprop (tieleman & hinton, 2012). (nair , 2015) was a recent example of asynchronous and parallel gradient updates in deep reinforcement learning; in our case, we focus on the specific asynchronous advantage actor critic (a3c) reinforcement learning procedure in (mnih , 2016).
learning follows closely the paradigm described in (mnih , 2016). we use 16 workers and the same rmsprop algorithm without momentum or centering of the variance. gradients are computed over non-overlaping chunks of the episode. the score for each point of a training curve is the average over all the episodes the model gets to finish in 5e4 environment steps.
the whole experiments are run for a maximum of 1e8 environment step. the agent has an action repeat of 4 as in (mnih , 2016), which means that for 4 consecutive steps the agent will use the same action picked at the beginning of the series. for this reason through out the paper we actually report results in terms of agent perceived steps rather than environment steps. that is, the maximal number of agent perceived step that we do for any particular run is 2.5e7.
in our grid we sample hyper-parameters from categorical distributions:
• learning rate was sampled from [10−4, 5 · 10−4]. • strength of the entropy regularization from [10−4, 10−3]. • rewards were not scaled and not clipped in the new set of experiments. in our previous set
of experiments, rewards were scaled by a factor from {0.3, 0.5} and clipped to 1 prior to back-propagation in the advantage actor-critic algorithm. • gradients are computed over non-overlaping chunks of 50 or 75 steps of the episode. in our
previous set of experiments, we used chunks of 100 steps.
the auxiliary tasks, when used, have hyperparameters sampled from:
• coefficient βd of the depth prediction loss from convnet features ld sampled from {3.33, 10, 33}. • coefficient β′d of the depth prediction loss from lstm hiddens ld′ sampled from {1, 3.33, 10}. • coefficient βl of the loop closure prediction loss ll sampled from {1, 3.33, 10}.
loop closure uses the following thresholds: maximum distance for position similarity η1 = 1 square and minimum distance for removing trivial loop-closures η2 = 2 squares.figure 9 shows additional learning curves. in particular in the left plot we show that the baselines (a3c ff and a3c lstm) as well as nav a3c agent without auxiliary losses, perform worse without reward clipping than with reward clipping. it seems that removing reward clipping makes learning unstable in absence of auxiliary tasks. for this particular reason we chose to show the baselines with reward clipping in our main results.the right subplot of figure 9 compares having depth as an input versus as a target. note that using rgbd inputs to the nav a3c agent performs even worse than predicting depth as a regression task, and in general is worse than predicting depth as a classification task.we have evaluated the behaviour of the agents introduced in this paper, as well as agents with reward prediction, introduced in (jaderberg , 2017) (nav a3c*+r) and with a combination of reward prediction from the convnet and depth prediction from the policy lstm (nav a3c+rd2), on different 3d maze environments with non-navigation specific tasks. in the first environment, seek-avoid arena, there are apples (yielding 1 point) and lemons (yielding -1 point) disposed in an arena, and the agents needs to pick all the apples before respawning; episodes last 20 seconds. the second environment, stairway to melon, is a thin square corridor; in one direction, there is a lemon followed by a stairway to a melon (10 points, resets the level) and in the other direction are 7 apples and a dead end, with the melon visible but not reachable. the agent spawns between the lemon and the apples with a random orientation. both environments have been released in deepmind lab (beattie , 2016). these environments do not require navigation skills such as shortest path planning, but a simple reward identification (lemon vs. apple or melon) and persistent exploration. as figure 10 shows, there is no major difference between auxiliary tasks related to depth prediction or reward prediction. depth prediction boosts the performance of the agent beyond that of the stacked lstm architecture, hinting at a more general applicability of depth prediction beyond navigation tasks.for each of the experiments in this paper, 64 replicas were run with hyperparameters (learning rate, entropy cost) sampled from the same interval. figure 11 shows that the nav architectures with
auxiliary tasks achieve higher results for a comparatively larger number of replicas, hinting at the fact that auxiliary tasks make learning more robust to the choice of hyperparameters.finally, we compared the asymptotic performance of the agents, both in terms of navigation (final rewards obtained at the end of the episode) and in terms of their representation in the policy lstm. rather than visualising the convolutional filters, we quantify the change in representation, with and
without auxiliary task, in terms of position decoding, following the approach explained in section 5.1. specifically, we compare the baseline agent (lstm a3c*) to a navigation agent with one auxiliary task (depth prediction), that gets about twice as many gradient updates for the same number of frames seen in the environment: once for the rl task and once for the auxiliary depth prediction task. as table 3 shows, the performance of the baseline agent as well as the position decoding accuracy do significantly increase after twice the number of training steps (going from 57 points to 90 points, and from 33.4% to 66.5%, but do not reach the performance and position decoding accuracy of the nav a3c+d2 agent after half the number of training frames. for this reason, we believe that the auxiliary task do more than simply accelerate training.",1
444.pdf.json,"neural network language models, especially recurrent neural networks (rnn), are now standard tools for natural language processing. amongst other things, they are used for translation sutskever  (2014), language modelling jozefowicz  (2016), and question answering hewlett  (2016). in particular, the long short term memory (lstm) hochreiter & schmidhuber (1997) architecture has become a basic building block of neural nlp. although lstm’s are regularly used in state of the art systems, their operation is not well understood. besides the basic desire from a scientific viewpoint to clarify their workings, it is often the case that it is important to understand why a machine learning algorithm made a particular choice. moreover, lstm’s are computationally intensive compared to discrete models with lookup tables and pattern matching.
in this work, we describe a novel method for visualizing the importance of specific inputs for determining the output of an lstm. we then demonstrate that, by searching for phrases which are consistently important, the importance scores can be used to extract simple phrase patterns consisting of one to five words from a trained lstm. the phrase extraction is first done in a general document classification framework on two different sentiment analysis datasets. we then demonstrate that it can also be specialized to more complex models by applying it to wikimovies, a recently introduced question answer dataset. to concretely validate the extracted patterns, we use them as input to a rules-based classifier which approximates the performance of the original lstm.there are two lines of related work on visualizing lstms. first, hendrik  (2016) and karpathy  (2016) analyse the movement of the raw gate activations over a sequence. karpathy  (2016) is able to identify co-ordinates of ct that correspond to semantically meaningful attributes such as whether the text is in quotes and how far along the sentence a word is. however, most of the cell co-ordinates are harder to interpret, and in particular, it is often not obvious from their activations which inputs are important for specific outputs.
∗work started during an internship at facebook ai research
another approach that has emerged in the literature alikaniotis  (2016) denil  (2015) bansal  (2016) is for each word in the document, looking at the norm of the derivative of the loss function with respect to the embedding parameters for that word. this bridges the gap between high-dimensional cell state and low-dimensional outputs. these techniques are general- they are applicable to visualizing the importance of sets of input coordinates to output coordinates of any differentiable function. in this work, we describe techniques that are designed around the structure of lstm’s, and show that they can give better results in that setting.
a recent line of work li  (2016) hewlett  (2016) rajpurkar  (2016) miller  (2016) has focused on neural network techniques for extracting answers directly from documents. previous work had focused on knowledge bases (kbs), and techniques to map questions to logical forms suitable for querying them. although they are effective within their domain, kbs are inevitably incomplete, and are thus an unsatisfactory solution to the general problem of question-answering. wikipedia, in contrast, has enough information to answer a far broader array of questions, but is not as easy to query. originally introduced in miller  (2016), the wikimovies dataset consists of questions about movies paired with wikipedia articles.we present a novel decomposition of the output of an lstm into a product of factors, where each term in the product can be interpreted as the contribution of a particular word. thus, we can assign importance scores to words according to their contribution to the lstm’s predictionover the past few years, lstms have become an important part of neural nlp systems. given a sequence of word embeddings x1, ..., xt ∈ rd, an lstm processes one word at a time, keeping track of cell and state vectors (c1, h1), ..., (ct , ht ) which contain information in the sentence up to word i. ht and ct are computed as a function of xt, ct−1 using the below updates
ft = σ(wfxt + vfht−1 + bf ) (1) it = σ(wixt + viht−1 + bi) (2) ot = σ(woxt + voht−1 + bo) (3) c̃t = tanh(wcxt + vcht−1 + bc) (4) ct = ftct−1 + itc̃t (5) ht = ot tanh(ct) (6)
as initial values, we define c0 = h0 = 0. after processing the full sequence, a probability distribution over c classes is specified by p, with
pi = softmax(wht ) = ewiht∑c j=1 e wjht (7)
where wi is the i’th row of the matrix wwe now show that we can decompose the numerator of pi in equation 7 into a product of factors, and interpret those factors as the contribution of individual words to the predicted probability of class i. define βi,j = exp (wi(ot (tanh(cj)− tanh(cj−1))) , (8) so that
exp(wiht ) = exp  t∑ j=1 wi(ot (tanh(cj)− tanh(cj−1))  = t∏ j=1 βi,j .
as tanh(cj)− tanh(cj−1) can be viewed as the update resulting from word j, so βi,j can be interpreted as the multiplicative contribution to pi by word j.we will show below that the βi,j capture some notion of the importance of a word to the lstm’s output. however, these terms fail to account for how the information contributed by word j is affected by the lstm’s forget gates between words j and t . consequently, we empirically found that the importance scores from this approach often yield a considerable amount of false positives. a more nuanced approach is obtained by considering the additive decomposition of ct in equation (9), where each term ej can be interpreted as the contribution to the cell state ct by word j. by iterating the equation ct = ftct−1 + itc̃t, we get that
ct = t∑ i=1 ( t∏ j=i+1 fj)iic̃i = t∑ i=1 ei,t (9)
this suggests a natural definition of an alternative score to the βi,j , corresponding to augmenting the cj terms with products of forget gates to reflect the upstream changes made to cj after initially processing word j.
exp(wiht ) = t∏ j=1 exp
( wi(ot (tanh(
j∑ k=1 ek,t )− tanh( j−1∑ k=1 ek,t )))
) (10)
= t∏ j=1 exp wi(ot (tanh(( t∏ k=j+1 fk)cj)− tanh(( t∏ k=j fk)cj−1)))  (11) =
t∏ j=1 γi,j (12)we now introduce a technique for using our variable importance scores to extract phrases from a trained lstm. to do so, we search for phrases which consistently provide a large contribution to the prediction of a particular class relative to other classes. the utility of these patterns is validated by using them as input for a rules based classifier. for simplicity, we focus on the binary classification case.a phrase can be reasonably described as predictive if, whenever it occurs, it causes a document to both be labelled as a particular class, and not be labelled as any other. as our importance scores introduced above correspond to the contribution of particular words to class predictions, they can be used to score potential patterns by looking at a pattern’s average contribution to the prediction of a given class relative to other classes. more precisely, given a collection of d documents {{xi,j}ndi=1}dj=1, for a given phrase w1, ..., wk we can compute scores s1, s2 for classes 1 and 2, as well as a combined score s and class c as
s1(w1, ..., wk) = averagej,b
{∏k l=1 β1,b+l,j |xb+i,j = wi, i = 1, ..., k } averagej,b {∏k l=1 β2,b+l,j |xb+i,j = wi, i = 1, ..., k
} (13) s2(w1, .., wk) = 1
s1(w1, ..., wk) (14)
s(w1, ..., wk) = max i (si(w1, ..., wk)) (15)
c(w1, ..., wk) = argmaxi(si(w1, ..., wk)) (16)
where βi,j,k denotes βi,j applied to document k.
the numerator of s1 denotes the average contribution of the phrase to the prediction of class 1 across all occurrences of the phrase. the denominator denotes the same statistic, but for class 2. thus, if
s1 is high, then w1, ..., wk is a strong signal for class 1, and likewise for s2. we propose to use s as a score function in order to search for high scoring, representative, phrases which provide insight into the trained lstm, and c to denote the class corresponding to a phrase.
in practice, the number of phrases is too large to feasibly compute the score of them all. thus, we approximate a brute force search through a two step procedure. first, we construct a list of candidate phrases by searching for strings of consecutive words j with importance scores βi,j > c for any i and some threshold c; in the experiments below we use c = 1.1. then, we score and rank the set of candidate phrases, which is much smaller than the set of all phrases.the extracted patterns from section 4.1 can be used to construct a simple, rules-based classifier which approximates the output of the original lstm. given a document and a list of patterns sorted by descending score given by s, the classifier sequentially searches for each pattern within the document using simple string matching. once it finds a pattern, the classifier returns the associated class given by c, ignoring the lower ranked patterns. the resulting classifier is interpretable, and despite its simplicity, retains much of the accuracy of the lstm used to build it.we now present the results of our experiments.we implemented all models in torch using default hyperparameters for weight initializations. for wikimovies, all documents and questions were pre-processed so that multiple word entities were concatenated into a single word. for a given question, relevant articles were found by first extracting from the question the rarest entity, then returning a list of wikipedia articles containing any of those words. we use the pre-defined splits into train, validation and test sets, containing 96k, 10k and 10k questions, respectively. the word and hidden representations of the lstm were both set to dimension 200 for wikimovies, 300 and 512 for yelp, and 300 and 150 for stanford sentiment treebank. all models were optimized using adam kingma & ba (2015) with the default learning rate of 0.001 using early stopping on the validation set. for rule extraction using gradient scores, the product in the reward function is replaced by a sum. in both datasets, we found that normalizing the gradient scores by the largest gradient improved results.we first applied the document classification framework to two different sentiment analysis datasets. originally introduced in zhang  (2015), the yelp review polarity dataset was obtained from the yelp dataset challenge and has train and test sets of size 560,000 and 38,000. the task is binary prediction for whether the review is positive (four or five stars) or negative (one or two stars). the reviews are relatively long, with an average length of 160.1 words. we also used the binary classification task from the stanford sentiment treebank (sst) socher  (2013), which has less data with train/dev/test sizes of 6920/872/1821, and is done at a sentence level, so has much shorter document lengths.
we report results in table 1 for seven different models. we report state of the art results from prior work using convolutional neural networks; kim (2014) for sst and zhang  (2015) for yelp. we also report our lstm baselines, which are competitive with state of the art, along with the three different pattern matching models described above. for sst, we also report prior results using bag of words features with naive bayes.
the additive cell decomposition pattern equals or outperforms the cell-difference patterns, which handily beat the gradient results. this coincides with our empirical observations regarding the information contained within the importance measures, and validates our introduced measure. the differences between measures become more pronounced in yelp, as the longer document sizes provide more opportunities for false positives.
although our pattern matching algorithms underperform other methods, we emphasize that pure performance is not our goal, nor would we expect more from such a simple model. rather, the fact that our method provides reasonable accuracy is one piece of evidence, in addition to the qualitative evidence given later, that our word importance scores and extracted patterns contain useful information for understanding the actions of a lstm.although document classification comprises a sizeable portion of current research in natural language processing, much recent work focuses on more complex problems and models. in this section, we examine wikimovies, a recently introduced question answer dataset, and show that with some simple modifications our approach can be adapted to this problem.wikimovies is a dataset consisting of more than 100,000 questions about movies, paired with relevant wikipedia articles. it was constructed using the pre-existing dataset movielens, paired with templates extracted from the simplequestions dataset bordes  (2015), a open-domain question answering dataset based on freebase. they then selected a set of wikipedia articles about movies by identifying a set of movies from omdb that had an associated article by title match, and kept the title and first section for each article.
for a given question, the task is to read through the relevant articles and extract the answer, which is contained somewhere within the text. the dataso provides a list of 43k entities containing all possible answers.we propose a simplified version of recent work li  (2016). given a pair of question xq1, ..., x q n and document xd1, ..., x d t , we first compute an embedding for the question using a lstm. then, for each word t in the document, we augment the word embedding xt with the computed question embedding. this is equivalent to adding an additional term which is linear in the question embedding into the gate equations 3-6, allowing the patterns an lstm absorbs to be directly conditioned upon the question at hand.
hqt = lstm(x q t ) (17)
ht = lstm(xdt ‖h q n ) (18)
having run the above model over the document while conditioning on a question, we are given contextual representations h1, ..., ht of the words in the document. for each entity t in the document
we use pt to conduct a binary prediction for whether or not the entity is the answer. at test time, we return the entity with the highest probability as the answer.
pt = softmax(wht) (19)we now introduce some simple modifications that were useful in adapting our pattern extraction framework to this specific task. first, in order to define the set of classifications problems to search over, we treat each entity t within each document as a separate binary classification task with corresponding predictor pt. given this set of classification problems, rather than search over the space of all possible phrases, we restrict ourselves to those ending at the entity in question. we also distinguish patterns starting at the beginning of the document with those that do not and introduce an entity character into our pattern vocabulary, which can be matched by any entity. template examples can be seen below, in table 4. once we have extracted a list of patterns, in the rules-based classifier we only search for positive examples, and return as the answer the entity matched to the highest ranked positive pattern.we report results on six different models in tables 2 and 3. we show the results from miller  (2016), which fit a key-value memory network (kv-memnn) on representations from information extraction (ie) and raw text (doc). next, we report the results of the lstm described in section 5.3.2. finally, we show the results of using three variants of the pattern matching algorithm described in section 5.3.3: using patterns extracted using the additive decomposition (cell decomposition), difference in cells approaches (cell-difference) and gradient importance scores (gradient), as discussed in section 2. performance is reported using the accuracy of the top hit over all possible answers (all entities), i.e. the hits@1 metric.
as shown in table 2, our lstm model surpasses the prior state of the art by nearly 4%. moreover, our automatic pattern matching model approximates the lstm with less than 6% error, which is surprisingly small for such a simple model, and falls within 2% of the prior state of the art. similarly to sentiment analysis, we observe a clear ordering of the results across question categories, with our cell decomposition scores providing the best performance, followed by the cell difference and gradient scores.we present extracted patterns for both sentiment tasks, and some wikimovies question categories in table 4. these patterns are qualitatively sensible, providing further validation of our approach. the increased size of the yelp datasowed for longer phrases to be extracted relative to sst.
category top patterns yelp polarity positive definitely come back again., love love love this
place, great food and great service., highly recommended!, will definitely be coming back, overall great experience, love everything about, hidden gem.
yelp polarity negative worst customer service ever, horrible horrible horrible, won’t be back, disappointed in this place, never go back there, not worth the money, not recommend this place sst positive riveting documentary, is a real charmer, funny and touching, well worth your time, journey of the heart, emotional wallop, pleasure to watch, the whole family, cast is uniformly superb, comes from the heart, best films of the year, surprisingly funny, deeply satisfying sst negative pretentious mess ..., plain bad, worst film of the year, disappointingly generic, fart jokes, banal dialogue, poorly executed, waste of time, a weak script, dullard, how bad it is, platitudes, never catches fire, tries too hard to be, bad acting, untalented artistes, derivative horror film, lackluster wikimovies movie to writer film adaptation of charles dickens’, film adapted from ent, by journalist ent, written by ent wikimovies movie to actor western film starring ent, starring ben affleck, . the movie stars ent, that stars ent wikimovies movie to language is a 2014 french, icelandic, finnish, russian, danish, bengali, dutch, original german, zulu,czech, estonian, mandarin, filipino, hungarian
table 4: selected top patterns using cell decomposition scores, ent denotes an entity placeholderalthough our approach is able to extract sensible patterns and achieve reasonable performance, there is still an approximation gap between our algorithm and the lstm. in table 5 we present some examples of instances where the lstm was able to correctly classify a sentence, and our algorithm was not, along with the pattern used by our algorithm. at first glance, the extracted patterns are sensible, as ”gets the job done” or ”witty dialogue” are phrases you’d expect to see in a positive review of a movie. however, when placed in the broader context of these particular reviews, they cease to be predictive. this demonstrates that, although our work is useful as a firstorder approximation, there are still additional relationships that an lstm is able to learn from data.while the prediction accuracy of our rules-based classifier provides quantitative validation of the relative merits of our visualizations, the qualitative differences are also insightful. in table 6, we provide a side-by-side comparison between the different measures. as discussed before, the difference in cells technique fails to account for how the updates resulting from word j are affected by the lstm’s forget gates between when the word is initially processed and the answer. consequently, we empirically found that without the interluding forget gates to dampen cell movements, the variable importance scores were far noisier than in additive cell decomposition approach. under the additive cell decomposition, it identifies the phrase ’it stars’, as well as the actor’s name aqib khan as being important, a sensible conclusion. moreover, the vast majority of words are labelled with an importance score of 1, corresponding to irrelevant. on the other hand, the difference in cells approach yields widely changing importance scores, which are challenging to interpret. in terms of noise, the gradient measures seem to lie somewhere in the middle. these patterns are broadly consistent with what we have observed, and provide qualitative validation of our metrics.in this paper, we introduced a novel method for visualizing the importance of specific inputs in determining the output of an lstm. by searching for phrases which consistently provide large contributions, we are able to distill trained, state of the art, lstms into an ordered set of representative phrases. we quantitatively validate the extracted phrases through their performance in a simple, rules-based classifier. results are shown in a general document classification framework, then specialized to a more complex, recently introduced, question answer dataset. our introduced measures provide superior predictive ability and cleaner visualizations relative to prior work. we believe that this represents an exciting new paradigm for analysing the behaviour of lstm’s.
additive cell decomposition difference in cell values gradient
west is west is a 2010 british comedy - drama film , which is a sequel to the 1999 comedy ”
east is east ” . it stars aqib khan
west is west is a 2010 british comedy -
drama film , which is a sequel to the 1999 comedy ” east is east ” . it starsaqib khan
west is west is a 2010 british comedy - drama film , which is a sequel to the 1999 comedy ” east is east ”. itstars aqib khan
table 6: comparison of importance scores acquired by three different approaches, conditioning on the question ”the film west is west starred which actors?”. bigger and darker means more important.this research was partially funded by air force grant fa9550-14-1-0016. it was also supported by the center for science of information (csoi), an us nsf science and technology center, under grant agreement ccf-0939370.we provide an example heat map using the cell decomposition metric for each class in both sentiment analysis datasets, and selected wikimovie question categories
dataset category heat map
yelp polarity positive we went here twice for breakfast . had the bananas foster waffles with fresh whipped cream , they were amazing ! ! perfect seat out side on the terrace
yelp polarity negative call me spoiled ...this sushi is gross and the orange chicken , well it was so thin i don ’t think it had chicken in it. gosomewhereelse
stanford sentiment positive whether or not you ’re enlightened by any of derrida ’s lectures on “ the other ” and “ the self ,
” derrida is an undeniablyfascinatingandplayfulfellow
stanford sentiment negative ... begins with promise , but runs aground after being snared in its own tangled plot
pattern question heat map
movie to year what was the release year of another 48 hours?
another 48 hrs is a 1990
movie to writer which person wrote the movie last of the dogmen? last of the dogmen is a 1995 western adventure film written and directed by tab murphy
movie to actor who acted in the movie thunderbolt? thunderbolt ( ) ( ” piklik foh ” ) is a 1995 hong kong action filmstarring jackie chan
movie to director who directed bloody bloody bible camp? bloody bloody bible cam p is a 2012 american horror - comedy /s platter film . the film
was directed by vito trabucco
movie to genre what genre is trespass in? trespassisa 1992 action movie to votes how would people rate the pool? though filmed in hindi , a language smith didn ’t know , the film earned
good∗ movie to rating how popular was les miserables? les mis rables is a 1935 american drama film starring fredric march and charles laughton
based upon thefamous movie to tags describe rough magic?
rough magic is a 1995 comedy film directed by clare peploe and starring bridget fonda , russell crowe
movie to language what is the main language in fate?
fate ( ) is a 2001 turkish",1
457.pdf.json,"deep convolutional neural networks (cnns) have demonstrated record breaking results on a variety of computer vision tasks such as image classification (krizhevsky , 2012; simonyan & zisserman, 2015), face recognition (taigman , 2014; sun , 2014), semantic segmentation (long , 2015; chen , 2015a) and object detection (girshick, 2015; ren , 2015). regardless of the availability of significantly improved training resources such as abundant annotated data, powerful computational platforms and diverse training frameworks, the promising results of deep cnns are mainly attributed to the large number of learnable parameters, ranging from tens of millions to even hundreds of millions. recent progress further shows clear evidence that cnns could easily enjoy the accuracy gain from the increased network depth and width (he , 2016; szegedy , 2015; 2016). however, this in turn lays heavy burdens on the memory and other
∗this work was done when aojun zhou was an intern at intel labs china, supervised by anbang yao who proposed the original idea and is responsible for correspondence. the first three authors contributed equally to the writing of the paper. this notation applies to our method throughout the paper.
computational resources. for instance, resnet-152, a specific instance of the latest residual network architecture wining imagenet classification challenge in 2015, has a model size of about 230 mb and needs to perform about 11.3 billion flops to classify a 224× 224 image crop. therefore, it is very challenging to deploy deep cnns on the devices with limited computation and power budgets.
substantial efforts have been made to the speed-up and compression on cnns during training, feedforward test or both of them. among existing methods, the category of network quantization methods attracts great attention from researches and developers. some network quantization works try to compress pre-trained full-precision cnn models directly. gong  (2014) address the storage problem of alexnet (krizhevsky , 2012) with vector quantization techniques. by replacing the weights in each of the three fully connected layers with respective floating-point centroid values obtained from the clustering, they can get over 20× model compression at about 1% loss in top-5 recognition rate. hashednet (chen , 2015b) uses a hash function to randomly map pre-trained weights into hash buckets, and all the weights in the same hash bucket are constrained to share a single floating-point value. in hashednet, only the fully connected layers of several shallow cnn models are considered. for better compression, han  (2016) present deep compression method which combines the pruning (han , 2015), vector quantization and huffman coding, and reduce the model storage by 35× on alexnet and 49× on vgg-16 (simonyan & zisserman, 2015). vanhoucke  (2011) use an sse 8-bit fixed-point implementation to improve the computation of neural networks on the modern intel x86 cpus in feed-forward test, yielding 3× speed-up over an optimized floating-point baseline. training cnns by substituting the 32-bit floating-point representation with the 16-bit fixed-point representation has also been explored in gupta  (2015). other seminal works attempt to restrict cnns into low-precision versions during training phase. soudry  (2014) propose expectation backpropagation (ebp) to estimate the posterior distribution of deterministic network weights. with ebp, the network weights can be constrained to +1 and -1 during feed-forward test in a probabilistic way. binaryconnect (courbariaux , 2015) further extends the idea behind ebp to binarize network weights during training phase directly. it has two versions of network weights: floating-point and binary. the floating-point version is used as the reference for weight binarization. binaryconnect achieves state-of-the-art accuracy using shallow cnns for small datasets such as mnist (lecun , 1998) and cifar-10. later on, a series of efforts have been invested to train cnns with low-precision weights, low-precision activations and even low-precision gradients, including but not limited to binarynet (courbariaux , 2016), xnor-net (rastegari , 2016), ternary weight network (twn) (li & liu, 2016), dorefa-net (zhou , 2016) and quantized neural network (qnn) (hubara , 2016).
despite these tremendous advances, cnn quantization still remains an open problem due to two critical issues which have not been well resolved yet, especially under scenarios of using low-precision weights for quantization. the first issue is the non-negligible accuracy loss for cnn quantization methods, and the other issue is the increased number of training iterations for ensuring convergence. in this paper, we attempt to address these two issues by presenting a novel incremental network quantization (inq) method.
in our inq, there is no assumption on the cnn architecture, and its basic goal is to efficiently convert any pre-trained full-precision (i.e., 32-bit floating-point) cnn model into a low-precision version whose weights are constrained to be either powers of two or zero. the advantage of such kind of low-precision models is that the original floating-point multiplication operations can be replaced by cheaper binary bit shift operations on dedicated hardware like fpga. we noticed that most existing network quantization methods adopt a global strategy in which all the weights are simultaneously converted to low-precision ones (that are usually in the floating-point types). that is, they have not considered the different importance of network weights, leaving the room to retain network accuracy limited. in sharp contrast to existing methods, our inq makes a very careful handling for the model accuracy drop from network quantization. to be more specific, it incorporates three interdependent operations: weight partition, group-wise quantization and re-training. weight partition uses a pruning-inspired measure (han , 2015; guo , 2016) to divide the weights in each layer of a pre-trained full-precision cnn model into two disjoint groups which play complementary roles in our inq. the weights in the first group are quantized to be either powers of two or zero by a variable-length encoding method, forming a low-precision base for the original model. the weights in the other group are re-trained while keeping the quantized weights fixed, compensating for the accuracy loss resulted from the quantization. furthermore, these three operations are repeated on the
latest re-trained weight group in an iterative manner until all the weights are quantized, acting as an incremental network quantization and accuracy enhancement procedure (as illustrated in figure 1).
the main insight of our inq is that a compact combination of the proposed weight partition, groupwise quantization and re-training operations has the potential to get a lossless low-precision cnn model from any full-precision reference. we conduct extensive experiments on the imagenet large scale classification task using almost all known deep cnn architectures to validate the effectiveness of our method. we show that: (1) for alexnet, vgg-16, googlenet and resnets with 5-bit quantization, inq achieves improved accuracy in comparison with their respective full-precision baselines. the absolute top-1 accuracy gain ranges from 0.13% to 2.28%, and the absolute top-5 accuracy gain is in the range of 0.23% to 1.65%. (2) inq has the property of easy convergence in training. in general, re-training with less than 8 epochs could consistently generate a lossless model with 5-bit weights in the experiments. (3) taking resnet-18 as an example, our quantized models with 4-bit, 3-bit and 2-bit ternary weights also have improved or very similar accuracy compared with its 32-bit floating-point baseline. (4) taking alexnet as an example, the combination of our network pruning and inq outperforms deep compression method (han , 2016) with significant margins.in this section, we clarify the insight of our inq, describe its key components, and detail its implementation.suppose a pre-trained full-precision (i.e., 32-bit floating-point) cnn model can be represented by {wl : 1 ≤ l ≤ l}, where wl denotes the weight set of the lth layer, and l denotes the number of learnable layers in the model. to simplify the explanation, we only consider convolutional layers and fully connected layers. for cnn models like alexnet, vgg-16, googlenet and resnets as tested in this paper, wl can be a 4d tensor for the convolutional layer, or a 2d matrix for the fully connected layer. for simplicity, here the dimension difference is not considered in the expression. given a pre-trained full-precision cnn model, the main goal of our inq is to convert all 32-bit floating-point weights to be either powers of two or zero without loss of model accuracy. besides, we also attempt to explore the limit of the expected bit-width under the premise of guaranteeing lossless network quantization. here, we start with our basic network quantization method on how to
convert wl to be a low-precision version ŵl, and each of its entries is chosen from
pl = {±2n1 , · · · ,±2n2 , 0}, (1)
where n1 and n2 are two integer numbers, and they satisfy n2 ≤ n1. mathematically, n1 and n2 help to bound pl in the sense that its non-zero elements are constrained to be in the range of either [−2n1 ,−2n2 ] or [2n2 , 2n1 ]. that is, network weights with absolute values smaller than 2n2 will be pruned away (i.e., set to zero) in the final low-precision model. obviously, the problem is how to determine n1 and n2. in our inq, the expected bit-width b for storing the indices in pl is set beforehand, thus the only hyper-parameter shall be determined is n1 because n2 can be naturally computed once b and n1 are available. here, n1 is calculated by using a tricky yet practically effective formula as
n1 = floor(log2(4s/3)), (2)
where floor(·) indicates the round down operation and s is calculated by using
s = max(abs(wl)), (3)
where abs(·) is an element-wise operation and max(·) outputs the largest element of its input. in fact, equation (2) helps to match the rounding power of 2 for s, and it could be easily implemented in practical programming. after n1 is obtained, n2 can be naturally determined as n2 = n1 + 1 − 2(b−1)/2. for instance, if b = 3 and n1 = −1, it is easy to get n2 = −2. once pl is determined, we further use the ladder of powers to convert every entry of wl into a low-precision one by using
ŵl(i, j) = { βsgn(wl(i, j)) if (α+ β)/2 ≤ abs(wl(i, j)) < 3β/2 0 otherwise,
(4)
where α and β are two adjacent elements in the sorted pl, making the above equation as a numerical rounding to the quantum values. it should be emphasized that factor 4/3 in equation (2) is set to make sure that all the elements in pl correspond with the quantization rule defined in equation (4). in other words, factor 4/3 in equation (2) highly correlates with factor 3/2 in equation (4).
here, an important thing we want to clarify is the definition of the expected bit-width b. taking 5-bit quantization as an example, since zero value cannot be written as the power of two, we use 1 bit to represent zero value, and the remaining 4 bits to represent at most 16 different values for the powers of two. that is, the number of candidate quantum values is at most 2b−1 + 1, so our quantization method actually adopts a variable-length encoding scheme. it is clear that the quantization described above is performed in a linear scale. an alternative solution is to perform the quantization in the log scale. although it may also be effective, it should be a little bit more difficult in implementation and may cause some extra computational overhead in comparison to our method.we can naturally use the above described method to quantize any pre-trained full-precision cnn model. however, noticeable accuracy loss appeared in the experiments when using small bit-width values (e.g., 5-bit, 4-bit, 3-bit and 2-bit).
in the literature, there are many existing network quantization works such as hashednet (chen , 2015b), vector quantization (gong , 2014), fixed-point representation (vanhoucke , 2011; gupta , 2015), binaryconnect (courbariaux , 2015), binarynet (courbariaux , 2016), xnor-net (rastegari , 2016), twn (li & liu, 2016), dorefa-net (zhou , 2016) and qnn (hubara , 2016). similar to our basic network quantization method, they also suffer from non-negligible accuracy loss on deep cnns, especially when being applied on the imagenet large scale classification dataset. for all these methods, a common fact is that they adopt a global strategy in which all the weights are simultaneously converted into low-precision ones, which in turn causes accuracy loss. compared with the methods focusing on the pre-trained models, accuracy loss becomes worse for the methods such as xnor-net, twn, dorefa-net and qnn which intend to train low-precision cnns from scratch.
recall that our main goal is to achieve lossless low-precision quantization for any pre-trained fullprecision cnn model with no assumption on its architecture. to this end, our inq makes a special
handling of the strategy for suppressing resulting quantization loss in model accuracy. we are partially inspired by the latest progress in network pruning (han , 2015; guo , 2016). in these methods, the accuracy loss from removing less important network weights of a pre-trained neural network model could be well compensated by following re-training steps. therefore, we conjecture that the nature of changing network weight importance is critical to achieve lossless network quantization.
base on this assumption, we present inq which incorporates three interdependent operations: weight partition, group-wise quantization and re-training. weight partition is to divide the weights in each layer of a pre-trained full-precision cnn model into two disjoint groups which play complementary roles in our inq. the weights in the first group are responsible for forming a low-precision base for the original model, thus they are quantized by using equation (4). the weights in the second group adapt to compensate for the loss in model accuracy, thus they are the ones to be re-trained. once the first run of the quantization and re-training operations is finished, all the three operations are further conducted on the second weight group in an iterative manner, until all the weights are converted to be either powers of two or zero, acting as an incremental network quantization and accuracy enhancement procedure. as a result, accuracy loss under low-precision cnn quantization can be well suppressed by our inq. illustrative results at iterative steps of our inq are provided in figure 2.
for the lth layer, weight partition can be defined as
a (1) l ∪a (2) l = {wl(i, j)}, and a (1) l ∩a (2) l = ∅, (5)
where a(1)l denotes the first weight group that needs to be quantized, and a2 denotes the other weight group that needs to be re-trained. we leave the strategies for group partition to be chosen in the experiment section. here, we define a binary matrix tl to help distinguish above two categories of weights. that is, tl(i, j) = 0 means wl(i, j) ∈ a(1)l , and tl(i, j) = 1 means wl(i, j) ∈ a(2)l .now, we come to the training method. taking the lth layer as an example, the basic optimization problem of making its weights to be either powers of two or zero can be expressed as
min wl e(wl) = l(wl) + λr(wl)
s.t. wl(i, j) ∈ pl, 1 ≤ l ≤ l, (6)
where l(wl) is the network loss, r(wl) is the regularization term, λ is a positive coefficient, and the constraint term indicates each weight entry wl(i, j) should be chosen from the set pl consisting of a fixed number of the values of powers of two plus zero. direct solving above optimization problem in training from scratch is challenging since it is very easy to undergo convergence problem.
by performing weight partition and group-wise quantization operations beforehand, the optimization problem defined in (6) can be reshaped into a easier version. that is, we only need to optimize the following objective function
min wl e(wl) = l(wl) + λr(wl)
s.t. wl(i, j) ∈ pl, if tl(i, j) = 0, 1 ≤ l ≤ l, (7)
where pl is determined at group-wise quantization operation, and the binary matrix tl acts as a mask which is determined by weight partition operation. since pl and tl are known, the optimization problem (7) can be solved using popular stochastic gradient decent (sgd) method. that is, in inq, we can get the update scheme for the re-training as
wl(i, j)←wl(i, j)− γ ∂e
∂(wl(i, j)) tl(i, j), (8)
where γ is a positive learning rate. note that the binary matrix tl forces zero update to the weights that have been quantized. that is, only the weights still keep with floating-point values are updated, akin to the latest pruning methods (han , 2015; guo , 2016) in which only the weights that are not currently removed are re-trained to enhance network accuracy. the whole procedure of our inq is summarized as algorithm 1.
we would like to highlight that the merits of our inq are in three aspects: (1) weight partition introduces the importance-aware weight quantization. (2) group-wise weight quantization introduces much less accuracy loss than simultaneously quantizing all the network weights, thus making retraining have larger room to recover model accuracy. (3) by integrating the operations of weight partition, group-wise quantization and re-training into a nested loop, our inq has the potential to obtain lossless low-precision cnn model from the pre-trained full-precision reference.
algorithm 1 incremental network quantization for lossless cnns with low-precision weights. input: x: the training data, {wl : 1 ≤ l ≤ l}: the pre-trained full-precision cnn model, {σ1, σ2, · · · , σn}: the accumulated portions of weights quantized at iterative steps output: {ŵl : 1 ≤ l ≤ l}: the final low-precision model with the weights constrained to be either powers of two or zero : initialize a(1)l ← ∅, a (2) l ← {wl(i, j)}, tl ← 1, for 1 ≤ l ≤ l 2: for n = 1, 2, . . . , n do 3: reset the base learning rate and the learning policy 4: according to σn, perform layer-wise weight partition and update a (1) l , a (2) l and tl 5: based on a(1)l , determine pl layer-wisely 6: quantize the weights in a(1)l by equation (4) layer-wisely 7: calculate feed-forward loss, and update weights in {a(2)l : 1 ≤ l ≤ l} by equation (8) 8: end forto analyze the performance of our inq, we perform extensive experiments on the imagenet large scale classification task, which is known as the most challenging image classification benchmark so far. imagenet dataset has about 1.2 million training images and 50 thousand validation images. each image is annotated as one of 1000 object classes. we apply our inq to alexnet, vgg-16, googlenet, resnet-18 and resnet-50, covering almost all known deep cnn architectures. using the center crops of validation images, we report the results with two standard measures: top-1 error rate and top-5 error rate. for fair comparison, all pre-trained full-precision (i.e., 32-bit floatingpoint) cnn models except resnet-18 are taken from the caffe model zoo2. note that he  (2016) do not release their pre-trained resnet-18 model to the public, so we use a publicly available re-implementation by facebook3. since our method is implemented with caffe, we make use of an open source tool4 to convert the pre-trained resnet-18 model from torch to caffe.setting expected bit-width to 5, the first set of experiments is performed to testify the efficacy of our inq on different cnn architectures. regarding weight partition, there are several candidate strategies as we tried in our previous work for efficient network pruning (guo , 2016). in guo  (2016), we found random partition and pruning-inspired partition are the two best choices compared with the others. thus in this paper, we directly compare these two strategies for weight partition. in random strategy, the weights in each layer of any pre-trained full-precision deep cnn model are randomly split into two disjoint groups. in pruning-inspired strategy, the weights are divided into two disjoint groups by comparing their absolute values with layer-wise thresholds which are automatically determined by a given splitting ratio. here we directly use pruning-inspired strategy and the experimental results in section 3.2 will show why. after the re-training with no more than 8 epochs over each pre-trained full-precision model, we obtain the results as shown in table 1. it can be concluded that the 5-bit cnn models generated by our inq show consistently improved top-1 and top-5 recognition rates compared with respective full-precision references. parameter settings are described below.
alexnet: alexnet has 5 convolutional layers and 3 fully-connected layers. we set the accumulated portions of quantized weights at iterative steps as {0.3, 0.6, 0.8, 1}, the batch size as 256, the weight decay as 0.0005, and the momentum as 0.9.
vgg-16: compared with alexnet, vgg-16 has 13 convolutional layers and more parameters. we set the accumulated portions of quantized weights at iterative steps as {0.5, 0.75, 0.875, 1}, the batch size as 32, the weight decay as 0.0005, and the momentum as 0.9. https://github.com/bvlc/caffe/wiki/model-zoo 3https://github.com/facebook/fb.resnet.torch/tree/master/pretrained 4https://github.com/zhanghang1989/fb-caffe-exts
googlenet: compared with alexnet and vgg-16, googlenet is more difficult to quantize due to a smaller number of parameters and the increased network width. we set the accumulated portions of quantized weights at iterative steps as {0.2, 0.4, 0.6, 0.8, 1}, the batch size as 80, the weight decay as 0.0002, and the momentum as 0.9.
resnet-18: different from above three networks, resnets have batch normalization layers and relief the vanishing gradient problem by using shortcut connections. we first test the 18-layer version for exploratory purpose and test the 50-layer version later on. the network architectures of resnet18 and resnet-34 are very similar. the only difference is the number of filters in every convolutional layer. we set the accumulated portions of quantized weights at iterative steps as {0.5, 0.75, 0.875, 1}, the batch size as 80, the weight decay as 0.0005, and the momentum as 0.9. resnet-50: besides significantly increased network depth, resnet-50 has a more complex network architecture in comparison to resnet-18. however, regarding network architecture, resnet-50 is very similar to resnet-101 and resnet-152. the only difference is the number of filters in every convolutional layer. we set the accumulated portions of quantized weights at iterative steps as {0.5, 0.75, 0.875, 1}, the batch size as 32, the weight decay as 0.0005, and the momentum as 0.9.in our inq, the first operation is weight partition whose result will directly affect the following group-wise quantization and re-training operations. therefore, the second set of experiments is conducted to analyze two candidate strategies for weight partition. as mentioned in the previous section, we use pruning-inspired strategy for weight partition. unlike random strategy in which all the weights have equal probability to fall into the two disjoint groups, pruning-inspired strategy considers that the weights with larger absolute values are more important than the smaller ones to form a low-precision base for the original cnn model. we use resnet-18 as a test case to compare the performance of these two strategies. in the experiments, the parameter settings are completely the same as described in section 3.1. we set 4 epochs for weight re-training. table 2 summarizes the results of our inq with 5-bit quantization. it can be seen that our inq achieves top-1 error rate of 32.11% and top-5 error rate of 11.73% by using random partition. comparatively, pruning-inspired partition brings 1.09% and 0.83% decrease in top-1 and top-5 error rates, respectively. apparently, pruning-inspired partition is better than random partition, and this is the reason why we use it in this paper. for future works, weight partition based on quantization error could also be an option worth exploring.the third set of experiments is performed to explore the limit of the expected bit-width under which our inq can still achieve lossless network quantization. similar to the second set of experiments, we also use resnet-18 as a test case, and the parameter settings for the batch size, the weight decay and the momentum are completely the same. finally, lower-precision models with 4-bit, 3-bit and even 2-bit ternary weights are generated for comparisons. as the expected bit-width goes down, the number of candidate quantum values will be decreased significantly, thus we shall increase the number of iterative steps accordingly for enhancing the accuracy of final low-precision model. specifically, we set the accumulated portions of quantized weights at iterative steps as {0.3, 0.5, 0.8, 0.9, 0.95, 1}, {0.2, 0.4, 0.6, 0.7, 0.8, 0.9, 0.95, 1} and {0.2, 0.4, 0.6, 0.7, 0.8, 0.85, 0.9, 0.95, 0.975, 1} for 4-bit, 3-bit and 2-bit ternary models, respectively. the required number of epochs also increases when the expected bit-width goes down, and it reaches 30 when training our 2-bit ternary model. although our 4-bit model shows slightly decreased accuracy when compared with the 5-bit model, its accuracy is still better than that of the pre-trained full-precision model. comparatively, even when the expected bit-width goes down to 3, our low-precision model shows only 0.19% and .33% losses in top-1 and top-5 recognition rates, respectively. as for our 2-bit ternary model, although it incurs 2.25% decrease in top-1 error rate and 1.56% decrease in top-5 error rate in comparison to the pre-trained full-precision reference, its accuracy is considerably better than stateof-the-art results reported for binary-weight network (bwn) (rastegari , 2016) and ternary weight network (twn) (li & liu, 2016). detailed results are summarized in table 3 and table 4.in the literature, recently proposed deep compression method (han , 2016) reports so far best results on network compression without loss of model accuracy. therefore, the last set of experiments is conducted to explore the potential of our inq for much better deep compression. note that han  (2016) is a hybrid network compression solution combining three different techniques, namely network pruning (han , 2015), vector quantization (gong , 2014) and huffman coding. taking alexnet as an example, network pruning gets 9× compression, however this result is mainly obtained from the fully connected layers. actually its compression performance on the convolutional layers is less than 3× (as can be seen in the table 4 of han  (2016)). besides, network pruning is realized by separately performing pruning and re-training in an iterative way, which is very time-consuming. it will cost at least several weeks for compressing alexnet. we solved this problem by our dynamic network surgery (dns) method (guo , 2016) which achieves about 7× speed-up in training and improves the performance of network pruning from 9× to 17.7×. in han  (2016), after network pruning, vector quantization further improves compression ratio from 9× to 27×, and huffman coding finally boosts compression ratio up to 35×. for fair comparison, we combine our proposed inq and dns, and compare the resulting method with han  (2016). detailed results are summarized in table 5. when combing our proposed inq and dns, we achieve much better compression results compared with han  (2016). specifically, with 5-bit quantization, we can achieve 53× compression with slightly larger gains both in top-5 and top-1 recognition rates, yielding 51.43%/96.30% absolute improvement in compression performance compared with full version/fair version (i.e., the combination of network pruning and vector quantization) of han  (2016), respectively. consistently better results have also obtained for our 4-bit and 3-bit models.
besides, we also perform a set of experiments on alexnet to compare the performance of our inq and vector quantization (gong , 2014). for fair comparison, re-training is also used to enhance the performance of vector quantization, and we set the number of cluster centers for all of 5 convolutional layers and 3 fully connect layers to 32 (i.e., 5-bit quantization). in the experiment, vector quantization incurs over 3% loss in model accuracy. when we change the number of cluster centers for convolutional layers from 32 to 128, it gets an accuracy loss of 0.98%. this is consistent with the results reported in (gong , 2014). comparatively, vector quantization is mainly proposed
to compress the parameters in the fully connected layers of a pre-trained full-precision cnn model, while our inq addresses all network layers simultaneously and has no accuracy loss for 5-bit and 4-bit quantization. therefore, it is evident that our inq is much better than vector quantization. last but not least, the final weights for vector quantization (gong , 2014), network pruning (han , 2015) and deep compression (han , 2016) are still floating-point values, but the final weights for our inq are in the form of either powers of two or zero. the direct advantage of our inq is that the original floating-point multiplication operations can be replaced by cheaper binary bit shift operations on dedicated hardware like fpga.in this paper, we present inq, a new network quantization method, to address the problem of how to convert any pre-trained full-precision (i.e., 32-bit floating-point) cnn model into a lossless lowprecision version whose weights are constrained to be either powers of two or zero. unlike existing methods which usually quantize all the network weights simultaneously, inq is a more compact quantization framework. it incorporates three interdependent operations: weight partition, groupwise quantization and re-training. weight partition splits the weights in each layer of a pre-trained full-precision cnn model into two disjoint groups which play complementary roles in inq. the weights in the first group is directly quantized by a variable-length encoding method, forming a low-precision base for the original cnn model. the weights in the other group are re-trained while keeping all the quantized weights fixed, compensating for the accuracy loss from network quantization. more importantly, the operations of weight partition, group-wise quantization and re-training are repeated on the latest re-trained weight group in an iterative manner until all the weights are quantized, acting as an incremental network quantization and accuracy enhancement procedure. on the imagenet large scale classification task, we conduct extensive experiments and show that our quantized cnn models with 5-bit, 4-bit, 3-bit and even 2-bit ternary weights have improved or at least comparable accuracy against their full-precision baselines, including alexnet, vgg-16, googlenet and resnets. as for future works, we plan to extend incremental idea behind inq from low-precision weights to low-precision activations and low-precision gradients (we have actually already made some good progress on it, as shown in our supplementary materials). we will also investigate computation and power efficiency by implementing our low-precision cnn models on hardware platforms.taking our 5-bit alexnet model as an example, we analyze the distribution of the quantized weights. detailed statistical results are summarized in table 6. we can find: (1) in the 1st and 2nd convolutional layers, the values of {−2−6, −2−5, −2−4, 2−6, 2−5, 2−4} and {−2−8, −2−7, −2−6, −2−5, 0, 2−8, 2−7, 2−6, 2−5} occupy over 60% and 94% of all quantized weights, respectively; (2) the distributions of the quantized weights in the 3rd, 4th and 5th convolutional layers are similar to that of the 2nd convolutional layer, and more weights are quantized into zero in the 2nd, 3rd, 4th and 5th convolutional layers compared with the 1st convolutional layer; (3) in the 1st fully connected layer, the values of {−2−10, −2−9, −2−8, −2−7, 0, 2−10, 2−9, 2−8, 2−7} occupy about 98% of all quantized weights, and similar results can be seen for the 2nd fully connected layer; (4) generally, the distributions of the quantized weights in the convolutional layers are usually more scattered compared with the fully connected layers. this may be partially the reason why it is much easier to get good compression performance on fully connected layers in comparison to convolutional layers, when using methods such as network hashing (chen , 2015b) and vector quantization (gong , 2014); (5) for 5-bit alexnet model, the required bit-width for each layer is actually 4 but not 5.recently, we have made some good progress on developing our inq for lossless cnns with both low-precision weights and low-precision activations. according to the results summarized in table 7, it can be seen that our vgg-16 model with 5-bit weights and 4-bit activations shows improved top-5 and top-1 recognition rates in comparison to the pre-trained reference with 32-bit floating-point weights and 32-bit floating-point activations. to the best of our knowledge, this should be the best results reported on vgg-16 architecture so far.",1
460.pdf.json,"realistic simulated environments, where agents can be trained to learn a large repertoire of cognitive skills, are at the core of recent breakthroughs in ai (bellemare , 2013; mnih , 2015; schulman , 2015a; narasimhan , 2015; mnih , 2016; brockman , 2016; oh , 2016). with richer realistic environments, the capabilities of our agents have increased and improved. unfortunately, these advances have been accompanied by a substantial increase in the cost of simulation. in particular, every time an agent acts upon the environment, an expensive simulation step is conducted. thus to reduce the cost of simulation, we need to reduce the number of simulation steps (i.e. samples of the environment). this need for sample efficiency is even more compelling when agents are deployed in the real world.
experience replay (lin, 1992) has gained popularity in deep q-learning (mnih , 2015; schaul , 2016; wang , 2016; narasimhan , 2015), where it is often motivated as a technique for reducing sample correlation. replay is actually a valuable tool for improving sample efficiency and, as we will see in our experiments, state-of-the-art deep q-learning methods (schaul , 2016; wang , 2016) have been up to this point the most sample efficient techniques on atari by a significant margin. however, we need to do better than deep q-learning, because it has two important limitations. first, the deterministic nature of the optimal policy limits its use in adversarial domains. second, finding the greedy action with respect to the q function is costly for large action spaces.
policy gradient methods have been at the heart of significant advances in ai and robotics (silver , 2014; lillicrap , 2015; silver , 2016; levine , 2015; mnih , 2016; schulman , 2015a; heess , 2015). many of these methods are restricted to continuous domains or to very specific tasks such as playing go. the existing variants applicable to both continuous and discrete domains, such as the on-policy asynchronous advantage actor critic (a3c) of mnih  (2016), are sample inefficient.
the design of stable, sample efficient actor critic methods that apply to both continuous and discrete action spaces has been a long-standing hurdle of reinforcement learning (rl). we believe this paper
is the first to address this challenge successfully at scale. more specifically, we introduce an actor critic with experience replay (acer) that nearly matches the state-of-the-art performance of deep q-networks with prioritized replay on atari, and substantially outperforms a3c in terms of sample efficiency on both atari and continuous control domains.
acer capitalizes on recent advances in deep neural networks, variance reduction techniques, the off-policy retrace algorithm (munos , 2016) and parallel training of rl agents (mnih , 2016). yet, crucially, its success hinges on innovations advanced in this paper: truncated importance sampling with bias correction, stochastic dueling network architectures, and efficient trust region policy optimization.
on the theoretical front, the paper proves that the retrace operator can be rewritten from our proposed truncated importance sampling with bias correction technique.consider an agent interacting with its environment over discrete time steps. at time step t, the agent observes the nx-dimensional state vector xt ∈ x ⊆ rnx , chooses an action at according to a policy π(a|xt) and observes a reward signal rt ∈ r produced by the environment. we will consider discrete actions at ∈ {1, 2, . . . , na} in sections 3 and 4, and continuous actions at ∈ a ⊆ rna in section 5. the goal of the agent is to maximize the discounted return rt = ∑ i≥0 γ
irt+i in expectation. the discount factor γ ∈ [0, 1) trades-off the importance of immediate and future rewards. for an agent following policy π, we use the standard definitions of the state-action and state only value functions:
qπ(xt, at) = ext+1:∞,at+1:∞ [rt|xt, at] and v π(xt) = eat [qπ(xt, at)|xt] . here, the expectations are with respect to the observed environment states xt and the actions generated by the policy π, where xt+1:∞ denotes a state trajectory starting at time t+ 1.
we also need to define the advantage function aπ(xt, at) = qπ(xt, at)− v π(xt), which provides a relative measure of value of each action since eat [aπ(xt, at)] = 0.
the parameters θ of the differentiable policy πθ(at|xt) can be updated using the discounted approximation to the policy gradient (sutton , 2000), which borrowing notation from schulman  (2015b), is defined as:
g = ex0:∞,a0:∞
 ∑
t≥0
aπ(xt, at)∇θ log πθ(at|xt)   . (1)
following proposition 1 of schulman  (2015b), we can replaceaπ(xt, at) in the above expression with the state-action value qπ(xt, at), the discounted return rt, or the temporal difference residual rt + γv
π(xt+1) − v π(xt), without introducing bias. these choices will however have different variance. moreover, in practice we will approximate these quantities with neural networks thus introducing additional approximation errors and biases. typically, the policy gradient estimator using rt will have higher variance and lower bias whereas the estimators using function approximation will have higher bias and lower variance. combining rt with the current value function approximation to minimize bias while maintaining bounded variance is one of the central design principles behind acer.
to trade-off bias and variance, the asynchronous advantage actor critic (a3c) of mnih  (2016) uses a single trajectory sample to obtain the following gradient approximation:
ĝa3c = ∑
t≥0
(( k−1∑
i=0
γirt+i ) + γkv πθv (xt+k)− v πθv (xt) ) ∇θ log πθ(at|xt). (2)
a3c combines both k-step returns and function approximation to trade-off variance and bias. we may think of v πθv (xt) as a policy gradient baseline used to reduce variance.
in the following section, we will introduce the discrete-action version of acer. acer may be understood as the off-policy counterpart of the a3c method of mnih  (2016). as such, acer builds on all the engineering innovations of a3c, including efficient parallel cpu computation.
acer uses a single deep neural network to estimate the policy πθ(at|xt) and the value function v πθv (xt). (for clarity and generality, we are using two different symbols to denote the parameters of the policy and value function, θ and θv , but most of these parameters are shared in the single neural network.) our neural networks, though building on the networks used in a3c, will introduce several modifications and new modules.off-policy learning with experience replay may appear to be an obvious strategy for improving the sample efficiency of actor-critics. however, controlling the variance and stability of off-policy estimators is notoriously hard. importance sampling is one of the most popular approaches for offpolicy learning (meuleau , 2000; jie & abbeel, 2010; levine & koltun, 2013). in our context, it proceeds as follows. suppose we retrieve a trajectory {x0, a0, r0, µ(·|x0), · · · , xk, ak, rk, µ(·|xk)}, where the actions have been sampled according to the behavior policy µ, from our memory of experiences. then, the importance weighted policy gradient is given by:
ĝimp =
( k∏
t=0
ρt
) k∑
t=0
( k∑
i=0
γirt+i ) ∇θ log πθ(at|xt), (3)
where ρt = π(at|xt) µ(at|xt) denotes the importance weight. this estimator is unbiased, but it suffers from very high variance as it involves a product of many potentially unbounded importance weights. to prevent the product of importance weights from exploding, wawrzyński (2009) truncates this product. truncated importance sampling over entire trajectories, although bounded in variance, could suffer from significant bias.
recently, degris  (2012) attacked this problem by using marginal value functions over the limiting distribution of the process to yield the following approximation of the gradient:
gmarg = ext∼β,at∼µ [ρt∇θ log πθ(at|xt)qπ(xt, at)] , (4) where ext∼β,at∼µ[·] is the expectation with respect to the limiting distribution β(x) = limt→∞ p (xt = x|x0, µ) with behavior policy µ. to keep the notation succinct, we will replace ext∼β,at∼µ[·] with extat [·] and ensure we remind readers of this when necessary. two important facts about equation (4) must be highlighted. first, note that it depends on qπ and not on qµ, consequently we must be able to estimate qπ. second, we no longer have a product of importance weights, but instead only need to estimate the marginal importance weight ρt. importance sampling in this lower dimensional space (over marginals as opposed to trajectories) is expected to exhibit lower variance.
degris  (2012) estimateqπ in equation (4) using lambda returns: rλt = rt+(1−λ)γv (xt+1)+ λγρt+1r λ t+1. this estimator requires that we know how to choose λ ahead of time to trade off bias and variance. moreover, when using small values of λ to reduce variance, occasional large importance weights can still cause instability.
in the following subsection, we adopt the retrace algorithm of munos  (2016) to estimate qπ. subsequently, we propose an importance weight truncation technique to improve the stability of the off-policy actor critic of degris  (2012), and introduce a computationally efficient trust region scheme for policy optimization. the formulation of acer for continuous action spaces will require further innovations that are advanced in section 5.in this paper, we estimate qπ(xt, at) using retrace (munos , 2016). (we also experimented with the related tree backup method of precup  (2000) but found retrace to perform better in practice.) given a trajectory generated under the behavior policy µ, the retrace estimator can be expressed recursively as follows1:
qret(xt, at) = rt + γρ̄t+1[q ret(xt+1, at+1)−q(xt+1, at+1)] + γv (xt+1), (5) for ease of presentation, we consider only λ = 1 for retrace.
where ρ̄t is the truncated importance weight, ρ̄t = min {c, ρt} with ρt = π(at|xt)µ(at|xt) , q is the current value estimate of qπ, and v (x) = ea∼πq(x, a). retrace is an off-policy, return-based algorithm which has low variance and is proven to converge (in the tabular case) to the value function of the target policy for any behavior policy, see munos  (2016).
the recursive retrace equation depends on the estimate q. to compute it, in discrete action spaces, we adopt a convolutional neural network with “two heads” that outputs the estimate qθv (xt, at), as well as the policy πθ(at|xt). this neural representation is the same as in (mnih , 2016), with the exception that we output the vector qθv (xt, at) instead of the scalar vθv (xt). the estimate vθv (xt) can be easily derived by taking the expectation of qθv under πθ.
to approximate the policy gradient gmarg, acer uses qret to estimate qπ. as retrace uses multistep returns, it can significantly reduce bias in the estimation of the policy gradient 2.
to learn the critic qθv (xt, at), we again use q ret(xt, at) as a target in a mean squared error loss and update its parameters θv with the following standard gradient:
(qret(xt, at)−qθv (xt, at))∇θvqθv (xt, at)). (6) because retrace is return-based, it also enables faster learning of the critic. thus the purpose of the multi-step estimator qret in our setting is twofold: to reduce bias in the policy gradient, and to enable faster learning of the critic, hence further reducing bias.the marginal importance weights in equation (4) can become large, thus causing instability. to safe-guard against high variance, we propose to truncate the importance weights and introduce a correction term via the following decomposition of gmarg:
gmarg =extat [ρt∇θlog πθ(at|xt)qπ(xt, at)]
=ext [ eat[ρ̄t∇θlog πθ(at|xt)qπ(xt, at)]+e
a∼π ([ ρt(a)− c ρt(a) ]
+
∇θlog πθ(a|xt)qπ(xt, a) )] ,(7)
where ρ̄t = min {c, ρt} with ρt = π(at|xt)µ(at|xt) as before. we have also introduced the notation ρt(a) =
π(a|xt) µ(a|xt) , and [x]+ = x if x > 0 and it is zero otherwise. we remind readers that the above
expectations are with respect to the limiting state distribution under the behavior policy: xt ∼ β and at ∼ µ. the clipping of the importance weight in the first term of equation (7) ensures that the variance of the gradient estimate is bounded. the correction term (second term in equation (7)) ensures that our estimate is unbiased. note that the correction term is only active for actions such that ρt(a) > c. in particular, if we choose a large value for c, the correction term only comes into effect when the variance of the original off-policy estimator of equation (4) is very high. when this happens, our decomposition has the nice property that the truncated weight in the first term is at most c while the correction weight [ ρt(a)−c ρt(a) ] + in the second term is at most 1.
we model qπ(xt, a) in the correction term with our neural network approximation qθv (xt, at). this modification results in what we call the truncation with bias correction trick, in this case applied to the function ∇θ log πθ(at|xt)qπ(xt, at):
ĝmarg =ext [ eat [ ρ̄t∇θlog πθ(at|xt)qret(xt, at) ] +e a∼π ([ ρt(a)− c ρt(a) ]
+
∇θlog πθ(a|xt)qθv (xt, a) )] .(8)
equation (8) involves an expectation over the stationary distribution of the markov process. we can however approximate it by sampling trajectories {x0, a0, r0, µ(·|x0), · · · , xk, ak, rk, µ(·|xk)} an alternative to retrace here is q(λ) with off-policy corrections (harutyunyan , 2016) which we discuss in more detail in appendix b.
generated from the behavior policy µ. here the terms µ(·|xt) are the policy vectors. given these trajectories, we can compute the off-policy acer gradient:
ĝacert = ρ̄t∇θ log πθ(at|xt)[qret(xt, at)− vθv (xt)]
+ e a∼π ([ ρt(a)− c ρt(a) ]
+
∇θ log πθ(a|xt)[qθv (xt, a)− vθv (xt)] ) . (9)
in the above expression, we have subtracted the classical baseline vθv (xt) to reduce variance.
it is interesting to note that, when c = ∞, (9) recovers (off-policy) policy gradient up to the use of retrace. when c = 0, (9) recovers an actor critic update that depends entirely on q estimates. in the continuous control domain, (9) also generalizes stochastic value gradients if c = 0 and the reparametrization trick is used to estimate its second term (heess , 2015).the policy updates of actor-critic methods do often exhibit high variance. hence, to ensure stability, we must limit the per-step changes to the policy. simply using smaller learning rates is insufficient as they cannot guard against the occasional large updates while maintaining a desired learning speed. trust region policy optimization (trpo) (schulman , 2015a) provides a more adequate solution.
schulman  (2015a) approximately limit the difference between the updated policy and the current policy to ensure safety. despite the effectiveness of their trpo method, it requires repeated computation of fisher-vector products for each update. this can prove to be prohibitively expensive in large domains.
in this section we introduce a new trust region policy optimization method that scales well to large problems. instead of constraining the updated policy to be close to the current policy (as in trpo), we propose to maintain an average policy network that represents a running average of past policies and forces the updated policy to not deviate far from this average.
we decompose our policy network in two parts: a distribution f , and a deep neural network that generates the statistics φθ(x) of this distribution. that is, given f , the policy is completely characterized by the network φθ: π(·|x) = f(·|φθ(x)). for example, in the discrete domain, we choose f to be the categorical distribution with a probability vector φθ(x) as its statistics. the probability vector is of course parameterised by θ.
we denote the average policy network as φθa and update its parameters θa “softly” after each update to the policy parameter θ: θa ← αθa + (1− α)θ. consider, for example, the acer policy gradient as defined in equation (9), but with respect to φ:
ĝacert = ρ̄t∇φθ(xt) log f(at|φθ(x))[qret(xt, at)− vθv (xt)]
+ e a∼π ([ ρt(a)− c ρt(a) ]
+
∇φθ(xt) log f(at|φθ(x))[qθv (xt, a)− vθv (xt)] ) . (10)
given the averaged policy network, our proposed trust region update involves two stages. in the first stage, we solve the following optimization problem with a linearized kl divergence constraint:
minimize z  2 ‖ĝacert − z‖22
subject to ∇φθ(xt)dkl [f(·|φθa(xt))‖f(·|φθ(xt))] t z ≤ δ
(11)
since the constraint is linear, the overall optimization problem reduces to a simple quadratic programming problem, the solution of which can be easily derived in closed form using the kkt conditions. letting k = ∇φθ(xt)dkl [f(·|φθa(xt)‖f(·|φθ(xt)], the solution is:
z∗ = ĝacert −max { , kt ĝacert − δ ‖k‖22
} k (12)
this transformation of the gradient has a very natural form. if the constraint is satisfied, there is no change to the gradient with respect to φθ(xt). otherwise, the update is scaled down in the direction
of k, thus effectively lowering rate of change between the activations of the current policy and the average policy network.
in the second stage, we take advantage of back-propagation. specifically, the updated gradient with respect to φθ, that is z∗, is back-propagated through the network to compute the derivatives with respect to the parameters. the parameter updates for the policy network follow from the chain rule: ∂φθ(x) ∂θ z ∗.
the trust region step is carried out in the space of the statistics of the distribution f , and not in the space of the policy parameters. this is done deliberately so as to avoid an additional back-propagation step through the policy network.
we would like to remark that the algorithm advanced in this section can be thought of as a general strategy for modifying the backward messages in back-propagation so as to stabilize the activations.
instead of a trust region update, one could alternatively add an appropriately scaled kl cost to the objective function as proposed by heess  (2015). this approach, however, is less robust to the choice of hyper-parameters in our experience.
the acer algorithm results from a combination of the above ideas, with the precise pseudo-code appearing in appendix a. a master algorithm (algorithm 1) calls acer on-policy to perform updates and propose trajectories. it then calls acer off-policy component to conduct several replay steps. when on-policy, acer effectively becomes a modified version of a3c where q instead of v baselines are employed and trust region optimization is used.we use the arcade learning environment of bellemare  (2013) to conduct an extensive evaluation. we deploy one single algorithm and network architecture, with fixed hyper-parameters, to learn to play 57 atari games given only raw pixel observations and game rewards. this task is highly demanding because of the diversity of games, and high-dimensional pixel-level observations.
our experimental setup uses 16 actor-learner threads running on a single machine with no gpus. we adopt the same input pre-processing and network architecture as mnih  (2015). specifically, the network consists of a convolutional layer with 32 8× 8 filters with stride 4 followed by another convolutional layer with 64 4× 4 filters with stride 2, followed by a final convolutional layer with 64 3× 3 filters with stride 1, followed by a fully-connected layer of size 512. each of the hidden layers is followed by a rectifier nonlinearity. the network outputs a softmax policy and q values.
when using replay, we add to each thread a replay memory that is up to 50 000 frames in size. the total amount of memory used across all threads is thus similar in size to that of dqn (mnih , 2015). for all atari experiments, we use a single learning rate adopted from an earlier implementation of a3c without further tuning. we do not anneal the learning rates over the course of training as in mnih  (2016). we otherwise adopt the same optimization procedure as in mnih  (2016). specifically, we adopt entropy regularization with weight 0.001, discount the rewards with γ = 0.99, and perform updates every 20 steps (k = 20 in the notation of section 2). in all our experiments with experience replay, we use importance weight truncation with c = 10. we consider training acer both with and without trust region updating as described in section 3.3. when trust region updating is used, we use δ = 1 and α = 0.99 for all experiments.
to compare different agents, we adopt as our metric the median of the human normalized score over all 57 games. the normalization is calculated such that, for each game, human scores and random scores are evaluated to 1, and 0 respectively. the normalized score for a given game at time t is computed as the average normalized score over the past 1 million consecutive frames encountered until time t. for each agent, we plot its cumulative maximum median score over time. the result is summarized in figure 1.
the four colors in figure 1 correspond to four replay ratios (0, 1, 4 and 8) with a ratio of 4 meaning that we use the off-policy component of acer 4 times after using the on-policy component (a3c). that is, a replay ratio of 0 means that we are using a3c. the solid and dashed lines represent acer with and without trust region updating respectively. the gray and black curves are the original dqn (mnih , 2015) and prioritized replay agent of schaul  (2016) agents respectively.
as shown on the left panel of figure 1, replay significantly increases data efficiency. we observe that when using the trust region optimizer, the average reward as a function of the number of environmental steps increases with the ratio of replay. this increase has diminishing returns, but with enough replay, acer can match the performance of the best dqn agents. moreover, it is clear that the off-policy actor critics (acer) are much more sample efficient than their on-policy counterpart (a3c).
the right panel of figure 1 shows that acer agents perform similarly to a3c when measured by wall clock time. thus, in this case, it is possible to achieve better data-efficiency without necessarily compromising on computation time. in particular, acer with a replay ratio of 4 is an appealing alternative to either the prioritized dqn agent or a3c.retrace requires estimates of both q and v , but we cannot easily integrate over q to derive v in continuous action spaces. in this section, we propose a solution to this problem in the form of a novel representation for rl, as well as modifications necessary for trust region updating.retrace provides a target for learning qθv , but not for learning vθv . we could use importance sampling to compute vθv given qθv , but this estimator has high variance.
we propose a new architecture which we call stochastic dueling networks (sdns), inspired by the dueling networks of wang  (2016), which is designed to estimate both v π and qπ off-policy while maintaining consistency between the two estimates. at each time step, an sdn outputs a stochastic estimate q̃θv of q π and a deterministic estimate vθv of v π , such that
q̃θv (xt, at) ∼ vθv (xt) +aθv (xt, at)− 1
n
n∑
i=1
aθv (xt, ui), and ui ∼ πθ(·|xt) (13)
where n is a parameter, see figure 2. the two estimates are consistent in the sense that ea∼π(·|xt) [ eu1:n∼π(·|xt) ( q̃θv (xt, a) )] = vθv (xt). furthermore, we can learn about v π by learning q̃θv . to see this, assume we have learned q π perfectly such that eu1:n∼π(·|xt) ( q̃θv (xt, at) ) = qπ(xt, at), then vθv (xt) = ea∼π(·|xt) [ eu1:n∼π(·|xt) ( q̃θv (xt, a) )] = ea∼π(·|xt) [qπ(xt, a)] =
v π(xt). therefore, a target on q̃θv (xt, at) also provides an error signal for updating vθv .
in addition to sdns, however, we also construct the following novel target for estimating v π:
v target(xt) = min { 1, π(at|xt) µ(at|xt) }( qret(xt, at)−qθv (xt, at) ) + vθv (xt). (14)
the above target is also derived via the truncation and bias correction trick; for more details, see appendix d.
finally, when estimating qret in continuous domains, we implement a slightly different formulation of the truncated importance weights ρ̄t = min { 1, ( π(at|xt) µ(at|xt) ) 1 d } , where d is the dimensionality of
the action space. although not essential, we have found this formulation to lead to faster learning.to adopt the trust region updating scheme (section 3.3) in the continuous control domain, one simply has to choose a distribution f and a gradient specification ĝacert suitable for continuous action spaces.
for the distribution f , we choose gaussian distributions with fixed diagonal covariance and mean φθ(x).
to derive ĝacert in continuous action spaces, consider the acer policy gradient for the stochastic dueling network, but with respect to φ:
gacert = ext [ eat [ ρ̄t∇φθ(xt) log f(at|φθ(xt))(qopc(xt, at)− vθv (xt)) ]
+ e a∼π ([ ρt(a)− c ρt(a) ]
+
(q̃θv (xt, a)− vθv (xt))∇φθ(xt) log f(a|φθ(xt)) )] . (15)
in the above definition, we are using qopc instead of qret. here, qopc(xt, at) is the same as retrace with the exception that the truncated importance ratio is replaced with 1 (harutyunyan , 2016). please refer to appendix b an expanded discussion on this design choice. given an observation xt, we can sample a′t ∼ πθ(·|xt) to obtain the following monte carlo approximation
ĝacert = ρ̄t∇φθ(xt) log f(at|φθ(xt))(qopc(xt, at)− vθv (xt))
+
[ ρt(a ′ t)− c
ρt(a′t)
]
+
(q̃θv (xt, a ′ t)− vθv (xt))∇φθ(xt) log f(a′t|φθ(xt)). (16)
given f and ĝacert , we apply the same steps as detailed in section 3.3 to complete the update.
the precise pseudo-code of acer algorithm for continuous spaces results is presented in appendix a.we evaluate our algorithms on 6 continuous control tasks, all of which are simulated using the mujoco physics engine (todorov , 2012). for descriptions of the tasks, please refer to appendix e.1. briefly, the tasks with action dimensionality in brackets are: cartpole (1d), reacher (3d), cheetah (6d), fish (5d), walker (6d) and humanoid (21d). these tasks are illustrated in figure 3.
to benchmark acer for continuous control, we compare it to its on-policy counterpart both with and without trust region updating. we refer to these two baselines as a3c and trust-a3c. additionally, we also compare to a baseline with replay where we truncate the importance weights over trajectories as in (wawrzyński, 2009). for a detailed description of this baseline, please refer to appendix e. again, we run this baseline both with and without trust region updating, and refer to these choices as trust-tis and tis respectively. last but not least, we refer to our proposed approach with sdn and trust region updating as simply acer. all five setups are implemented in the asynchronous a3c framework.
all the aforementioned setups share the same network architecture that computes the policy and state values. we maintain an additional small network that computes the stochastic a values in the case of acer. we use n = 5 (using the notation in equation (13)) in all sdns. instead of mixing on-policy and replay learning as done in the atari domain, acer for continuous actions is entirely off-policy, with experiences generated from the simulator (4 times on average). when using replay, we add to each thread a replay memory that is 5, 000 frames in size and perform updates every 50 steps (k = 50 in the notation of section 2). the rate of the soft updating (α as in section 3.3) is set to 0.995 in all setups involving trust region updating. the truncation threshold c is set to 5 for acer.
we use diagonal gaussian policies with fixed diagonal covariances where the diagonal standard deviation is set to 0.3. for all setups, we sample the learning rates log-uniformly in the range [10−4, 10−3.3]. for setups involving trust region updating, we also sample δ uniformly in the range [0.1, 2]. with all setups, we use 30 sampled hyper-parameter settings.
the empirical results for all continuous control tasks are shown figure 3, where we show the mean and standard deviation of the best 5 out of 30 hyper-parameter settings over which we searched 3. for sensitivity analyses with respect to the hyper-parameters, please refer to figures 5 and 6 in the appendix.
in continuous control, acer outperforms the a3c and truncated importance sampling baselines by a very significant margin.
here, we also find that the proposed trust region optimization method can result in huge improvements over the baselines. the high-dimensional continuous action policies are much harder to optimize than the small discrete action policies in atari, and hence we observe much higher gains for trust region optimization in the continuous control domains. in spite of the improvements brought in by trust region optimization, acer still outperforms all other methods, specially in higher dimensions.to further tease apart the contributions of the different components of acer, we conduct an ablation analysis where we individually remove retrace / q(λ) off-policy correction, sdns, trust region, and truncation with bias correction from the algorithm. as shown in figure 4, retrace and offpolicy correction, sdns, and trust region are critical: removing any one of them leads to a clear deterioration of the performance. truncation with bias correction did not alter the results in the fish and walker2d tasks. however, in humanoid, where the dimensionality of the action space is much higher, including truncation and bias correction brings a significant boost which makes the originally kneeling humanoid stand. presumably, the high dimensionality of the action space increases the variance of the importance weights which makes truncation with bias correction important. for more details on the experimental setup please see appendix e.4.retrace is a very recent development in reinforcement learning. in fact, this work is the first to consider retrace in the policy gradients setting. for this reason, and given the core role that retrace plays in acer, it is valuable to shed more light on this technique. in this section, we will prove that retrace can be interpreted as an application of the importance weight truncation and bias correction trick advanced in this paper.
consider the following equation:
qπ(xt, at) = ext+1at+1 [rt + γρt+1qπ(xt+1, at+1)] . (17)
if we apply the weight truncation and bias correction trick to the above equation we obtain
qπ(xt, at) = ext+1at+1 [ rt + γρ̄t+1q
π(xt+1, at+1) + γ e a∼π ([ ρt+1(a)− c ρt+1(a) ]
+
qπ(xt+1, a) )] .
(18) by recursively expanding qπ as in equation (18), we can represent qπ(x, a) as:
qπ(x, a) = eµ
 ∑
t≥0
γt
( t∏
i=1
ρ̄i )( rt + γ e
b∼π ([ ρt+1(b)− c ρt+1(b) ]
+
qπ(xt+1, b) ))  . (19)
the expectation eµ is taken over trajectories starting from x with actions generated with respect to µ. when qπ is not available, we can replace it with our current estimate q to get a return-based  for videos of the policies learned with acer, please see: https://www.youtube.com/watch?v= nmbeqyovv5g&list=plkmhikhlfjitlvwxensjms3v7ser5hsp-.
esitmate of qπ . this operation also defines an operator:
bq(x, a) = eµ
 ∑
t≥0
γt
( t∏
i=1
ρ̄i )( rt + γ e
b∼π ([ ρt+1(b)− c ρt+1(b) ]
+
q(xt+1, b)
))  . (20)
in the following proposition, we show that b is a contraction operator with a unique fixed point qπ and that it is equivalent to the retrace operator. proposition 1. the operator b is a contraction operator such that ‖bq−qπ‖∞ ≤ γ‖q−qπ‖∞ and b is equivalent to retrace.
the above proposition not only shows an alternative way of arriving at the same operator, but also provides a different proof of contraction for retrace. please refer to appendix c for the regularization conditions and proof of the above proposition.
finally, b, and therefore retrace, generalizes both the bellman operator t π and importance sampling. specifically, when c = 0, b = t π and when c = ∞, b recovers importance sampling; see appendix c.we have introduced a stable off-policy actor critic that scales to both continuous and discrete action spaces. this approach integrates several recent advances in rl in a principle manner. in addition, it integrates three innovations advanced in this paper: truncated importance sampling with bias correction, stochastic dueling networks and an efficient trust region policy optimization method.
we showed that the method not only matches the performance of the best known methods on atari, but that it also outperforms popular techniques on several continuous control problems.
the efficient trust region optimization method advanced in this paper performs remarkably well in continuous domains. it could prove very useful in other deep learning domains, where it is hard to stabilize the training process.we are very thankful to marc bellemare, jascha sohl-dickstein, and sébastien racaniere for proofreading and valuable suggestions.algorithm 1 acer for discrete actions (master algorithm) // assume global shared parameter vectors θ and θv . // assume ratio of replay r. repeat
call acer on-policy, algorithm 2. n← possion(r) for i ∈ {1, · · · , n} do
call acer off-policy, algorithm 2. end for
until max iteration or time reached.
algorithm 2 acer for discrete actions reset gradients dθ ← 0 and dθv ← 0. initialize parameters θ′ ← θ and θ′v ← θv . if not on-policy then
sample the trajectory {x0, a0, r0, µ(·|x0), · · · , xk, ak, rk, µ(·|xk)} from the replay memory. else
get state x0 end if for i ∈ {0, · · · , k} do
compute f(·|φθ′(xi)), qθ′v (xi, ·) and f(·|φθa(xi)). if on-policy then
perform ai according to f(·|φθ′(xi)) receive reward ri and new state xi+1 µ(·|xi)← f(·|φθ′(xi))
end if ρ̄i ← min { 1,
f(ai|φθ′ (xi)) µ(ai|xi)
} .
end for
qret ← { 0 for terminal xk∑ aqθ′v (xk, a)f(a|φθ′(xk)) otherwise for i ∈ {k − 1, · · · , 0} do qret ← ri + γqret vi ← ∑ aqθ′v (xi, a)f(a|φθ′(xi))
computing quantities needed for trust region updating:
g ← min {c, ρi(ai)}∇φθ′ (xi) log f(ai|φθ′(xi))(q ret − vi)
+ ∑ a [ 1− c ρi(a) ] + f(a|φθ′(xi))∇φθ′ (xi) log f(a|φθ′(xi))(qθ′v (xi, ai)− vi)
k ← ∇φθ′ (xi)dkl [f(·|φθa(xi)‖f(·|φθ′(xi)]
accumulate gradients wrt θ′: dθ′ ← dθ′ + ∂φθ′ (xi) ∂θ′
( g −max { 0, k
t g−δ ‖k‖22
} k )
accumulate gradients wrt θ′v: dθv ← dθv +∇θ′v (q ret −qθ′v (xi, a)) 2 update retrace target: qret ← ρ̄i ( qret −qθ′v (xi, ai) ) + vi
end for perform asynchronous update of θ using dθ and of θv using dθv . updating the average policy network: θa ← αθa + (1− α)θ
b q(λ) with off-policy corrections
given a trajectory generated under the behavior policy µ, the q(λ) with off-policy corrections estimator (harutyunyan , 2016) can be expressed recursively as follows:
qopc(xt, at) = rt + γ[q opc(xt+1, at+1)−q(xt+1, at+1)] + γv (xt+1). (21)
notice that qopc(xt, at) is the same as retrace with the exception that the truncated importance ratio is replaced with 1.
algorithm 3 acer for continuous actions reset gradients dθ ← 0 and dθv ← 0. initialize parameters θ′ ← θ and θ′v ← θv . sample the trajectory {x0, a0, r0, µ(·|x0), · · · , xk, ak, rk, µ(·|xk)} from the replay memory. for i ∈ {0, · · · , k} do
compute f(·|φθ′(xi)), vθ′v (xi), q̃θ′v (xi, ai), and f(·|φθa(xi)). sample a′i ∼ f(·|φθ′(xi)) ρi ← f(ai|φθ′ (xi))µ(ai|xi) and ρ ′ i ← f(a′i|φθ′ (xi)) µ(a′i|xi)
ci ← min { 1, (ρi) 1 d } .
end for
qret ← { 0 for terminal xk vθ′v (xk) otherwise qopc ← qret for i ∈ {k − 1, · · · , 0} do qret ← ri + γqret qopc ← ri + γqopc computing quantities needed for trust region updating:
g ← min {c, ρi}∇φθ′ (xi) log f(ai|φθ′(xi)) ( qopc(xi, ai)− vθ′v (xi) ) + [ 1− c
ρ′i ] + (q̃θ′v (xi, a ′ i)− vθ′v (xi))∇φθ′ (xi) log f(a ′ i|φθ′(xi))
k ← ∇φθ′ (xi)dkl [f(·|φθa(xi)‖f(·|φθ′(xi)]
accumulate gradients wrt θ: dθ ← dθ + ∂φθ′ (xi) ∂θ′
( g −max { 0, k
t g−δ ‖k‖22
} k )
accumulate gradients wrt θ′v: dθv ← dθv + (qret − q̃θ′v (xi, ai))∇θ′v q̃θ′v (xi, ai) dθv ← dθv + min {1, ρi} ( qret(xt, ai)− q̃θ′v (xt, ai) ) ∇θ′vvθ′v (xi)
update retrace target: qret ← ci ( qret − q̃θ′v (xi, ai) ) + vθ′v (xi)
update retrace target: qopc ← ( qopc − q̃θ′v (xi, ai) ) + vθ′v (xi)
end for perform asynchronous update of θ using dθ and of θv using dθv . updating the average policy network: θa ← αθa + (1− α)θ
because of the lack of the truncated importance ratio, the operator defined by qopc is only a contraction if the target and behavior policies are close to each other (harutyunyan , 2016). q(λ) with off-policy corrections is therefore less stable compared to retrace and unsafe for policy evaluation.
qopc, however, could better utilize the returns as the traces are not cut by the truncated importance weights. as a result,qopc could be used efficiently to estimateqπ in policy gradient (e.g. in equation (16)). in our continuous control experiments, we have found that qopc leads to faster learning.for the purpose of proving proposition 1, we assume our environment to be a markov decision process (x ,a, γ, p, r). we restrict x to be a finite state space. for notational simplicity, we also restrict a to be a finite action space. p : x ,a → x defines the state transition probabilities and r : x ,a → [−rmax, rmax] defines a reward function. finally, γ ∈ [0, 1) is the discount factor.
proof of proposition 1. first we show that b is a contraction operator. |bq(x, a)−qπ(x, a)|
= ∣∣∣∣∣∣ eµ  ∑
t≥0
γt
( t∏
i=1
ρ̄i )( γ e b∼π ([ ρt+1(b)− c ρt+1(b) ]
+ (q(xt+1, b)−qπ(xt+1, b)) ))  ∣∣∣∣∣∣
≤ eµ
 ∑
t≥0
γt
( t∏
i=1
ρ̄i )[ γ e b∼π ([ ρt+1(b)− c ρt+1(b) ]
+
|q(xt+1, b)−qπ(xt+1, b)| )] 
≤ eµ
 ∑
t≥0
γt
( t∏
i=1
ρ̄i )( γ(1− p̄t+1) sup
b |q(xt+1, b)−qπ(xt+1, b)|
)  (22)
where p̄t+1 = 1− e b∼π [[ ρt+1(b)−c ρt+1(b) ] + ] = e b∼µ [ρ̄t+1(b)]. the last inequality in the above equation is due to hölder’s inequality.
(22) ≤ sup x,b |q(x, b)−qπ(x, b)|eµ
 ∑
t≥0
γt
( t∏
i=1
ρ̄i ) ( γ(1− p̄t+1) )  
= sup x,b |q(x, b)−qπ(x, b)|eµ
 γ ∑
t≥0
γt
( t∏
i=1
ρ̄i
) − ∑
t≥0
γt
( t∏
i=1
ρ̄i ) ( γp̄t+1 )  
= sup x,b |q(x, b)−qπ(x, b)|eµ
 γ ∑
t≥0
γt
( t∏
i=1
ρ̄i
) − ∑
t≥0
γt+1
( t+1∏
i=1
ρ̄i
) 
= sup x,b |q(x, b)−qπ(x, b)| (γc − (c − 1))
wherec = ∑ t≥0 γ
t (∏t
i=1 ρ̄i ) . sincec ≥∑0t=0 γt (∏t i=1 ρ̄i ) = 1, we have that γc−(c−1) ≤
γ. therefore, we have shown that b is a contraction operator. now we show that b is the same as retrace. by apply the trunction and bias correction trick, we have
e b∼π [q(xt+1, b)] = e b∼µ [ρ̄t+1(b)q(xt+1, b)] + e b∼π ([ ρt+1(b)− c ρt+1(b) ]
+
q(xt+1, b)
) . (23)
by adding and subtracting the two sides of equation (23) inside the summand of equation (20), we have bq(x, a) = eµ [∑
t≥0
γt ( t∏
i=1
ρ̄i )[ rt + γ e
b∼π ([ ρt+1(b)− c ρt+1(b) ]
+
q(xt+1, b)
) +γ e
b∼π [q(xt+1, b)]
−γ e b∼µ [ρ̄t+1(b)q(xt+1, b)]− γ e b∼π ([ ρt+1(b)− c ρt+1(b) ]
+
q(xt+1, b)
)]]
= eµ
 ∑
t≥0
γt
( t∏
i=1
ρ̄i )( rt + γ e
b∼π [q(xt+1, b)]− γ e b∼µ [ρ̄t+1(b)q(xt+1, b)]
) 
= eµ
 ∑
t≥0
γt
( t∏
i=1
ρ̄i )( rt + γ e
b∼π [q(xt+1, b)]− γρ̄t+1q(xt+1, at+1)
) 
= eµ
 ∑
t≥0
γt
( t∏
i=1
ρ̄i )( rt + γ e
b∼π [q(xt+1, b)]−q(xt, at)
) +q(x, a) = rq(x, a)
in the remainder of this appendix, we show that b generalizes both the bellman operator and importance sampling. first, we reproduce the definition of b:
bq(x, a) = eµ
 ∑
t≥0
γt
( t∏
i=1
ρ̄i )( rt + γ e
b∼π ([ ρt+1(b)− c ρt+1(b) ]
+
q(xt+1, b)
))  .
when c = 0, we have that ρ̄i = 0 ∀i. therefore only the first summand of the sum remains:
bq(x, a) = eµ [ rt + γ e
b∼π (q(xt+1, b))
] .
in this case b = t . when c =∞, the compensation term disappears and ρ̄i = ρi ∀i:
bq(x, a) = eµ
 ∑
t≥0
γt
( t∏
i=1
ρi )( rt + γ e
b∼π (0×q(xt+1, b))
)  = eµ  ∑
t≥0
γt
( t∏
i=1
ρi ) rt   .
in this case b is the same operator defined by importance sampling.
d derivation of v target
by using the truncation and bias correction trick, we can derive the following:
v π(xt) = e a∼µ
[ min { 1, π(a|xt) µ(a|xt) } qπ(xt, a) ] + e a∼π ([ ρt(a)− 1 ρt(a) ]
+
qπ(xt+1, a) ) .
we, however, cannot use the above equation as a target as we do not have access to qπ . to derive a target, we can take a monte carlo approximation of the first expectation in the rhs of the above equation and replace the first occurrence of qπ with qret and the second with our current neural net approximation qθv (xt, ·):
v targetpre (xt) := min { 1, π(at|xt) µ(at|xt) } qret(xt, at) + e a∼π ([ ρt(a)− 1 ρt(a) ]
+
qθv (xt, a)
) . (24)
through the truncation and bias correction trick again, we have the following identity:
e a∼π [qθv (xt, a)] = e a∼µ
[ min { 1, π(a|xt) µ(a|xt) } qθv (xt, a) ] + e a∼π ([ ρt(a)− 1 ρt(a) ]
+
qθv (xt, a)
) . (25)
adding and subtracting both sides of equation (25) to the rhs of (24) while taking a monte carlo approximation, we arrive at v target(xt):
v target(xt) := min { 1, π(at|xt) µ(at|xt) }( qret(xt, at)−qθv (xt, at) ) + vθv (xt).e.1 description of the continuous control problems
our continuous control tasks were simulated using the mujoco physics engine (todorov  (2012)). for all experiments we considered an episodic setup with an episode length of t = 500 steps and a discount factor of 0.99.
cartpole swingup this is an instance of the classic cart-pole swing-up task. it consists of a pole attached to a cart running on a finite track. the agent is required to balance the pole near the center of the track by applying a force to the cart only. an episode starts with the pole at a random angle and zero velocity. a reward zero is given except when the pole is approximately upright (within ±5 deg) and the track approximately in the center of the track (±0.05) for a track length of 2.4. the observations include position and velocity of the cart, angle and angular velocity of the pole. a sine/cosine of the angle, the position of the tip of the pole, and cartesian velocities of the pole. the dimension of the action space is 1.
reacher3 the agent needs to control a planar 3-link robotic arm in order to minimize the distance between the end effector of the arm and a target. both arm and target position are chosen randomly at the beginning of each episode. the reward is zero except when the tip of the arm is within 0.05 of the target, where it is one. the 8-dimensional observation consists of the angles and angular velocity of all joints as well as the displacement between target and the end effector of the arm. the 3-dimensional action are the torques applied to the joints.
cheetah the half-cheetah (wawrzyński (2009); heess  (2015)) is a planar locomotion task where the agent is required to control a 9-dof cheetah-like body (in the vertical plane) to move in the direction of the x-axis as quickly as possible. the reward is given by the velocity along the x-axis and a control cost: r = vx + 0.1‖a‖2. the observation vector consists of the z-position of the torso and its x, z velocities as well as the joint angles and angular velocities. the action dimension is 6.
fish the goal of this task is to control a 13-dof fish-like body to swim to a random target in 3d space. the reward is given by the distance between the head of the fish and the target, a small penalty for the body not being upright, and a control cost. at the beginning of an episode the fish is initialized facing in a random direction relative to the target. the 24-dimensional observation is given by the displacement between the fish and the target projected onto the torso coordinate frame, the joint angles and velocities, the cosine of the angle between the z-axis of the torso and the world z-axis, and the velocities of the torso in the torso coordinate frame. the 5-dimensional actions control the position of the side fins and the tail.
walker the 9-dof planar walker is inspired by (schulman  (2015a)) and is required to move forward along the x-axis as quickly as possible without falling. the reward consists of the x-velocity of the torso, a quadratic control cost, and terms that penalize deviations of the torso from the preferred height and orientation (i.e. terms that encourage the walker to stay standing and upright). the 24-dimensional observation includes the torso height, velocities of all dofs, as well as sines and cosines of all body orientations in the x-z plane. the 6-dimensional action controls the torques applied at the joints. episodes are terminated early with a negative reward when the torso exceeds upper and lower limits on its height and orientation.
humanoid the humanoid is a 27 degrees-of-freedom body with 21 actuators (21 action dimensions). it is initialized lying on the ground in a random configuration and the task requires it to achieve a standing position. the reward function penalizes deviations from the height of the head when standing, and includes additional terms that encourage upright standing, as well as a quadratic action penalty. the 94 dimensional observation contains information about joint angles and velocities and several derived features reflecting the body’s pose.
e.2 update equations of the baseline tis
the baseline tis follows the following update equations,
updates to the policy: min { 5, ( k−1∏
i=0
ρt+i
)}[ k−1∑
i=0
γirt+i + γ kvθv (xk+t)− vθv (xt) ] ∇θ log πθ(at|xt),
updates to the value: min { 5, ( k−1∏
i=0
ρt+i
)}[ k−1∑
i=0
γirt+i + γ kvθv (xk+t)− vθv (xt) ] ∇θvvθv (xt).
the baseline trust-tis is appropriately modified according to the trust region update described in section 3.3.
e.3 sensitivity analysis
in this section, we assess the sensitivity of acer to hyper-parameters. in figures 5 and 6, we show, for each game, the final performance of our acer agent versus the choice of learning rates, and the trust region constraint δ respectively.
note, as we are doing random hyper-parameter search, each learning rate is associated with a random δ and vice versa. it is therefore difficult to tease out the effect of either hyper-parameter independently.
we observe, however, that acer is not very sensitive to the hyper-parameters overall. in addition, smaller δ’s do not seem to adversely affect the final performance while larger δ’s do in domains of higher action dimensionality. similarly, smaller learning rates perform well while bigger learning rates tend to hurt final performance in domains of higher action dimensionality.
e.4 experimental setup of ablation analysis
for the ablation analysis, we use the same experimental setup as in the continuous control experiments while removing one component at a time.
to evaluate the effectiveness of retrace/q(λ) with off-policy correction, we replace both with importance sampling based estimates (following degris  (2012)) which can be expressed recursively: rt = rt + ρt+1rt+1.
to evaluate the stochastic dueling networks, we replace it with two separate networks: one computing the state values and the other q values. given qret(xt, at), the naive way of estimating the state values is to use the following update rule:
( ρtq ret(xt, at)− vθv (xt) ) ∇θvvθv (xt).
the above update rule, however, suffers from high variance. we consider instead the following update rule:
ρt ( qret(xt, at)− vθv (xt) ) ∇θvvθv (xt)
which has markedly lower variance. we update our q estimates as before.
to evaluate the effects of the truncation and bias correction trick, we change our c parameter (see equation (16)) to∞ so as to use pure importance sampling.",1
471.pdf.json,"chatbots are one of the classical applications of artificial intelligence and are now ubiquitous in technology, business and everyday life. many corporate entities are now increasingly using chatbots to either replace or assist humans in customer service contexts. for example, microsoft is currently actively building a chat bot to optimise and streamline its technical support service.
in these scenarios, there is usually an abundance of historical data since past conversations between customers and human customer service agents are usually recorded by organisations. an apparently straightforward solution would be to train chatbots to reproduce the responses by human agents using standard techniques such as maximum likelihood. while this seems natural, it is far from desirable for several reasons. it has been observed that such procedures have a tendency to produce very generic responses (sordoni , 2015). for instance, when we trained chatbots via maximum likelihood on a restaurant recommendations dataset, they repeatedly output responses to the effect of how large is your group?, what is your budget? etc. further, they also produce responses such as let me look that up. or give me a second. which, although permissible for a human agent to say, are not appropriate for a chatbot. although there are ways to increase the diversity of responses (li , 2015), our focus is on encouraging the bot to meaningfully advance the conversation. one way to address this problem is to provide some form of weak supervision for responses generated by a chatbot. for example, a human labeller, such as a quality assurance agent, could score each response generated by a chatbot in a conversation with a customer. this brings us to the reinforcement learning (rl) paradigm where these rewards (scores) are to be used to train a good chatbot. in this paper we will use the terms score, label, and reward interchangeably. labelled data will mean conversations which have been assigned a reward of some form as explained above.
nonetheless, there are some important differences in the above scenario when compared to the more popular approaches for rl.
• noisy and expensive rewards: obtaining labels for each conversation can be time consuming and economically expensive. as a result, there is a limited amount of labelled data available. moreover, labels produced by humans are invariably noisy due to human error and subjectivity.
• off-line evaluations: unlike conventional rl settings, such as games, where we try to find the optimal policy while interacting with the system, the rewards here are not immediately available. previous conversations are collected, labelled by human experts, and then given to an algorithm which has to manage with the data it has.
• unlabelled data: while labelled data is limited, a large amount of unlabelled data is available.
if labelled data is in short supply, reinforcement learning could be hopeless. however, if unlabelled data can be used to train a decent initial bot, say via maximum likelihood, we can use policy iteration techniques to refine this bot by making local improvements using the labelled data (bellman, 1956). besides chatbots, this framework also finds applications in tasks such as question answering (ferrucci , 2010; hermann , 2015; sachan , 2016), generating image descriptions (karpathy & fei-fei, 2015) and machine translation (bahdanau , 2014) where a human labeller can provide weak supervision in the form of a score to a sentence generated by a bot.
to contextualise the work in this paper, we make two important distinctions in policy iteration methods in reinforcement learning. the first is on-policy vs off-policy. in on-policy settings, the goal is to improve the current policy on the fly while exploring the space. on-policy methods are used in applications where it is necessary to be competitive (achieve high rewards) while simultaneously exploring the environment. in off-policy, the environment is explored using a behaviour policy, but the goal is to improve a different target policy. the second distinction is on-line vs batch (off-line). in on-line settings one can interact with the environment. in batch methods, which is the setting for this work, one is given past exploration data from possibly several behaviour policies and the goal is to improve a target policy using this data. on-line methods can be either on-policy or off-policy whereas batch methods are necessarily off-policy.
in this paper, we study reinforcement learning in batch settings, for improving chat bots with seq2seq recurrent neural network (rnn) architectures. one of the challenges when compared to on-line learning is that we do not have interactive control over the environment. we can only hope to do as well as our data permits us to. on the other hand, the batch setting affords us some luxuries. we can reuse existing data and use standard techniques for hyper-parameter tuning based on cross validation. further, in on-line policy updates, we have to be able to “guess” how an episode will play out, i.e. actions the behaviour/target policies would take in the future and corresponding rewards. however, in batch learning, the future actions and rewards are directly available in the data. this enables us to make more informed choices when updating our policy.recently there has been a surge of interest in deep learning approaches to reinforcement learning, many of them adopting q-learning, e.g. (he , 2015; mnih , 2013; narasimhan , 2015). in q-learning, the goal is to estimate the optimal action value function q∗. then, when an agent is at a given state, it chooses the best greedy action according to q∗. while q-learning has been successful in several applications, it is challenging in the settings we consider since estimating q∗ over large action and state spaces will require a vast number of samples. in this context, policy iteration methods are more promising since we can start with an initial policy and make incremental local improvements using the data we have. this is especially true given that we can use maximum likelihood techniques to estimate a good initial bot using unlabelled data.
policy gradient methods, which fall within the paradigm of policy iteration, make changes to the parameters of a policy along the gradient of a desired objective (sutton , 1999). recently, the natural language processing (nlp) literature has turned its attention to policy gradient methods for improving language models. ranzato  (2015) present a method based on the classical reinforce algorithm (williams, 1992) for improving machine translation after preliminary training with maximum likelihood objectives. bahdanau  (2016) present an actor-critic method also for machine translation. in both cases, as the reward, the authors use the bleu (bilingual evaluation understudy) score of the output and the translation in the training dataset. this setting, where the rewards are deterministic and cheaply computable, does not reflect difficulties inherent to training chatbots where labels are noisy and expensive. li  (2016) develop a policy gradient method bot for chatbots. however, they use user defined rewards (based on some simple rules) which, once again, are cheaply obtained and deterministic. perhaps the closest to our work is that of williams & zweig (2016) who use a reinforce based method for chat bots. we discuss the differences of
this and other methods in greater detail in section 3. the crucial difference between all of the above efforts and ours is that they use on-policy and/or on-line updates in their methods.
the remainder of this manuscript is organised as follows. in section 2 we review seq2seq models and markov decision processes (mdp) and describe our framework for batch reinforcement learning. section 3 presents our method bpg and compares it with prior work in the rl and nlp literature. section 4 presents experiments on a synthetic task and a customer service dataset for restaurant recommendations.the goal of a seq2seq model in natural language processing is to produce an output sequence y = [a1, a2, . . . , at ] given an input sequence x (cho , 2014; kalchbrenner & blunsom, 2013; sutskever , 2014). here ai ∈ a where a is a vocabulary of words. for example, in machine translation from french to english, x is the input sequence in french, and y is its translation in english. in customer service chatbots, x is the conversation history until the customer’s last query and y is the response by an agent/chatbot. in a seq2seq model, we use an encoder network to represent the input sequence as a euclidean vector and then a decoder network to convert this vector to an output sequence. typically, both the encoder and decoder networks are recurrent neural networks (rnn) (mikolov , 2010) where the recurrent unit processes each word in the input/output sequences one at a time. in this work, we will use the lstm (long short term memory) (hochreiter & schmidhuber, 1997) as our recurrent unit due to its empirical success in several applications.
in its most basic form, the decoder rnn can be interpreted as assigning a probability distribution over a given the current “state”. at time t, the state st is the input sequence x and the words yt−1 = [a1, . . . , at−1] produced by the decoder thus far, i.e. st = (x, yt−1). we sample the next word at from this probability distribution π(·|st), then update our state st+1 = (x, yt) where yt = [yt−1, at], and proceed in a similar fashion. the vocabulary a contains an end-of-statement token <eos>. if we sample <eos> at time t + 1, we terminate the sequence and output yt .we present a formalism for mdps simplified to our setting. in an mdp, an agent takes an action a in a state s and transitions to a state s′. an episode refers to a sequence of transitions s1 → a1 → s2 → a2 → · · · → at → st+1 until the agent reaches a terminal state st+1. at a terminal state, the agent receives a reward. formally, an mdp is the triplet (s,a, r). here, s is a set of states anda is a set of actions. when we take an action a at state s we transition to a new state s′ = s′(s, a) which, in this work, will be deterministic. a will be a finite but large discrete set and s will be discrete but potentially infinite. r : s → r is the expected reward function such that when we receive a reward r at state s ∈ s, e[r] = r(s). let s0 ⊂ s be a set of terminal states. when we transition to any s ∈ s0, the episode ends. in this work, we will assume that the rewards are received only at a terminal state, i.e r(s) is nonzero only on s0. a policy π is a rule to select an action at a given state. we will be focusing on stochastic policies π : a×s → r+ where π(a|s) denotes the probability an agent will execute action a at state s. we define the value function v π : s → r of policy π, where v (s) is the expected reward at the end of the episode when we follow policy π from state s. for any terminal state s ∈ s0, v π(s) = r(s) regardless of π. we will also find it useful to define the action-value function qπ : s × a :→ r, where qπ(s, a) is the expected reward of taking action a at state s and then following policy π. with deterministic state transitions this is simply qπ(s, a) = v π(s′(s, a)). it can be verified that v π(s) = ea∼π(·|s) [qπ(s, a)] (sutton & barto, 1998).we now frame our learning from labels scenario for rnn chatbots as an mdp. the treatment has similarities to some recent rl work in the nlp literature discussed above.
let x be the input and yt−1 = [a1, . . . , at−1] be the words output by the decoder until time t. the state of our mdp at time t of the current episode will be st = (x, yt−1). therefore, the set of states s will be all possible pairs of inputs and partial output sequences. the actions a will be the vocabulary. the terminal states s0 will be (x, y) such that the last literal of y is <eos>. the stochastic policy π will be a seq2seq rnn which produces a distribution overa given state st. when we wish to make the dependence of the policy on the rnn parameters θ explicit, we will write πθ. when we sample an action at ∼ π(·|st), we deterministically transition to state (x, [yt−1, at]). if we sample at+1 = <eos> at time t + 1, the episode terminates and we observe a stochastic reward.
we are given a dataset of input-output-reward triples {(x(i), y(i), r(i))}ni=1 where y(i) = (a
(i) 1 , . . . , a (i) ti , <eos>) is the sequence of output words. this data was collected from possibly multiple behaviour policies which output y(i) for the given input x(i). in the above customer service example, the behaviour policies could be chatbots, or even humans, which were used for conversations with a customer. the rewards ri are scores assigned by a human quality assurance agent to each response of the chatbot. our goal is to use this data to improve a given target policy πθ. we will use q to denote the distribution of the data. q(s) is the distribution of the states in the dataset, q(a|s) is the conditional distribution of an action given a state, and q(s, a) = q(s)q(a|s) is the joint distribution over states and actions. q will be determined by the initial distribution of the inputs x(i) and the behaviour policies used to collect the training data. our aim is to find a policy that does well with respect to q. specifically, we wish to maximise the following objective,
j(θ) = ∑ s∈s q(s)v πθ (s). (1)
here, the value function v πθ is not available to us but has to be estimated from the data. this is similar to objectives used in on-line off-policy policy gradient literature where q is replaced by the limiting distribution of the behaviour policy (degris , 2012). in the derivation of our algorithm, we will need to know q(a|s) to compute the gradient of our objective. in off-policy reinforcement learning settings this is given by the behaviour policy which is readily available. if the behaviour policy if available to us, then we can use this too. otherwise, a simple alternative is to “learn” a behaviour policy. for example, in our experiments we used an rnn trained using the unlabelled data to obtain values for q(a|s). as long as this learned policy can capture the semantics of natural language (for example, the word apple is more likely than car when the current state is (x, i ate an)), then it can be expected to do reasonably well. in the following section, we will derive a stochastic gradient descent (sgd) procedure that will approximately minimise (1).
before we proceed, we note that it is customary in the rl literature to assume stochastic transitions between states and use rewards at all time steps instead of the terminal step. further, the future rewards are usually discounted by a discount factor γ < 1. while we use the above formalism to simplify the exposition, the ideas presented here extend naturally to more conventional settings.our derivation follows the blueprint in degris  (2012) who derive an off-policy on-line actor critic algorithm. following standard policy gradient methods, we will aim to update the policy by taking steps along the gradient of the objective∇j(θ).
∇j(θ) = ∇es∼q [∑ a∈a πθ(a|s)qπθ (s, a) ] = es∼q [∑ a∈a ∇πθ(a|s)qπθ (s, a) + πθ(a|s)∇qπθ (s, a) ] .
the latter term inside the above summation is difficult to work with, so the first step is to ignore it and work with the approximate gradient g(θ) = es∼q[ ∑ a∈a∇πθ(a|s)qπθ (s, a)] ≈ ∇j(θ). degris  (2012) provide theoretical justification for this approximation in off policy settings by establishing that j(θ) ≤ j(θ + αg(θ)) for all small enough α. expanding on g(θ), we obtain:
g(θ) = es∼q [∑ a∈a πθ(a|s) ∇πθ(a|s) πθ(a|s) qπθ (s, a) ] = e s∼q a∼q(·|s) [ ρ(s, a)ψ(a, s)qπθ (s, a) ] = e(st,at)∼q(·,·) [ρ(st, at)ψ(at, st)(q πθ (st, at)− v πθ (st))] . (2)
here ψ(a, s) = ∇πθ(a|s)πθ(a|s) = ∇ log πθ(a|s) is the score function of the policy and ρ(s, a) = πθ(a|s)/q(a|s) is the importance sampling coefficient. in the last step, we have used the fact that e[π(a|s)ψ(a|s)h(s)] = 0 for any function h : s → r of the current state (szepesvári, 2010). the purpose of introducing the value function v πθ is to reduce the variance of the sgd updates – we want to assess how good/bad action at is relative to how well πθ will do at state st in expectation. if at is a good action (qπθ (st, at) is large relative to v πθ (st)), the coefficient of the score function is positive and it will change θ so as to assign a higher probability to action at at state st.
the qπθ , v πθ functions are not available to us so we will replace them with estimates. for v πθ (st) we will use an estimate v̂ (st) – we will discuss choices for this shortly. however, the action value function is usually not estimated in rl policy gradient settings to avoid the high sample complexity. a sensible stochastic approximation for qπθ (st, at) is to use the sum of future rewards from the current state (sutton & barto, 1998)1. if we receive reward r at the end of the episode, we can then use qπθ (st, at) ≈ r for all time steps t in the episode. however, since q(at|st) is different from πθ(at|st) we will need to re-weight future rewards via importance sampling r ∏t i=t ρ(si, ai). this is to account for the fact that an action a given s may have been more likely under the policy πθ(·|s) than it was under q(·|s) or vice versa. instead of directly using the re-weighted rewards, we will use the so called λ–return which is a convex combination of the re-weighted rewards and the value function (sutton, 1988; 1984). in our setting, they are defined recursively from the end of the episode t = t + 1 to t = 1 as follows. for λ ∈ (0, 1],
r̃λt+1 = r, r̃ λ t = (1− λ)v πθ (st+1) + λρ(st, at)r̃λt+1 for t = t, . . . , 1. (3)
the purpose of introducing λ is to reduce the variance of using the future rewards alone as an estimate for qπθ (st, at). this is primarily useful when rewards are noisy. if the rewards are deterministic, λ = 1 which ignores the value function is the best choice. in noisy settings, it is recommended to use λ < 1 (see sec 3.1 of (szepesvári, 2010)). in our algorithm, we will replace r̃λt with r λ t where v πθ is replaced with the estimate v̂ . putting it all together, and letting α denote the step size, we have the following update rule for the parameters θ of our policy:
θ ← θ + αρ(st, at)ψ(st, at)(rλt − v̂ (st)). in algorithm 1, we have summarised the procedure where the updates are performed after an entire pass through the dataset. in practice, we perform the updates in mini-batches.
an estimator for the value function: all that is left to do is to specify an estimator v̂ for the value function. we first need to acknowledge that this is a difficult problem: s is quite large and for typical applications for this work there might not be enough data since labels are expensive. that said, the purpose of v̂ in (2), (3) is to reduce the variance of our sgd updates and speed up convergence so it is not critical that this be precise – even a bad estimator will converge eventually. secondly, standard methods for estimating the value function based on minimising the projected bellman error require the second derivatives, which might be intractable for highly nonlinear parametrisations of v̂ (maei, 2011). for these two statistical and computational reasons, we resort to simple estimators for v πθ . we will study two options. the first is a simple heuristic used previously in the rl literature, namely a constant estimator for v̂ which is equal to the mean of all rewards in the dataset (williams, 1992). the second uses the parametrisation v̂ (s) = σ(ξ>φ(s)) where σ is the logistic function and φ(s) ∈ rd is a euclidean representation of the state. for v̂ (s) of the above form, the hessian ∇2ξv̂ (s) can be computed in o(d) time. to estimate this value function, we use the gtd(λ) estimator from maei (2011). as φ(s) we will be using the hidden state of the lstm. the rationale for this is as follows. in an lstm trained using maximum likelihood, the hidden state contains useful information about the objective. if there is overlap between the maximum likelihood and reinforcement learning objectives, we can expect the hidden state to also carry useful information about the rl objective. therefore, we can use the hidden state to estimate the value function whose expectation is the rl objective. we have described our implementation of gtd(λ) in appendix a and specified some implementation details in section 4.  note qπθ (st, at) = v πθ (st+1) for deterministic transitions. however, it is important not to interpret the term in (2) as the difference in the value function between successive states. conditioned on the current time step, v πθ (st) is deterministic, while v πθ (st+1) is stochastic. in particular, while a crude estimate suffices for the former, the latter is critical and should reflect the rewards received during the remainder of the episode.
algorithm 1 batch policy gradient (bpg) given: data {(xi, yi, ri)}ni=1, step size α, return coefficient λ, initial θ0.
– set θ ← θ0. – for each epoch k = 1, 2, . . .
i set ∆θ ← 0 i for each episode i = 1, . . . , n • rλt+1 ← ri • ρt ← πθ(a(i)t |s (i) t )/q(a (i) t |s (i) t ) for t = 1, . . . , t
(i). • for each time step in reverse t = t (i), . . . , 1
(i) rλt ← (1− λ)v̂ (s (i) t+1) + λρtr λ t+1
(ii) ∆θ ← ∆θ + 1 t (i) ρtψ(s (i) t , a (i) t )(r λ t − v̂ (s (i) t ))
(iii) compute updates for the value function estimate v̂ . i update the policy θ ← θ + α∆θ i update the value function estimate v̂ .policy gradient methods have been studied extensively in on policy settings where the goal is to improve the current policy on the fly (amari, 1998; williams, 1992). to our knowledge, all rl approaches in seq2seq models have also adopted on-policy policy gradient updates (bahdanau , 2016; li , 2016; ranzato , 2015; williams & zweig, 2016). however, on policy methods break down in off-policy settings, because any update must account for the probability of the action under the target policy. for example, suppose the behaviour policy took action a at state s and received a low reward. then we should modify the target policy θ so as to reduce πθ(a|s). however, if the target policy is already assigning low probability to a|s then we should not be as aggressive when making the updates. the re-weighting ρ(s, a) via importance sampling does precisely this.
a second difference is that we study batch rl. standard on-line methods are designed for settings where we have to continually improve the target while exploring using the behaviour policy. critical to such methods are the estimation of future rewards at the current state and the future actions that will be taken by both the behaviour and target policies. in order to tackle this, previous research either ignore future rewards altogether (williams, 1992), resort to heuristics to distribute a delayed reward to previous time steps (bahdanau , 2016; williams & zweig, 2016), or make additional assumptions about the distribution of the states such as stationarity of the markov process (degris , 2012; maei, 2011). however, in batch settings, the λ-return from a given time step can be computed directly (3) since the future action and rewards are available in the dataset. access to this information provides a crucial advantage over techniques designed for on-line settings.implementation details: we implement our methods using chainer (tokui , 2015), and group sentences of the same length together in the same batch to make use of gpu parallelisation. since different batches could be of different length, we do not normalise the gradients by the batch size as we should take larger steps after seeing more data. however, we normalise by the length of the output sequence to allocate equal weight to all sentences. we truncate all output sequences to length 64 and use a maximum batch size of 32. we found it necessary to use a very small step size (10−5), otherwise the algorithm has a tendency to get stuck at bad parameter values. while importance reweighting is necessary in off-policy settings, it can increase the variance of the updates, especially when q(at|st) is very small. a common technique to alleviate this problem is to clip the ρ(st, at) value (swaminathan & joachims, 2015). in addition to single ρ(st, at) values, our procedure has a product of ρ(st, at) values when computing the future rewards (3). the effect of large ρ values is a large weight ρt(rλt −v̂ (st)) for the score function in step (ii) of algorithm 1. in our implementation,
lstm lstm lstm
lstm lstm lstm
softmax softmax softmax
lstm lstm
lstm lstm
encoder decoder
we clip this weight at 5 which controls the variance of the updates and ensures that a single example does not disproportionately affect the gradient.
rnn design: in both experiments we use deep lstms with two layers for the encoder and decoder rnns. the output of the bottom layer is fed to the top layer and in the decoder rnn, the output of the top layer is fed to a softmax layer of size |a|. when we implement gtd(λ) to estimate v πθ we use the hidden state of the bottom lstm as φ(s). when performing our policy updates, we only change the parameters of the top lstm and the softmax layer in our decoder rnn. if we were to change the bottom lstm too, then the state representation φ(s) would also change as the policy changes. this violates the mdp framework. in other words, we treat the bottom layer as part of the environment in our mdp. to facilitate a fair comparison, we only modify the top lstm and softmax layers in all methods. we have illustrated this set up in fig. 1. we note that if one is content with using the constant estimator, then one can change all parameters of the rnn.to convey the main intuitions of our method, we compare our methods against other baselines on a synthetic task on the european parliament proceedings corpus (koehn, 2005). we describe the experimental set up briefly, deferring details to appendix b.1. the input sequence to the rnn was each sentence in the dataset. given an input, the goal was to reproduce the words in the input without repeating words in a list of forbidden words. the rl algorithm does not explicitly know either goal of the objective but has to infer it from the stochastic rewards assigned to input output sequences in the dataset. we used a training set of 500 input-output-reward triplets for the rl methods.
we initialised all methods by maximum likelihood training on 6000 input output sequences where the output sequence was the reverse of the input sequence. the maximum likelihood objective captures part of the rl objective. this set up reflects naturally occurring practical scenarios for the algorithm where a large amount unlabelled data can be used to bootstrap a policy if the maximum likelihood and reinforcement learning objectives are at least partially aligned. we trained the rl algorithms for 200 epochs on the training set. at the end of each epoch, we generated outputs from the policy on test set of 500 inputs and scored them according to our criterion. we plot the test set error against the number of epochs for various methods in fig. 2.
fig. 2(a) compares 3 methods: bpg with and without maximum likelihood initialisation and a version of bpg which does not use importance sampling. clearly, bootstrapping an rl algorithm with ml can be advantageous especially if data is abundantly available for ml training. further, without importance sampling, the algorithm is not as competitive for reasons described in section 3. in all 3 cases, we used a constant estimator for v̂ and λ = 0.5. the dashed line indicates the performance of ml training alone. bpg-nis is similar to the algorithms of ranzato  (2015); williams & zweig (2016) except that there, their methods implicitly use λ = 1.
fig. 2(b) compares 4 methods: bpg and its on-line version opg with constant (const) and gtd(λ) estimators for v̂ . the on-line versions of the algorithms are a direct implementation of the method in degris  (2012) which do not use the future rewards as we do. the first observation is that while gtd(λ) is slightly better in the early iterations, it performs roughly the same as using a constant estimator in the long run. next, bpg performs significantly better than opg. we believe this is due to the following two reasons. first, the online updates assume stationarity of the mdp. when this does not hold, such as in limited data instances like ours, the sgd updates can be
very noisy. secondly, the value function estimate plays a critical role in the online version. while obtaining a reliable estimate v̂ is reasonable in on-line settings where we can explore indefinitely to collect a large number of samples, it is difficult when one only has a limited number of labelled samples. finally, we compare bpg with different choices for λ in fig. 2(c). as noted previously, λ < 1 is useful with stochastic rewards, but choosing too small a value is detrimental. the optimal λ value may depend on the problem.we use data from an on-line restaurant recommendation service. customers log into the service and chat with a human agent asking recommendations for restaurants. the agents ask a series of questions such as food preferences, group size etc. before recommending a restaurant. the goal is to train a chatbot (policy) which can replace or assist the agent. for reasons explained in section 1, maximum likelihood training alone will not be adequate. by obtaining reward labels for responses produced by various other bots, we hope to improve on a bot initialised using maximum likelihood.
data collection: we collected data for rl as follows. we trained five different rnn chatbots with different lstm parameters via maximum likelihood on a dataset of 6000 conversations from this dataset. the bots were trained to reproduce what the human agent said (output y) given the past conversation history (input x). while the dataset is relatively small, we can still expect our bots to do reasonably well since we work in a restricted domain. next, we generated responses from these bots on 1216 separate conversations and had them scored by workers on amazon mechanical turk (amt). for each response by the bots in each conversation, the workers were shown the history before the particular response and asked to score (label) each response on a scale of 0− 1− 2. we collected scores from three different workers for each response and used the mean as the reward.
policies and rl application: next, we initialised 2 bots via maximum likelihood and then used bpg to improve them using the labels collected from amt. for the 2 bots we used the following lstm hidden state size h , word embedding size e and bpg parameters. these parameters were chosen arbitrarily and are different from those of the bots used in data collection described above.
• bot-1: h = 512, e = 256. bpg: λ = 0.5, gtd(λ) estimator for v̂ .
• bot-2: h = 400, e = 400. bpg: λ = 0.5, constant estimator for v̂ .
testing: we used a separate test set of 500 conversations which had a total of more than 3500 inputoutput (conversation history - response) pairs. for each bot-1 and bot-2 we generated responses before and after applying bpg, totalling 4 responses per input. we then had them scored by workers on amt using the same set up described above. the same worker labels the before-bpg and afterbpg responses from the same bot. this controls spurious noise effects and allows us to conduct a paired test. we collected 16, 808 before and after label pairs each for bot-1 and bot-2 and compare them using a paired t-test and a wilcoxon signed rank test.
results: the results are shown in table 1. the improvements on bot-2 are statistically significant at the 10% level on both tests, while bot-1 is significant on the wilcoxon test. the large p-values for bot-1 are due to the noisy nature of amt experiments and we believe that we can attain significance if we collect more labels which will reduce the standard error in both tests. in appendix b.2 we present some examples of conversation histories and the responses generated by the bots before and after applying bpg. we qualitatively discuss specific kinds of issues that we were able to overcome via reinforcement learning.we presented a policy gradient method for batch reinforcement learning to train chatbots. the data to this algorithm are input-output sequences generated using other chatbots/humans and stochastic rewards for each output in the dataset. this setting arises in many applications, such as customer service systems, where there is usually an abundance of unlabelled data, but labels (rewards) are expensive to obtain and can be noisy. our algorithm is able to efficiently use minimal labelled data to improve chatbots previously trained through maximum likelihood on unlabelled data. while our method draws its ideas from previous policy gradient work in the rl and nlp literature, there are some important distinctions that contribute to its success in the settings of interest for this work. via importance sampling we ensure that the probability of an action is properly accounted for in off-policy updates. by explicitly working in the batch setting, we are able to use knowledge of future actions and rewards to converge faster to the optimum. further, we use the unlabelled data to initialise our method and also learn a reasonable behaviour policy. our method outperforms baselines on a series of synthetic and real experiments.
the ideas presented in this work extend beyond chatbots. they can be used in applications such as question answering, generating image descriptions and machine translation where an output sentence generated by a policy is scored by a human labeller to provide a weak supervision signal.we would like to thank christoph dann for the helpful conversations and michael armstrong for helping us with the amazon mechanical turk experiments.a implementation of gtd(λ)
we present the details of the gtd(λ) algorithm (maei, 2011) to estimate a value function in algorithm 2. however, while maei (2011) give an on-line version we present the batch version here where the future rewards of an episode are known. we use a parametrisation of the form v̂ (s) = v̂ξ(s) = σ(ξ
>φ(s)) where ξ ∈ rd is the parameter to be estimated. σ(z) = 1/(1 + e−z) is the logistic function.
the algorithm requires two step sizes α′, α′′ below for the updates to ξ and the ancillary parameter w. following the recommendations in borkar (1997), we use α′′ α. in our implementations, we used α′ = 10−5 and α′′ = 10−6. when we run bpg, we perform steps (a)-(f) of algorithm 2 in step (iii) of algorithm 1 and the last two update steps of algorithm 2 in the last update step of algorithm 1.
the gradient and hessian of v̂ξ have the following forms,
∇ξv̂ξ(s) = v̂ξ(s)(1− v̂ξ(s))φ(s), ∇2ξv̂ξ(s) = v̂ξ(s)(1− v̂ξ(s))(1− 2v̂ξ(s))φ(s)φ(s)>.
the hessian product in step (d) of algorithm 2 can be computed in o(d) time via, ∇2ξv̂ξ(s) · w = [ v̂ξ(s)(1− v̂ξ(s))(1− 2v̂ξ(s))(φ(s)>w) ] φ(s).
algorithm 2 gtd(λ) given: data {(xi, yi, ri)}ni=1, step sizes α′, α′′, return coefficient λ, initial ξ0.
– set ξ ← ξ0, w ← 0. – for each epoch k = 1, 2, . . .
i set ∆ξ ← 0, ∆w ← 0. i for each episode i = 1, . . . , n • set rλt+1 ← ri, gλt+1 ← 0, qλt+1 ← 0 • ρt ← πθ(a(i)t |s (i) t )/q(a (i) t |s (i) t ) for t = 1, . . . , t
(i). • for each time step in reverse t = t (i), . . . , 1:
(a) gλt ← ρt ( (1− λ)v̂ξ(s(i)t+1) + λρtrλt+1 )
(b) qλt ← ρt ( (1− λ)∇ξv̂ξ(s(i)t+1) + λqλt+1 )
(c) δt ← gλt − v̂ξ(s (i) t ) (d) ht ← ( δt − w>∇ξv̂ξ(s(i)t ) ) ∇2ξv̂ξ(s (i) t ) · w
(e) ∆w ← ∆w + 1 t (i) ( δt − w>∇ξv̂ξ(s(i)t ) ) ∇ξv̂ξ(s(i)t )
(f) ∆ξ ← ∆ξ + 1 t (i) ( δt∇ξv̂ξ(s(i)t )− qλt w>∇ξv̂ξ(s (i) t )− ht ) i w ← w + α′′∆w. i ξ ← ξ + α′∆ξ.given an input and output sequence, we used the average of five bernoulli rewards bern(r), where the parameter r was r = 0.75 × rr + 0.25 × rf. here rr was the fraction of common words in the input and output sequences while rf = 0.01pf where pf is the fraction of forbidden words in the dataset. as the forbidden words, we used the 50 most common words in the dataset. so if an input
had 10 words of which 2 were forbidden, an output sequence repeating 7 of the allowed words and 1 forbidden word would receive an expected score of 0.75× (8/10) + 0.25× 0.01(1/8) = 0.7406. the training and testing set for reinforcement learning were obtained as follows. we trained 4 bots using maximum likelihood on 6000 input output sequences as indicated in section 4.1. the lstm hidden state size h and word embedding size e for the 4 bots were, (h,e) = (256, 128), (128, 64), (64, 32), (32, 16). the vocabulary size was |a| = 12000. we used these bots to generate outputs for 500 different input sequences each. this collection of input and output pairs was scored stochastically as described above to produce a pool of 2000 input-output-score triplets. from this pool we use a fixed set of 500 triplets for testing across all our experiments. from the remaining 1500 data points, we randomly select 500 for training for each execution of an algorithm. for all rl algorithms, we used an lstm with 16 layers and 16 dimensional word embeddings.we collected the initial batch of training data for rl as follows: we trained, via maximum likelihood on 6000 conversations, five rnn bots whose lstm hidden sizeh and word embedding sizee were (h,e) = (512, 512), (256, 256), (128, 128), (512, 256), (256, 64). the inputs x were all words from the history of the conversation truncated at length 64, i.e. the most recent 64 words in the conversation history. the outputs were the actual responses of the agent which were truncated to length 64. as the vocabulary we use the |a| = 4000 most commonly occurring words in the dataset and replace the rest with an <unk> token.
using the bots trained this way we generate responses on 1216 separate conversations. this data was sent to amt workers who were asked to label the conversations on the following scale.
• 2: the response is coherent and appropriate given the history and advances the conversation forward.
• 1: the response has some minor flaws but is discernible and appropriate. • 0: the response is either completely incoherent or inappropriate and fails to advance the
conversation forward.in tables 2 and 3 we have presented some examples. the text in black/grey shows the conversation history, the response in blue is by the bot trained via maximum likelihood (ml) alone and in red is the bot after improvement using our bpg reinforcement learning algorithm. the first two examples of table 2 present examples where the ml algorithm repeated generic questions (on budget, group size etc.) even though they had already been answered previously. after applying bpg, we are able to correct such issues, even though there are some grammatical errors. in the second, third and fourth example, we see that the ml+bpg bot is able to take context into consideration well when responding. for example, the customer asks for oriental/mexican/italian food. while the ml bot doesn’t take this into consideration, the ml+bpg bot is able to provide relevant answers. however, in the third example, the name of the restaurant suggests that the food might be indian and not mexican. in the final example of table 2 the customer asks a direct question about smoking. the ml bot provides an irrelevant answer where as the ml+bpg bot directly responds to the question.
in some examples, the ml bot had a tendency to produce sentences that were grammatically correct but nonsensical, sensible but grammatically incorrect, or just complete gibberish. we were able to correct such issues via rl. the first three examples of table 3 present such cases. occasionally the opposite happened. the last example of table 3 is one such instance.",1
482.pdf.json,"the idea of exploiting the large amounts of data captured in electronic medical records for both clinical care and secondary research holds great promise, but its potential is weakened by errors and omissions in those records (safran , 2007; de lusignan & van weel, 2006). among many other problems, accurately capturing the list of medications currently taken by a given patient is extremely challenging (velo & minuz, 2009). in one study, over 50% of electronic medication lists contained omissions (caglar , 2011), and in another, 25% of all medications taken by patients were not recorded (kaboli , 2004). even medication lists provided by the patients themselves contain multiple errors and omissions (green , 2010) .
many efforts have been made to ensure the correctness of medication lists, most of them involving improved communication between patients and providers (keogh , 2016), but these efforts have not yet been successful, and incorrect or incomplete medication documentation continues to be a source of error in computational medical research. in this work we attempt to identify likely errors and omissions in the record, predicting the set of active medications from the sequence of most recent disease-based billing codes in the record. predictions from such a model could be used either in manual medication reconciliation (a common process undertaken to correct the medication record) or to provide a prior to other models, such as an nlp model attempting to extract medication use from the narrative clinical text.
given the sequential nature of clinical data, we suspected that recurrent neural networks would be a good architecture for making these predictions. in this work we investigate this potential, comparing the performance of recurrent networks to that of similarly-configured feed forward networks.
the input for each case is a sequence of icd-9 billing codes (section 2.1), for which the model produces a single, multi-label prediction of the therapeutic classes (section 3.1) of medications taken by the patient during the period of time covered by the billing code sequence.
this work is designed to test how well the complete set of medications a patient is actively taking at a given moment can be predicted by the sequence of diagnostic billing codes leading up to that moment, in the context of non-trivial label noise. it also explores whether sequence-oriented recursive neural nets can do a better job of that prediction than standard feed-forward networks.each time a patient has billable contact with the healthcare system, one or more date-stamped billing codes are attached to the patient record, indicating the medical conditions that are associated (or suspected to be associated) with the reason for the visit. while these codes are notoriously unreliable because they are only used for billing and not actual clinical practice (o’malley , 2005), they are nevertheless useful in a research context (bastarache & denny, 2011; denny , 2010), especially if they are used probabilistically (lasko, 2014). in our institution, codes from the international classification of diseases, ninth revision (icd-9) have historically been used, although we have recently transitioned to the tenth revision (icd-10). for this project, we used icd-9 codes.
the icd-9 hierarchy consists of 21 chapters roughly corresponding to a single organ system or pathologic class (appendix b). leaf-level codes in that tree represent single diseases or disease subtypes. for this project, we used a subset of the two thousand most common leaf-level codes as our input data.most of the iclr community are very familiar with recurrent neural networks and their variations, but we include a conceptual description of them here for readers coming from other fields. more thorough descriptions are available elsewhere (graves, 2012; olah, 2015).
a recurrent neural network is a variation in which the output of one node on input xt loops around to become an input to another node on input xt+1, allowing information to be preserved as it iterates over an input data sequence (figure 1). they were introduced in the 1980s (rumelhart , 1986), but achieved explosive popularity only recently, after the development of methods to more reliably capture long-term dependencies, which significantly improved their performance on sequence-tosequence mapping (hochreiter & schmidhuber, 1997; sutskever , 2014).
the basic rnn unit has a simple internal structure (figure 2a). output from the previous iteration ht−1 and the next input in a sequence xt are both fed to the network on the next iteration. the long short-term memory configuration (lstm) introduces new, more complex internal structure (figure 2b) consisting of four neural network layers and a cell state (ct), which is carried from one iteration to another. the additional layers form forget, input and output gates, which allow for the information to be forgotten (reset) or passed on to varying degrees.
the lstm model and its variations are commonly used in applications where sequence and temporal data are involved, such as in image captioning (vinyals , 2014), language translation (sutskever , 2014), and speech recognition (graves , 2013). in many cases lstm models define the state of the art, such as with a recent conversational speech recognizer that (slightly) outperforms professional transcriptionists (xiong , 2016).
a recent variation on the lstm architecture is the gated recurrent unit (gru) (cho , 2014), which introduces a single update gate in place of input and forget gates (figure 2c). grus perform as well as or better than lstms in many cases (chung , 2014; jozefowicz , 2015), and have the additional advantage of a simpler structure.
in this work we try both an lstm and a gru on our learning problem.little research in the computational medical domain has used recurrent neural networks. the earliest example we are aware of is the use of an lstm model that produced reasonable accuracy
(micro-auc 0.86) in a 128-dimensional multi-label prediction of diagnoses from regularly sampled, continuously-monitored, real-valued physiologic variables in an intensive care unit setting. this was an interesting initial application, but it turned out to be only 0.001 better than the baseline classifier, which was a multi-layer perceptron with expert-designed features (lipton , 2016). given the dataset size (10,401 patient records) the lack of improvement may have been due to insufficient data to power accurate feature learning in the recurrent network.
very recent work, contemporary with ours, used a gru model with a semantic embedding in 32,787 patient records to predict the development of heart failure 3 - 6 months in the future, from medication orders and billing codes in an 18-month window. the model achieved respectable accuracy (0.88 auc), and demonstrated a meaningful 0.05 auc improvement over a deep feedforward network (choi , 2016b).
other recent work from the same group used a gru model in a multi-label context to predict the medications, billing codes, and time of the next patient visit from a sequence of that same information for previous visits, using 263,706 patient records. it achieved a recall@30 of 72.4 for the task, an improvement of 20 over a single-hidden-layer mlp with 2000 units (choi , 2016a). this is an example of using one of the strengths of a recurrent network - predicting the next element in a sequence. it contrasts with our work that exploits a different strength of recurrent networks - predicting a sequence or class that is semantically distinct from but parallel to the elements of the input sequence.
the closest work to ours from a medical domain perspective is a series of collaborative filter models (including co-occurrence counting, k-nearest neighbors, and logistic regression) that predict missing medications using a leave-one-drug-out evaluation design, with predictions based on the rest of the medications, icd-9 billing codes, and demographic data. the models were trained and tested on data from 419 patients in three different clinics, with accuracy varying by clinic, as expected, but not appreciably by model. most models ranked the missing drug in the top 10 results between 40 and 50% of the time, and ranked the therapeutic class of the drug in the top 10 results between 50 and 65% of the time.
many aspects of our work can be found in these prior efforts, but none addresses our particular problem in the same way. our work is unique in its learning problem of identifying all drugs a patient is likely to be taking, based only on the billing codes in the record. like most others cited, we use recurrent neural networks in a multi-label predictive context, but in contrast to them we compare
to the most similar non-recurrent model we can construct, in order to evaluate the contribution of the temporal sequence information to the solution. finally, we use one to four orders of magnitude more data (3.3 million instances, see section 3.1) than these prior efforts, which we hope will give us a more realistic assessment of the various deep architectures we use on our problem.our source database was the deidentified mirror of vanderbilt’s electronic medical record, which contains billing codes, medication histories, laboratory test results, narrative text and medical imaging data for over 2 million patients, reaching back nearly 30 years (roden , 2008). we obtained irb approval to use this data in this research.
for this experiment we filtered all records in our database to include only the top 1,000 most common medications and the top m = 2000 most common billing codes, which cover 99.5% of all medication occurrences and 85.1% of all billing code occurrences. we then included all records from the filtered data that had at least one medication occurrence and at least ten billing code occurrences. this resulted in 610,076 complete patient records, which we divided 80/5/15 into training, validation, and final test sets.
a data instance d = {e, t, y} consisted of a sequence e = {e1, . . . , en}, of one-hot billing code vectors ei ∈ {0, 1}m and their associated times t = {t1, . . . , tn}, ti ∈ r as input, and a multi-label vector y ∈ {0, 1}k of medication classes as the output target. the most recent n = 100 billing codes to a selected reference time point in a given patient record were collected into the input sequence e, and their occurrence times into t , zero padding if necessary. all medications that occurred during the time span of t were then collected into the output vector y. practice patterns change over time, so simply taking the most recent 100 codes for each patient could produce a biased result. to avoid this, we chose random reference points, stratified by medication. in other words, the reference points were randomly chosen from the occurrences of each medication in the entire dataset, up to 10,000 points per medication. this resulted in 3.3 million data instances, an average of 5.4 instances per patient record. each patient’s data was included in at most one of the training, validation, or test sets.
because there are often many approximately equivalent medication choices for a given therapeutic purpose, we converted medication names to their therapeutic class (beta blocker, immunosuppressant, corticosteroid, etc.) as a synonym reduction step. this step also aggregated generic with brand names, as well as different formulations of the same active ingredient. for this task we used the anatomical chemical classification system (atc)1, which is a multi-level ontology of medications, organized by both anatomic and therapeutic class. the top level is a broad categorization of medications (appendix b), the bottom (fifth) level is individual medications, and we used the third level, which contains 287 therapeutic classes of the approximately appropriate abstraction level for our purpose. we used a publicly available mapping2 to translate between our medication names and atc codes, with manual mapping for the minority of medications that had no mapping entry. our set of medications used k = 182 third-level atc codes, rendering our output label a 182-elementlong multi-label vector, in which an element is set yi = 1 if a medication in that class appeared in the set of medications identified for that instance, yi = 0 otherwise. some medications mapped to more than one class, and we set yi = 1 for all of them.
our medication data was collected from structured order entry records and extracted using nlp (xu , 2010) from mentions in the narrative text of a patient record that included the medication name, dose, route and frequency. as discussed above, we assumed (and our results demonstrate) that the medication data is incomplete, and our hope was that a model learned from a sufficiently large dataset will be robust to the missing data.
this configuration represents the input billing codes in a sequence, but the output medications as a multi-label vector. this is because icd-9 codes are represented sequentially in our source data, but medications are not. they are represented as a list that changes over time in the record. the http://www.whocc.no/atc/structure and principles/ 2https://www.nlm.nih.gov/research/umls/rxnorm/
usual goal of clinicians is to verify the list of medications at each visit, and if omissions or additions are indicated by the patient, to change the list to reflect that. but in the time-constrained reality of clinical practice, this reconciliation happens sporadically, and many clinicians are hesitant to change an entry on the medication list for which they were not the original prescriber, so the timing of the changes in the documentation do not reflect the timing of changes in reality. therefore we are reduced to predicting a single multi-label vector, representing the medications that the patient probably took during the span of time represented by the input codes. (we actually did attempt some full sequence-to-sequence mappings, with various orderings of the medication sequences, but we did not achieve any promising results in that direction.)our main technical goal was to test the performance of recurrent neural networks on this sequencecentric prediction problem. to evaluate the specific gains provided by the recurrent architectures, we compare performance against a fully connected feed-forward network configured as similarly as possible to the recurrent networks, and (as baselines) a random forest and a constant-prevalence model. we discuss the specific configurations of these classifiers in this section.we tested both lstms and grus in this experiment. we configured both architectures to first compute a semantic embedding xi ∈ rb of each input ei vector, before appending the times ti (figure 3) and feeding the result to three layers of recurrent units. the final output from the last pass of recurrent unit is as a multi-label prediction for each candidate medication.
the optimal hyperparameters for the model were selected in the randomized parameter optimization (bergstra & bengio, 2012), with the embedding dimension b = 32, number of layers, and number of nodes optimized by a few trials of human-guided search. other optimized parameters included the fraction of dropout (between layers, input gates and recurrent connections), and l1 and l2 regularization coefficients (final values are presented in appendix a).
both models were implemented using keras (chollet, 2015) and trained for 300 iterations using cross-entropy under the adadelta optimizer (zeiler, 2012).the fully connected network used as similar an architecture as possible to the recurrent networks, in an attempt to isolate the gain achieved from the recurrence property. specifically, we used the same architecture for embedding and timestamp appending (figure 3).
hyperparameters were optimized using random search over the number of layers, number of nodes, dropout, activation function between layers, l1 and l2 regularization coefficients (appendix a). (surprisingly, the optimizer chose tanh over relu as the optimal activation function.)
the models were also implemented using keras, and were trained using cross-entropy for 500 iterations under the adadelta optimizer.because the random forest model is not easily structured to operate on sequences, we represented the input data as either binary occurrence vectors v ∈ {0, 1}m, or bag-of-codes vectors w ∈ nm (counts of each code value in the sequence) rather than as sequences of codes with associated times. no embedding was used, because random forest code was not able to cope with the large size of the data in the (dense) embedded space.
even in the (sparse) original space, the full dataset was too large for the random forest code, so we implemented it as an ensemble of ten independent forests, each trained on one tenth of the training data, and their average score used for test predictions.
models were implemented using scikit-learn (pedregosa , 2011) with parameters optimized under random search (appendix a).
while other models could reasonably serve as a baseline for this work, we chose a random forest because they tend to perform well on widely varying datasets (fernández-delgado , 2014), they are efficient to train and test, and they don’t require a huge effort to optimize (in order to produce a fair comparison).this minimum baseline model simply predicts the prevalence of each label for all instances. for example, if there were three possible medications, with prevalences of 0.3, 0.9, and 0.2, then the prediction of this model would be a constant [0.3, 0.9, 0.2] for each instance. we include this model in order to mitigate the fact that while all of our evaluation measures are suitable for comparing models on the same data, some are not well suited for external comparison because they depend, for example, on the prevalence of positive labels (section 3.4). by including this model we can at least establish a true minimum baseline for reference.our main evaluation focused on the models, although we also performed a separate evaluation of the embedding.there are several possibilities for evaluation in a multi-label classification context (sechidis , 2011; zhang & zhou, 2014). we chose micro-averaged area under the roc curve (auc) and label ranking loss as the primary methods of evaluation, because they treat each instance with equal weight, regardless of the nature of the positive labels for that instance. in other words, we wanted primary measures that did not give a scoring advantage to instances with either very many or very few positive labels, or that included very rare or very prevalent labels. additionally, both of these measures appeal to us as intuitive extensions of the usual binary auc, when seen from the perspective of a single instance. however, because these two measures don’t reflect all aspects of multi-label prediction performance, we also include macro-averaged auc, label ranking average precision and coverage error measures.
micro-averaged auc considers each of the multiple label predictions in each instance as either true or false, and then computes the binary auc as if they all belonged to the same 2-class problem (zhang & zhou, 2014). in other words, micro-averaged auc aµ is:
aµ = ∣∣(x, x′, l, l′) : f(x, l) ≥ f(x′, l′), (x, l),∈ s, (x′, l′) ∈ s̄∣∣∣∣s∣∣∣∣s̄∣∣ , (1) where s = {(x, l) : l ∈ y } is the set of (instance, label) pairs with a positive label, and y = {yi : yi = 1, i = 1 . . . k} is the set of positive labels for input x. label ranking loss lr gives the average fraction of all possible (positive, negative) label pairs for each instance in which the negative label has a higher score than the positive label (tsoumakas , 2010):
lr = 1
n n∑ j=1 
|y (j)||y (j)| ∣∣∣{(l, l′) : r(j)(l) > r(j)(l′), (l, l′) ∈ y (j) × y (j) }∣∣∣ (2) where the superscript (j) refers to the jth test instance (of n total instances) and r(l) is the predicted rank of a label l.
macro-averaged auc can be thought of as averaging the auc performance of several one-vs-all classifiers, one model for each label. it treats each model equally, regardless of the prevalence of positive labels for that model. this gives a score of 0.5 to the constant-prevalence model, at the cost of weighting instances differently in order to achieve that. this is in contrast to micro-averaged auc, which can be thought of as averaging across instances rather than labels. it weighs each instance equally, at the cost of a 0.5 score no longer being the random-guessing baseline.
label ranking average precision gives the mean fraction of correct positive labels among all positive labels with lower scores for each label. the coverage error function calculates the mean number of labels on the ranked list that are needed to cover all the positive labels of the sample. both of these depend on the prevalence of positive labels in a test instance.we evaluated the embedding based on how strongly related in a clinical semantic sense the nearest neighbor to each code is (in the embedding space). a licensed physician manually annotated the list of all 2000 codes with its match category m ∈ {strongly related,loosely related,unrelated}, and we computed the empirical marginal probability p (m) of each category, the empirical conditional probability p (m|d) of the match category given the nearest neighbor (manhattan) distance d and the empirical marginal probability p (d). for comparison, we computed p (m) under 100 random code pairings.the gru model had the top performance by all measures, although the lstm was a close second (table 1), a performance pattern consistent with previous reports (chung , 2014). the deep neural net performance was about 0.01 worse in both measures, suggesting that the recurrent models were able to use the sequence information, but only to a small advantage over the most similar nontemporal architecture. however, we note that both rnns’ performance peaked at the top end of our tractable range for model size, while the feed-forward network peaked using a model about one third that size (appendix a). experimenting with the architecture, we found that increasing the number of nodes or layers for the feed-forward network increased training time but not performance. this suggests that the rnn performance was limited by the hardware available, and increasing the size of the model may further increase performance, and that the feed-forward network was limited by something else.
both random forest models were weaker than the deep neural net, as might be expected from the need to resort to binary and bag-of-codes representations of the input data.
a natural question is what performance is good enough for clinical use. while there is little clinical experience with multi-label classifiers, we would generally expect clinicians using a binary classifier in an advisory role to find an auc & 0.9 to be useful, and auc & 0.95 to be very useful. an auc difference of 0.01, and perhaps 0.005 are potentially noticeable in clinical use.
this 0.9/0.01 rule of thumb may loosely translate to our auc variants, but it can directly translate to label ranking loss lr (2). if we think of a single output prediction ŷ ∈ [0, 1]k as a set of predictions for k binary labels, then 1− auc for that set of predictions is equivalent to lr for the original instance ŷ. therefore, values of lr . 0.1 may be clinically useful, and lr . 0.05 may be very useful.
subjectively examining performance on 20 randomly selected cases, we find very good detailed predictions, but also evidence of both missing medications and missing billing codes. an example of a good set of detailed predictions is from a complex patient suffering from multiple myeloma (a type of cancer) with various complications. this patient was taking 26 medications, 24 of which had moderate to high probability predictions (figure 4). (we have found by eyeball that a prediction cutoff of 0.2 gives a reasonable balance between sensitivity and specificity for our model.) in the other direction, only two of the high-prediction classes were not actually being taken, but those classes, along with several of the other moderately-predicted classes, are commonly used for cancer and are clinically reasonable for the case. (details of this and the two cases below are in appendix c).
a good example of missing medications is a case in which the record has multiple billing codes for both osteoporosis (which is very commonly treated with medication) and postablative hypothyroidism (a deliberately induced condition that is always treated with medication), but no medications of the appropriate classes were in the record. the gru model predicted both of these classes, which the patient was almost surely taking.
a good example of either missing billing codes or discontinued medications that remain documented as active is a case in which the record has at least five years of data consisting only of codes for parkinson’s disease, but which lists medications for high cholesterol, hypertension, and other heart disease. the gru model predicted a reasonable set of medications for parkinson’s disease and its complications, but did not predict the other medications that are not suggested by the record.
given how easy it was to find cases with apparently missing codes and medications, we conclude that there is indeed a substantial amount of label noise in our data, and we therefore interpret our models’ performance as lower bounds on the actual performance. we are encouraged that this kind of a model may actually be useful for identifying missing medications in the record, but of course a more thorough validation, and possibly a more accurate model, would be necessary before using in a clinical scenario. a definitive experiment would use off-line research, including reconciling information from various electronic and human sources to establish the ground truth of which medications were being taken on a particular day, but such efforts are labor intensive and expensive, and can only be conducted on a very small scale.
an interesting byproduct of these models is the semantic embedding of icd-9 codes used in the recurrent networks (figure 5). transforming input to a semantic embedding is a common preprocessing step to improve performance, but clearly the semantic understanding it provides to an algorithm can be useful beyond the immediate learning problem (mikolov , 2013). investigating the embedding learned in this experiment shows some generalizable potential, but it also reveals the need for further refinement before it can be truly useful. specifically, while it’s easy to find tight groups of icd-9 codes that are strongly clinically related in our embedding, we also find groups for which we cannot see a meaningful clinical relationship.
for example, we see two groups of codes relating to kidney failure and diabetes mellitus, two classes of very prevalent disease (figure 5, insets). in other iterations with different parameter settings, the kidney failure codes were even embedded in a sequence reflecting the natural progression of the disease, with the code for dialysis (an intensive treatment for end-stage kidney failure) embedded at the appropriate place. interestingly, these were not the parameter settings that optimized overall prediction performance. in other settings, such as our performance-optimal setting, the sequence is close to the natural progression of the disease, but not quite identical. nevertheless, this is an exciting result that suggests great potential.
further evaluation of the embedding found that 49% of codes were strongly related semantically to their nearest neighbor, 10% were loosely related, and 41% unrelated. this fraction of strongly related nearest neighbors was lower than we had hoped, but much higher than expected by chance (figure 6), and it definitely improved classification performance. furthermore, it was obvious by inspection that in general, codes closer in the embedding were more semantically related than distant codes, but interestingly, the distance to the nearest such neighbor showed the opposite relationship — nearest neighbors that were very close were less likely to be semantically related than nearest neighbors that were far, and this trend is roughly linear across the full range of d (figure 6). so the sparser the points are in the embedded space, the more semantically related they are to their nearest neighbor, but the causal direction of that effect and the technical reason for it are beyond the scope of this initial work.
for this prediction problem, we settled on predicting the medications that occurred in the record during the same time span as the billing codes used. originally, we intended to predict only the medications listed on the day of the reference point, but that turned out to greatly exacerbate the missing medication problem. after trying medications that fell on the reference day only, the week prior to the reference day, and the six months prior, our best performance both subjectively and objectively was achieved using the full time range of the input data.
while the performance of the recurrent networks was quite good, we believe it could be improved by including additional input data, such as laboratory test results, demographics, and perhaps vital
signs. we also suspect that if we can devise a way to convert our medication data into reliablyordered sequences, we can more fully exploit the strengths of recurrent networks for medication prediction. we look forward to trying these and other variations in future work.this work was funded by grants from the edward mallinckrodt, jr. foundation and the national institutes of health r21lm011664 and r01eb020666. clinical data was provided by the vanderbilt synthetic derivative, which is supported by institutional funding and by the vanderbilt ctsa grant ultr000445.this appendix lists the optimized parameters for the different models. except where noted, parameters were optimized under random search.
recurrent neural network models: (parameters marked with an asterisk were optimized with human-guided search.)
parameter model
gru lstm
dropout for input gates 0.1 0.25 dropout for recurrent connections 0.75 0.75 l1 applied to the input weights matrices 0 0 l1 applied to the recurrent weights matrices 0 0 l2 applied to the input weights matrices 0.0001 0.0001 l2 applied to the recurrent weights matrices 0.0001 0.001 l2 applied to the output layer’s weights matrices 0.0001 0.001 dropout before the output layer 0.5 0.5 *number of recurrent layers 3 3 *number of nodes in recurrent units 400 400
feed forward neural network model:
parameter value
dropout before the output layer 0.1 dropout between feed-forward layers 0.1 number of feed-forward layers 3 activation function between feed-forward layers tanh number of nodes in feed-forward layers 128
random forest model (binary input):
parameter value
number of estimators 800 ratio of features to consider when looking for the best split 0.4666 minimum number of samples required to split an internal node 87 minimum number of samples required to be at a leaf node 3 the function to measure the quality of a split entropythis appendix lists the top level classes for international statistical classification of diseases and related health problems, ninth revision (icd-9) and anatomical chemical classification system (atc).
icd-9 chapters.
code range description -139 infectious and parasitic diseases 140-239 neoplasms 240-279 endocrine, nutritional and metabolic diseases, and immunity disorders 280-289 diseases of the blood and blood-forming organs 290-319 mental disorders 320-359 diseases of the nervous system 360-389 diseases of the sense organs 390-459 diseases of the circulatory system 460-519 diseases of the respiratory system 520-579 diseases of the digestive system 580-629 diseases of the genitourinary system 630-679 complications of pregnancy, childbirth, and the puerperium 680-709 diseases of the skin and subcutaneous tissue 710-739 diseases of the musculoskeletal system and connective tissue 740-759 congenital anomalies 760-779 certain conditions originating in the perinatal period 780-799 symptoms, signs, and ill-defined conditions 800-999 injury and poisoning
v01-v91 supplementary - factors influencing health status and contact with health services e000-e999 supplementary - external causes of injury and poisoning
top level groups atc codes and their corresponding colors used in figure 4 and appendix c.
code contents color
a alimentary tract and metabolism b blood and blood forming organs c cardiovascular system d dermatologicals g genito-urinary system and sex hormones h systemic hormonal preparations, excluding sex hormones and insulins j antiinfectives for systemic use l antineoplastic and immunomodulating agents m musculo-skeletal system n nervous system p antiparasitic products, insecticides and repellents r respiratory system s sensory organs v variousthis appendix presents results from three illustrative cases from the dozen cases randomly selected for individual evaluation.
case 1.
icd-9 code code description time estimate (ago) .00 multiple myeloma, without mention of having achieved remission 4.8 months ago 273.1 monoclonal paraproteinemia 4.8 months ago 285.9 anemia, unspecified 4.8 months ago 276.50 volume depletion, unspecified 4.8 months ago 733.00 osteoporosis, unspecified 4.8 months ago 203.00 multiple myeloma, without mention of having achieved remission 4.8 months ago 203.00 multiple myeloma, without mention of having achieved remission 2.9 months ago 203.01 multiple myeloma, in remission 2.9 months ago 273.1 monoclonal paraproteinemia 2.9 months ago 273.1 monoclonal paraproteinemia 1.6 months ago 279.3 unspecified immunity deficiency 1.6 months ago 203.00 multiple myeloma, without mention of having achieved remission 1.6 months ago 781.2 abnormality of gait 3.7 weeks ago 203.00 multiple myeloma, without mention of having achieved remission 3.7 weeks ago 401.9 unspecified essential hypertension 3.7 weeks ago v12.54 personal history of transient ischemic attack (tia), and cerebral infarction without residual deficits 3.7 weeks ago 794.31 nonspecific abnormal electrocardiogram [ecg] [ekg] 3.7 weeks ago 786.09 other respiratory abnormalities 3.7 weeks ago 273.1 monoclonal paraproteinemia 3.7 weeks ago 203.00 multiple myeloma, without mention of having achieved remission 3.6 weeks ago v58.69 long-term (current) use of other medications 3.6 weeks ago 794.31 nonspecific abnormal electrocardiogram [ecg] [ekg] 3.4 weeks ago 203.00 multiple myeloma, without mention of having achieved remission 4 days ago v42.82 peripheral stem cells replaced by transplant 4 days ago 203.01 multiple myeloma, in remission 3 days ago 8.97 central venous catheter placement with guidance 3 days ago v42.82 peripheral stem cells replaced by transplant 3 days ago v58.81 fitting and adjustment of vascular catheter 3 days ago 203.00 multiple myeloma, without mention of having achieved remission 3 days ago v42.82 peripheral stem cells replaced by transplant 2 days ago 203.01 multiple myeloma, in remission 2 days ago 203.00 multiple myeloma, without mention of having achieved remission 1 day ago v42.82 peripheral stem cells replaced by transplant 1 day ago 203.00 multiple myeloma, without mention of having achieved remission now v42.82 peripheral stem cells replaced by transplant now
medication predictions for a complicated patient. each vertical bar represents the prediction for a single medication class, with the height of the bar representing the confidence of the prediction. black labels above arrows indicate atc therapeutic classes for medications the patient was actually taking. colors and letters below the axis indicate high-level therapeutic class groups.
predicted vs. actual medication classes for the patient in case 1. the four-character sequence in the first and fourth columns is the atc code for the medication therapeutic class, and an asterisk in the first column indicates that the predicted medication is in the actual medication list. probabilities listed are the model predictions for the listed therapeutic class. in the predicted medications column, all predictions with probability at least 0.2 are listed.
top predictions prob. true labels prob.
s03b* corticosteroids 97.01% s03b corticosteroids 97.01% s01c* antiinflammatory agents and antiinfectives in combination 95.54% s01c antiinflammatory agents and antiinfectives in combination 95.54%
s02b* corticosteroids 95.54% s02b corticosteroids 95.54% l01a alkylating agents 94.00% d07x corticosteroids, other combinations 93.37% d07x* corticosteroids, other combinations 93.37% h02a corticosteroids for systemic use, plain 91.06% h02a* corticosteroids for systemic use, plain 91.06% d07a corticosteroids, plain 90.83% d07a* corticosteroids, plain 90.83% s01b antiinflammatory agents 90.79% s01b* antiinflammatory agents 90.79% d10a anti-acne preparations for topical use 88.56% d10a* anti-acne preparations for topical use 88.56% c05a agents for treatment of hemorrhoids and anal fissures
for topical use 88.52%
c05a* agents for treatment of hemorrhoids and anal fissures for topical use 88.52% r01a decongestants and other nasal preparations for topical use 87.02% a04a antiemetics and antinauseants 87.95% j05a direct acting antivirals 86.83% r01a* decongestants and other nasal preparations for topical use 87.02% a01a stomatological preparations 86.11%
j05a* direct acting antivirals 86.8% n02a opioids 84.86% a01a* stomatological preparations 86.11% b05c irrigating solutions 82.56% n02a* opioids 84.86% a12c other mineral supplements 79.50% b05c* irrigating solutions 82.56% b05x i.v. solution additives 74.84% a12c* other mineral supplements 79.50% l04a immunosuppressants 68.76% b05x* i.v. solution additives 74.84% n02b other analgesics and antipyretics 57.24% l04a* immunosuppressants 68.76% s01a antiinfectives 54.59% n05a antipsychotics 58.64% j01d other beta-lactam antibacterials 43.40% n02b* other analgesics and antipyretics 57.24% c03c high-ceiling diuretics 39.88% s01a* antiinfectives 54.59% j01m quinolone antibacterials 29.78% l03a immunostimulants 45.96% c07a beta blocking agents 27.08% a02b drugs for peptic ulcer and gastro-oesophageal reflux
disease 44.56%
j01d* other beta-lactam antibacterials 43.40% n03a antiepileptics 20.00% c03c* high-ceiling diuretics 39.88% j01x other antibacterials 5.88% b01a antithrombotic agents 37.80% m03b muscle relaxants, centrally acting agents 5.09% v03a all other therapeutic products 34.18% r06a antihistamines for systemic use 31.78% a06a drugs for constipation 31.57% j01m* quinolone antibacterials 29.78% n05b anxiolytics 29.42% d04a antipruritics, incl. antihistamines, anesthetics, etc. 27.62% c07a* beta blocking agents 27.08% l01x other antineoplastic agents 24.72% r05c expectorants, excl. combinations with cough suppressants 20.43%
n03a* antiepileptics 20.00%
case 2.
icd-9 code code description time estimate (ago) .4 other hammer toe (acquired) 2.4 years ago 729.5 pain in limb 2.4 years ago 244.1 other postablative hypothyroidism 1.5 years ago 285.9 anemia, unspecified 1.5 years ago 244.1 other postablative hypothyroidism 1.2 years ago 244.1 other postablative hypothyroidism 11.5 months ago .00 osteoporosis, unspecified 11.5 months ago 733.01 senile osteoporosis 7.7 months ago 268.9 unspecified vitamin d deficiency 7.7 months ago 729.5 pain in limb 7.7 months ago 174.9 malignant neoplasm of breast (female), unspecified 7.7 months ago 722.52 degeneration of lumbar or lumbosacral intervertebral disc 7.7 months ago 279.3 unspecified immunity deficiency 7.7 months ago 733.01 senile osteoporosis 6.4 months ago 733.01 senile osteoporosis 6.2 months ago 244.1 other postablative hypothyroidism 6.0 months ago 401.1 benign essential hypertension 6.0 months ago v58.69 long-term (current) use of other medications 1.9 weeks ago 733.01 senile osteoporosis now 244.1 other postablative hypothyroidism now v58.69 long-term (current) use of other medications now
predicted vs. actual medication classes for case 2. table structure as in case 1.
top predictions prob. true labels prob.
m05b drugs affecting bone structure and mineralization 88.18% a11c vitamin a and d, incl. combinations of the two 39.42% h03a thyroid preparations 84.82% n06a antidepressants 20.88% h05a parathyroid hormones and analogues 66.33% c10a lipid modifying agents, plain 17.05% a11c* vitamin a and d, incl. combinations of the two 39.42% n03a antiepileptics 15.61% n02b other analgesics and antipyretics 37.58% c09c angiotensin ii antagonists, plain 10.38% a01a stomatological preparations 23.05% l02b hormone antagonists and related agents 4.22% a12a calcium 21.59% n06a* antidepressants 20.88% c07a beta blocking agents 20.81%
medication predictions for a simpler patient. note that the high-prediction medications are clinically reasonable given the billing codes in the sequence. figure representation as in case 1.
case 3.
icd-9 code code description time estimate (ago) .0 paralysis agitans 5.0 years ago 332.0 paralysis agitans 4.7 years ago 332.0 paralysis agitans 4.5 years ago 332.0 paralysis agitans 4.0 years ago 332.0 paralysis agitans 3.5 years ago 332.0 paralysis agitans 3.0 years ago 332.0 paralysis agitans 2.7 years ago 332.0 paralysis agitans 2.4 years ago 332.0 paralysis agitans 2.0 years ago 332.0 paralysis agitans 1.7 years ago 332.0 paralysis agitans 1.0 years ago 332.0 paralysis agitans 9.9 months ago 332.0 paralysis agitans 4.1 months ago 332.0 paralysis agitans now
predicted vs. actual medication classes for case 3. table structure as in case 1.
top predictions prob. true labels prob.
n04b dopaminergic agents 97.66% c10a lipid modifying agents, plain 13.90% n03a antiepileptics 34.01% c09a ace inhibitors, plain 9.21% n02b other analgesics and antipyretics 32.81% c01e other cardiac preparations 5.56% n06a antidepressants 26.10% c02c antiadrenergic agents, peripherally acting 0.72% n02a opioids 20.33% g03b androgens 0.32%
a14a anabolic steroids 0.08%
medication predictions for a patient with only one icd-9 code, repeated many times over five years. the medications listed under true labels are not indicated for paralysis agitans (parkinson’s disease), but the patient was surely taking them for reasons not documented in the icd-9 sequence. the model predicted mostly reasonable medications for a patient with parkinson’s disease, especially dopaminergic agents, which is the primary treatment for the disease. figure representation as in case 1, above.",1
486.pdf.json,"we consider the problem of classifying nodes (such as documents) in a graph (such as a citation network), where labels are only available for a small subset of nodes. this problem can be framed as graph-based semi-supervised learning, where label information is smoothed over the graph via some form of explicit graph-based regularization (zhu , 2003; zhou , 2004; belkin , 2006; weston , 2012), e.g. by using a graph laplacian regularization term in the loss function:
l = l0 + λlreg , with lreg = ∑ i,j aij‖f(xi)− f(xj)‖2 = f(x)>∆f(x) . (1)
here, l0 denotes the supervised loss w.r.t. the labeled part of the graph, f(·) can be a neural networklike differentiable function, λ is a weighing factor and x is a matrix of node feature vectors xi. ∆ = d − a denotes the unnormalized graph laplacian of an undirected graph g = (v, e) with n nodes vi ∈ v , edges (vi, vj) ∈ e , an adjacency matrix a ∈ rn×n (binary or weighted) and a degree matrix dii = ∑ j aij . the formulation of eq. 1 relies on the assumption that connected nodes in the graph are likely to share the same label. this assumption, however, might restrict modeling capacity, as graph edges need not necessarily encode node similarity, but could contain additional information.
in this work, we encode the graph structure directly using a neural network model f(x,a) and train on a supervised target l0 for all nodes with labels, thereby avoiding explicit graph-based regularization in the loss function. conditioning f(·) on the adjacency matrix of the graph will allow the model to distribute gradient information from the supervised loss l0 and will enable it to learn representations of nodes both with and without labels.
our contributions are two-fold. firstly, we introduce a simple and well-behaved layer-wise propagation rule for neural network models which operate directly on graphs and show how it can be motivated from a first-order approximation of spectral graph convolutions (hammond , 2011). secondly, we demonstrate how this form of a graph-based neural network model can be used for fast and scalable semi-supervised classification of nodes in a graph. experiments on a number of datasets demonstrate that our model compares favorably both in classification accuracy and efficiency (measured in wall-clock time) against state-of-the-art methods for semi-supervised learning.in this section, we provide theoretical motivation for a specific graph-based neural network model f(x,a) that we will use in the rest of this paper. we consider a multi-layer graph convolutional network (gcn) with the following layer-wise propagation rule:
h(l+1) = σ ( d̃− 1 2 ãd̃− 1 2h(l)w (l) ) . (2)
here, ã = a + in is the adjacency matrix of the undirected graph g with added self-connections. in is the identity matrix, d̃ii = ∑ j ãij and w
(l) is a layer-specific trainable weight matrix. σ(·) denotes an activation function, such as the relu(·) = max(0, ·). h(l) ∈ rn×d is the matrix of activations in the lth layer; h(0) = x . in the following, we show that the form of this propagation rule can be motivated1 via a first-order approximation of localized spectral filters on graphs (hammond , 2011; defferrard , 2016).we consider spectral convolutions on graphs defined as the multiplication of a signal x ∈ rn (a scalar for every node) with a filter gθ = diag(θ) parameterized by θ ∈ rn in the fourier domain, i.e.:
gθ ? x = ugθu >x , (3)
where u is the matrix of eigenvectors of the normalized graph laplacian l = in −d− 1 2ad− 1 2 = uλu>, with a diagonal matrix of its eigenvalues λ and u>x being the graph fourier transform of x. we can understand gθ as a function of the eigenvalues of l, i.e. gθ(λ). evaluating eq. 3 is computationally expensive, as multiplication with the eigenvector matrix u iso(n2). furthermore, computing the eigendecomposition of l in the first place might be prohibitively expensive for large graphs. to circumvent this problem, it was suggested in hammond  (2011) that gθ(λ) can be well-approximated by a truncated expansion in terms of chebyshev polynomials tk(x) up to k th order:
gθ′(λ) ≈ k∑ k=0 θ′ktk(λ̃) , (4)
with a rescaled λ̃ = 2λmax λ − in . λmax denotes the largest eigenvalue of l. θ ′ ∈ rk is now a vector of chebyshev coefficients. the chebyshev polynomials are recursively defined as tk(x) = 2xtk−1(x) − tk−2(x), with t0(x) = 1 and t1(x) = x. the reader is referred to hammond  (2011) for an in-depth discussion of this approximation.
going back to our definition of a convolution of a signal x with a filter gθ′ , we now have:
gθ′ ? x ≈ k∑ k=0 θ′ktk(l̃)x , (5)
with l̃ = 2λmaxl − in ; as can easily be verified by noticing that (uλu >)k = uλku>. note that this expression is nowk-localized since it is ak th-order polynomial in the laplacian, i.e. it depends only on nodes that are at maximum k steps away from the central node (k th-order neighborhood). the complexity of evaluating eq. 5 is o(|e|), i.e. linear in the number of edges. defferrard  (2016) use this k-localized convolution to define a convolutional neural network on graphs.a neural network model based on graph convolutions can therefore be built by stacking multiple convolutional layers of the form of eq. 5, each layer followed by a point-wise non-linearity. now, imagine we limited the layer-wise convolution operation to k = 1 (see eq. 5), i.e. a function that is linear w.r.t. l and therefore a linear function on the graph laplacian spectrum. we provide an alternative interpretation of this propagation rule based on the weisfeiler-lehman algorithm (weisfeiler & lehmann, 1968) in appendix a.
in this way, we can still recover a rich class of convolutional filter functions by stacking multiple such layers, but we are not limited to the explicit parameterization given by, e.g., the chebyshev polynomials. we intuitively expect that such a model can alleviate the problem of overfitting on local neighborhood structures for graphs with very wide node degree distributions, such as social networks, citation networks, knowledge graphs and many other real-world graph datasets. additionally, for a fixed computational budget, this layer-wise linear formulation allows us to build deeper models, a practice that is known to improve modeling capacity on a number of domains (he , 2016).
in this linear formulation of a gcn we further approximate λmax ≈ 2, as we can expect that neural network parameters will adapt to this change in scale during training. under these approximations eq. 5 simplifies to:
gθ′ ? x ≈ θ′0x+ θ′1 (l− in )x = θ′0x− θ′1d− 1 2ad− 1 2x , (6)
with two free parameters θ′0 and θ ′ 1. the filter parameters can be shared over the whole graph. successive application of filters of this form then effectively convolve the kth-order neighborhood of a node, where k is the number of successive filtering operations or convolutional layers in the neural network model.
in practice, it can be beneficial to constrain the number of parameters further to address overfitting and to minimize the number of operations (such as matrix multiplications) per layer. this leaves us with the following expression:
gθ ? x ≈ θ ( in +d − 12ad− 1 2 ) x , (7)
with a single parameter θ = θ′0 = −θ′1. note that in + d− 1 2ad− 1 2 now has eigenvalues in the range [0, 2]. repeated application of this operator can therefore lead to numerical instabilities and exploding/vanishing gradients when used in a deep neural network model. to alleviate this problem, we introduce the following renormalization trick: in +d− 1 2ad− 1 2 → d̃− 12 ãd̃− 12 , with
ã = a+ in and d̃ii = ∑ j ãij .
we can generalize this definition to a signalx ∈ rn×c withc input channels (i.e. ac-dimensional feature vector for every node) and f filters or feature maps as follows:
z = d̃− 1 2 ãd̃− 1 2xθ , (8)
where θ ∈ rc×f is now a matrix of filter parameters and z ∈ rn×f is the convolved signal matrix. this filtering operation has complexity o(|e|fc), as ãx can be efficiently implemented as a product of a sparse matrix with a dense matrix.having introduced a simple, yet flexible model f(x,a) for efficient information propagation on graphs, we can return to the problem of semi-supervised node classification. as outlined in the introduction, we can relax certain assumptions typically made in graph-based semi-supervised learning by conditioning our model f(x,a) both on the data x and on the adjacency matrix a of the underlying graph structure. we expect this setting to be especially powerful in scenarios where the adjacency matrix contains information not present in the data x , such as citation links between documents in a citation network or relations in a knowledge graph. the overall model, a multi-layer gcn for semi-supervised learning, is schematically depicted in figure 1.in the following, we consider a two-layer gcn for semi-supervised node classification on a graph with a symmetric adjacency matrix a (binary or weighted). we first calculate â = d̃− 1 2 ãd̃− 1 2 in a pre-processing step. our forward model then takes the simple form:
z = f(x,a) = softmax ( â relu ( âxw (0) ) w (1) ) . (9)  0
here, w (0) ∈ rc×h is an input-to-hidden weight matrix for a hidden layer with h feature maps. w (1) ∈ rh×f is a hidden-to-output weight matrix. the softmax activation function, defined as softmax(xi) = 1 z exp(xi) with z = ∑ i exp(xi), is applied row-wise. for semi-supervised multiclass classification, we then evaluate the cross-entropy error over all labeled examples:
l = − ∑ l∈yl f∑ f=1 ylf lnzlf , (10)
where yl is the set of node indices that have labels. the neural network weights w (0) and w (1) are trained using gradient descent. in this work, we perform batch gradient descent using the full dataset for every training iteration, which is a viable option as long as datasets fit in memory. using a sparse representation for a, memory requirement is o(|e|), i.e. linear in the number of edges. stochasticity in the training process is introduced via dropout (srivastava , 2014). we leave memory-efficient extensions with mini-batch stochastic gradient descent for future work.in practice, we make use of tensorflow (abadi , 2015) for an efficient gpu-based implementation2 of eq. 9 using sparse-dense matrix multiplications. the computational complexity of evaluating eq. 9 is then o(|e|chf ), i.e. linear in the number of graph edges.our model draws inspiration both from the field of graph-based semi-supervised learning and from recent work on neural networks that operate on graphs. in what follows, we provide a brief overview on related work in both fields.a large number of approaches for semi-supervised learning using graph representations have been proposed in recent years, most of which fall into two broad categories: methods that use some form of explicit graph laplacian regularization and graph embedding-based approaches. prominent examples for graph laplacian regularization include label propagation (zhu , 2003), manifold regularization (belkin , 2006) and deep semi-supervised embedding (weston , 2012). code to reproduce our experiments is available at https://github.com/tkipf/gcn.
recently, attention has shifted to models that learn graph embeddings with methods inspired by the skip-gram model (mikolov , 2013). deepwalk (perozzi , 2014) learns embeddings via the prediction of the local neighborhood of nodes, sampled from random walks on the graph. line (tang , 2015) and node2vec (grover & leskovec, 2016) extend deepwalk with more sophisticated random walk or breadth-first search schemes. for all these methods, however, a multistep pipeline including random walk generation and semi-supervised training is required where each step has to be optimized separately. planetoid (yang , 2016) alleviates this by injecting label information in the process of learning embeddings.neural networks that operate on graphs have previously been introduced in gori  (2005); scarselli  (2009) as a form of recurrent neural network. their framework requires the repeated application of contraction maps as propagation functions until node representations reach a stable fixed point. this restriction was later alleviated in li  (2016) by introducing modern practices for recurrent neural network training to the original graph neural network framework. duvenaud  (2015) introduced a convolution-like propagation rule on graphs and methods for graph-level classification. their approach requires to learn node degree-specific weight matrices which does not scale to large graphs with wide node degree distributions. our model instead uses a single weight matrix per layer and deals with varying node degrees through an appropriate normalization of the adjacency matrix (see section 3.1).
a related approach to node classification with a graph-based neural network was recently introduced in atwood & towsley (2016). they report o(n2) complexity, limiting the range of possible applications. in a different yet related model, niepert  (2016) convert graphs locally into sequences that are fed into a conventional 1d convolutional neural network, which requires the definition of a node ordering in a pre-processing step.
our method is based on spectral graph convolutional neural networks, introduced in bruna  (2014) and later extended by defferrard  (2016) with fast localized convolutions. in contrast to these works, we consider here the task of transductive node classification within networks of significantly larger scale. we show that in this setting, a number of simplifications (see section 2.2) can be introduced to the original frameworks of bruna  (2014) and defferrard  (2016) that improve scalability and classification performance in large-scale networks.we test our model in a number of experiments: semi-supervised document classification in citation networks, semi-supervised entity classification in a bipartite graph extracted from a knowledge graph, an evaluation of various graph propagation models and a run-time analysis on random graphs.we closely follow the experimental setup in yang  (2016). dataset statistics are summarized in table 1. in the citation network datasets—citeseer, cora and pubmed (sen , 2008)—nodes are documents and edges are citation links. label rate denotes the number of labeled nodes that are used for training divided by the total number of nodes in each dataset. nell (carlson , 2010; yang , 2016) is a bipartite graph dataset extracted from a knowledge graph with 55,864 relation nodes and 9,891 entity nodes.
citation networks we consider three citation network datasets: citeseer, cora and pubmed (sen , 2008). the datasets contain sparse bag-of-words feature vectors for each document and a list of citation links between documents. we treat the citation links as (undirected) edges and construct a binary, symmetric adjacency matrix a. each document has a class label. for training, we only use 20 labels per class, but all feature vectors.
nell nell is a dataset extracted from the knowledge graph introduced in (carlson , 2010). a knowledge graph is a set of entities connected with directed, labeled edges (relations). we follow the pre-processing scheme as described in yang  (2016). we assign separate relation nodes r1 and r2 for each entity pair (e1, r, e2) as (e1, r1) and (e2, r2). entity nodes are described by sparse feature vectors. we extend the number of features in nell by assigning a unique one-hot representation for every relation node, effectively resulting in a 61,278-dim sparse feature vector per node. the semi-supervised task here considers the extreme case of only a single labeled example per class in the training set. we construct a binary, symmetric adjacency matrix from this graph by setting entries aij = 1, if one or more edges are present between nodes i and j.
random graphs we simulate random graph datasets of various sizes for experiments where we measure training time per epoch. for a dataset with n nodes we create a random graph assigning 2n edges uniformly at random. we take the identity matrix in as input feature matrix x , thereby implicitly taking a featureless approach where the model is only informed about the identity of each node, specified by a unique one-hot vector. we add dummy labels yi = 1 for every node.unless otherwise noted, we train a two-layer gcn as described in section 3.1 and evaluate prediction accuracy on a test set of 1,000 labeled examples. we provide additional experiments using deeper models with up to 10 layers in appendix b. we choose the same dataset splits as in yang  (2016) with an additional validation set of 500 labeled examples for hyperparameter optimization (dropout rate for all layers, l2 regularization factor for the first gcn layer and number of hidden units). we do not use the validation set labels for training.
for the citation network datasets, we optimize hyperparameters on cora only and use the same set of parameters for citeseer and pubmed. we train all models for a maximum of 200 epochs (training iterations) using adam (kingma & ba, 2015) with a learning rate of 0.01 and early stopping with a window size of 10, i.e. we stop training if the validation loss does not decrease for 10 consecutive epochs. we initialize weights using the initialization described in glorot & bengio (2010) and accordingly (row-)normalize input feature vectors. on the random graph datasets, we use a hidden layer size of 32 units and omit regularization (i.e. neither dropout nor l2 regularization).we compare against the same baseline methods as in yang  (2016), i.e. label propagation (lp) (zhu , 2003), semi-supervised embedding (semiemb) (weston , 2012), manifold regularization (manireg) (belkin , 2006) and skip-gram based graph embeddings (deepwalk) (perozzi , 2014). we omit tsvm (joachims, 1999), as it does not scale to the large number of classes in one of our datasets.
we further compare against the iterative classification algorithm (ica) proposed in lu & getoor (2003) in conjunction with two logistic regression classifiers, one for local node features alone and one for relational classification using local features and an aggregation operator as described in sen  (2008). we first train the local classifier using all labeled training set nodes and use it to bootstrap class labels of unlabeled nodes for relational classifier training. we run iterative classification (relational classifier) with a random node ordering for 10 iterations on all unlabeled nodes (bootstrapped using the local classifier). l2 regularization parameter and aggregation operator (count vs. prop, see sen  (2008)) are chosen based on validation set performance for each dataset separately.
lastly, we compare against planetoid (yang , 2016), where we always choose their bestperforming model variant (transductive vs. inductive) as a baseline.results are summarized in table 2. reported numbers denote classification accuracy in percent. for ica, we report the mean accuracy of 100 runs with random node orderings. results for all other baseline methods are taken from the planetoid paper (yang , 2016). planetoid* denotes the best model for the respective dataset out of the variants presented in their paper.
we further report wall-clock training time in seconds until convergence (in brackets) for our method (incl. evaluation of validation error) and for planetoid. for the latter, we used an implementation provided by the authors3 and trained on the same hardware (with gpu) as our gcn model. we trained and tested our model on the same dataset splits as in yang  (2016) and report mean accuracy of 100 runs with random weight initializations. we used the following sets of hyperparameters for citeseer, cora and pubmed: 0.5 (dropout rate), 5 · 10−4 (l2 regularization) and 16 (number of hidden units); and for nell: 0.1 (dropout rate), 1 · 10−5 (l2 regularization) and 64 (number of hidden units).
in addition, we report performance of our model on 10 randomly drawn dataset splits of the same size as in yang  (2016), denoted by gcn (rand. splits). here, we report mean and standard error of prediction accuracy on the test set split in percent.we compare different variants of our proposed per-layer propagation model on the citation network datasets. we follow the experimental set-up described in the previous section. results are summarized in table 3. the propagation model of our original gcn model is denoted by renormalization trick (in bold). in all other cases, the propagation model of both neural network layers is replaced with the model specified under propagation model. reported numbers denote mean classification accuracy for 100 repeated runs with random weight matrix initializations. in case of multiple variables θi per layer, we impose l2 regularization on all weight matrices of the first layer. .3 training time per epoch
here, we report results for the mean training time per epoch (forward pass, cross-entropy calculation, backward pass) for 100 epochs on simulated random graphs, measured in seconds wall-clock time. see section 5.1 for a detailed description of the random graph dataset used in these experiments. we compare results on a gpu and on a cpu-only implementation4 in tensorflow (abadi , 2015). figure 2 summarizes the results.in the experiments demonstrated here, our method for semi-supervised node classification outperforms recent related methods by a significant margin. methods based on graph-laplacian regularization (zhu , 2003; belkin , 2006; weston , 2012) are most likely limited due to their assumption that edges encode mere similarity of nodes. skip-gram based methods on the other hand are limited by the fact that they are based on a multi-step pipeline which is difficult to optimize. our proposed model can overcome both limitations, while still comparing favorably in terms of efficiency (measured in wall-clock time) to related methods. propagation of feature information from neighboring nodes in every layer improves classification performance in comparison to methods like ica (lu & getoor, 2003), where only label information is aggregated.
we have further demonstrated that the proposed renormalized propagation model (eq. 8) offers both improved efficiency (fewer parameters and operations, such as multiplication or addition) and better predictive performance on a number of datasets compared to a naı̈ve 1st-order model (eq. 6) or higher-order graph convolutional models using chebyshev polynomials (eq. 5).here, we describe several limitations of our current model and outline how these might be overcome in future work.
memory requirement in the current setup with full-batch gradient descent, memory requirement grows linearly in the size of the dataset. we have shown that for large graphs that do not fit in gpu memory, training on cpu can still be a viable option. mini-batch stochastic gradient descent can alleviate this issue. the procedure of generating mini-batches, however, should take into account the number of layers in the gcn model, as the k th-order neighborhood for a gcn with k layers has to be stored in memory for an exact procedure. for very large and densely connected graph datasets, further approximations might be necessary.
directed edges and edge features our framework currently does not naturally support edge features and is limited to undirected graphs (weighted or unweighted). results on nell however show that it is possible to handle both directed edges and edge features by representing the original directed graph as an undirected bipartite graph with additional nodes that represent edges in the original graph (see section 5.1 for details).
limiting assumptions through the approximations introduced in section 2, we implicitly assume locality (dependence on the k th-order neighborhood for a gcn with k layers) and equal importance of self-connections vs. edges to neighboring nodes. for some datasets, however, it might be beneficial to introduce a trade-off parameter λ in the definition of ã:
ã = a+ λin . (11) 4hardware used: 16-core intel r© xeon r© cpu e5-2640 v3 @ 2.60ghz, geforce r© gtx titan x
this parameter now plays a similar role as the trade-off parameter between supervised and unsupervised loss in the typical semi-supervised setting (see eq. 1). here, however, it can be learned via gradient descent.we have introduced a novel approach for semi-supervised classification on graph-structured data. our gcn model uses an efficient layer-wise propagation rule that is based on a first-order approximation of spectral convolutions on graphs. experiments on a number of network datasets suggest that the proposed gcn model is capable of encoding both graph structure and node features in a way useful for semi-supervised classification. in this setting, our model outperforms several recently proposed methods by a significant margin, while being computationally efficient.we would like to thank christos louizos, taco cohen, joan bruna, zhilin yang, dave herman, pramod sinha and abdul-saboor sheikh for helpful discussions. this research was funded by sap.a neural network model for graph-structured data should ideally be able to learn representations of nodes in a graph, taking both the graph structure and feature description of nodes into account. a well-studied framework for the unique assignment of node labels given a graph and (optionally) discrete initial node labels is provided by the 1-dim weisfeiler-lehman (wl-1) algorithm (weisfeiler & lehmann, 1968):
algorithm 1: wl-1 algorithm (weisfeiler & lehmann, 1968)
input: initial node coloring (h(0)1 , h (0) 2 , ..., h (0) n ) output: final node coloring (h(t )1 , h (t ) 2 , ..., h (t ) n ) t← 0; repeat
for vi ∈ v do h (t+1) i ← hash (∑ j∈ni h (t) j ) ;
t← t+ 1; until stable node coloring is reached;
here, h(t)i denotes the coloring (label assignment) of node vi (at iteration t) and ni is its set of neighboring node indices (irrespective of whether the graph includes self-connections for every node or not). hash(·) is a hash function. for an in-depth mathematical discussion of the wl-1 algorithm see, e.g., douglas (2011).
we can replace the hash function in algorithm 1 with a neural network layer-like differentiable function with trainable parameters as follows:
h (l+1) i = σ ∑ j∈ni 1 cij h (l) j w (l)  , (12) where cij is an appropriately chosen normalization constant for the edge (vi, vj). further, we can take h(l)i now to be a vector of activations of node i in the l
th neural network layer. w (l) is a layer-specific weight matrix and σ(·) denotes a differentiable, non-linear activation function.
by choosing cij = √ didj , where di = |ni| denotes the degree of node vi, we recover the propagation rule of our graph convolutional network (gcn) model in vector form (see eq. 2)5.
this—loosely speaking—allows us to interpret our gcn model as a differentiable and parameterized generalization of the 1-dim weisfeiler-lehman algorithm on graphs.
a.1 node embeddings with random weights
from the analogy with the weisfeiler-lehman algorithm, we can understand that even an untrained gcn model with random weights can serve as a powerful feature extractor for nodes in a graph. as an example, consider the following 3-layer gcn model:
z = tanh ( â tanh ( â tanh ( âxw (0) ) w (1) ) w (2) ) , (13)
with weight matricesw (l) initialized at random using the initialization described in glorot & bengio (2010). â, x and z are defined as in section 3.1.
we apply this model on zachary’s karate club network (zachary, 1977). this graph contains 34 nodes, connected by 154 (undirected and unweighted) edges. every node is labeled by one of four classes, obtained via modularity-based clustering (brandes , 2008). see figure 3a for an illustration. note that we here implicitly assume that self-connections have already been added to every node in the graph (for a clutter-free notation).
we take a featureless approach by setting x = in , where in is the n by n identity matrix. n is the number of nodes in the graph. note that nodes are randomly ordered (i.e. ordering contains no information). furthermore, we choose a hidden layer dimensionality6 of 4 and a two-dimensional output (so that the output can immediately be visualized in a 2-dim plot).
figure 3b shows a representative example of node embeddings (outputs z) obtained from an untrained gcn model applied to the karate club network. these results are comparable to embeddings obtained from deepwalk (perozzi , 2014), which uses a more expensive unsupervised training procedure.
a.2 semi-supervised node embeddings
on this simple example of a gcn applied to the karate club network it is interesting to observe how embeddings react during training on a semi-supervised classification task. such a visualization (see figure 4) provides insights into how the gcn model can make use of the graph structure (and of features extracted from the graph structure at later layers) to learn embeddings that are useful for a classification task.
we consider the following semi-supervised learning setup: we add a softmax layer on top of our model (eq. 13) and train using only a single labeled example per class (i.e. a total number of 4 labeled nodes). we train for 300 training iterations using adam (kingma & ba, 2015) with a learning rate of 0.01 on a cross-entropy loss.
figure 4 shows the evolution of node embeddings over a number of training iterations. the model succeeds in linearly separating the communities based on minimal supervision and the graph structure alone. a video of the full training process can be found on our website7. we originally experimented with a hidden layer dimensionality of 2 (i.e. same as output layer), but observed that a dimensionality of 4 resulted in less frequent saturation of tanh(·) units and therefore visually more pleasing results. http://tkipf.github.io/graph-convolutional-networks/in these experiments, we investigate the influence of model depth (number of layers) on classification performance. we report results on a 5-fold cross-validation experiment on the cora, citeseer and pubmed datasets (sen , 2008) using all labels. in addition to the standard gcn model (eq. 2), we report results on a model variant where we use residual connections (he , 2016) between hidden layers to facilitate training of deeper models by enabling the model to carry over information from the previous layer’s input:
h(l+1) = σ ( d̃− 1 2 ãd̃− 1 2h(l)w (l) ) +h(l) . (14)
on each cross-validation split, we train for 400 epochs (without early stopping) using the adam optimizer (kingma & ba, 2015) with a learning rate of 0.01. other hyperparameters are chosen as follows: 0.5 (dropout rate, first and last layer), 5 · 10−4 (l2 regularization, first layer), 16 (number of units for each hidden layer) and 0.01 (learning rate). results are summarized in figure 5.
for the datasets considered here, best results are obtained with a 2- or 3-layer model. we observe that for models deeper than 7 layers, training without the use of residual connections can become difficult, as the effective context size for each node increases by the size of its k th-order neighborhood (for a model with k layers) with each additional layer. furthermore, overfitting can become an issue as the number of parameters increases with model depth.",1
498.pdf.json,"deep neural networks (dnns, e.g., lecun , 2015; schmidhuber, 2015), if trained properly, have been demonstrated to significantly improve the benchmark performances in a wide range of application domains. as neural networks go deeper and deeper, naturally, its model complexity also increases quickly, hence the pressing need to reduce overfitting in training dnns. a number of techniques have emerged over the years to address this challenge, among which dropout (hinton , 2012; srivastava, 2013) has stood out for its simplicity and effectiveness. in a nutshell, dropout randomly “drops” neural units during training as a means to prevent feature co-adaptation—a sign of overfitting (hinton , 2012). simple as it appears to be, dropout has led to several record-breaking performances (hinton , 2012; ma & hovy, 2016), and thus spawned a lot of recent interests in analyzing and justifying dropout from the theoretical perspective, and also in further improving dropout from the algorithmic and practical perspective.
in their pioneering work, hinton  (2012) and srivastava  (2014) interpreted dropout as an extreme form of model combination (aka. model ensemble) with extensive parameter/weight sharing, and they proposed to learn the combination through minimizing an appropriate expected loss. interestingly, they also pointed out that for a single logistic neural unit, the output of dropout is in fact the geometric mean of the outputs of the model ensemble with shared parameters. subsequently, many theoretical justifications of dropout have been explored, and we can only mention a few here due to space limits. building on the weight sharing perspective, baldi & sadowski (2013; 2014) analyzed the ensemble averaging property of dropout in deep non-linear logistic networks, and supported the view that dropout is equivalent to applying stochastic gradient descent on some regularized
loss function. wager  (2013) treated dropout as an adaptive regularizer for generalized linear models (glms). helmbold & long (2016) discussed the differences between dropout and traditional weight decay regularization. in terms of statistical learning theory, gao & zhou (2014) studied the rademacher complexity of different types of dropout, showing that dropout is able to reduce the rademacher complexity polynomially for shallow neural networks (with one or no hidden layers) and exponentially for deep neural networks. this latter work (gao & zhou, 2014) formally demonstrated that dropout, due to its regularizing effect, contributes to reducing the inherent model complexity, in particular the variance component in the generalization error.
seen as a model combination technique, it is intuitive that dropout contributes to reducing the variance of the model performance. surprisingly, dropout has also been shown to play some role in reducing the model bias. for instance, jain  (2015) studied the ability of dropout training to escape local minima, hence leading to reduced model bias. other studies (chen , 2014; helmbold & long, 2014; wager , 2014) focus on the effect of the dropout noise on models with shallow architectures. we noted in passing that there are also some work (kingma , 2015; gal & ghahramani, 2015; 2016) trying to understand dropout from the bayesian perspective.
in this work, we first formulate dropout as a tractable approximation of a latent variable model, and give a clean view of weight sharing (§3). then, we focus on an inference gap in dropout that has somehow gotten under-appreciated: in the inference phase, for computational tractability considerations, the model ensemble generated by dropout is approximated by a single model with scaled weights, resulting in a gap between training and inference, and rendering the many previous theoretical findings inapplicable. in general, this inference gap can be very large and no attempt (to our best knowledge) has been made to control it. we make three contributions in bridging this gap: theoretically, we introduce expectation-linear dropout neural networks, through which we are able to explicitly quantify the inference gap (§4). in particular, our theoretical results explain why the max-norm constraint on the network weights, a standard practice in training dnns, can lead to a small inference gap hence potentially improve performance. algorithmically, we propose to add a sampled version of the inference gap to regularize the standard dropout training objective (expectationlinearization), hence allowing explicit control of the inference gap, and analyze the interaction between expectation-linearization and the model accuracy (§5). experimentally, through three benchmark datasets we show that our regularized dropout is not only as simple and efficient as standard dropout but also consistently leads to improved performance (§6).in this section we set up the notations, review the dropout neural network model, and discuss the inference gap in standard dropout training that we will attempt to study in the rest of the paper.throughout we use uppercase letters for random variables (and occasionally for matrices as well), and lowercase letters for realizations of the corresponding random variables. let x ∈ x be the input of the neural network, y ∈ y be the desired output, and d = {(x1, y1), . . . , (xn , yn )} be our training sample, where xi, i = 1, . . . , n, (resp. yi) are usually i.i.d. samples of x (resp. y ).
let m denote a deep neural network with l hidden layers, indexed by l ∈ {1, . . . , l}. let h(l) denote the output vector from layer l. as usual, h(0) = x is the input, and h(l) is the output of the neural network. denote θ = {θl : l = 1, . . . , l} as the set of parameters in the network m, where θl assembles the parameters in layer l. with dropout, we need to introduce a set of dropout random variables s = {γ(l) : l = 1, . . . , l}, where γ(l) is the dropout random variable for layer l. then the deep neural network m can be described as:
h(l) = fl(h (l−1) γ(l); θl), l = 1, . . . , l, (1)
where is the element-wise product and fl is the transformation function of layer l. for example, if layer l is a fully connected layer with weight matrix w , bias vector b, and sigmoid activation function σ(x) = 11+exp(−x) , then fl(x) = σ(wx+ b)). we will also use h
(l)(x, s; θ) to denote the output of layer l with input x and dropout value s, under parameter θ.
in the simplest form of dropout, which is also called standard dropout, γ(l) is a vector of independent bernoulli random variables, each of which has probability pl of being 1 and 1− pl of being 0. this corresponds to dropping each of the weights independently with probability pl.the standard dropout neural networks can be trained using stochastic gradient decent (sgd), with a sub-network sampled by dropping neural units for each training instance in a mini-batch. forward and backward pass for that training instance are done only on the sampled sub-network. intuitively, dropout aims at, simultaneously and jointly, training an ensemble of exponentially many neural networks (one for each configuration of dropped units) while sharing the same weights/parameters.
the goal of the stochastic training procedure of dropout can be understood as minimizing an expected loss function, after marginalizing out the dropout variables (srivastava, 2013; wang & manning, 2013). in the context of maximal likelihood estimation, dropout training can be formulated as:
θ∗ = argmin θ esd [−l(d,sd; θ)] = argmin θ esd
[ − n∑ i=1 log p(yi|xi, si; θ) ] , (2)
where recall that d is the training sample, sd = {s1, . . . , sn} is the dropout variable (one for each training instance), and l(d,sd; θ) is the (conditional) log-likelihood function defined by the conditional distribution p(y|x, s; θ) of output y given input x, under parameter θ and dropout variable s. throughout we use the notation ez to denote the conditional expectation where all random variables except z are conditioned on.
dropout has also been shown to work well with regularization, such as l2 weight decay (tikhonov, 1943), lasso (tibshirani, 1996), kl-sparsity(bradley & bagnell, 2008; hinton, 2010), and max-norm regularization (srebro , 2004), among which the max-norm regularization — that constrains the norm of the incoming weight matrix to be bounded by some constant — was found to be especially useful for dropout (srivastava, 2013; srivastava , 2014).as mentioned before, dropout is effectively training an ensemble of neural networks with weight sharing. consequently, at test time, the output of each network in the ensemble should be averaged to deliver the final prediction. this averaging over exponentially many sub-networks is, however, intractable, and standard dropout typically implements an approximation by introducing a deterministic scaling factor for each layer to replace the random dropout variable:
es [h (l)(x, s; θ)] ? ≈ h(l)(x,e[s]; θ), (3)
where the right-hand side is the output of a single deterministic neural network whose weights are scaled to match the expected number of active hidden units on the left-hand side. importantly, the right-hand side can be easily computed since it only involves a single deterministic network.
bulò  (2016) combined dropout with knowledge distillation methods (hinton , 2015) to better approximate the averaging processing of the left-hand side. however, the quality of the approximation in (3) is largely unknown, and to our best knowledge, no attempt has been made to explicitly control this inference gap. the main goal of this work is to explicitly quantify, algorithmically control, and experimentally demonstrate the inference gap in (3), in the hope of improving the generalization performance of dnns eventually. to this end, in the next section we first present a latent variable model interpretation of dropout, which will greatly facilitate our later theoretical analysis.with the end goal of studying the inference gap in (3) in mind, in this section, we first formulate dropout neural networks as a latent variable model (lvm) in § 3.1. then, we point out the relation between the training procedure of lvm and that of standard dropout in § 3.2. the advantage of formulating dropout as a lvm is that we need only deal with a single model (with latent structure), instead of an ensemble of exponentially many different models (with weight sharing). this much
simplified view of dropout enables us to understand and analyze the model parameter θ in a much more straightforward and intuitive way.a latent variable model consists of two types of variables: the observed variables that represent the empirical (observed) data and the latent variables that characterize the hidden (unobserved) structure. to formulate dropout as a latent variable model, the input x and output y are regarded as observed variables, while the dropout variable s, representing the sub-network structure, is hidden. then, upon fixing the input space x , the output space y , and the latent space s for dropout variables, the conditional probability of y given x under parameter θ can be written as
p(y|x; θ) = ∫ s p(y|x, s; θ)p(s)dµ(s), (4)
where p(y|x, s; θ) is the conditional distribution modeled by the neutral network with configuration s (same as in eq. (2)), p(s) is the distribution of dropout variable s (e.g. bernoulli), here assumed to be independent of the input x, and µ(s) is the base measure on the space s.building on the above latent variable model formulation (4) of dropout, we are now ready to point out a simple relation between the training procedure of lvm and that of standard dropout. given an i.i.d. training sample d, the maximum likelihood estimate for the lvm formulation of dropout in (4) is equivalent to minimizing the following negative log-likelihood function:
θ∗ = argmin θ −l(d; θ) = argmin θ − n∑ i=1 log p(yi|xi; θ), (5)
where p(y|x; θ) is given in eq. (4). recall the dropout training objective esd [−l(d,sd; θ)] in eq. (2). we have the following theorem as a simple consequence of jensen’s inequality (details in appendix a): theorem 1. the expected loss function of standard dropout (eq. (2)) is an upper bound of the negative log-likelihood of lvm dropout (eq. (5)):
−l(d; θ) ≤ esd [−l(d,sd; θ)]. (6)
theorem 1, in a rigorous sense, justifies dropout training as a convenient and tractable approximation of the lvm formulation in (4). indeed, since directly minimizing the marginalized negative loglikelihood in (5) may not be easy, a standard practice is to replace the marginalized (conditional) likelihood p(y|x; θ) in (4) with its empirical monte carlo average through drawing samples from the dropout variable s. the dropout training objective in (2) corresponds exactly to this monte carlo approximation when a single sample si is drawn for each training instance (xi, yi). importantly, we note that the above lvm formulation involves only a single network parameter θ, which largely simplifies the picture and facilitates our subsequent analysis.building on the latent variable model formulation in § 3, we introduce in this section the notion of expectation-linearity that essentially measures the inference gap in (3). we then characterize a general class of neural networks that exhibit expectation-linearity, either exactly or approximately over a distribution p(x) on the input space.
we start with defining expectation-linearity in the simplest single-layer neural network, then we extend the notion into general deep networks in a natural way. definition 1 (expectation-linear layer). a network layer h = f(x γ; θ) is expectation-linear with respect to a set x ′ ⊆ x , if for all x ∈ x ′ we have∥∥e[f(x γ; θ)]− f(x e[γ]; θ)∥∥  = 0. (7)
in this case we say that x ′ is expectation-linearizable, and θ is expectation-linearizing w.r.t x ′.
obviously, the condition in (7) will guarantee no gap in the dropout inference approximation (3)—an admittedly strong condition that we will relax below. clearly, if f is an affine function, then we can choose x ′ = x and expectation-linearity is trivial. note that expectation-linearity depends on the network parameter θ and the dropout distribution γ.
expectation-linearity, as defined in (7), is overly strong: under standard regularity conditions, essentially the transformation function f has to be affine over the set x ′, ruling out for instance the popular sigmoid or tanh activation functions. moreover, in practice, downstream use of dnns are usually robust to small errors resulting from approximate expectation-linearity (hence the empirical success of dropout), so it makes sense to define an inexact extension. we note also that the definition in (7) is uniform over the set x ′, while in a statistical setting it is perhaps more meaningful to have expectation-linearity “on average,” since inputs from lower density regions are not going to play a significant role anyway. taking into account the aforementioned motivations, we arrive at the following inexact extension: definition 2 (approximately expectation-linear layer). a network layer h = f(x γ; θ) is δ-approximately expectation-linear with respect to a distribution p(x) over x if
ex [∥∥eγ[f(x γ; θ)|x]− f(x e[γ]; θ)∥∥2] < δ. (8) in this case we say that p(x) is δ-approximately expectation-linearizable, and θ is δ-approximately expectation-linearizing.
to appreciate the power of cutting some slack from exact expectation-linearity, we remark that even non-affine activation functions often have approximately linear regions. for example, the logistic function, a commonly used non-linear activation function in dnns, is approximately linear around the origin. naturally, we can ask whether it is sufficient for a target distribution p(x) to be well-approximated by an approximately expectation-linearizable one. we begin by providing an appropriate measurement of the quality of this approximation. definition 3 (closeness, (andreas , 2015)). a distribution p(x) is c-close to a set x ′ ⊆ x if
e [
inf x∗∈x ′ sup γ∈s ‖x γ − x∗ γ‖2
] ≤ c, (9)
where recall that s is the (bounded) space that the dropout variable lives in.
intuitively, p(x) is c-close to a set x ′ if a random sample from p is no more than a distance c from x ′ in expectation and under the worst “dropout perturbation”. for example, a standard normal distribution is close to an interval centering at origin ([−α, α]) with some constant c. our definition of closeness is similar to that in andreas  (2015), who used this notion to analyze self-normalized log-linear models.
we are now ready to state our first major result that quantifies approximate expectation-linearity of a single-layered network (proof in appendix b.1): theorem 2. given a network layer h = f(x γ; θ), where θ is expectation-linearizing w.r.t. x ′ ⊆ x . suppose p(x) is c-close to x ′ and for all x ∈ x , ‖∇xf(x)‖op ≤ b, where ‖ · ‖op is the usual operator norm. then, p(x) is 2bc-approximately expectation-linearizable.
roughly, theorem 2 states that the input distribution p(x) that place most of its mass on regions close to expectation-linearizable sets are approximately expectation-linearizable on a similar scale. the bounded operator norm assumption on the derivative ∇f is satisfied in most commonly used layers. for example, for a fully connected layer with weight matrix w , bias vector b, and activation function σ, ‖∇f(·)‖op = |σ′(·)| · ‖w‖op is bounded by ‖w‖op and the supremum of |σ′(·)| (1/4 when σ is sigmoid and 1 when σ is tanh).
next, we extend the notion of approximate expectation-linearity to deep dropout neural networks. definition 4 (approximately expectation-linear network). a deep neural network with l layers (cf. eq. (1)) is δ-approximately expectation-linear with respect to p(x) over x if
ex [∥∥es[h(l)(x,s; θ)|x]− h(l)(x,e[s]; θ)∥∥2] < δ. (10) where h(l)(x,e[s]; θ) is the output of the deterministic neural network in standard dropout.
lastly, we relate the level of approximate expectation-linearity of a deep neural network to the level of approximate expectation-linearity of each of its layers: theorem 3. given an l-layer neural network as in eq. (1), and suppose that each layer l ∈ {1, . . . , l} is δ-approximately expectation-linear w.r.t. p(h(l)), e[γ(l)] ≤ γ, supx ‖∇fl(x)‖op ≤ b, and e [ var[h(l)|x] ] ≤ σ2. then the network is ∆-approximately expectation-linear with
∆ = (bγ)l−1δ + (δ +bγσ)
( 1− (bγ)l−1 −bγ
) . (11)
from theorem 3 (proof in appendix b.2) we observe that the level of approximate expectationlinearity of the network mainly depends on four factors: the level of approximate expecatationlinearity of each layer (δ), the expected variance of each layer (σ), the operator norm of the derivative of each layer’s transformation function (b), and the mean of each layer’s dropout variable (γ). in practice, γ is often a constant less than or equal to 1. for example, if γ ∼ bernoulli(p), then γ = p. according to the theorem, the operator norm of the derivative of each layer’s transformation function is an important factor in the level of approximate expectation-linearity: the smaller the operator norm is, the better the approximation. interestingly, the operator norm of a layer often depends on the norm of the layer’s weight (e.g. for fully connected layers). therefore, adding max-norm constraints to regularize dropout neural networks can lead to better approximate expectation-linearity hence smaller inference gap and the often improved model performance.
it should also be noted that when bγ < 1, the approximation error ∆ tends to be a constant when the network becomes deeper. when bγ = 1, ∆ grows linearly with l, and when bγ > 1, the growth of ∆ becomes exponential. thus, it is essential to keep bγ < 1 to achieve good approximation, particularly for deep neural networks.in the previous section we have managed to bound the approximate expectation-linearity, hence the inference gap in (3), of dropout neural networks. in this section, we first prove a uniform deviation bound of the sampled approximate expectation-linearity measure from its mean, which motivates adding the sampled (hence computable) expectation-linearity measure as a regularization scheme to standard dropout, with the goal of explicitly controlling the inference gap of the learned parameter, hence potentially improving the performance. then we give the upper bounds on the loss in accuracy due to expectation-linearization, and describe classes of distributions that expectation-linearize easily.we now show that an expectation-linear network can be found by expectation-linearizing the network on the training sample. to this end, we prove a uniform deviation bound between the empirical expectation-linearization measure using i.i.d. samples (eq. (12)) and its mean (eq. (13)).
theorem 4. let h = { h(l)(x, s; θ) : θ ∈ θ } denote a space of l-layer dropout neural networks
indexed with θ, where h(l) : x × s → r and θ is the space that θ lives in. suppose that the neural networks inh satisfy the constraints: 1) ∀x ∈ x , ‖x‖2 ≤ α; 2) ∀l ∈ {1, . . . , l},e(γ(l)) ≤ γ and ‖∇fl‖op ≤ b; 3) ‖h(l)‖ ≤ β. denote empirical expectation-linearization measure and its mean as:
∆̂ = 1
n n∑ i=1 ∥∥esi[h(l)(xi, si; θ)]− h(l)(xi,e[si]; θ)∥∥2, (12) ∆ = ex
[∥∥es[h(l)(x,s; θ)]− h(l)(x,e[s]; θ)∥∥2]. (13) then, with probability at least 1− ν, we have
sup θ∈θ |∆− ∆̂| < 2αb l(γl/2 + 1)√ n + β
√ log(1/ν)
n . (14)
from theorem 4 (proof in appendix c.1) we observe that the deviation bound decreases exponentially with the number of layers l when the operator norm of the derivative of each layer’s transformation
function (b) is less than 1 (and the contrary if b ≥ 1). importantly, the square root dependence on the number of samples (n) is standard and cannot be improved without significantly stronger assumptions.
it should be noted that theorem 4 per se does not imply anything between expectation-linearization and the model accuracy (i.e. how well the expectation-linearized neural network actually achieves on modeling the data). formally studying this relation is provided in § 5.3. in addition, we provide some experimental evidences in § 6 on how improved approximate expectation-linearity (equivalently smaller inference gap) does lead to better empirical performances.the uniform deviation bound in theorem 4 motivates the possibility of obtaining an approximately expectation-linear dropout neural networks through adding the empirical measure (12) as a regularization scheme to the standard dropout training objective, as follows:
loss(d; θ) = −l(d; θ) + λv (d; θ), (15) where −l(d; θ) is the negative log-likelihood defined in eq. (5), λ > 0 is a regularization constant, and v (d; θ) measures the level of approximate expectation-linearity:
v (d; θ) = 1
n n∑ i=1 ∥∥esi[h(l)(xi, si; θ)]− h(l)(xi,e[si]; θ)∥∥22. (16) to solve (15), we can minimize loss(d; θ) via stochastic gradient descent as in standard dropout, and approximate v (d; θ) using monte carlo:
v (d; θ) ≈ 1 n n∑ i=1 ∥∥h(l)(xi, si; θ)− h(l)(xi,e[si]; θ)∥∥22, (17) where si is the same dropout sample as in l(d; θ) for each training instance in a mini-batch. thus, the only additional computational cost comes from the deterministic term h(l)(xi,e[si]; θ). overall, our regularized dropout (15), in its monte carlo approximate form, is as simple and efficient as the standard dropout.so far our discussion has concentrated on the problem of finding expectation-linear neural network models, without any concerns on how well they actually perform at modeling the data. in this section, we characterize the trade-off between maximizing “data likelihood” and satisfying an expectationlinearization constraint.
to achieve the characterization, we measure the likelihood gap between the classical maximum likelihood estimator (mle) and the mle subject to a expectation-linearization constraint. formally, given training data d = {(x1, y1), . . . , (xn, yn)}, we define
θ̂ = argmin θ∈θ
−l(d; θ) (18)
θ̂δ = argmin θ∈θ,v (d;θ)≤δ
−l(d; θ) (19)
where −l(d; θ) is the negative log-likelihood defined in eq. (5), and v (d; θ) is the level of approximate expectation-linearity in eq. (16).
we would like to control the loss of model accuracy by obtaining a bound on the likelihood gap defined as:
∆l(θ̂, θ̂δ) = 1
n (l(d; θ̂)− l(d; θ̂δ)) (20)
in the following, we focus on neural networks with softmax output layer for classification tasks.
p(y|x, s; θ) = h(l)y (x, s; θ) = fl(h(l−1)(x, s); η) = eη
t y h (l−1)(x,s)∑ y′∈y e ηt y′h (l−1)(x,s) (21)
where θ = {θ1, . . . , θl−1, η}, y = {1, . . . , k} and η = {ηy : y ∈ y}. we claim:
theorem 5. given an l-layer neural network h(l)(x, s; θ) with softmax output layer in (21), where parameter θ ∈ θ, dropout variable s ∈ s, input x ∈ x and target y ∈ y . suppose that for every x and s, p(y|x, s; θ̂) makes a unique best prediction—that is, for each x ∈ x , s ∈ s, there exists a unique y∗ ∈ y such that ∀y 6= y∗, η̂ty h(l−1)(x, s) < η̂ty∗h(l−1)(x, s). suppose additionally that ∀x, s, ‖h(l−1)(x, s; θ̂)‖ ≤ β, and ∀y, p(y|x; θ̂) > 0. then
∆l(θ̂, θ̂δ) ≤ c1β2 ( ‖η̂‖2 − δ β
)2 e−c2δ/4β (22)
where c1 and c2 are distribution-dependent constants.
from theorem 5 (proof in appendix c.2) we observe that, at one extreme, distributions closed to deterministic can be expectation-linearized with little loss of likelihood.
what about the other extreme — distributions “as close to uniform distribution as possible”? with suitable assumptions about the form of p(y|x, s; θ̂) and p(y|x; θ̂), we can achieve an accuracy loss bound for distributions that are close to uniform: theorem 6. suppose that ∀x, s, ‖h(l−1)(x, s; θ̂)‖ ≤ β. additionally, for each (xi, yi) ∈ d, s ∈ s , log 1k ≤ log p(yi|xi, s; θ̂) ≤ 1 k ∑ y∈y log p(y|xi, s; θ̂). then asymptotically as n→∞:
∆l(θ̂, θ̂δ) ≤ ( − δ 4β‖η̂‖2
) e [kl (p(·|x; θ)‖unif(y))] (23)
theorem 6 (proof in appendix c.3) indicates that uniform distributions are also an easy class for expectation-linearization.
the next question is whether there exist any classes of conditional distributions p(y|x) for which all distributions are provably hard to expectation-linearize. it remains an open problem and might be an interesting direction for future work.in this section, we evaluate the empirical performance of the proposed regularized dropout in (15) on a variety of network architectures for the classification task on three benchmark datasets—mnist, cifar-10 and cifar-100. we applied the same data preprocessing procedure as in srivastava  (2014). to make a thorough comparison and provide experimental evidence on how the expectationlinearization interacts with the predictive power of the learned model, we perform experiments of monte carlo (mc) dropout, which approximately computes the final prediction (left-hand side of (3)) via monte carlo sampling, w/o the proposed regularizer. in the case of mc dropout, we average m = 100 predictions using randomly sampled configurations. in addition, the network architectures and hyper-parameters for each experiment setup are the same as those in srivastava  (2014), unless we explicitly claim to use different ones. following previous works, for each data set we held out 10,000 random training images for validation to tune the hyper-parameters, including λ in eq. (15). when the hyper-parameters are fixed, we train the final models with all the training data, including the validation data. a more detailed description of the conducted experiments can be provided in appendix d. for each experiment, we report the mean test errors with corresponding standard deviations over 5 repetitions.the mnist dataset (lecun , 1998) consists of 70,000 handwritten digit images of size 28×28, where 60,000 images are used for training and the rest for testing. this task is to classify the images into 10 digit classes. for the purpose of comparison, we train 6 neural networks with different architectures. the experimental results are shown in table 1.the cifar-10 and cifar-100 datasets (krizhevsky, 2009) consist of 60,000 color images of size 32× 32, drawn from 10 and 100 categories, respectively. 50,000 images are used for training and the
rest for testing. the neural network architecture we used for these two datasets has 3 convolutional layers, followed by two fully-connected (dense) hidden layers (again, same as that in srivastava  (2014)). the experimental results are recorded in table 1, too.
from table 1 we can see that on mnist data, dropout network training with expectation-linearization outperforms standard dropout on all 6 neural architectures. on cifar data, expectation-linearization reduces error rate from 12.82% to 12.20% for cifar-10, achieving 0.62% improvement. for cifar-100, the improvement in terms of error rate is 0.97% with reduction from 37.22% to 36.25%.
from the results we see that with or without expectation-linearization, the mc dropout networks achieve similar results. it illustrates that by achieving expectation-linear neural networks, the predictive power of the learned models has not degraded significantly. moreover, it is interesting to see that with the regularization, on mnist dataset, standard dropout networks achieve even better accuracy than mc dropout. it may be because that with expectation-linearization, standard dropout inference achieves better approximation of the final prediction than mc dropout with (only) 100 samples. on cifar datasets, mc dropout networks achieve better accuracy than the ones with the regularization. but, obviously, mc dropout requires much more inference time than standard dropout (mc dropout with m samples requires about m times the inference time of standard dropout). .3 effect of regularization constant λ
in this section, we explore the effect of varying the hyper-parameter for the expectation-linearization rate λ. we train the network architectures in table 1 with the λ value ranging from 0.1 to 10.0. figure 1 shows the test errors obtained as a function of λ on three datasets. in addition, figure 1, middle and right panels, also measures the empirical expectation-linearization risk ∆̂ of eq. (12) with varying λ on cifar-10 and cifar-100, where ∆̂ is computed using monte carlo with 100 independent samples.
from figure 1 we can see that when λ increases, better expectation-linearity is achieved (i.e. ∆̂ decreases). the model accuracy, however, has not kept growing with increasing λ, showing that in practice considerations on the trade-off between model expectation-linearity and accuracy are needed.to make a thorough empirical comparison with the recently proposed dropout distillation method (bulò , 2016), we also evaluate our regularization method on cifar-10 and cifar-100 datasets with the all convolutional network (springenberg , 2014) (allconv). to facilitate comparison, we adopt the originally reported hyper-parameters and the same setup for training.
table 2 gives the results comparison the classification error percentages on test data under allconv using standard dropout, monte carlo dropout, standard dropout with our proposed expectationlinearization, and recently proposed dropout distillation on cifar-10 and cifar-100 1. according to table 2, our proposed expectation-linear regularization method achieves comparable performance to dropout distillation.in this work, we attempted to establish a theoretical basis for the understanding of dropout, motivated by controlling the gap between dropout’s training and inference phases. through formulating dropout as a latent variable model and introducing the notion of (approximate) expectation-linearity, we have formally studied the inference gap of dropout, and introduced an empirical measure as a regularization scheme to explicitly control the gap. experiments on three benchmark datasets demonstrate that reducing the inference gap can indeed improve the end performance. in the future, we intend to formally relate the inference gap to the generalization error of the underlying network, hence providing further justification of regularized dropout.this research was supported in part by darpa grant fa8750-12-2-0342 funded under the deft program. any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of darpa.esd [l(d,sd; θ)] = ∫ s n∏ i=1 p(si) ( n∑ i=1 log p(yi|xi, si; θ) ) dµ(s1) . . . dµ(sn )
= n∑ i=1 ∫ s p(si) log p(yi|xi, si; θ)dµ(si)
because log(·) is a concave function, from jensen’s inequality,∫ s p(s) log p(y|x, s; θ)dµ(s) ≤ log ∫ s p(s)p(y|x, s; θ)dµ(s)
thus
esd [−l(d,sd; θ)] ≥ n∑ i=1 log ∫ s p(si)p(yi|xi, si; θ)dµ(si) = −l(d; θ).proof. let γ∗ = e[γ], and
a ∆ = {x : ‖e[f(x γ; θ)]− f(x γ∗; θ)‖2 = 0}
let x∗ = argmin x∈a sup γ∈s ‖x γ − x γ‖2, and x− = x −x∗. then,
x γ = x∗ γ +x− γ
in the following, we omit the parameter θ for convenience. moreover, we denote eγ [ f(x γ; θ) ] ∆ = e [ f(x γ; θ)|x ] from taylor series, there exit some x ′, x ′′ ∈ x satisfy that
f(x γ) = f(x∗ γ) + f ′(x ′ γ)(x− γ) f(x γ∗) = f(x∗ γ∗) + f ′(x ′′ γ∗)(x− γ∗)
where we denote f ′(x) = (∇xf(x))t . then,
eγ[f(x γ)− f(x γ∗)] = eγ[f(x
∗ γ +x− γ)− f(x∗ γ∗ +x− γ∗)] = eγ[f(x
∗ γ)− f(x∗ γ∗) + f ′(x ′ γ)(x− γ)− f ′(x ′′ γ∗)(x− γ∗)] = eγ[f(x ∗ γ)− f(x∗ γ∗)] + eγ[f ′(x ′ γ)(x− γ)− f ′(x ′′ γ∗)(x− γ∗)]
since x∗ ∈ a, we have eγ[f(x
∗ γ)− f(x∗ γ∗)] = 0. then,
eγ[f(x γ)− f(x γ∗)] = eγ[f
′(x ′ γ)(x− γ)− f ′(x ′′ γ∗)(x− γ∗)] = eγ[(f
′(x ′ γ)− f ′(x ′′ γ∗))(x− γ)] + eγ[f ′(x ′′ γ∗)(x− γ−x− γ∗)] = eγ[(f ′(x ′ γ)− f ′(x ′′ γ∗))(x− γ)]
then, ‖eγ[f(x γ)]− f(x γ∗)‖2 = ‖eγ[(f ′(x ′ γ)− f ′(x ′′ γ∗))(x− γ)]‖2 since ‖x− γ′‖2 ≤ sup
γ∈s ‖x− γ‖2 = inf x∈a sup γ∈s ‖x γ − x γ‖2, and from jensen’s inequality
and property of operator norm,
‖eγ[(f ′(x ′ γ)− f ′(x ′′ γ∗))(x− γ)]‖2 ≤ eγ [ ‖f ′(x ′ γ)− f ′(x ′′ γ∗)‖op‖x− γ‖2 ] ≤ 2beγ [ ‖x− γ‖2
] ≤ 2b inf
x∈a sup γ∈s ‖x γ − x γ‖2
finally we have,
ex [ ‖eγ[(f ′(x ′ γ)− f ′(x ′′ γ∗))(x− γ)]‖2 ] ≤ 2be [ inf x∈a sup γ∈s ‖x γ − x γ‖2 ] ≤ 2bcproof. induction on the number of the layers l. as before, we omit the parameter θ. initial step: when l = 1, the statement is obviously true. induction on l: suppose that the statement is true for neural networks with l layers. now we prove the case l+ 1. from the inductive assumption, we have,
ex [∥∥esl[h(l)(x,sl)]− h(l)(x,e[sl])∥∥2] ≤ ∆l (1) where sl = {γ(1), . . . ,γ(l)} is the dropout random variables for the first l layers, and
∆l = (bγ) l−1δ + (δ +bγσ)
( 1− (bγ)l−1 −bγ ) in addition, the l+ 1 layer is δ-approximately expectation-linear, we have:
eh(l) [∥∥eγ(l+1)[fl+1(h(l) γ(l+1))]− fl+1(h(l) γ(l+1))∥∥2] ≤ δ (2)
let e[γ(l)] = γ(l),∀l ∈ {1, . . . , l + 1}, and let h(l) and h(l) be short for h(l)(x,sl) and h(l)(x,e(sl)), respectively, when there is no ambiguity. moreover, we denote
es [ h(l)(x,s; θ) ] = es [ h(l)(x,s; θ) ∣∣x] for convenience. then,
ex [∥∥esl+1[h(l+1)]− h(l+1)∥∥2] = ex
[∥∥∥esl[eγ(l+1)[fl+1(h(l) γ(l+1))]− fl+1(h(l) γ(l+1))] +esl [ fl+1(h (l) γ(l+1)) ] − fl+1(h(l) γ(l+1)) ∥∥∥ 2
] ≤ ex [∥∥∥esl[eγ(l+1)[fl+1(h(l) γ(l+1))]− fl+1(h(l) γ(l+1))]∥∥∥ 2
] +ex [∥∥∥esl[fl+1(h(l) γ(l+1))]− fl+1(h(l) γ(l+1))∥∥∥ 2
] from eq. 2 and jensen’s inequality, we have
ex [∥∥∥esl[eγ(l+1)[fl+1(h(l) γ(l+1))]− fl+1(h(l) γ(l+1))]∥∥∥ 2 ] ≤ eh(l) [∥∥∥eγ(l+1)[fl+1(h(l) γ(l+1))]− fl+1(h(l) γ(l+1))∥∥∥ 2 ] ≤ δ
(3)
and
ex [∥∥∥esl[fl+1(h(l) γ(l+1))]− fl+1(h(l) γ(l+1))∥∥∥ 2 ] = ex
[∥∥∥esl[fl+1(h(l) γ(l+1))]− fl+1(esl[h(l)] γ(l+1)) +fl+1(esl [ h(l) ] γ(l+1))− fl+1(h(l) γ(l+1)) ∥∥∥ 2
] ≤ ex [∥∥∥esl[fl+1(h(l) γ(l+1))]− fl+1(esl[h(l)] γ(l+1))∥∥∥ 2
] +ex [∥∥∥fl+1(esl[h(l)] γ(l+1))− fl+1(h(l) γ(l+1))∥∥∥ 2 ] (4)
using jensen’s inequality, property of operator norm and e [ var[h(l)|x] ] ≤ σ2, we have
ex [∥∥∥esl[fl+1(h(l) γ(l+1))]− fl+1(esl[h(l)] γ(l+1))∥∥∥ 2 ] ≤ eh(l) [∥∥∥fl+1(h(l) γ(l+1))− fl+1(esl[h(l)] γ(l+1))∥∥∥ 2
] ≤ bγeh(l)
[∥∥h(l) − esl[h(l)]∥∥2] ≤ bγ ( eh(l) [∥∥h(l) − esl[h(l)]∥∥22]) 12 ≤ bγσ (5)
from eq. 1
ex [∥∥∥fl+1(esl[h(l)] γ(l+1))− fl+1(h(l) γ(l+1))∥∥∥ 2 ] = bγex
[∥∥esl[h(l)]− h(l)∥∥2] ≤ bγ∆l (6) finally, to sum up with eq. 3, eq. 4, , eq. 5, , eq. 6, we have
ex [∥∥esl+1[h(l+1)]− h(l+1)∥∥2] ≤ δ +bγσ +bγ∆l = (bγ)lδ + (δ +bγσ) ( 1−(bγ)l −bγ
) = ∆l+1before proving theorem 4, we first define the notations.
let xn = {x1, . . . , xn} be a set of n samples of input x . for a function space f : x → r, we use radn(f , xn) to denote the empirical rademacher complexity of f ,
radn(f , xn) = eσ [
sup f∈f ( 1 n n∑ i=1 σif(xi) )]
and the rademacher complexity is defined as radn(f) = exn [ radn(f , xn) ] in addition, we import the definition of dropout rademacher complexity from gao & zhou (2014):
rn(h, xn, sn) = eσ [
sup h∈h
( 1 n n∑ i=1 σih(xi, si) )]
rn(h) = exn,sn [ radn(h, xn, sn) ]
where h : x × s → r is a function space defined on input space x and dropout variable space s. rn(h, xn, sn) and rn(h) are the empirical dropout rademacher complexity and dropout rademacher complexity, respectively. we further denotern(h, xn) ∆ = esn [ radn(h, xn, sn) ] .
now, we define the following function spaces: f = { f(x; θ) : f(x; θ) = es [ h(l)(x, s; θ) ] , θ ∈ θ } g = { g(x; θ) : g(x; θ) = h(l)(x,e[s]; θ), θ ∈ θ
} h = { h(x, s; θ) : h(x, s; θ) = h(l)(x, s; θ), θ ∈ θ
} then, the function space of v(x) = f(x)− g(x) is v = {f(x)− g(x) : f ∈ f , g ∈ g}. lemma 7.
radn(f , xn) ≤ rn(h, xn)
proof. rn(h, xn) = esn [ radn(h, xn, sn) ] = esn [ eσ [ sup h∈h ( 1 n n∑ i=1 σih(xi, si) )]]
= eσ [ esn [ sup h∈h ( 1 n n∑ i=1 σih(xi, si) )]]
≥ eσ [
sup h∈h
esn [( 1 n n∑ i=1 σih(xi, si) )]]
= eσ [ sup h∈h ( 1 n n∑ i=1 σiesi [ h(xi, si) ])] = eσ [ sup h∈h ( 1 n n∑ i=1 σiesi [ h(l)(xi, si; θ) ])] = radn(f , xn)
from lemma 7, we have radn(f) ≤ rn(h). lemma 8.
rn(h) ≤ αb lγl/2√ n
radn(g) ≤ αb l
√ n
proof. see theorem 4 in gao & zhou (2014).
now, we can prove theorem 4.proof. from rademacher-based uniform bounds theorem, with probability ≥ 1− δ,
sup v∈v |∆− ∆̂| < 2radn(v) + β
√ log(1/δ)
n
since v = f − g, we have
radn(v) = radn(f − g) ≤ radn(f) +radn(g) ≤ αbl(γl/2 + 1)√
n
then, finally, we have that with probability ≥ 1− δ,
sup θ∈θ |∆− ∆̂| < 2αb l(γl/2 + 1)√ n + β
√ log(1/δ)
nfor convenience, we denote λ = {θ1, . . . , θl−1}. then θ = {λ, η}, and mle θ̂ = {λ̂, η̂} lemma 9.
‖∇fl(·; η)t ‖op ≤ 2‖η‖2 (7)
proof. denote
a = ∇fl(·; η)t = [ py(ηy − η)t ] ∣∣∣k y=1
where py = p(y|x, s; θ), η = e [ηy ] = k∑ y=1 pyηy .
for each v such that ‖v‖2 = 1,
‖av‖22 = ∑ y∈y ( py (ηy − η)t v )2 ≤ ∑ y∈y ‖py (ηy − η) ‖22‖v‖22 = ∑ y∈y ‖py (ηy − η) ‖22
≤ ∑ y∈y py‖ηy − η‖22 ≤ ∑ y∈y 2py ( ‖η‖22 + ∑ y′∈y py′‖ηy′‖22 ) = 4
∑ y∈y py‖ηy‖22 ≤ 4‖η‖22
so we have ‖a‖op ≤ 2‖η‖2.
lemma 10. if parameter θ̃ = {λ̂, η} satisfies that ‖η‖2 ≤ δ4β , then v (d; θ̃) ≤ δ, where v (d; θ) is defined in eq. (16).
proof. let sl = {γ(1), . . . ,γ(l)}, and let h(l) and h(l) be short for h(l)(x,sl; θ̃) and h(l)(x,e(sl); θ̃), respectively.
from lemma 9, we have ‖fl(x; η)− fl(y; η)‖2 ≤ 2‖η‖2‖x− y‖2. then,∥∥esl [hl]− hl∥∥2 = ∥∥esl−1 [fl(h(l−1); η)]− fl(h(l−1); η)∥∥2 ≤ esl−1
∥∥fl(h(l−1); η)− fl(h(l−1); η)∥∥2 ≤ 2‖η‖2 ∥∥h(l−1) − h(l−1)∥∥ 2 ≤ 4β‖η‖2 ≤ δ
lemma 10 says that we can get θ satisfying the expectation-linearization constrain by explicitly scaling down η̂ while keeping λ̂.
in order to prove theorem 5, we make the following assumptions:
• the dimension of h(l−1) is d, i.e. h(l−1) ∈ rd. • since ∀y ∈ y, p(y|x; θ̂) > 0, we assume p(y|x; θ̂) ≥ 1/b, where b ≥ |y| = k. • as in the body text, let p(y|x, s; θ̂) be nonuniform, and in particular let η̂ty∗h (l−1)(x, s; λ̂)− η̂ty h(l−1)(x, s; λ̂) > c‖η̂‖2,∀y 6= y∗.
for convenience, we denote ηth(l−1)(x, s;λ) = ηtuy(x, s;λ), where uty (x, s;λ) = (v t 0 , . . . , v t k ) and
vi = { h(l−1)(x, s;λ) if i = y 0 otherwise
to prove theorem 5, we first prove the following lemmas.
lemma 11. if p(y|x; θ̂) ≥ 1/b, then ∀α ∈ [0, 1], for parameter θ̃ = {λ̂, αη̂}, we have
p(y|x; θ̃) ≥ 1 b
proof. we define
f(α) ∆ = (y|x, s; θ̃) = e αηty h (l−1)(x,s;λ̂)∑
y′∈y e αηt y′h (l−1)(x,s;λ̂)
=
( eη t y h (l−1)(x,s;λ̂) )α
∑ y′∈y ( e ηt y′h (l−1)(x,s;λ̂) )α
since y = {1, . . . , k}, for fixed x ∈ x , s ∈ s, log f(α) is a concave function w.r.t α. since b ≥ k, we have
log f(α) ≥ (1− α) log f(0) + α log f(1) ≥ − log b
so we have ∀x, s, p(y|x, s; θ̃) ≥ 1/b. then
p(y|x; θ̃) = es [ p(y|x, s; θ̂) ] ≥ 1 b
lemma 12. if y is not the majority class, i.e. y 6= y∗, then for parameter θ̃ = {λ̂, αη̂}
p(y|x, s, θ̃) ≤ e−cα‖η̂‖2
proof.
p(y|x, s, θ̃) = e αη̂tuy∑
y′∈y eαη̂
tuy′ ≤ e
αη̂tuy
eαη̂ tuy∗
≤ e−cα‖η̂‖2
lemma 13. for a fixed x and s, the absolute value of the entry of the vector under the parameter θ̃ = {λ̂, αη̂}:
|p(y|x, s; θ̃)(uy − ey [uy ])|i ≤ β(k − 1)e−cα‖η̂‖2
proof. suppose y is the majority class of p(y|x, s; θ̃). then,
uy − ey[uy ] = (vy′)ky′=1
where
vy = { (1− p(y|x, s; θ̃)h(l−1) if y = y∗ −p(y|x, s; θ̃)h(l−1) otherwise
from lemma 12, we have
|p(y|x, s; θ̃)(uy − ey [uy ])|i ≤ |(uy − ey [uy ])|i ≤ β(k − 1)e−cα‖η̂‖2
now, we suppose y is not the majority class of p(y|x, s; θ̃). then,
|p(y|x, s; θ̃)(uy − ey [uy ])|i ≤ p(y|x, s; θ̃)β ≤ βe−cα‖η̂‖2
overall, the lemma follows.
lemma 14. we denote the matrix
a ∆ = es [ p(y|x,s;θ̃) p(y|x;θ̃) (uy − ey [uy ])(uy − ey [uy ]) t ]
−es [ p(y|x,s;θ̃) p(y|x;θ̃) (uy − ey [uy ]) ] es [ p(y|x,s;θ̃) p(y|x;θ̃) (uy − ey [uy ]) ]t then the absolute value of the entry of a under the parameter θ̃ = {λ̂, αη̂}:
|aij | ≤ 2b(k − 1)β2e−cα‖η̂‖2
proof. from lemma 11, we have p(y|x; θ̃) ≥ 1/b. additionally, the absolute value of the entry of uy − ey [uy ] is bounded by β. we have for each i∣∣∣∣∣es [ p(y|x, s; θ̃) p(y|x; θ̃) (uy − ey [uy ]) ]∣∣∣∣∣ i ≤ es [ p(y|x, s; θ̃) p(y|x; θ̃) β ] = β
then from lemma 13 |aij | ≤ 2b(k − 1)β2e−cα‖η̂‖2
lemma 15. we denote the matrix
b ∆ = es [ p(y|x, s; θ̃) p(y|x; θ̃) ( ey [ uy u t y ] − ey [uy ]ey [uy ]t )]
then the absolute value of the entry of b under the parameter θ̃ = {λ̂, αη̂}:
|bij | ≤ 2(k − 1)β2e−cα‖η̂‖2
proof. we only need to prove that for fixed x and s, for each i, j:∣∣ey [uy uty ]− ey [uy ]ey [uy ]t ∣∣ij ≤ 2(k − 1)β2e−cα‖η̂‖2 since ∣∣ey [uy uty ]− ey [uy ]ey [uy ]t ∣∣ij = |covy [(uy )i, (uy )j ]| ≤ β2 k∑ y=1 p(y|x, s; θ̃)− p(y|x, s; θ̃)2
suppose y is the majority class. then from lemma 12,
p(y|x, s; θ̃)− p(y|x, s; θ̃)2 ≤ 1− p(y|x, s; θ̃) ≤ (k − 1)e−cα‖η̂‖2
if y is not the majority class. then,
p(y|x, s; θ̃)− p(y|x, s; θ̃)2 ≤ p(y|x, s; θ̃) ≤ e−cα‖η̂‖2
so we have k∑ y=1 p(y|x, s; θ̃)− p(y|x, s; θ̃)2 ≤ 2(k − 1)e−cα‖η̂‖2
the lemma follows.
lemma 16. under the parameter θ̃ = {λ̂, αη̂}, the largest eigenvalue of the matrix 
n n∑ i=1 (a(xi, yi)−b(xi, yi)) (8)
is at most 2dk(k − 1)(b+ 1)β2e−cα‖η̂‖2
proof. from lemma 14 and lemma 15, each entry of the matrix in (8) is at most 2(k − 1)(b + 1)β2e−cα‖η̂‖2 . thus, by gershgorin’s theorem, the maximum eigenvalue of the matrix in (8) is at most 2dk(k − 1)(b+ 1)β2e−cα‖η̂‖2 .
now, we can prove theorem 5 by constructing a scaled version of θ̂ that satisfies the expectationlinearization constraint.proof. consider the likelihood evaluated at θ̃ = {λ̂, αη̂}, where α = δ4β‖η̂‖2 . if α > 1, then ‖η‖2 > δ4β . we know the mle θ̂ already satisfies the expectation-linearization constraint. so we can assume that 0 ≤ α ≤ 1, and we know that θ̃ satisfies v (d; θ̃) ≤ δ. then,
∆l(θ̂, θ̂δ) ≤ ∆l(θ̂, θ̃) = 1
n (l(d; θ̂)− l(d; θ̃)) = g(λ̂, η̂)− g(λ̂, αη̂)
where g(λ, η) = 1n l(d; (λ, η)). taking the second-order taylor expansion about η, we have
g(λ̂, αη̂) = g(λ̂, η̂) +∇tη g(λ̂, η̂)(αη̂ − η̂) + (αη̂ − η̂)t∇2ηg(λ̂, η̂)(αη̂ − η̂)
since θ̂ is the mle, the first-order term ∇tη g(λ̂, η̂)(αη̂ − η̂) = 0. the hessian in the second-order term is just eq.(8). thus, from lemma 16 we have
g(λ̂, αη̂) ≤ g(λ̂, η̂)− (1− α)2‖η̂‖222dk(k − 1)(b+ 1)β2e−cα‖η̂‖2 = g(λ̂, η̂)− 2dk(k − 1)(b+ 1)β2 ( ‖η̂‖2 − δ4β )2 e−cδ/4β
= g(λ̂, η̂)− c1β2 ( ‖η̂‖2 − δ4β )2 e−c2δ/4β
with setting c1 = 2dk(k − 1)(b+ 1) and c2 = c. then the theorem follows.in the following, we denote θ̃ = {λ̂, αη̂}.
lemma 17. for each y ∈ y , if p(y|x, s; θ̂) ≥ 1/k, then ∀α ∈ [0, 1]
p(y|x, s; θ̃) ≥ 1 k
proof. this lemma can be regarded as a corollary of lemma 11.
lemma 18. for a fixed x and s, we denote eη̂ t y h (l−1)(x,s;λ̂) = wy . then we have
p(y|x, s, θ̃) = e αη̂ty h (l−1)(x,s;λ̂)∑ y′∈y e αη̂t y′h (l−1)(x,s;λ̂) = (wy) α∑ y′∈y (wy′)α
additionally, we denote gs(α) = ∑ y′∈y p(y′|x, s; θ̃) logwy′ − logwy . we assume gs(0) ≥ 0. then we have ∀α ≥ 0 gs(α) ≥ 0
proof.
∂gs(α) ∂α = ∑ y′∈y logwy′ ∂p(y′|x, s; θ̃) ∂α = vary [logwy |x − x, s = s] ≥ 0
so gs(α) is non-decreasing. since gs(0) ≥ 0, we have gs(α) ≥ 0 when α ≥ 0.
from above lemma, we have for each training instance (xi, yi) ∈ d, and ∀α ∈ [0, 1],
ey [ log p(y |xi, s; θ̃) ] ≥ log p(yi|xi, s; θ̃) (9)
for convenience, we define m(s, y) = log p(y|x, s; θ̃)− ey [ log p(y |x, s; θ̃) ]
lemma 19. if y satisfies lemma 17 and gs(α) ≥ 0, then
vary [m(s, y )] ≥ m(s, y)2
proof. first we have m(s, y) = log p(y|x, s; θ̃)− log 1/k −kl ( p(·|x, s; θ̃)|unif(y) ) ≤ 0
so we have
(vary [m(s, y )]) 1/2 = √ ey [( log p(y |x, s; θ̃)− ey [ log p(y |x, s; θ̃) ])2] ≥ ey
[∣∣∣log p(y |x, s; θ̃)− ey [log p(y |x, s; θ̃)]∣∣∣] = ey
[∣∣∣kl(p(·|x, s; θ̃)|unif(y))+ log 1/k − log p(y |x, s; θ̃)∣∣∣] = ey [ kl ( p(·|x, s; θ̃)|unif(y) ) + ∣∣∣log 1/k − log p(y |x, s; θ̃)∣∣∣]
≥ kl ( p(·|x, s; θ̃)|unif(y) ) + ey [ log p(y |x, s; θ̃)− log 1/k ] = 2kl ( p(·|x, s; θ̃)|unif(y)
) as kl ( p(·|x, s; θ̃)|unif(y) ) ≥ 0 and log p(y|x, s; θ̃) ≥ log 1/k. so we have 2kl ( p(·|x, s; θ̃)|unif(y) ) ≥ kl ( p(·|x, s; θ̃)|unif(y) ) +log 1/k−log p(y|x, s; θ̃) = −m(s, y)
then the lemma follows.
from lemma 19 and eq. (9), we have for each training instance (xi, yi) ∈ d, and ∀α ∈ [0, 1],
vary [m(s, y )] ≥ m(s, yi)2 (10)
lemma 20. for each training instance (xi, yi) ∈ d, and ∀α ∈ [0, 1], we have
log p(yi|xi; {λ̂, αη̂}) ≥ (1− α) log p(yi|xi; {λ̂, 0}) + α log p(yi|xi; {λ̂, η̂})
proof. we define
f(α) = log p(yi|xi; {λ̂, αη̂})− (1− α) log p(yi|xi; {λ̂, 0})− α log p(yi|xi; {λ̂, η̂})
because f(0) = f(1) = 0, we only need to prove that f(α) is concave on [0, 1]. we have
∇2f(α) = −es|y=yi [vary [m(s, y )]] + vars|y=yi [m(s, yi)]
where s|y = yi is under the probability distribution p(s|y = yi, xi; θ̃) = p(yi|xi,s;θ̃)p(s)p(yi|xi;θ̃) from eq. (10), we have
es|y=yi [vary [m(s, y )]] ≥ es|y=yi [ m(s, yi) 2 ] ≥ vars|y=yi [m(s, yi)]
so we have ∇2f(α) ≤ 0. the lemma follows.
now, we can prove theorem 6 by using the same construction of an expectation-linearizing parameter as in theorem 5.proof. consider the same parameter θ̃ = {λ̂, αη̂}, where α = δ4β‖η̂‖2 ≤ 1. we know that θ̃ satisfies v (d; θ̃) ≤ δ. then,
∆l(θ̂, θ̂δ) ≤ ∆l(θ̂, θ̃) = 1
n (l(d; θ̂)− l(d; θ̃))
from lemma 20 we have:
l(d; θ̃) = l(d; {λ̂, αη̂}) ≥ (1− α)l(d; {λ̂, 0}) + αl(d; {λ̂, η̂})
so ∆l(θ̂, θ̂δ) ≤ (1− α) 1n ( l(d; θ̂)− l(d; {λ̂, 0}) ) = (1− α) 1n n∑ i=1 log p(yi|xi; θ̂)− log unif(y)
(1− α)e [kl (p(·|x; θ)‖unif(y))] ≤ ( 1− δ4β‖η̂‖2 ) e [kl (p(·|x; θ)‖unif(y))]mnist for mnist, we train 6 different fully-connected (dense) neural networks with 2 or 3 layers (see table 1). for all architectures, we used dropout rate p = 0.5 for all hidden layers and p = 0.2 for the input layer.
cifar-10 and cifar-100 for the two cifar datasets, we used the same architecture in srivastava  (2014) — three convolutional layers followed by two fully-connected hidden layers. the convolutional layers have 96, 128, 265 filters respectively, with a 5× 5 receptive field applied with a stride of 1. each convolutional layer is followed by a max pooling layer pools 3× 3 regions at strides of 2. the fully-connected layers have 2048 units each. all units use the rectified linear activation function. dropout was applied to all the layers with dropout rate p = (0.1, 0.25, 0.25, 0.5, 0.5, 0.5) for the layers going from input to convolutional layers to fully-connected layers.neural network training in all the experiments is performed with mini-batch stochastic gradient descent (sgd) with momentum. we choose an initial learning rate of η0, and the learning rate is updated on each epoch of training as ηt = η0/(1 + ρt), where ρ is the decay rate and t is the number of epoch completed. we run each experiment with 2,000 epochs and choose the parameters achieving the best performance on validation sets.
table 3 summarizes the chosen hyper-parameters for all experiments. most of the hyper-parameters are chosen from srivastava  (2014). but for some experiments, we cannot reproduce the performance reported in srivastava  (2014) (we guess one of the possible reasons is that we used different library for implementation.). for these experiments, we tune the hyper-parameters on the validation sets by random search. due to time constrains it is infeasible to do a random search across the full hyper-parameter space. thus, we try to use as many hyper-parameters reported in srivastava  (2014) as possible.
d.3 effect of expectation-linearization rate λ
table 4 illustrates the detailed results of the experiments on the effect of λ. for mnist, it lists the error rates under different λ values for six different network architectures. for two datasets of cifar, it gives the error rates under different λ values, among with the empirical expectation-linearization risk ∆̂.",1
518.pdf.json,"modern machine learning increasingly relies on highly complex probabilistic models to reason about uncertainty. a key computational challenge is to develop efficient inference techniques to approximate, or draw samples from complex distributions. currently, most inference methods, including mcmc and variational inference, are hand-designed by researchers or domain experts. this makes it difficult to fully optimize the choice of different methods and their parameters, and exploit the structures in the problems of interest in an automatic way. the hand-designed algorithm can also be inefficient when it requires to make fast inference repeatedly on a large number of different distributions with similar structures. this happens, for example, when we need to reason about a number of observed datasets in settings like online learning, or need fast inference as inner loops for other algorithms such as maximum likelihood training. therefore, it is highly desirable to develop more intelligent probabilistic inference systems that can adaptively improve its own performance to fully the optimize computational efficiency, and generalize to new tasks with similar structures.
specifically, denote by p(x) a probability density of interest specified up to the normalization constant, which we want to draw sample from, or marginalize to estimate its normalization constant. we want to study the following problem:
problem 1. given a distribution with density p(x) and a function f(η; ξ) with parameter η and random input ξ, for which we only have assess to draws of the random input ξ (without knowing its true distribution q0), and the output values of f(η; ξ) and its derivative ∂ηf(η; ξ) given η and ξ. we want to find an optimal parameter η so that the density of the random output variable x = f(η; ξ) with ξ ∼ q0 closely matches the target density p(x).
because we have no assumption on the structure of f(η; ξ) and the distribution of random input, we can not directly calculate the actual distribution of the output random variable x = f(η; ξ); this makes it difficult to solve problem 1 using the traditional variational inference (vi) methods. recall that traditional vi approximates p(x) using simple proposal distributions qη(x) indexed by parameter η, and finds the optimal η by minimizing kl divergence kl(qη || p) = eqη [log(qη/p)], which requires to calculate the density qη(x) or its derivative that is not computable by our assumption (even when the monte carlo gradient estimation and the reparametrization trick (kingma & welling, 2013) are applied).
in fact, it is this requirement of calculating qη(x) that has been the major constraint for the designing of state-of-the-art variational inference methods with rich approximation families; the recent successful algorithms (e.g., rezende & mohamed, 2015b; tran , 2015; ranganath , 2015, to name only a few) have to handcraft special variational families to ensure the computational tractability of qη(x) and simultaneously obtain high approximation accuracy, which require substantial mathematical insights and research effects. methods that do not require to explicitly calculate qη(x) can significantly simplify the design and applications of vi methods, allowing practical users to focus more on choosing proposals that work best with their specific tasks. we will use the term wild variational inference to refer to new variants of variational methods that require no tractability qη(x), to distinguish with the black-box variational inference (ranganath , 2014) which refers to methods that work for generic target distributions p(x) without significant model-by-model consideration (but still require to calculate the proposal density qη(x)).
a similar problem also appears in importance sampling (is), where it requires to calculate the is proposal density q(x) in order to calculate the importance weight w(x) = p(x)/q(x). however, there exist methods that use no explicit information of q(x), which, seemingly counter-intuitively, give better asymptotic variance or converge rates than the typical is that uses the proposal information (e.g., liu & lee, 2016; briol , 2015; henmi , 2007; delyon & portier, 2014). discussions on this phenomenon dates back to o’hagan (1987), who argued that “monte carlo (that uses the proposal information) is fundamentally unsound” for violating the likelihood principle, and developed bayesian monte carlo (o’hagan, 1991) as an example that uses no information on q(x), yet gives better convergence rate than the typical monte carlo o(n−1/2) rate (briol , 2015). despite the substantial difference between is and vi, these results intuitively suggest the possibility of developing efficient variational inference without calculating q(x) explicitly.
in this work, we propose a simple algorithm for problem 1 by iteratively adjusting the network parameter η to make its output random variable changes along a stein variational gradient direction (svgd) (liu & wang, 2016) that optimally decreases its kl divergence with the target distribution. critically, the svgd gradient includes a repulsive term to ensure that the generated samples have the right amount of variability that matches p(x). in this way, we “amortize svgd” using a neural network, which makes it possible for our method to adaptively improve its own efficiency by leveraging fast experience, especially in cases when it needs to perform fast inference repeatedly on a large number of similar tasks. as an application, we use our method to amortize the mle training of deep energy models, where a neural sampler is adaptively trained to approximate the likelihood function. our method, which we call steingan, mimics an adversarial game between the energy model and the neural sampler, and obtains realistic-looking images competitive with the state-of-theart results produced by generative adversarial networks (gan) (goodfellow , 2014; radford , 2015).
related work the idea of amortized inference (gershman & goodman, 2014) has been recently applied in various domains of probabilistic reasoning, including both amortized variational inference (e.g., kingma & welling, 2013; rezende & mohamed, 2015a), and data-driven proposals for (sequential) monte carlo methods (e.g., paige & wood, 2016), to name only a few. most of these methods, however, require to explicitly calculate q(x) (or its gradient). one exception is a very recent paper (ranganath , 2016) that avoids calculating q(x) using an idea related to stein discrepancy (gorham & mackey, 2015; liu , 2016; oates , 2014; chwialkowski , 2016). there is also a raising interest recently on a similar problem of “learning to optimize” (e.g., andrychowicz , 2016; daniel , 2016; li & malik, 2016), which is technically easier than the more general problem of “learning to sample”. in fact, we show that our algorithm reduces to “learning to optimize” when only one particle is used in svgd.
generative adversarial network (gan) and its variants have recently gained remarkable success on generating realistic-looking images (goodfellow , 2014; salimans , 2016; radford , 2015; li , 2015; dziugaite , 2015; nowozin , 2016). all these methods are set up to train latent variable models (the generator) under the assistant of the discriminator. our steingan instead performs traditional mle training for a deep energy model, with the help of a neural sampler that learns to draw samples from the energy model to approximate the likelihood
function; this admits an adversarial interpretation: we can view the neural sampler as a generator that attends to fool the deep energy model, which in turn serves as a discriminator that distinguishes the real samples and the simulated samples given by the neural sampler. this idea of training mle with neural samplers was first discussed by kim & bengio (2016); one of the key differences is that the neural sampler in kim & bengio (2016) is trained with the help of a heuristic diversity regularizer based on batch normalization, while svgd enforces the diversity in a more principled way. another method by zhao  (2016) also trains an energy score to distinguish real and simulated samples, but within a non-probabilistic framework (see section 5 for more discussion). other more traditional approaches for training energy-based models (e.g., ngiam , 2011; xie , 2016) are often based on variants of mcmc-mle or contrastive divergence (geyer, 1991; hinton, 2002; tieleman, 2008), and have difficulty generating realistic-looking images from scratch.stein variational gradient descent (svgd) (liu & wang, 2016) is a general purpose bayesian inference algorithm motivated by stein’s method (stein, 1972; barbour & chen, 2005) and kernelized stein discrepancy (liu , 2016; chwialkowski , 2016; oates , 2014). it uses an efficient deterministic gradient-based update to iteratively evolve a set of particles {xi}ni=1 to minimize the kl divergence with the target distribution. svgd has a simple form that reduces to the typical gradient descent for maximizing log p when using only one particle (n = 1), and hence can be easily combined with the successful tricks for gradient optimization, including stochastic gradient, adaptive learning rates (such as adagrad), and momentum.
to give a quick overview of the main idea of svgd, let p(x) be a positive density function on rd which we want to approximate with a set of particles {xi}ni=1. svgd initializes the particles by sampling from some simple distribution q0, and updates the particles iteratively by
xi ← xi + φ(xi), ∀i = 1, . . . , n, (1) where is a step size, and φ(x) is a “particle gradient direction” chosen to maximumly decrease the kl divergence between the distribution of particles and the target distribution, in the sense that
φ = arg max φ∈f { − d d kl(q[ φ] || p) ∣∣ =0 } , (2)
where q[ φ] denotes the density of the updated particle x′ = x + φ(x) when the density of the original particle x is q, and f is the set of perturbation directions that we optimize over. we choose f to be the unit ball of a vector-valued reproducing kernel hilbert space (rkhs)hd = h×· · ·×h with eachh associating with a positive definite kernel k(x, x′); note thath is dense in the space of continuous functions with universal kernels such as the gaussian rbf kernel.
critically, the gradient of kl divergence in (2) equals a simple linear functional of φ, allowing us to obtain a closed form solution for the optimal φ. liu & wang (2016) showed that
− d d kl(q[ φ] || p) ∣∣ =0 = ex∼q[tpφ(x)], (3)
with tpφ(x) = ∇x log p(x)>φ(x) +∇x · φ(x), (4) where tp is considered as a linear operator acting on function φ and is called the stein operator in connection with stein’s identity which shows that the rhs of (3) equals zero if p = q:
ep[tpφ] = ep[∇x log p>φ +∇x · φ] = 0. (5) this is a result of integration by parts assuming the value of p(x)φ(x) vanishes on the boundary of the integration domain.
therefore, the optimization in (2) reduces to
d(q || p) def= max φ∈hd {ex∼q[tpφ(x)] s.t. ||φ||hd ≤ 1}, (6)
where d(q || p) is the kernelized stein discrepancy defined in liu  (2016), which equals zero if and only if p = q under mild regularity conditions. importantly, the optimal solution of (6) yields a closed form
φ∗(x′) ∝ ex∼q[∇x log p(x)k(x, x′) +∇xk(x, x′)].
algorithm 1 amortized svgd for problem 1 set batch size m, step-size scheme { t} and kernel k(x, x′). initialize η0. for iteration t do
draw random {ξi}mi=1, calculate xi = f(ηt; ξi), and the stein variational gradient ∆xi in (7). update parameter η using (8), (9) or (10).
end for
by approximating the expectation under q with the empirical average of the current particles {xi}ni=1, svgd admits a simple form of update:
xi ← xi + ∆xi, ∀i = 1, . . . , n, where ∆xi = êx∈{xi}ni=1 [∇x log p(x)k(x, xi) +∇xk(x, xi)], (7)
and êx∼{xi}ni=1 [f(x)] = ∑ i f(xi).. the two terms in ∆xi play two different roles: the term with the gradient ∇x log p(x) drives the particles toward the high probability regions of p(x), while the term with ∇xk(x, xi) serves as a repulsive force to encourage diversity; to see this, consider a stationary kernel k(x, x′) = k(x − x′), then the second term reduces to êx∇xk(x, xi) = −êx∇xik(x, xi), which can be treated as the negative gradient for minimizing the average similarity êxk(x, xi) in terms of xi. overall, this particle update produces diverse points for distributional approximation and uncertainty assessment, and also has an interesting “momentum” effect in which the particles move collaboratively to escape the local optima.
it is easy to see from (7) that ∆xi reduces to the typical gradient ∇x log p(xi) when there is only a single particle (n = 1) and ∇xk(x, xi) when x = xi, in which case svgd reduces to the standard gradient ascent for maximizing log p(x) (i.e., maximum a posteriori (map)).svgd and other particle-based methods become inefficient when we need to repeatedly infer a large number different target distributions for multiple tasks, including online learning or inner loops of other algorithms, because they can not improve based on the experience from the past tasks, and may require a large memory to restore a large number of particles. we propose to “amortize svgd” by training a neural network f(η; ξ) to mimic the svgd dynamics, yielding a solution for problem 1.
one straightforward way to achieve this is to run svgd to convergence and train f(η; ξ) to fit the svgd results. this, however, requires to run many epochs of fully converged svgd and can be slow in practice. we instead propose an incremental approach in which η is iteratively adjusted so that the network outputs x = f(η; ξ) changes along the stein variational gradient direction in (7) in order to decrease the kl divergence between the target and approximation distribution.
to be specific, denote by ηt the estimated parameter at the t-th iteration of our method; each iteration of our method draws a batch of random inputs {ξi}mi=1 and calculate their corresponding output xi = f(η; ξi) based on ηt; here m is a mini-batch size (e.g., m = 100). the stein variational gradient ∆xi in (7) would then ensure that x′i = xi + ∆xi forms a better approximation of the target distribution p. therefore, we should adjust η to make its output matches {x′i}, that is, we want to update η by
ηt+1 ← arg min η m∑ i=1 ||f(η; ξi)− x′i||22, where x′i = xi + ∆xi. (8)
see algorithm 1 for the summary of this procedure. if we assume is very small, then (8) reduces to a least square optimization. to see this, note that f(η; ξi) ≈ f(ηt; ξi) + ∂ηf(ηt; ξi)(η − ηt) by taylor expansion. since xi = f(ηt; ξi), we have
||f(η; ξi)− x′i||22 ≈ ||∂ηf(ηt; ξi)(η − ηt)− ∆xi||22. as a result, (8) reduces to the following least square optimization:
ηt+1 ← ηt + ∆ηt, where ∆ηt = arg min δ m∑ i=1 ||∂ηf(ηt; ξi)δ −∆xi||22. (9)
update (9) can still be computationally expensive because of the matrix inversion. we can derive a further approximation by performing only one step of gradient descent of (8) (or (9)), which gives
ηt+1 ← ηt + m∑ i=1 ∂ηf(η t; ξi)∆xi. (10)
although update (10) is derived as an approximation of (8)-(9), it is computationally faster and we find it works very effectively in practice; this is because when is small, one step of gradient update can be sufficiently close to the optimum.
update (10) also has a simple and intuitive form: (10) can be thought as a “chain rule” that backpropagates the stein variational gradient to the network parameter η. this can be justified by considering the special case when we use only a single particle (n = 1) in which case ∆xi in (7) reduces to the typical gradient ∇x log p(xi) of log p(x), and update (10) reduces to the typical gradient ascent for maximizing eξ[log p(f(η; ξ))], in which case f(η; ξ) is trained to maximize log p(x) (that is, learning to optimize), instead of learning to draw samples from p for which it is crucial to use stein variational gradient ∆xi to diversify the network outputs.
update (10) also has a close connection with the typical variational inference with the reparameterization trick (kingma & welling, 2013). let qη(x) be the density function of x = f(η; ξ), ξ ∼ q0. using the reparameterization trick, the gradient of kl(qη || p) w.r.t. η can be shown to be
∇ηkl(qη || p) = −eξ∼q0 [∂ηf(η; ξ)(∇x log p(x)−∇x log qη(x))].
with {ξi} i.i.d. drawn from q0 and xi = f(η; ξi), ∀i, the standard stochastic gradient descent for minimizing the kl divergence is
ηt+1 ← ηt + ∑ i ∂ηf(η t; ξi)∆̃xi, where ∆̃xi = ∇x log p(xi)−∇x log qη(xi). (11)
this is similar with (10), but replaces the stein gradient ∆xi defined in (7) with ∆̃xi. the advantage of using ∆xi is that it does not require to explicitly calculate qη , and hence admits a solution to problem 1 in which qη is not computable for complex network f(η; ξ) and unknown input distribution q0. further insights can be obtained by noting that
∆xi ≈ ex∼q[∇x log p(x)k(x, xi) +∇xk(x, xi)] = ex∼q[(∇x log p(x)−∇x log q(x))k(x, xi)] (12) = ex∼q[(∆̃x)k(x, xi)],
where (12) is obtained by using stein’s identity (5). therefore, ∆xi can be treated as a kernel smoothed version of ∆̃xi.our method allows us to design efficient approximate sampling methods adaptively and automatically, and enables a host of novel applications. in this paper, we apply it in an amortized mle method for training deep generative models.
maximum likelihood estimator (mle) provides a fundamental approach for learning probabilistic models from data, but can be computationally prohibitive on distributions for which drawing samples or computing likelihood is intractable due to the normalization constant. traditional methods such as mcmc-mle use hand-designed methods (e.g., mcmc) to approximate the intractable likelihood function but do not work efficiently in practice. we propose to adaptively train a generative neural network to draw samples from the distribution during mle training, which not only provides computational advantage, and also allows us to generate realistic-looking images competitive with, or better than the state-of-the-art generative adversarial networks (gan) (goodfellow , 2014; radford , 2015) (see figure 1-5).
algorithm 2 amortized mle as generative adversarial learning goal: mle training for energy model p(x|θ) = exp(−φ(x, θ)− φ(θ)). initialize η and θ. for iteration t do
updating η: draw ξi ∼ q0, xi = f(η; ξi); update η using (8), (9) or (10) with p(x) = p(x|θ). repeat several times when needed. updating θ: draw a mini-batch of observed data {xi,obs}, and simulated data xi = f(η; ξi), update θ by (13).
end for
to be specific, denote by {xi,obs} a set of observed data. we consider the maximum likelihood training of energy-based models of form
p(x|θ) = exp(−φ(x, θ)− φ(θ)), φ(θ) = log ∫ exp(−φ(x, θ))dx,
where φ(x; θ) is an energy function for x indexed by parameter θ and φ(θ) is the log-normalization constant. the log-likelihood function of θ is
l(θ) = 1
n n∑ i=1 log p(xi,obs|θ),
whose gradient is
∇θl(θ) = −êobs[∂θφ(x; θ)] + eθ[∂θφ(x; θ)],
where êobs[·] and eθ[·] denote the empirical average on the observed data {xi,obs} and the expectation under model p(x|θ), respectively. the key computational difficulty is to approximate the model expectation eθ[·]. to address this problem, we use a generative neural network x = f(η; ξ) trained by algorithm 1 to approximately sample from p(x|θ), yielding a gradient update for θ of form
θ ← θ + ∇̂θl(θ), ∇̂θl(θ) = −êobs[∂θφ(x; θ)] + êη[∂θφ(x; θ)], (13)
where êη denotes the empirical average on {xi} where xi = f(η; ξi), {ξi} ∼ q0. as θ is updated by gradient ascent, η is successively updated via algorithm 1 to follow p(x|θ). see algorithm 2. we call our method steingan, because it can be intuitively interpreted as an adversarial game between the generative network f(η; ξ) and the energy model p(x|θ) which serves as a discriminator: the mle gradient update of p(x|θ) effectively decreases the energy of the training data and increases the energy of the simulated data from f(η; ξ), while the svgd update of f(η; ξ) decreases the energy of the simulated data to fit better with p(x|θ). compared with the traditional methods based on mcmc-mle or contrastive divergence, we amortize the sampler as we train, which gives much faster speed and simultaneously provides a high quality generative neural network that can generate realistic-looking images; see kim & bengio (2016) for a similar idea and discussions.we evaluated our steingan on four datasets, mnist, cifar-10, celeba (liu , 2015), and large-scale scene understanding (lsun) (yu , 2015), on which we find our method tends to generate realistic-looking images competitive with, sometimes better than dcgan (radford , 2015) (see figure 2 - figure 3). our code is available at https://github.com/dartml/ steingan.
model setup in order to generate realistic-looking images, we define our energy model based on an autoencoder:
p(x|θ) ∝ exp(−||x−d(e(x; θ); θ)||), (14)
where x denotes the image. this choice is motivated by energy-based gan (zhao , 2016) in which the autoencoder loss is used as a discriminator but without a probabilistic interpretation. we
assume f(η; ξ) to be a neural network whose input ξ is a 100-dimensional random vector drawn by uniform([−1, 1]). the positive definite kernel in svgd is defined by the rbf kernel on the hidden representation obtained by the autoencoder in (14), that is,
k(x, x′) = exp(− 1 h2 ||e(x; θ)− e(x′; θ)||2).
as it is discussed in section 3, the kernel provides a repulsive force to produce an amount of variability required for generating samples from p(x). this is similar to the heuristic repelling regularizer in zhao  (2016) and the batch normalization based regularizer in kim & bengio (2016), but is derived in a more principled way. we take the bandwidth to be h = 0.5 ×med, where med is the median of the pairwise distances between e(x) on the image simulated by f(η; ξ). this makes the kernel change adaptively based on both θ (through e(x; θ)) and η (through bandwidth h).
some datasets include both images x and their associated discrete labels y. in these cases, we train a joint energy model on (x, y) to capture both the inner structure of the images and its predictive relation with the label, allowing us to simulate images with a control on which category it belongs to. our joint energy model is defined to be
p(x, y|θ) ∝ exp { − ||x−d(e(x; θ); θ)|| −max[m, σ(y, e(x; θ))] } , (15)
where σ(·, ·) is the cross entropy loss function of a fully connected output layer. in this case, our neural sampler first draws a label y randomly according to the empirical counts in the dataset, and then passes y into a neural network together with a 100 × 1 random vector ξ to generate image x. this allows us to generate images for particular categories by controlling the value of input y.
stabilization in practice, we find it is useful to modify (13) to be θ ← θ − êobs[∇θφ(x, θ)] + (1− γ)êη[∇θφ(x, θ)]. (16)
where γ is a discount factor (which we take to be γ = 0.7). this is equivalent to maximizing a regularized likelihood:
max θ {log p(x|θ) + γφ(θ)}
where φ(θ) is the log-partition function; note that exp(γφ(θ)) is a conjugate prior of p(x|θ). we initialize the weights of both the generator and discriminator from gaussian distribution n (0, 0.02), and train them using adam (kingma & ba, 2014) with a learning rate of 0.001 for the generator and 0.0001 for the energy model (the discriminator). in order to keep the generator and discriminator approximately aligned during training, we speed up the mle update (16) of the discriminator (by increasing its learning rate to 0.0005) when the energy of the real data batch is larger than the energy of the simulated images, while slow down it (by freezing the mle update of θ in (16)) if the magnitude of the energy difference between the real images and the simulated images goes above a threshold of 0.5. we used the bag of architecture guidelines for stable training suggested in dcgan (radford , 2015).
discussion the mnist dataset has a training set of 60, 000 examples. both dcgan and our model produce high quality images, both visually indistinguishable from real images; see figure 1.
cifar-10 is very diverse, and with only 50,000 training examples. figure 2 shows examples of simulated images by dcgan and steingan generated conditional on each category, which look equally well visually. we also provide quantitively evaluation using a recently proposed inception score (salimans , 2016), as well as the classification accuracy when training resnet using 50, 000 simulated images as train sets, evaluated on a separate held-out testing set never seen by the gan models. besides dcgan and steingan, we also evaluate another simple baseline obtained by subsampling 500 real images from the training set and duplicating them 100 times. we observe that these scores capture rather different perspectives of image generation: the inception score favors images that look realistic individually and have uniformly distributed labels; as a result, the inception score of the duplicated 500 images is almost as high as the real training set. we find that the inception score of steingan is comparable, or slightly lower than that of dcgan. on the other hand, the classification accuracy measures the amount information captured in the simulated image sets; we find that steingan achieves the highest classification accuracy, suggesting that it captures more information in the training set.
figure 3 and 4 visualize the results on celeba (with more than 200k face images) and lsun (with nearly 3m bedroom images), respectively. we cropped and resized both dataset images into 64×64.we propose a new method to train neural samplers for given distributions, together with a new steingan method for generative adversarial training. future directions involve more applications and theoretical understandings for training neural samplers.",0
554.pdf.json,"deep reinforcement learning has had many practical successes in game playing (mnih  (2015),silver  (2016)) and robotics (levine & abbeel (2014)). our interest is in further exploring these algorithms in the context of environments with sparse rewards and partial observability. to this end, we investigate the use of two methods that are known to mitigate these problems: recurrent networks, which provide a form of memory summarizing past experiences, and eligibility traces, which allow information to propagate over multiple time steps. eligibility traces have been shown empirically to provide faster learning (sutton & barto (2017), in preparation) but their use with deep rl has been limited so far (van seijen & sutton (2014), hausknecht & stone (2015)). we provide experiments in the atari domain showing that eligibility traces boost the performance of deep rl. we also demonstrate a surprisingly strong effect of the optimization method on the performance of the recurrent networks.
the paper is structured as follows. in sec. 2 we provide background and notation needed for the paper. sec. 3 describes the algorithms we use. in sec. 4 we present and discuss our experimental results. in sec. 5 we conclude and present avenues for future work.a markov decision process (mdp) consists of a tuple 〈s,a, r,p, γ〉, where s is the set of states, a is the set of actions, r : s × a 7→ r is the reward function, p(s′|s, a) is the transition function (giving the next state distribution, conditioned on the current state and action), and γ ∈ [0, 1) is the discount factor. reinforcement learning (rl) (sutton & barto, 1998) is a framework for solving unknown mdps, which means finding a good (or optimal) way of behaving, also called a policy. rl works by obtaining transitions from the environment and using them, in order to compute a policy that maximizes the expected return, given by e [∑∞ t=0 γ trt ] .
the state-value function for a policy π : s × a → [0, 1], v π(s), is defined as the expected return obtained by starting at state s and picking actions according to π. state-action values q(s, a) are similar to state values, but conditioned also on the initial action a. a policy can be derived from the q values by picking always the action with the best estimated value at any state.
monte carlo (mc) and temporal difference (td) are two standard methods for updating the value function from data. in mc, an entire trajectory’s return is used as the target value of the current
state.
mc error = ∞∑ i=0 γirt+i − v (st) (1)
in td, the estimate of the next state’s value is used to correct the current state’s estimate:
td error = rt + γv (st+1)− v (st) (2)
q-learning is an rl algorithm that allows an agent to learn by imagining that it will take the best possible action in the following step:
td error = rt + γmax a′
q(st+1, a ′)−q(st, at) (3)
this is an instance of off-policy learning, in which the agent gathers data with an exploratory policy, which randomizes the choice of action, but updates its estimates by constructing targets according to a differnet policy (in this case, the policy that is greedy with respect to the current value estimates.eligibility traces are a fundamental reinforcement learning mechanism which allows a trade-off between td and mc. mc methods suffer from high variance, as many trajectories can be taken from any given state and stochasticity is often present in the mdp. td suffers from high bias, as it updates values based on its own estimates.
using eligibility traces allows one to design algorithms that cover the middle-ground between mc and td. the central notion for these are n-step returns, which provide a way of calculating the target by using the value estimate for the state which occurs n steps in the future (compared to the current state):
r (n) t = n−1∑ i=0 γirt+i + γ nv (st+n). (4)
when n is 1, the results is the td target, and taking n→∞ yields the mc target. eligibility traces use a geometric weighting of these n-step returns, where the weight of the k-step return is λ times the weight of the k − 1-step return. using a λ = 0 reduces to using td, as all n-steps for n > 1 have a weight of 0. one of the appealing effects of using eligibility traces is that a single update allows states many steps behind a reward signal to receive credit. this propagates knowledge back at a faster rate, allowing for accelerated learning. especially in environments where rewards are sparse and/or delayed, eligibility traces can help assign credit to past states and actions. without traces, seeing a sparse reward will only propagate the value back by one step, which in turn needs to be sampled to send the value back a second step, and so on.
rλt = (1− λ) ∞∑ i=0 λir (i) t = (1− λ) ∞∑ i=1 λi−1 i−1∑ j=0 γjrj + γ i+1v (st+i) (5)
this way of viewing eligibility traces is called the forward view, as states are looking ahead at the rewards received in the future. the forward view is rarely used, as it requires a state to wait for the future to unfold before calculating an update, and requires memory to store the experience. there is an equivalent view called the backward view, which allows us to calculate updates for every previous state as we take a single action. this requires no memory and lets us perform updates without having to wait for the future. however, this view has had limited success in the neural network setting as it requires using a trace on each neuron of the network, which tend to be dense and heavily used at each step resulting in noisy signals. for this reason, eligibility traces aren’t heavily used when using deep learning, despite their potential benefits. .1.1 q(λ)
q(λ) is a variant of q-learning where eligibility traces are used to calculate the td error. as mentioned previously, the backwards view of traces is traditionally used.
a few versions of q(λ) exist, but the most used one is watkins’s q(λ). as q-learning is off-policy, the sequence of actions used in the past trajectory used to calculate the trace might be different from the actions that the current policy might take. in that case, one should not be using the trajectory past the point where actions differ. to handle such a case, watkins’s q(λ) sets the trace to 0 if the action that the current policy would select is different from the one used in the past.mnih  (2015) introduced deep q-networks (dqn), one of the first successful reinforcement learning algorithms that use deep learning for function approximation in a way general enough which is applicable to a variety of environments. applying it to a set of atari games, they used a convolutional neural network (cnn) which took as input the last four frames of the game, and output q-values for each possible action.
equation 6 shows the dqn cost function, where we are optimizing the θ parameters. the θ− parameters represent frozen q-value weights which are update at a chosen frequency.
l(st, at|θ) = (rt + γmax a′ q(st+1, a ′|θ−)−q(st, at|θ))2 (6)as introduced in hausknecht & stone (2015), deep recurrent q-networks (drqn) are a modification on dqn, where single frames are passed through a cnn, which generates a feature vector that is then fed to an rnn which finally outputs q-values. this architecture gives the agent a memory, allowing it to learn long-term temporal effects and handle partial observability, which is the case in many environments. the authors showed that randomly blanking out frames was difficult to overcome for dqn, but that drqn learned to handle without issue.
to train drqn, they proposed two variants of experience replay. the first was to sample entire trajectories and run the rnn from end to end. however this is very computationally demanding as some trajectories can be over 10000 steps long. the second alternative was to sample subtrajectories instead of single transitions. this is required as the rnn needs to fill its hidden state and to allow it to understand the temporal aspect of the data.stochastic gradient descent (sgd) is generally the algorithm used to optimize neural networks. however, some information is lost during the process as past gradients might signal that a weight drastically needs to change, or that it is oscillating, requiring a decrease in learning rate. adaptive sgd algorithms have been built to use this information.
rmsprop (tieleman & hinton (2012)), uses a geometric averaging over gradients squared, and divides the current gradient by its square root. to perform rmsprop, first we calculate the averaging as g = βg + (1− β)∇θ2 and then update the parameters θ ← θ + α ∇θ√
g+ .
dqn (graves (2013)) introduced a variant of rmsprop where the gradient is instead divided by the standard deviation of the running average. first we calculate the running averages m = βm+ (1− β)∇θ and g = βg + (1 − β)∇θ2, and then update the parameters using θ ← θ + α ∇θ√
g−m2+ . in
the rest of the paper, when mentioning rmsprop, we’ll be referring to this version.
finally, kingma & ba (2014) introduced adam, which is essentially rmsprop coupled with nesterov momentum, along with the running averages being corrected for bias. we have a term for the rate of momentum of each of the running averages. to calculate the update with adam, we start with the updating the averages m = β1m+ (1− β1)∇θ, v = β2v + (1− β2)∇θ2, the correct their biases m̂ = m/(1−βt1), v̂ = v/(1−βt2) and finally calculate the gradient update θ ← θ+α m̂√v̂+ .as explained, the forward view of eligibility traces can be useful, but is computationally demanding in terms of memory and time. one must store all transitions and apply the neural network to each state in the trajectory. by using drqn, experience replay is already part of the algorithm, which removes the memory requirement of the traces. then, by training on sub-trajectories of data, the states must be run through the rnn with all state values as the output, which eliminates the computational cost. finally, all that’s left to use eligibility traces is simply to calculate the weighted sum of the targets, which is very cheap to do.
in this section we analyze the use of eligibility traces when training drqn and try both rmsprop and adam as optimizers. we only tested the algorithms on fully observable games as to compare the learning capacities without the unfair advantage of having a memory, as would be the case on partially observable environments.we tested the algorithms on two atari 2600 games, part of the arcade learning environment (bellemare  (2012)), pong and tennis. the architecture used is similar to the one used in hausknecht & stone (2015). the frames are converted to gray-scale and re-sized to 84x84. these are then fed to a cnn with the first layer being 32 8x8 filters and a stride of 4, followed by 64 4x4 filters with a stride of 2, then by 64 3x3 filters with a stride of 1. the output of the cnn is then flattened before being fed to a single dense layer of 512 output neurons, which is finally fed to an lstm (hochreiter & schmidhuber (1997)) with 512 cells. we then have a last linear layer that takes the output of the recurrent layer to output the q-values. all layers before the lstm are activated using rectified linear units (relu).
as mentioned in subsection 2.2.1, we also altered experience replay to sample sub-trajectories. we use backprop through time (bptt) to train the rnn, but only train on a sub-trajectory of experience. in runtime, the rnn will have had a large sequence of inputs in its hidden state, which can be problematic if always trained with an empty hidden state. like in lample & singh chaplot (2016), we therefore sample a slightly longer length of trajectory and use the first m states to fill the hidden state. in our experiments, we selected trajectory lengths of 32, where the first 10 states are used as filler and the remaining 22 are used for the traces and td costs. we used a batch size of 4.
all experiments using eligibility traces use λ = 0.8. furthermore, we use watkins’s q(λ). to limit computation costs of using traces, we cut the trace off once it becomes too small. in our experiments, we choose the limit of 0.01, which allows the traces to affect 21 states ahead (when λ = 0.8). we
calculate the trace for every state in the trajectory, except for a few in the beginning, use to fill in the hidden state of the rnn.
when using rmsprop, we used a momentum of 0.95, an epsilon of 0.01 and a learning rate of 0.00025. when using adam, we used a momentum of gradients of 0.9, a momentum of squared gradients of 0.999, an epsilon of 0.001 and a learning rate of 0.00025.
testing phases are consistent across all models, with the score being the average over each game played during 125000 frames. we also use an of 0.05 for action selection.
choose k as number of trace steps and m as rnn-filler steps initialize weights θ, experience replay d θ− ← θ s← s0 repeat
initialize rnn hidden state to 0. repeat
choose a according to −greedy policy on q(s, a|θ) take action a in s, observe s′, r store s, a, r, s′ in experience replay sample 4 sub-trajectories of m+ k sequential transitions (s, a, r, s′) from d
ŷ = { r s’ is terminal, r + γmax
ā q(s′, ā|θ−) otherwise
foreach transition sampled do
λt = { λ at = arg maxā(st, ā|θ), 0 otherwise
end for l from 0 to k − 1 do
r̂λt+l = [∑k s=l (∏s i=l λt+i ) r (s−l+1) t+s ] / [∑k s=l (∏s i=l λt+i )] end perform gradient descent on∂(r̂
λ−q(s,a|θ))2 ∂θ
every 10000 steps θ− ← θ s← s′
until s′ is terminal until training complete algorithm 1: deep recurrent q-networks with forward view eligibility traces on atari. the eligibility traces are calculated using the n-step return function r(n)t for time-step t was described in section 2.1.we describe experiments in two atari games: pong and tennis. we chose pong because it permits quick experimentation, and tennis because it is one of the games that has proven difficult in all published results on atari.first, we tested an rnn model both with λ = 0 and λ = 0.8, trained with rmsprop. figure 2 shows that the model without a trace (λ = 0) learned at the same rate as dqn, while the model with traces (λ = 0.8) learned substantially faster and with more stability, without exhibiting any epochs with depressed performance. this is probably due to the eligibility traces propagating rewards back by many steps in a single update. in pong, when the agent hits the ball, it must wait several time-steps before the ball gets either to or past the opponent. once this happens, the agent must assign the credit of the event back to the time when it hit the ball, and not to the actions performed after the ball had already left. the traces clearly help send this signal back faster.
we then tested the same models but using adam as the optimizer instead of rmsprop. all models learn much faster with this setting. however, the model with no trace gains significantly more than the model with the trace. our current intuition is that some hyper-parameters, such as the frozen network’s update frequency, are limiting the rate at which the model can learn. note also that the dqn model also learns faster with adam as the optimizer, but remains quite unstable, in comparison with the recurrent net models.
finally, the results in table 1 show that both using eligibility traces and adam provide performance improvements. while training with rmsprop, the model with traces gets to near optimal performance more than twice as quickly as the other models. with adam, the model learns to be optimal in just 6 epochs.the second atari 2600 game we tested was tennis. a match consists of only one set, which is won by the player who is the first to win 6 ”games” (as in regular tennis). the score ranges from 24 to -24, given as the difference between the number of balls won by the two players.
as in pong, we first tried an rnn trained with rmsprop and the standard learning rate of 0.00025, both with and without eligibility traces (using again λ = 0.8 and λ = 0). figure 3 shows that both rnn models learned to get optimal scores after about 50 epochs. this is in contrast with dqn, which never seems to be able to pass the 0 threshold, with large fluctuations ranging from -24 to 0. after visually inspecting the games played in the testing phase, we noticed that the dqn agent gets stuck in a loop, where it exchanges the ball with the opponent until the timer runs out. in such a case, the agent minimizes the number of points scored against, but never learns to beat the opponent. the score fluctuations depend on how few points the agent allows before entering the loop. we suspect that the agent gets stuck in this policy because the reward for trying to defeat the opponent is delayed, waiting for the ball to reach the opponent and get past it. furthermore, the experiences of getting a point are relatively sparse. together, it makes it difficult to propagate the reward back to the action of hitting the ball correctly.
we also notice that both the rnn with and without eligibility traces manage to learn a near-optimal policy without getting stuck in the bad policy. the rnn has the capacity of sending the signal back to past states with bptt, allowing it to do credit assignment implicitly, which might explain their ability to escape the bad policy. remarkably, this is the only algorithm that succeeds in getting near-optimal scores on tennis, out of all variants of dqn (mnih  (2015), munos  (2016), wang  (2015), mnih  (2016), schaul  (2015)), which tend to get stuck in the policy of delaying. the model without traces learned at a faster pace than the one with traces, arriving to a score of 20 in 45 epochs as opposed to 62 for its counterpart. it’s possible that the updates for model with traces were smaller, due to the weighting of target values, indirectly leading to a lower learning rate. we also trained the models with rmsprop and a higher learning rate of 0.001. this led to the model with traces getting to 20 points in just 27 epochs, while the model without traces lost its ability to get optimal scores and never passed the 0 threshold.
we then tried using adam as the optimizer, with the original learning rate of 0.00025. both rnn models learned substantially faster than with rmsprop, with the rnn with traces getting to nearoptimal performance in just 13 epochs. with adam, the gradient for the positive td is stored in the momentum part of the equation for quite some time. once in momentum, the gradient is part of many updates, which makes it enough to overtake the safe strategy. we also notice that the model with traces was much more stable than its counterpart. the model without traces fell back to the policy of delaying the game on two occasions, after having learned to beat the opponent. finally, we trained dqn with adam, but the model acted the same way as dqn trained with rmsprop.in this paper, we analyzed the effects of using eligibility traces and different optimization functions. we showed that eligibility traces can improve and stabilize learning and using adam can strongly accelerate learning.
as shown in the pong results, the model using eligibility traces didn’t gain much performance from using adam. one possible cause is the frozen network. while it has a stabilizing effect in dqn, by stopping policies from drastically changing from a single update, it also stops newly learned values from being propagated back. double dqn seems to partially go around this issue, allowing
the policy of the next state to change, while keeping the values frozen. in future experiments, we must consider eliminating or increasing the frozen network’s update frequency. it would also be interesting to reduce the size of experience replay, as with increased learning speed, old observations can become too off-policy and barely be used in eligibility traces.",0
556.pdf.json,"deep neural networks are trained by optimizing an extremely high-dimensional loss function with respect to the weights of the network’s linear layers. the objective function minimized is some measure of the error of the network’s predictions based on these weights compared to training data. this loss function is non-convex and has many local minima. these loss functions are usually minimized using first-order gradient descent (robbins & monro, 1951; polyak, 1964) algorithms such as stochastic gradient descent (sgd) (bottou, 1991). the success of deep learning critically depends on how well we can minimize this loss function, both in terms of the quality of the local minima found and the time to find them. understanding the geometry of this loss function and how well optimization algorithms can find good local minima is thus of vital importance.
several works have theoretically analyzed and characterized the geometry of deep network loss functions. however, to make these analyses tractible, they have relied on simplifications of the network structures, including that the networks are linear (saxe , 2014), or assuming the path and variable independence of the neural networks (choromanska , 2015). orthogonally, the performance of various gradient descent algorithms has been theoretically characterized (nesterov, 1983). again, these analyses make simplifying assumptions, in particular that the loss function is strictly convex, i.e. there is only a single local minimum.
in this work, we empirically investigated the geometry of the real loss functions for state-of-the-art networks and data sets. in addition, we investigated how popular optimization algorithms interact with these real loss surfaces. to do this, we plotted low-dimensional projections of the loss function in subspaces chosen to investigate properties of the local minima selected by different algorithms. we chose these subspaces to address the following questions:
• what types of changes to the optimization procedure result in different local minima? • do different optimization algorithms find qualitatively different types of local minima?there have been several attempts to understand the loss surfaces of deep neural networks. some have studied the critical points of the deep linear neural networks (baldi, 1989; baldi & hornik,
∗work done during an internship at janelia research campus 9; baldi & lu, 2012). others further investigated the learning dynamics of the deep linear neural networks (saxe , 2014). more recently, several others have attempted to study the loss surfaces of deep non-linear neural networks (choromanska , 2015; kawaguchi, 2016; soudry & carmon, 2016).
one approach is to analogize the states of neurons as the magnetics dipoles used in spherical spinglass ising models from statistical physics (parisi, 2016; fyodorov & williams, 2007; bray & dean, 2007). choromanska  (2015) attempted to understand the loss function of neural networks through studying the random gaussian error functions of ising models. recent results (kawaguchi, 2016; soudry & carmon, 2016) have provided cursory evidence in agreement with the theory provided by choromanska  (2015) in that they found that that there are no “poor” local minima in neural networks still with strong assumptions.
there is some potential disconnect between these theoretical results and what is found in practice due to several strong assumptions such as the activation of the hidden units and output being independent of the previous hidden units and input data. the work of dauphin  (2014) empirically investigated properties of the critical points of neural network loss functions and demonstrated that their critical points behave similarly to the critical points of random gaussian error functions in high dimensional space. we will expose further evidence along this trajectory.in practice, the local minima of deep network loss functions are for the most part decent. this implies that we probably do not need to take many precautions to avoid bad local minima in practice. if all local minima are decent, then the task of finding a decent local minimum quickly is reduced to the task of finding any local minimum quickly. from an optimization perspective this implies that solely focusing on designing fast methods are of key importance for training deep networks.
in the literature the common method for measuring performance of optimization methods is to analyze them on nice convex quadratic functions (polyak, 1964; broyden, 1970; nesterov, 1983; martens, 2010; erdogdu & montanari, 2015) even though the problems are applied to non-convex problems. for non-convex problems, however, if two methods converge to different local minima their performance will be dictated on how those methods solve those two convex subproblems. it is challenging to show that one method will beat another without knowledge of the sort of convex subproblems, which is generally not known apriori. what we will explore is whether indeed are some characteristics that can found experimentally. if so, perhaps one could validate where these analytical results are valid or even improve methods for training neural networks. .2.1 learning phases
one of the interesting empirical observation is that we often observe is that the incremental improvement of optimization methods decreases rapidly even in non-convex problems. this behavior has been discussed as a “transient” phase followed by a “minimization” phase (sutskever , 2013)
where the former finds the neighborhood of a decent local minima and the latter finds the local minima within that neighborhood. the existence of these phases implies that if certain methods are better at different phases one could create novel methods that schedule when to apply each method.we conducted experiments on three state-of-the-art neural network architectures. network-innetwork (nin) (lin , 2014) and the vgg(simonyan & zisserman, 2015) network are feedforward convolutional networks developed for image classification, and have excellent performance on the imagenet (russakovsky , 2014) and cifar10 (krizhevsky, 2009) data sets. the long short-term memory network (lstm) (hochreiter & schmidhuber, 1997) is a recurrent neural network that has been successful in tasks that take variable-length sequences as input and/or produce variable-length sequences as output, such as speech recognition and image caption generation. these are large networks currently used in many machine vision and learning tasks, and the loss functions minimized by each are highly non-convex.
all results using the feed-forward convolutional networks (nin and vgg) are on the cifar10 image classification data set, while the lstm was tested on the penn treebank next-word prediction data set.we analyzed the performance of five popular gradient-descent optimization methods for these learning frameworks: stochastic gradient descent (sgd) (robbins & monro, 1951), stochastic gradient descent with momentum (sgdm), rmsprop (tieleman & hinton, 2012), adadelta (zeiler , 2011), and adam (kingma & ba, 2014). these are all first-order gradient descent algorithms that estimate the gradients based on randomly-grouped minibatches of training examples. one of the major differences between these algorithms is how they select the weight-update step-size at each iteration, with sgd and sgdm using fixed schedules, and rmsprop, adadelta, and adam using adaptive, per-parameter step-sizes. details are provided in section a.2.
in addition to these five existing optimization methods, we compare to a new gradient descent method we developed based on the family of runge kutta integrators. in our experiments, we tested a second-order runge-kutta integrator in combination with sgd (rk2) and in combination with adam (adam&rk2). details are provided in section a.3).several of our empirical analyses are based on the technique of goodfellow  (goodfellow , 2015). they visualize the loss function by projecting it down to one carefully chosen dimension. they plot the value of the loss function along a set of samples along this dimension. the projection space is chosen based on important weight configurations, thus they plot the value of the loss function at linear interpolations between two weight configurations. they perform two such analyses: one in which they interpolate between the initialization weights and the final learned weights, and one in which they interpolate between two sets of final weights, each learned from different initializations.
in this work, we use a similar visualization technique, but choose different low-dimensional subspaces for the projection of the loss function. these subspaces are based on the initial weights as well as the final weights learned using the different optimization algorithms and combinations of them, and are chosen to answer a variety of questions about the loss function and how the different optimization algorithms interact with this loss function. in contrast, goodfellow  only looked at sgdm. in addition, we explore the use of two-dimensional projections of the loss function, allowing us to better visualize the space between local minima. we do this via barycentric and bilinar interpolation for triplets and quartets of points respectively (details in section a.1).
we refer to the critical points found using these variants of sgd, for which the gradient is approximately 0, as local minima. our evidence that these are local minima as opposed to saddle points is
similar to that presented in goodfellow  (goodfellow , 2015). if we interpolate beyond the critical point, in this one-dimensional projection, the loss increases (fig. 10).we used the vgg and nin implementations from https://github.com/szagoruyko/cifar.torch.git.
the batch size was set to 128 and the number of epochs was set to 200. the learning rate was chosen from the discrete range between [0.2, 0.1, 0.05, 0.01] for sgd and [0.002, 0.001, 0.0005, 0.0001] for adaptive learning methods. we doubled the learning rates when we ran our augmented versions with runge-kutta because they required two stochastic gradient computations per epoch. we used batchnormalization and dropout to regularize our networks. all experiments were run on a 6-core intel(r) xeon(r) cpu @ 2.40ghz with a titan x.we trained the neural networks described above using each optimization method starting from the same initial weights and with the same minibatching. we computed the value of the loss function for weight vectors interpolated between the initial weights, the final weights for one algorithm, and the final weights for a second algorithm for several pairings of algorithms. the results are shown in the lower triangle of table 1.
for every pair of optimization algorithms, we observe that the training loss between the final weights for different algorithms shows a sharp increase along the interpolated path. this suggests that each optimization algorithm found a different critical point, despite starting at the same initialization. we investigated the space between other triplets and quadruples of weight vectors (figure 2 and 3), and even in these projections of the loss function, we still see that the local minima returned by different algorithms are separated by high loss weight parameters.
deep networks are overparameterized. for example, if we switch all corresponding weights for a pair of nodes in our network, we will obtain effectively the same network, with both the original and permuted networks outputting the same prediction for a given input. to ensure that the weight vectors returned by the different algorithms were functionally different, we compared the outpts of the networks on each example in a validation data set:
dist(θ1, θ2) = √√√√ 1 ntest ntest∑ i=1 ‖f (xi, θ1)− f (xi, θ2)‖2,
where θ1 and θ2 are the weights learned by two different optimization algorithms, xi is the input for a validation example, and f (x, θ) is the output of the network for weights θ on input x.
we found that, for all pairs of algorithms, the average distance between the outputs of the networks (equation 4.1) was approximately 0.16, corresponding to a label disagreement of about 8% (upper triangle of table 1). given the generalization error of these networks (approximately 11%, figure 4), the maximum disagreement we could see was 22%. thus, these networks disagreed on a large fraction of these test examples – over 13 rd. thus, the local minima found by different algorithms correspond to effectively different networks, not trivial reparameterizations of the same one.next, we investigated whether the local minima found by the different optimization algorithms had distinguishing properties. to do this, we trained the networks with each optimization algorithm using different initial parameters. we then compared differences between runs of the same algorithm but different initializations to differences between different algorithms.
as shown in figure 4(a), in terms of training accuracy, we do see some stereotypy for the optima found by different algorithms, with sgd finding local minima with the lowest training accuracy and adam, rmsprop, and adadelta finding local minima with the highest training accuracy. however, this could be attributed to sgd’s asymtotically slow convergence near local minima due to the gradient diminishing near extrema. despite this limitation, figure 4(b) shows that the generalization accuracy of these different local minima on validation data was not significantly different between algorithms. we also did not see a relationship between the weight initialization and the validation accuracy. thus, while these algorithms fall into different local minima, they are not different in terms of their final quality.
we visualized the loss surface around each of the local minima for the multiple runs. to do this, we plotted the value of the loss function between the initial and final weights for each algorithm (figure 5(a,c)) for each run of the algorithm from a different initialization. in addition, we plotted
the value of the loss function between the final weights for selected pairs of algorithms for each run (figure 5(b,d)). we see that the surfaces look strikingly similar for different runs of the same algorithm, but characteristically different for different algorithms. thus, we found evidence that the different algorithms land in qualitatively different types of local minima.
in particular, we see in figure 5(a,c) that the size of the basins around the local minima found by adam and adam&rk2 are larger than those found by sgd and rk2, i.e. that the training loss is small for a wider range of α values. this is a relative measure, and the magnitude of the change in the weight vector is ∆α‖θ1 − θ0‖ for a change of size ∆α, where θ0 is the initial weight vector θ1 is the result found by a given optimization algorithm. in figure 6, we repeat this analysis, instead showing the loss as a function of the absolute distance in parameter space:
θ(λ) = θ1 + λ θ0 − θ1 ‖θ0 − θ1‖
(1)
we again see that the size of the basin around the local minima varies by optimization algorithm. note that we evaluate the loss for weight vectors beyond the initial configuration, which had a loss of 2.4.recall that, during optimization, it has been observed that there is a short “transient” phase when the loss decreases rapidly and a “minimization” phase in which the loss decreases slowly (section 2.2.1 and figure 1). in this set of experiments, we investigated the effects of switching from one type of optimization method to another at various points during training, in particular at late stages of training when it is thought that a local minimum has been chosen and is only being localized. we switched from one optimization method to another 25%, 50%, and 75% of the way through training. the results are plotted in figure 7d. we emphasize that we are not switching methods to improve performance, but rather to investigate the shape of the loss function in regions explored during the “minimization” phase of optimization.
we found that, regardless of how late we switch optimization algorithms, as shown in the rightmost column of figure 7, the local minima found were all different. this directly disagrees with the notion that the local minimum has effectively been chosen before the “minimization” phase, but instead that which local minimum is found is still in flux this late in optimization. it appears that this switch from one local minimum to another happens almost immediately after the optimization method switches, with the training accuracy jumping to the characteristic accuracy for the given method within a few epochs (figure 7, left column). interestingly, we also see the distance between the initial and current weight vectors changes drastically after switching from one optimization
method to another, and that this distance is characteristic per algorithm (figure 7, middle column). while distance increases with training epoch for any single optimization method, it actually starts to decrease when switching from adam to sgd.to understand how batch normalization affects the types of local minima found, we performed a set of experiments comparing loss surfaces near local minima found with and without batch normalization for each of the optimization methods. we visualized the surface near these local minima by interpolating between the initial weights and the final weights as well as between pairs of final weights found with different algorithms.
we observed clear qualitative differences between optimization with (figure 5) and without (figure 8) batch normalization. we see that, without batch normalization, the quality of local minimum found by a given algorithm is much more dependent on the initialization. in addition, the surfaces between different local minima are more complex in appearance: with batch normalization we see sharp unimodal jumps in performance but without batch normalization we obtain wide bumpy shapes that aren’t necessarily unimodal.
the neural networks are typically initialized with very small parameter values (glorot & bengio, 2010; he , 2015). instead, we trained nin with exotic intializations such as initial parameters drawn from n (−10.0, 0.01) or n (−1.0, 1.0) and observe the loss surface behaviours. the details of results are discussed in appendix a.5.in this work, we performed a series of empirical analyses to understand the geometry of the loss functions corresponding to deep neural networks, and how different optimization methods minimize this loss to answer the two questions posed in the introduction.
what types of changes to the optimization procedure result in different local minima?
we found that every type of change to the optimization procedure we tested resulted in a different local minimum. different local minima were found using the different optimization algorithms from the same initialization (section 4.1). even switching the optimization algorithm to another very late in optimization – during the slow “mimimization” portion of learning – resulted in a different local minimum (section 4.3). the quality of the local minima found, in terms of training and generalization error, is similar. these different local minima were not equivalent, and made mistakes on different test examples (section 4.1). thus, they were not trivially different local minima, as would occur if nodes in internal layers of the network were permuted. we observed that the quality of these local minima was only consistently good when we used batch normalization for regularization. without batch normalization, the quality of the critical points found depended on the initialization, and some solutions found were not as good as others. our observations are in contrast to the conclusions of goodfellow , i.e. that local minima are not a problem in deep learning because, in the region of the loss function explored by sgd algorithms, the loss function is well-behaved (goodfellow , 2015). instead, our observations are more consistent with the explanation that the local minima found by popular sgd optimization methods are almost all good (choromanska , 2015; kawaguchi, 2016; soudry & carmon, 2016).interestingly, we found that, while the local minima found by the same optimization algorithm from different initializations were different, the shape of the loss function around these local minima was strikingly similar, and was a characteristic of the optimization algorithm. in particular, we found that the size of the basin around adam-based optimization was larger than that around vanilla sgd (section 4.2). a large basin is related to a large margin, as small changes in the weight vector will not affect the training error, and perhaps could have some implications for generalization error. in our experiments, however, we did not observe better generalization error for adam than sgd. questions for potential future research are why the shapes of the loss functions around different local minima found by the same algorithm are so similar, and what the practical implications of this are.a.1 3d visualization
goodfellow  (2015) introduced the idea of visualizing 1d subspace of the loss surface between the parameters. here, we propose to visualize loss surface in 3d space through interpolating over three and four vertices.
linear interpolation given two parameters θ1 and θ2, θi = αθ1 + (1− α)θ2, ∀α ∈ [0, 1]. (2)
bilinear interpolation given four parameters θ0, θ1, θ2, and θ3, φi = αθ1 + (1− α)θ2 (3) ϕi = αθ3 + (1− α)θ4 (4) θj = βφi + (1− β)ϕi (5)
for all α ∈ [0, 1] and β ∈ [0, 1].
barycentric interpolation given four parameters θ0, θ1, and θ2, let d1 = θ1 − θ0 and d2 = θ2 − θ0. then, the formulation of the interpolation is
φi = αd1 + θ0 (6) ϕi = αd2 + θ0 (7) θj = βφi + (1− β)ϕi (8)
for all α ∈ [0, 1] and β ∈ [0, 1].in many deep learning applications both the number of parameters and quantity of input data points can be quite large. this makes the full evaluation of u(θ) be prohibitively expensive. a standard technique for aleviating computational loadis to apply an stochastic approximation to the gradient robbins & monro (1951). more precisely, one approximates u by a subset of n data points, denoted by {σj}nj=1 at each timestep:
un(θ) = 1
n n∑ j=1 `(θ,xσj ) ' 1 n n∑ i=1 `(θ,xi) = u(θ) (9)
of course this approximation also carries over to the gradient, which is of vital importance to optimization techniques:
∇un(θ) = 1 n n∑ j=1 ∇`(θ,xσj ) ' ∇u(θ) (10)
this method is what is commonly called stochastic gradient descent or sgd. so long as the data is distributed nicely the approximation error of un should be sufficiently small such that not only will sgd still behave like normal gd , but it’s wall clock time for to converge should be significantly lower as well.
usually one uses the stochastic gradient rather than the true gradient, but the inherent noisiness must be kept in mind. in what follows we will always mean the stochastic gradient.in order to aleviate both noise in the input data as well as noise from stochasticity used in computing quantities one often maintains history of previous evaluations. in order to only require one extra variable one usually stores variables of the form
e[f ]t = αft + βe[f ]t−1. (11)
where ft is some value changing over time and e[f ]t is the averaged quantity.
an easy scheme to apply this method to is to compute a rolling weighted average of gradients such as e[g]t = (1− α)gt + αe[g]t−1 but there will be other uses in the future.with the aforementioned tools there are a variety of methods that can be constructed. we choose to view these algorithms as implementations of explicit euler on a variety of different vector fields to remove the ambiguity between η and gt. we therefore can define a method by the vector field xt that explicit euler is applied to with a single η that is never changed.
sgd with momentum (sgdm) by simply applying momentum to gt one obtains this stabilized stochastic version of gradient descent:
xt = −e[g]t. (12) this is the most fundamental method that is used in practice and the basis for everything that follows.
adagrad adagrad rescalesxt by summing up the sqaures of all previous gradients in a coefficientwise fashion:
xt = − gt√∑t
i=1 g 2 i +
. (13)
here is simply set to some small positive value to prevent division-by-zero. in the future we will neglect this term in denominators because it is always necessary.
the concept is to accentuate variations in gt, but because the denominator is monotonically nondecreasing over time this method is doomed to retard its own progress over time. the denominator can also be seen as a form of momentum where α and β are both set to 1.
rmsprop a simple generalization of adagrad is to simply allow for α and β to be changed from 1. in particular one usually chooses a β less than 1, and presumably α = 1− β. thus one arrives at a method where the effects of the distance history are diminished:
xt =− gt√ e[g2]t . (14)
adadelta adadelta adds another term to rmsprop in order to guarantee that the magnitude of x is balanced with gt zeiler  (2011). more precisely it maintains
xt√ e[x 2t ] = − gt√ e[g2t ]
(15)
which results in the following vector field: xt =− √ e[x 2t ]√ e[g2t ] gt. (16)
and η is set to 1.
adam by applying momentum to both gt and g2t one arrives at what is called adam. this is often considered a combination of sgdm + rmsprop,
xt = ct e[g]t√ e[g2]t . (17)
ct =
√ 1−βt2 −βt1 is the initialization bias correction term with β1, β2 ∈ [0, 1) being the β parameters
used in momentum for g and g2 respectively. initialization bias is caused by the history of the momentum variable being initially set to zero.runge-kutta methods butcher (1963) are a broad class of numerical integrators categorized by their truncation error. because the ordinary differential equations runge-kutta methods solve generalize gradient descent, our augmentation is quite straightforward. although our method applies to all explicit runge-kutta methods we will only describe second order methods for simplicity.
the general form of second-order explicit runge-kutta on a time-independent vector field is
θt+1 = θt + (a1k1 + a2k2)h (18) k1 = x (θt) (19) k2 = x (θt + q1hk1) (20)
where a1, a2, and q1 are parameters that define a given runge-kutta method. table 3 refers to the parameters used for the different runge-kutta variants we use in our experiments.for a given timestep, explicit integrators can be seen as a morphism over vector fields x → x̄ h. for a gradient gt = ∇θu we can solve a modified rk2 gradient ḡt in the following fashion:
θt+1 = θt + ḡth = advect rk2 g (θ, h) (21)
rearranged with respect to ḡt
ḡt = advectrk2g (θ, h)− θt
h (22)
= θt + (a1k1 + a2k2)h− θt
h (23)
= (a1k1 + a2k2). (24) if we simply substitute the gradient gt with ḡt one obtains an rk2-augmented optimization technique.the results in figure 9 illustrates that, with the exception of the midpoint method, stochastic rungekutta methods outperform sgd. “sgd x2” is the stochastic gradient descent with twice of the learning rate of “sgd”. from the figure, we observe that the runge-kutta methods perform even better with half the number of gradient computed by sgd. the reason is because sgd has the accumulated truncated error of o(h) while second-order runge-kutta methods have the accumulated truncated error of o(h2).
unfortunately, adam outperforms adam+rk2 methods. we speculate that this is because the way how adam’s renormalization of input gradients in conjunction with momentum eliminates the value added by using our rk-based descent directions.the neural networks are typically initialized with very small parameter values (glorot & bengio, 2010; he , 2015). instead, we trained nin with exotic intializations such as initial parameters drawn from n (−10.0, 0.01) or n (−1.0, 1.0) and observe the loss surface behaviours. the results are shown in figure 11. we can see that nin without bn does not train at all with any of these initializations. swirszcz  (2016) mentioned that bad performance of neural networks trained with these initializations are due to finding a bad local minima. however, we see that loss surface region around these initializations are plateau 1 rather than a bad local minima as shown in figure 11b. on we used same initializations as (swirszcz , 2016) but we trained different neural networks with sgd on a different dataset. we used nin and cifar10 and swirszcz  (2016) used smaller neural network and mnist.
the other hand, nin with bn does train slowly over time but finds a local minima. this implies that bn redeems the ill-posed loss surface (plateau region). nevertheless, the local minima it found was not good as when the parameters were initialized with small values. however, it is not totally clear whether this is due to difficulty of training or due to falling in a bad local minima.",0
566.pdf.json,"a daunting challenge in many contexts is to gather annotated data. this can be a long and tedious process, which often slows down the development of a framework and may jeopardize its economic prospects.
we refer to active learning cohn (1994) as the field of machine learning which targets building iteratively the annotated training set with the help of an oracle.
in this setting and in a context of pool-based active learning1, a model is trained on a small amount of data (i.e. the initial training set) and a scoring function discriminates samples which should be labeled by the oracle from the ones which do not hold new information for the model. the queried samples are then submitted to an oracle (which can be another decision algorithm for instance in co-training context, or a human expert in interactive learning context) to be labeled. they are then added to the current training set. finally the model is retrained from scratch. this process is repeated recursively to grow the training set.
although active learning and deep learning represent two important pillars of machine learning, they have mainly coexisted into independent stream of works owing to the complexity of combining them. the main issues are the scalability and the adaptability of common active learning schemes when considering architectures with a huge number of parameters such as deep networks. another issue lies in the overall number of training iterations since training a deep architecture remains a computationally expensive process despite all the optimizations through gpu processing. this specificity has prevented deep learning from being prevalent within active learning. indeed seminal active learning frameworks cohn (1994) have mainly focused on adding one sample at-a-time. when it comes to selecting a batch of queries, the most intuitive solution is to select top scoring samples. other settings exist but are not considered here for the sake of clarity, we refer the reader to settles (2012)
such a solution is immediate in the process but fails to model the correlations between samples. labeling one sample at-a-time may therefore lead to the labeling of another sample totally useless.
in our work, batches of actively selected samples are added at each training iteration. we propose a batch active learning framework designed for deep architectures, especially deep convolutional neural networks (cnn).
batch active learning is highly suitable for deep networks which are trained on minibatches of data at each iterations. indeed training with minibatches help the training of deep networks, and we empirically noticed that the size of the minibatch is a major hyperparameter. thus it makes sense to query a batch of unlabelled data whose size would be proportionnal to the size of a minibatch. in our work, batches have the same size as the minibatches but they could be decorrelated by considering importance sampling techniques.
our model focuses on log loss which is involved in the training process of most neural networks. to achieve the required scalability of active learning for deep architectures, we step away from traditional active learning methods and focus our attention on a more general setting: maximum likelihood estimation (mle) and bayesian inference. provided certain assumptions, our active selection relies on a criterion which is based on fisher information and is obtained from the minimization of a stochastic method for variational inference. our active selection relies on the fisher matrices on the unlabeled data and on the data selected by the active learning step. an approximation of fisher information, based on a diagonal kronecker-block decomposition makes our criterion computationally affordable for an active greedy selection scheme.
variational methods have been previously explored like in graves (2011) as a tractable approximation to bayesian inference for artificial neural networks (anns). one advantage of such a representation is that it leads to a two-term active learning criterion: one related to the prediction accuracy on the observed data and the second term expressing the model complexity. such a two-fold criterion is, to the best of our knowledge, the first of the kind scalable for active learning. such an expression may help both to analyze and to optimize anns, not only in an active learning framework but also for curriculum learning.
we dedicate section related works to the presentation of active learning literature. section covering presents the theoretical aspects of our active learning framework, while section active learning as a greedy selection scheme details our greedy algorithm. we then assess our active learning method through experiments on mnist and usps benchmarks. we discuss possible improvements of our approach and connections with previous mle-based active learning methods before concluding.active learning is a framework to automatize the selection of instances to be labeled in a learning process. active learning offers a variety of strategies where the learner actively selects which samples seem “optimal” to annotate, so as to reduce the size of the labeled training set required to achieve equivalent performance.
we consider the context of pool-based active learning where the learner selects its queries among a given unlabeled data set. for other variants (query synthesis, (stream-based) selective sampling) we refer the reader to settles (2012).when it comes to pool-based active learning, the most intuitive approaches focus on minimizing some error on the target classifier. uncertainty sampling minimizes the training error by querying unlabeled data on which the current classifier (i.e. from previous training iteration) is assigning labels with the weakest confidence. this method, uncertainty sampling, while being the least computational consuming among all active learning techniques has the main drawback of ignoring much of the output distribution classes, and is prone to querying outliers. thanks to its low cost and easy setup, uncertainty has been adapted to deep architectures for sentiment classification zhou  (2010). however, deep architectures are subject to adversarial examples, a type of noise we suspect uncertainty selection to be highly sensitive to szegedy  (2014); goodfellow  (2015). other strategies (expected error reduction, expected output variance reduction) directly minimize the
error on a validation set after querying a new unlabeled sample. however they are computationally expensive especially when considering neural networks.
traditional active learning techniques handle selection of one sample at-a-time. one of the main drawbacks of the aforementioned active learning techniques is that is does not pay attention to the information held in unlabeled data besides considering it as potential queries. hence once the strategy for selecting samples to be labeled and added to the training set is defined, the question on the impact of the possible correlation between successive selected samples remains.
to that end, one recent class of methods deals with the selection of a batch of samples during the active process, batch mode active learning. batch mode active learning selects a set of most informative unlabeled sample instead of a unique sample. such a strategy is highly suitable when retraining the model is not immediate and require to restart the training from scratch at each iteration as it is the case for neural networks. a simple strategy (whose has also been used for previous deep active learning strategy zhou  (2010)) is to select a batch of top scoring instances. however that strategy fails to consider the correlation among pairs of samples. the redundancy between the so-selected samples may therefore hinder the learning process.
in the context of a deep learning scenario, if several elements related to the same direction of the gradient are in the same minibatch, the gradient descent in the next learning step may lead at once too close to a local minimum, diverting the process away from the global minimum.
while one sample at-a-time can prevent from being misled that way, it gets prohibitive when considering big data because the number of iterations is equal to the number of learning samples, unlike the batch-based strategies.
recently some solutions have been proposed for choosing an appropriate subset of samples so as to minimize any significant loss in performance. those methods consider the minimization of the kullback-leibler (kl) divergence between the resampled distribution of any possible subset selected for the active process and the whole unlabeled data set distribution. a lower bound of the negative of this kl divergence is then defined and rewritten as a submodular function. the minimization of the initial kl divergence becomes then a problem of submodular maximization hoi  (2006). in wei  (2015), wei have designed several submodular functions so as to answer at best the need of specific classifiers (naive bayes classifiers, logistic regression classifier, nearest neighbor classifier). however, their approach is hardly scalable to handle all the information from non-shallow classifiers such as deep networks.
another solution to minimize the correlation among a set of queries is to perform bayesian inference on the weights of a neural network. in a bayesian context, a neural network is considered as a parametric model which assigns a conditional probability on the observed labeled data a given a set of weights w. the weights follow some prior distribution p (α) depending on the parameter α and the posterior distribution of the weights p (w | a, α) is deduced. the goal is thus to maximize the posterior probability of the weights on the observed data a. indeed bayesian inference expresses the uncertainty of the weights which consequently leads to a relevant exploration of the underlying distribution of the input data x. when it comes to active learning, the learner needs not only to estimate the posterior given the observed data a but also to consider the impact of new data on that posterior golovin  (2010). in our context, bayesian inference is intractable, partially due to the high number of weights involved in a deep network. to solve this issue, graves (2011) introduced a variational approximation to perform bayesian inference on neural networks. specifically he approximates the posterior distribution p (w | a, α) with a tractable distribution of his choice q(w | β) depending on a new parameter β. the quality of the approximation q(w | β) compared to the true posterior p (w | a, α) is measured by the variational free energy f with respect to the parameters α and β. f has no upper bound but gets closer to zero as both distributions become more and more similar.
f(α, β) = −ew∼q(β)
( ln ( p (a | w)p (w | α)
q(w | β)
)) (1)
finally in graves (2011), f is then expressed as a minimum description loss function on α and β: f(α, β) = ew∼q(β)(l(a;w)) +kl(q(w) || p(α)) (2)
where kl is the kullback leibler divergence between q(β) and p(α).
under certain assumptions on the family distribution for the posterior and prior of the weights ( diagonal gaussian ...), graves proposed a backpropagation compatible algorithm to train an ensemble of networks, whose weights are sampled from a shared probability distribution.
the primary purpose of the variational free energy is to propose a new training objectif for neural network by learning α and β. in an active learning context, the main drawback of variational free energy based method is that it requires to update by backpropagation the parameters for each unlabeled data submitted as a query. however we know from statistical assumption on the maximum likelihood the posterior and prior distribution of trained weights given the current labeled training set: if and only if we consider trained networks, we know how to build α and β in a unique iteration without backpropagation. this knowledge helps us to extend graves first objectives to the use of variational free energy to measure how new observations affect the posterior.as done for the majority of neural networks, we measure the error of the weights w by the negative log likelihood on an observed set of annotated data a:
l(a;w) = − ∑
(x,y)∈a
ln(p (y | x,w)) (3)
we consider the maximum likelihood estimator (mle) w as the value which makes the data observed a as likely as possible for a fixed architecture. note than even for a fixed a in the case of neural network,w may not be unique.
w = argminwl(a;w) (4)
when assuming that an arbitrary parameterw∗ is governing the data generation process, we know that the expected negative log likelihood is lower bounded by the expected negative log likelihood of the true parameterw∗ governing the data generation process. what it means is that no distribution describes the data as well as the true distribution that generated it. it turns out that, under certain assumptions, we can prove using the central limit theorem that the mle is asymptotically normal with a mean equal to the true parameter value and variance equal to the inverse of the expected fisher information evaluated at the true parameter.
if we denote by x the underlying data distribution,wx the mle andw∗x the true parameter, we know thatwx is a sample from a multivariate gaussian distribution parametrized byw∗x . note that in this context we assume the fisher matrices are invertible.
wx ∼ n (w∗x , i−1x (w ∗ x)) (5)
however the expected fisher information on the underlying distribution is intractable. eventually, using the law of large numbers, we know that the observed fisher information converges to the expected fisher information as the sample size increases. another theoretical limitation is that the true parameter is unknown but we can approximate its observed fisher information with the observed fisher information at the mle because of the consistency of the mle. for a sake of simplicity we keep the same notation for observed and expected fisher matrix.
let denote by y the random variable after resampling the underlying distribution x using an active learning strategy. w∗x,w∗y are the true parameters with respect to their respective data distributions and their respective mle variableswx,wy, then the following relations hold:
wx ∼ n (w∗x, i−1x (w ∗ x)) wy ∼ n (w∗y, i−1y (w ∗ y))
(6)
we thus notice than in an active learning context, the learner is trained on data uniformly sampled from y, while the optimal solution would be when training on data uniformly sampled from x.
the asymptotic behaviour provides us with a prior distribution of the weights based on the data distribution x. in our context of active learning, we approximate the posterior distribution with the mle distribution induced by the resampling y. hence we define a prior and posterior distribution which did not require to be learnt by backpropagation directly but depend on the two data distribution x and y.
p (α) ≡ p (αx) = n (w∗x, i−1x (w ∗ x)) q(β) ≡ q(βy) = n (w∗y, i−1y (w ∗ y))
(7)
our active learning scheme relies on the selection of input data whose induced mle distribution q(βy) is minimizing the variational free energy.
y = argminy f(αx, βy) (8)
it consists in the minimization of the sum of two terms which we denote respectively by the training factor ew∼q(β)(l(a;w)) and the generalization factor kl(q(β) || p(α)). it is possible to analyze both terms independently and explain their role into the minimization:
• training factor: ideally, the cramer rao bound implies that the minimum on the training factor is reached whenq(β) matches the asymptotically most efficient estimator of the optimal parameter on the error loss on the observed data. hence the training factor corresponds to the minimization of the error on the observed data a.
• generalization factor: empirical results choromanska  (2015) tend to show that the variance of the accuracy diminishes as the depth of the classifier increases. so our ultimate goal would be to converge to any set of parameters of the mle distribution as their effectiveness is similar. the goal of the generalization factor is to converge to the asymptotic distribution on the whole input distribution x and to minimize the error of prediction of new input data.
if the expression of the variational free energy provides us a theoretical context to work on, the usage of fisher matrices of deep networks renders it computationally unaffordable. indeed the fisher matrix is a quadratic matrix in terms of the number of parameters of the deep networks. because of the huge number of parameters involved, such matrices takes a lot of memory and processing them costs a lot of ressources, especially if the operations may be repeated often in the framework (as it would be the case for every possible query processed by an active learning scheme.)
the next section 3.2 explains the different approximation proposed to deduce a more friendly user criterion.of a cnn
recently an approximation of the fisher information for deep architectures has been proposed first for fully connected layer in martens & grosse (2015), and then for convolutional layer as well in grosse & martens (2016). the block kronecker decomposition content (ψ, τ ) is explained in martens & grosse (2015); grosse & martens (2016)
based on their decomposition definition, we define the evaluation of blocks of the fisher information at a certain point xi(ψxi,l, τxi,l) and an empirical estimation of the fisher matrix on a set of data a. a sum up of their decomposition is presented in eq. (9) while the exact content of the kronecker
blocks ψ and τ is left as undescribed in this paper for the sake of concision.
ia(w) = diag([ψa,l(w)⊗ τa,l(w)]ll=1)
ψa,l(w) = 1 | a | ∑ xi∈a ψxi,l(w)
τa,l(w) = 1 | a | ∑ xi∈a τxi,l(w)
(9)
the strength of this decomposition lies in the properties of block diagonal combined with those of the kronecker product. ψ and τ are respectively related to the covariance matrix of the activation and the covariance of the derivative given the input of a layer. recent deep architectures tend to prevail the depth over the width (i.e. the number of input and output neurons) so this expression becomes really suitable and tractable.despite the block kronecker product approximation of the fisher matrix, sampling on q(β) requires to compute the inverse. because the kronecker blocks may still have an important number of parameters involved (especially the first fully connected layer suceeding to a convolutional layer), the inverse of the blocks may be still too computationally expensive. to approximate the training factor, we opt for a second order approximation of the log likelihood for parametersw close to the mean parameterw∗y of q(β).
l(a;w) ≈ l(a;w∗y) + ∂l(a;w∗y)
∂w + (w −w∗y)t ∂2l(a;w∗y) ∂w ′∂w (w −w∗y) (10)
our first approximation consists in assuming that the mle parameter ŵ of the currently trained network is a good approximator ofw∗y. because the network has converged on the current set of observed data a the first derivative of the log likelihood is also set to zero. hence eq. (10) thus becomes:
l(a;w) ≈ l(a; ŵ) + (w − ŵ)t i−1a (ŵ)(w − ŵ) (11)
to compute the expectation over the range of weights sampled fromq(β) we need to upperbound the expectation of the dot product ofw given the fisher matrix. because we assume our fisher matrices invertible, and because a covariance matrix is at least semi-definite, our fisher matrices are positive definite matrix. hence every eigenvalue is positive and the trace of the fisher matrix is greater than its maximum eigenvalue. from basic properties of the variance covariance matrix, if we denote by n the number of parameters in the network we obtain the following upperbound for the training factor:
ew∼q(β)(l(a;w)) ≤ l(a; ŵ) + n√ π tr(i−1y (ŵ) t i−1a (ŵ)i −1 y (ŵ)) (12)
when it comes to the trace of the inverse, we approximate it by the closest lower bound with the inverse of the trace like in wei  (2015).
ew∼q(β)(l(a;w)) ∝∼ l(a; ŵ) + n√ π
n2
tr(iy(ŵ)ia(ŵ)iy(ŵ)t ) (13)our generalization factor corresponds to the kl divergence between the approximation of our posterior q(β) and the prior p(α). because both distributions are multivariate gaussians, we have a direct formulation of the kl which is always definite since the fisher matrices are invertible:
kl(q(β) || p(α)) = 1 2
( ln ( det(i−1x (w∗x)) det(i−1y (w∗y)) ) −n+tr(ix(w∗x)i−1y (w ∗ y))+(w∗x−w∗y)t ix(w∗x)(w∗x−w∗y) ) (14)
our first approximation consists in assuming that the mle parameter ŵ of the currently trained network is a good approximator of both optimal parametersw∗x,w∗y like in zhang & oles (2000). we also upper bound the determinant with a function of the trace and the number n of parameters. when it comes to the trace of the inverse, we approximate it again by the closest lower bound with the inverse of the trace.
kl(q(β) || p(α)) ∝∼ n
( ln ( tr(iy(ŵ)i−1x (ŵ)) ) +
n
tr(iy(ŵ)i−1x (ŵ))
) (15)in the previous subsections, we proposed independent approximations of both our sub-criteria: the training factor and the generalization factor. however the scale of our approximations may not be balanced so we sum up our criterion with an hyperparameter factor γ which counterparts the difference of scale between the factors:
f ∝∼ γ ( n√ π
n2
tr(iy(ŵ)ia(ŵ)iy(ŵ)t )
) +n ( ln ( tr ( iy(ŵ)i−1x (ŵ) )) +
n
tr(iy(ŵ)i−1x (ŵ)) ) (16)
we approximate the expected fisher matrices on the underlying distribution y and x by the observed fisher matrices on a set of data sampled from those distributions. this approximation is relevant due to the consistenty of the mle.
as we are in a pool-based selection case, we dispose at first of two sets of data: a and u which denote respectively the annotated observed data and unlabeled data. note that the derivatives in the fisher matrix computation implies to know the label of the samples. thus at each active learning step, an unknown label is approximated by its prediction from the current trained network. we denote by s the subset of data to be queried by an oracle. the size of s is fixed with | s |= k. s is the subset sampled from y while u is sampled from x. finally an approximation of f will be:
f ∝∼ γ ( n√ π
n2
tr(is(ŵ)ia(ŵ)is(ŵ)t )
) +n ( ln ( tr ( is(ŵ)i−1u (ŵ) )) +
n
tr(is(ŵ)i−1u (ŵ)) ) (17)
now we express the trace based on the approximation of the fisher matrix: we consider that every fisher matrix for cnn is a l diagonal block matrix, with l the number of layers of the cnn. every block is made of a kronecker product of two terms ψ and τ . we rely on the properties involved by the choice of this specific matrix topology to obtain a more computationally compliant approximation of f in eq. (18):
f ∝∼γ ( n√ π n2∑ l∈(1,l) tr(ψs,l(ŵ)ψ −1 a,l(ŵ)ψs,l(ŵ) t )tr(τs,l(ŵ)τ −1 a,l(ŵ)τs,l(ŵ) t ) )
+n ( ln ( ∑ l∈(1,l) tr ( ψs,l(ŵ)ψ −1 u,l(ŵ) ) tr(τs,l(ŵ)τ −1 u,l (ŵ)) )
+ n∑
l∈(1,l) tr(ψs,l(ŵ)ψ −1 u,l(ŵ))tr(τs,l(ŵ)τ −1 u,l (ŵ))
) (18)the selected subset s selected at one step of active learning is only involved through the kronecker product of the fisher matrix is(ŵ). we express our approximation of the free energy by a criterion
on the subset s in eq. (19): c(s;a,u) =γ ( n√ π n2∑ l∈(1,l) tr(ψs,l(ŵ)ψa,l(ŵ)ψs,l(ŵ) t )tr(τs,l(ŵ)τa,l(ŵ)τs,l(ŵ)t ) )
+n ( ln ( ∑ l∈(1,l) tr(ψs,l(ŵ)ψ −1 u,l(ŵ))tr(τs,l(ŵ)τ −1 u,l (ŵ)) )
+ n∑
l∈(1,l) tr(ψs,l(ŵ)ψ −1 u,l(ŵ))tr(τs,l(ŵ)τ −1 u,l (ŵ)) ) (19)
finally we estimate our subset s by a greedy procedure: to be more robust to outliers and for reasons of computational efficiency, we select first a pool of samples d ⊂ u which we will use as the set of possible queries. we recursively build s ⊂ d by picking the next sample xi ∈ d which minimizes c(s ∪ {xi};a,u) among all remaining samples in d. when it comes to the training factor coefficient, we notice that it is a quadratic term in is(ŵ) which increases the complexity in a greedy selection scheme. our choice is to estimate the trace in the following way:
tr(ψs∪{x},l(ŵ)ψa,l(ŵ)ψs∪{x},l(ŵ) t ) ≈ tr(ψs,l(ŵ)ψa,l(ŵ)ψs,l(ŵ)t )+tr(ψ{x},l(ŵ)ψa,l(ŵ)ψ{x},l(ŵ)t )
pseudo-code and illustration of the algorithm are provided in table 1 in appendix.we demonstrate the validity of our approach on two datasets: mnist (28-by-28 pictures, 50.000 training samples, 10.0000 validation samples and 10.000 test samples) and usps (16-by-16 pictures, 4185 training samples, 464 validation samples and 4649 testing samples) both gray scaled digits image datasets. we describe the cnn configuration and the hyperparameters settings in table 2 in appendix. note that we do not optimize the hyperparameters specifically for the size of the current annotated training set a. we picked those two similar datasets to judge of the robustness of our method against different size of unlabeled datasets, as expected our method is efficient on both small and large databases.we run 10 runs of experiments and average the error on the test set of the best validation error before a pass of active learning. we start from an annotated training set of the size of one minibatch selected randomly. we stop both set of experiments after 30% of the training set has been selected (15.000 image for mnist, 1255 for usps). we compare the lowest test error achieved so far by our mle based method against naive baselines: uncertainty sampling, curriculum sampling and a random selection of a minibatch of examples. we measure both uncertainty and curriculum scores based on the log likelihood of a sample using as label its prediction on the full network. while uncertainty selects samples with the highest log likelihood, our version of curriculum does the exact contrary. we select randomly the set of possible queries d among the unlabeled training data. its size is set to 30 times the minibatch size. we present the results in two phases for the sake of clarity in figure 1 for mnist and figure 2 for usps: the first rounds of active learning when the annotated training set is almost empty, and the second round which is more stable in the evolution of the error. in both phases and for both databases we observe a clear difference between the test error achieved by our mle method with the test error obtained by selecting randomly the data to be queried. moreover the error achieved by our method on 30 % is close (even equivalent in the case of usps), to the error achieved using the standard full training sets defined for both datasets (this error rate is defined as yellow line groundtruth on the figures). the experiments made appear that curriculum learning is not a good active learning strategy for both tested datasets. as for the uncertainty selection, it works really well on mnist while it fails on usps. while mnist is a pretty clean database, usps contains more outliers and noisy samples rendering it more difficult in terms of accuracy even though both databases are designed to assess digit classification. as other works we mentioned in the related work section, we are led to explain uncertainty selection to select useless samples with the amount of outliers and noisy samples in usps.to validate our method in terms of scalability and time complexity, we measured in seconds, the current processor time for one pass of active learning. we repeated this evaluation for different size of query (8 to 128 unlabeled samples added to the currrent training set). for this experiments we used a laptop with a titan-x (gtx 980 m) with 8 gb ram gpu memory. metrics were reported in figure 3. our criterions takes few seconds to select a batch of query of hundreds of unlabeled data. moreover the evolution of the time given the size of the query is less than linear.
page 1 we believe our method is a proof of concept for the use of variational inference for active learning on deep neural networks. however our approximations are subject to improvements which may lead to faster convergence and lower generalization error.
the first point to raise is that our approximation of the posterior is an asymptotic distribution which may be unstable on a small subset of observed data, as it is the case for active learning. such a distribution may be regularized by taking the probability provided by the central limit theorem about how well our data fits to the asymptotic gaussian distribution. when it comes to the kfac approximation, it suffers from the same issue and could be regularized when evaluating on small subset. a refinement of the approximations, especially for the generalization factor, following the approaches of submodular functions may be investigated.
finally, an interesting observation is that our formulation of the variational free energy finds similarities with other mle based active learning criteria previously proposed in the litterature. indeed, in zhang & oles (2000) the authors study active learning by looking among the possible resampling of the input distribution. they formulate their criterion as the minimization of the trace of the inverse fisher of the resampled distribution multiplied by the fisher matrix on the input distribution: mins tr(i−1s (ŵ)iu (ŵ))in a nutshell, we proposed a scalable batch active learning framework for deep networks relying on a variational approximation to perform bayesian inference. we deduced a formulation of the posterior and prior distributions of the weights using statistical knowledge on the maximum likelihood estimator. those assumptions combined with an existing approximation of the fisher information for neural network, lead us to a backpropagation free active criterion. eventually we used our own approximations to obtain a greedy active selection scheme.
our criterion is the first of the kind to scale batch active learning to deep networks, especially convolutional neural networks. on different databases, it achieves better test accuracy than random sampling, and is scalable with increasing size of queries. it achieves near optimal error on the test set using a limited percentage (30%) of the annotated training set on larger and more reduced dataset. our works demonstrated the validity of batch mode active learning for deep networks and the promise of the kfac approximations for deep fisher matrices for the active learning community. such a solution is also interesting as a new technique for curriculum learning approach.",0
574.pdf.json,"online commerce has been a great impact on our life over the past decade. we focus on an online market for fashion related items1. finding similar fashion-product images for a given image query is a classical problem in an application to computer vision, however, still challenging due to the absence of an absolute definition of the similarity between arbitrary fashion items.
deep learning technology has given great success in computer vision tasks such as efficient feature representation (razavian , 2014; babenko , 2014), classification (he , 2016a; szegedy , 2016b), detection (ren , 2015; zhang , 2016), and segmentation (long , 2015). furthermore, image to caption generation (vinyals , 2015; xu , 2015) and visual question answering (vqa) (antol , 2015) are emerging research fields combining vision, language (mikolov , 2010), sequence to sequence (sutskever , 2014), long-term memory (xiong , 2016) based modelling technologies.
these computer vision researches mainly concern about general object recognition. however, in our fashion-product search domain, we need to build a very specialised model which can mimic human's perception of fashion-product similarity. to this end, we start by brainstorming about what makes two fashion items are similar or dissimilar. fashion-specialist and merchandisers are also involved. we then compose fashion-attribute dataset for our fashion-product images. table 1 explains a part of our fashion-attributes. conventionally, each of the columns in table 1 can be modelled as a multi-class classification. therefore, our fashion-attributes naturally is modelled as a multi-label classification.
∗this work was done by the author at sk planet. 1in our e-commerce platform, 11st (http://english.11st.co.kr/html/en/main.html), almost a half of user-queries are related to the fashion styles, and clothes.
multi-label classification has a long history in the machine learning field. to address this problem, a straightforward idea is to split such multi-labels into a set of multi-class classification problems. in our fashion-attributes, there are more than 90 attributes. consequently, we need to build more than 90 classifiers for each attribute. it is worth noting that, for example, collar attribute can represent the upper-garments, but it is absent to represent bottom-garments such as skirts or pants, which means some attributes are conditioned on other attributes. this is the reason that the learning tree structure of the attributes dependency can be more efficient (zhang & zhang, 2010; fu , 2012; gibaja & ventura, 2015).
recently, recurrent neural networks (rnn) are very commonly used in automatic speech recognition (asr) (graves , 2013; graves & jaitly, 2014), language modelling (mikolov , 2010), word dependency parsing (mirowski & vlachos, 2015), machine translation (cho , 2014), and dialog modelling (henderson , 2014; serban , 2016). to preserve long-term dependency in hidden context, long-short term memory (lstm) (hochreiter & schmidhuber, 1997) and its variants (zaremba , 2014; cooijmans , 2016) are breakthroughs in such fields. we use this lstm to learn fashion-attribute dependency structure implicitly. by using the lstm, our attribute recognition problem is regarded to as a sequence classification. there is a similar work in wang  (2016), however, we do not use the vgg16 network (simonyan & zisserman, 2014) as an image encoder but use our own encoder. to the best of our knowledge, it is the first work applying lstm into a multi-label classification task in the commercial fashion-product search domain.
the remaining of this paper is organized as follows. in sec. 2, we describe details about our fashion-attribute dataset. sec. 3 describes the proposed fashion-product search system in detail. sec. 4 explains empirical results given image queries. finally, we draw our conclusion in sec. 5.we start by building large-scale fashion-attribute dataset in the last year. we employ maximum 100 man-months and take almost one year for completion. there are 19 fashion-categories and more than 90 attributes for representing a specific fashion-style. for example, top garments have the tshirts, blouse, bag etc. the t-shirts category has the collar, sleeve-length, gender, etc. the gender attribute has binary classes (i.e. female and male). sleeve-length attribute has multiple classes (i.e. long, a half, sleeveless etc.). theoretically, the combination of our attributes can represent thousands of unique fashion-styles. a part of our attributes are in table 1. rois for each fashion item in an image are also included in this dataset. finally, we collect 1 million images in total. this internal dataset is to be used for training our fashion-attribute recognition model and fashion-product roi detector respectively.in this section, we describe the details of our system. the whole pipeline is illustrated in fig. 3. as a conventional information retrieval system, our system has offline and online phase. in offline process, we take both an image and its textual meta-information as the inputs. the reason we take additional textual meta-information is that, for example, in fig. 1a dominant fashion item in the image is a white dress however, our merchandiser enrolled it to sell the brown cardigan as described
in its meta-information. in fig. 1b, there is no way of finding which fashion item is to be sold without referring the textual meta-information seller typed manually. therefore, knowing intension (i.e. what to sell) for our merchandisers is very important in practice. to catch up with these intension, we extract fashion-category information from the textual meta. the extracted fashion-category information is fed to the fashion-attribute recognition model. the fashion-attribute recognition model predicts a set of fashion-attributes for the given image. (see fig. 2) these fashion-attributes are used as keys in the inverted indexing scheme. on the next stage, our fashion-product roi detector finds where the fashion-category item is in the image. (see fig. 8) we extract colour and appearance features for the detected roi. these visual features are stored in a postings list. in these processes, it is worth noting that, as shown in fig. 8, our system can generate different results in the fashion-attribute recognition and the roi detection for the same image by guiding the fashioncategory information. in online process, there is two options for processing a user-query. we can
take a guided information, what the user wants to find, or the fashion-attribute recognition model automatically finds what fashion-category item is the most likely to be queried. this is up to the user's choice. for the given image by the user, the fashion-attribute recognition model generates fashion-attributes, and the results are fed into the fashion-product roi detector. we extract colour and appearance features in the roi resulting from the detector. we access to the inverted index addressed by the generated a set of fashion-attributes, and then get a postings list for each fashionattribute. we perform nearest-neighbor retrieval in the postings lists so that the search complexity is reduced drastically while preserving the semantic similarity. to reduce memory capacity and speed up this nearest-neighbor retrieval process once more, our features are binarized and cpu dependent intrinsic instruction (i.e. assembly popcnt instruction2) is used for computing the hamming distance.we build our own vision encoder network (resception) which is based on inception-v3 architecture (szegedy , 2016b). to improve both speed of convergence and generalization, we introduce a shortcut path (he , 2016a;b) for each data-flow stream (except streams containing one convolutional layer at most) in all inception-v3 modules. denote input of l-th layer , xl ∈ r , output of the l-th layer, xl+1, a l-th layer is a function, h : xl 7→ xl+1 and a loss function, l(θ;xl). then forward and back(ward)propagation is derived such that
xl+1 = h(xl) + xl (1) ∂xl+1
∂xl = ∂h(xl) ∂xl + 1 (2)
imposing gradients from the loss function to l-th layer to eq. (2),
∂l ∂xl := ∂l ∂xl . . . ∂xl+2 ∂xl+1 ∂xl+1 ∂xl
= ∂l ∂xl
( 1+ · · ·+ ∂h(x l−2)
∂xl + ∂h(xl−1) ∂xl ) =
∂l ∂xl
( 1+ l∑ i=l−1 ∂h(xi) ∂xl ) . (3)
as in the eq. (3), the error signal, ∂l ∂xl
, goes down to the l-th layer directly through the shortcut path, and then the gradient signals from (l − 1)-th layer to l-th layer are added consecutively (i.e.∑l i=l−1 ∂h(xi) ∂xl
). consequently, all of terms in eq. (3) are aggregated by the additive operation instead of the multiplicative operation except initial error from the loss (i.e. ∂l
∂xl ). it prevents
from vanishing or exploding gradient problem. fig. 4 depicts network architecture for shortcut http://www.gregbugaj.com/?tag=assembly (accessed at aug. 2016)
paths in an inception-v3 module. we use projection shortcuts throughout the original inception-v3 modules due to the dimension constraint.3 to demonstrate the effectiveness of the shortcut paths in the inception modules, we reproduce ilsvrc2012 classification benchmark (russakovsky , 2015) for inception-v3 and our resception network. as in fig. 5a, we verify that residual shortcut paths are beneficial for fast training and slight better generalization.4 the whole of the training curve is shown in fig. 5b. the best validation error is reached at 23.37% and 6.17% at top-1 and top-5, respectively. that is a competitive result.5 to demonstrate the representation power of our resception, we employ the transfer learning strategy for applying the pre-trained resception as an image encoder to generate captions. in this experiment, we verify our resception encoder outperforms the existing vgg16 network6 on ms-coco challenge benchmark (chen , 2015). the best validation cider-d score (vedantam , 2015) for c5 is 0.923 (see fig. 5c) and test cider-d score for c40 is 0.937.7the traditional multi-class classification associates an instance x with a single label a from previously defined a finite set of labels a. the multi-label classification task associates several finite sets of labels an ⊂ a. the most well known method in the multi-label literature are the binary relevance method (bm) and the label combination method (cm). there are drawbacks in both bm if the input and output dimension of the main-branch is not the same, projection shortcut should be used instead of identity shortcut. this is almost the same finding from szegedy  (2016a) but our work was done independently. 5http://image-net.org/challenges/lsvrc/2015/results 6https://github.com/torch/torch7/wiki/modelzoo 7we submitted our final result with beam search on ms-coco evaluation server and found out the beam
search improves final cider-d for c40 score by 0.02.
and cm. the bm ignores label correlations that exist in the training data. the cm directly takes into account label correlations, however, a disadvantage is its worst-case time complexity (read , 2009). to tackle these drawbacks, we introduce to use the rnn. suppose we have random variables a ∈ an, an ⊂ a. the objective of the rnn is to maximise the joint probability, p(at, at−1, at−2, . . . a0), where t is a sequence (time) index. this joint probability is factorized as a product of conditional probabilities recursively,
p(at, at−1, . . . a0) = p(a0)p(a1|a0)︸ ︷︷ ︸ p(a0,a1) p(a2|a1, a0)
︸ ︷︷ ︸ p(a0,a1,a2)
· · ·
︸ ︷︷ ︸ p(a0,a1,a2,... )
(4)
= p(a0) ∏t t=1 p(at|at−1, . . . , a0).
following the eq. 4, we can handle multi-label classification as sequence classification which is illustrated in fig. 6. there are many label dependencies among our fashion-attributes. direct modelling of such label dependencies in the training data using the rnn is our key idea. we use the resception as a vision encoder θi , lstm and softmax regression as our sequence classifier θseq, and negative log-likelihood (nll) as the loss function. we backpropagage gradient signal from the sequence classifier to vision encoder.8 empirical results of our resception-lstm based attribute recognition are in fig. 2. many fashion-category dependent attributes such as sweetpants, fading, zipper-lock, mini, and tailored-collar are recognized quite well. fashion-category independent attributes (e.g., male, female) are also recognizable. it is worth noting we do not model the fashionattribute dependance tree at all. we demonstrate the rnn learns attribute dependency structure implicitly. we evaluate our attribute recognition model on the fashion-attribute dataset. we split this dataset into 721544, 40000, and 40000 images for training, validating, and testing. we employ the early-stopping strategy to preventing over-fitting using the validation set. we measure precision and recall for a set of ground-truth attributes and a set of predicted attributes for each image. the quantitative results are in table 2. our attribute recognition model is parameterized as θ = [θi ; θseq]. in our case, updating θi as well as θseq in the gradient descent step helps for much better performance. .3 guided attribute-sequence generation
our prediction model of the fashion-attribute recognition is based on the sequence generation process in the rnn (graves, 2013). the attribute-sequence generation process is illustrated in fig. 7. first, we predict a probability of the first attribute for a given internal representation of the image i.e. pθseq(a0|gθi (i)), and then sample from the estimated probability of the attribute, a0 ∼ pθseq(a0|gθi (i)). the sampled symbol is fed to as the next input to compute pθseq(a1|a0, gθi (i)). this sequential process is repeated recursively until a sampled result is reached at the special endof-sequence (eos) symbol. in case that we generate a set of attributes for a guided fashion-category, we do not sample from the previously estimated probability, but select the guided fashion-category, and then we feed into it as the next input deterministically. it is the key to considering for each seller's intention. results for the guided attribute-sequence generation is shown in fig. 8. .4 guided roi detection
our fashion-product roi detection is based on the faster r-cnn (ren , 2015). in the conventional multi-class faster r-cnn detection pipeline, one takes an image and outputs a tuple of (roi coordinate, object-class, class-score). in our roi detection pipeline, we take additional information, guided fashion-category from the resception-lstm based attribute-sequence generator. our fashion-product roi detector finds where the guided fashion-category item is in a given image. jing  (2015) also uses a similar idea, but they train several detectors for each category independently so that their works do not scale well. we train a detector for all fashion-categories jointly. our detector produces rois for all of the fashion-categories at once. in post-processing, we reject rois that their object-classes are not matched to the guided fashion-category. we demonstrate that the guided fashion-category information contributes to higher performance in terms of mean average precision (map) on the fashion-attribute dataset. we measure the map for the intersection-of-union (iou) between ground-truth rois and predicted rois. (see table 3) that is due to the fact that our guided fashion-category information reduces the false positive rate. in our fashion-product search pipeline, the colour and appearance features are extracted in the detected rois.to extract appearance feature for a given roi, we use pre-trained googlenet (szegedy , 2015). in this network, both inception4 and inception5 layer's activation maps are used. we evaluate this feature on two similar image retrieval benchmarks, i.e. holidays (jegou , 2008) and uk-benchmark (ukb) (nistér & stewénius, 2006). in this experiment, we do not use any postprocessing method or fine-tuning at all. the map on holidays is 0.783, and the precision@4 and recall@4 on ukb is 0.907 and 0.908 respectively. these scores are competitive against several deep feature representation methods (razavian , 2014; babenko , 2014). examples of queries and resulting nearest-neighbors are in fig. 9. on the next step, we binarize this appearance feature by simply thresholding at 0. the reason we take this simple thresholding to generate the hash code is twofold. the neural activation feature map at a higher layer is a sparse and distributed code in nature. furthermore, the bias term in a linear layer (e.g., convolutional layer) compensates for
aligning zero-centering of the output feature space weakly. therefore, we believe that a code from a well-trained neural model, itself, can be a good feature even to be binarized. in our experiment, such simple thresholding degrades map by 0.02 on the holidays dataset, but this method makes it possible to scaling up in the retrieval. in addition to the appearance feature, we extract colour feature using the simple (bins) colour histogram in hsv space, and distance between a query and a reference image is computed by using the weighted combination of the two distances from the colour and the appearance feature.to evaluate empirical results of the proposed fashion-product search system, we select 3 million fashion-product images in our e-commerce platform at random. these images are mutually exclusive to the fashion-attribute dataset. we have again selected images from the web used for the queries. all of the reference images pass through the offline process as described in sec. 3, and resulting inverted indexing database is loaded into main-memory (ram) by our daemon system. we send the pre-selected queries to the daemon system with the restful api. the daemon system then performs the online process and returns nearest-neighbor images correspond to the queries. in this scenario, there are three options to get similar fashion-product images. option 1 is that the fashion-attribute recognition model automatically selects fashion-category, the most likely to be queried in the given image. option 2 is that a user manually selects a fashion-category given a query image. (see fig. 10) option 3 is that a user draw a rectangle to be queried by hand like jing  (2015). (see fig. 11) by the recognized fashion-attributes, the retrieved results reflect the user's main needs, e.g. gender, season, utility as well as the fashion-style, that could be lacking when using visual feature representation only.today's deep learning technology has given great impact on various research fields. such a success story is about to be applied to many industries. following this trend, we traced the start-of-the art computer vision and language modelling research and then, used these technologies to create value for our customers especially in the e-commerce platform. we expect active discussion on that how to apply many existing research works into the e-commerce industry.",0
597.pdf.json,"combinatorial optimization is a fundamental problem in computer science. a canonical example is the traveling salesman problem (tsp), where given a graph, one needs to search the space of permutations to find an optimal sequence of nodes with minimal total edge weights (tour length). the tsp and its variants have myriad applications in planning, manufacturing, genetics, etc. (see (applegate , 2011) for an overview).
finding the optimal tsp solution is np-hard, even in the two-dimensional euclidean case (papadimitriou, 1977), where the nodes are 2d points and edge weights are euclidean distances between pairs of points. in practice, tsp solvers rely on handcrafted heuristics that guide their search procedures to find competitive (and in many cases optimal) tours efficiently. even though these heuristics work well on tsp, once the problem statement changes slightly, they need to be revised. in contrast, machine learning methods have the potential to be applicable across many optimization tasks by automatically discovering their own heuristics based on the training data, thus requiring less handengineering than solvers that are optimized for one task only.
while most successful machine learning techniques fall into the family of supervised learning, where a mapping from training inputs to outputs is learned, supervised learning is not applicable to most combinatorial optimization problems because one does not have access to optimal labels. however, one can compare the quality of a set of solutions using a verifier, and provide some reward feedbacks to a learning algorithm. hence, we follow the reinforcement learning (rl) paradigm to tackle combinatorial optimization. we empirically demonstrate that, even when using optimal solutions as labeled data to optimize a supervised mapping, the generalization is rather poor compared to an rl agent that explores different tours and observes their corresponding rewards.
we propose neural combinatorial optimization, a framework to tackle combinatorial optimization problems using reinforcement learning and neural networks. we consider two approaches based on policy gradients (williams, 1992). the first approach, called rl pretraining, uses a training set to optimize a recurrent neural network (rnn) that parameterizes a stochastic policy over solutions, using the expected reward as objective. at test time, the policy is fixed, and one performs inference ∗equal contributions. members of the google brain residency program (g.co/brainresidency).
by greedy decoding or sampling. the second approach, called active search, involves no pretraining. it starts from a random policy and iteratively optimizes the rnn parameters on a single test instance, again using the expected reward objective, while keeping track of the best solution sampled during the search. we find that combining rl pretraining and active search works best in practice.
on 2d euclidean graphs with up to 100 nodes, neural combinatorial optimization significantly outperforms the supervised learning approach to the tsp (vinyals , 2015b) and obtains close to optimal results when allowed more computation time (see figure 1). we illustrate the flexibility of the method by also applying it to the knapsack problem, for which we get optimal results for instances with up to 200 items. our results, while still inferior to the state-of-the-art in many dimensions (such as speed, scale and performance), give insights into how neural networks can be used as a general tool for tackling combinatorial optimization problems, especially those that are difficult to design heuristics for.the traveling salesman problem is a well studied combinatorial optimization problem and many exact or approximate algorithms have been proposed for both euclidean and non-euclidean graphs. christofides (1976) proposes a heuristic algorithm that involves computing a minimum-spanning tree and a minimum-weight perfect matching. the algorithm has polynomial running time and returns solutions that are guaranteed to be within a factor of 1.5× to optimality in the metric instance of the tsp.
the best known exact dynamic programming algorithm for tsp has a complexity of θ(2nn2), making it infeasible to scale up to large instances, say with 40 points. nevertheless, state of the art tsp solvers, thanks to carefully handcrafted heuristics that describe how to navigate the space of feasible solutions in an efficient manner, can solve symmetric tsp instances with thousands of nodes. concorde (applegate , 2006), widely accepted as one of the best exact tsp solvers, makes use of cutting plane algorithms (dantzig , 1954; padberg & rinaldi, 1990; applegate , 2003), iteratively solving linear programming relaxations of the tsp, in conjunction with a branch-and-bound approach that prunes parts of the search space that provably will not contain an optimal solution. similarly, the lin-kernighan-helsgaun heuristic (helsgaun, 2000), inspired from the lin-kernighan heuristic (lin & kernighan, 1973), is a state of the art approximate search heuristic for the symmetric tsp and has been shown to solve instances with hundreds of nodes to optimality.
more generic solvers, such as google’s vehicle routing problem solver (google, 2016) that tackles a superset of the tsp, typically rely on a combination of local search algorithms and metaheuristics. local search algorithms apply a specified set of local move operators on candidate solutions, based
on hand-engineered heuristics such as 2-opt (johnson, 1990), to navigate from solution to solution in the search space. a metaheuristic is then applied to propose uphill moves and escape local optima. a popular choice of metaheuristic for the tsp and its variants is guided local search (voudouris & tsang, 1999), which moves out of a local minimum by penalizing particular solution features that it considers should not occur in a good solution.
the difficulty in applying existing search heuristics to newly encountered problems - or even new instances of a similar problem - is a well-known challenge that stems from the no free lunch theorem (wolpert & macready, 1997). because all search algorithms have the same performance when averaged over all problems, one must appropriately rely on a prior over problems when selecting a search algorithm to guarantee performance. this challenge has fostered interest in raising the level of generality at which optimization systems operate (burke , 2003) and is the underlying motivation behind hyper-heuristics, defined as ”search method[s] or learning mechanism[s] for selecting or generating heuristics to solve computation search problems”. hyper-heuristics aim to be easier to use than problem specific methods by partially abstracting away the knowledge intensive process of selecting heuristics given a combinatorial problem and have been shown to successfully combine human-defined heuristics in superior ways across many tasks (see (burke , 2013) for a survey). however, hyper-heuristics operate on the search space of heuristics, rather than the search space of solutions, therefore still initially relying on human created heuristics.
the application of neural networks to combinatorial optimization has a distinguished history, where the majority of research focuses on the traveling salesman problem (smith, 1999). one of the earliest proposals is the use of hopfield networks (hopfield & tank, 1985) for the tsp. the authors modify the network’s energy function to make it equivalent to tsp objective and use lagrange multipliers to penalize the violations of the problem’s constraints. a limitation of this approach is that it is sensitive to hyperparameters and parameter initialization as analyzed by (wilson & pawley, 1988). overcoming this limitation is central to the subsequent work in the field, especially by (aiyer , 1990; gee, 1993). parallel to the development of hopfield networks is the work on using deformable template models to solve tsp. perhaps most prominent is the invention of elastic nets as a means to solve tsp (durbin, 1987), and the application of self organizing map to tsp (fort, 1988; angeniol , 1988; kohonen, 1990). addressing the limitations of deformable template models is central to the following work in this area (burke, 1994; favata & walker, 1991; vakhutinsky & golden, 1995). even though these neural networks have many appealing properties, they are still limited as research work. when being carefully benchmarked, they have not yielded satisfying results compared to algorithmic methods (sarwar & bhatti, 2012; la maire & mladenov, 2012). perhaps due to the negative results, this research direction is largely overlooked since the turn of the century.
motivated by the recent advancements in sequence-to-sequence learning (sutskever , 2014), neural networks are again the subject of study for optimization in various domains (yutian , 2016), including discrete ones (zoph & le, 2016). in particular, the tsp is revisited in the introduction of pointer networks (vinyals , 2015b), where a recurrent network with non-parametric softmaxes is trained in a supervised manner to predict the sequence of visited cities. despite architecural improvements, their models were trained using supervised signals given by an approximate solver.we focus on the 2d euclidean tsp in this paper. given an input graph, represented as a sequence of n cities in a two dimensional space s = {xi}ni=1 where each xi ∈ r2, we are concerned with finding a permutation of the points π, termed a tour, that visits each city once and has the minimum total length. we define the length of a tour defined by a permutation π as
l(π | s) = ∥∥xπ(n) − xπ(1)∥∥2 + n−1∑
i=1 ∥∥xπ(i) − xπ(i+1)∥∥2 , (1) where ‖·‖2 denotes `2 norm. we aim to learn the parameters of a stochastic policy p(π | s) that given an input set of points s, assigns high probabilities to short tours and low probabilities to long tours. our neural network
architecture uses the chain rule to factorize the probability of a tour as
p(π | s) = n∏ i=1 p (π(i) | π(< i), s) , (2)
and then uses individual softmax modules to represent each term on the rhs of (2).
we are inspired by previous work (sutskever , 2014) that makes use of the same factorization based on the chain rule to address sequence to sequence problems like machine translation. one can use a vanilla sequence to sequence model to address the tsp where the output vocabulary is {1, 2, . . . , n}. however, there are two major issues with this approach: (1) networks trained in this fashion cannot generalize to inputs with more than n cities. (2) one needs to have access to groundtruth output permutations to optimize the parameters with conditional log-likelihood. we address both isssues in this paper.
for generalization beyond a pre-specified graph size, we follow the approach of (vinyals , 2015b), which makes use of a set of non-parameteric softmax modules, resembling the attention mechanism from (bahdanau , 2015). this approach, named pointer network, allows the model to effectively point to a specific position in the input sequence rather than predicting an index value from a fixed-size vocabulary. we employ the pointer network architecture, depicted in figure 2, as our policy model to parameterize p(π | s).our pointer network comprises two recurrent neural network (rnn) modules, encoder and decoder, both of which consist of long short-term memory (lstm) cells (hochreiter & schmidhuber, 1997). the encoder network reads the input sequence s, one city at a time, and transforms it into a sequence of latent memory states {enci}ni=1 where enci ∈ rd. the input to the encoder network at time step i is a d-dimensional embedding of a 2d point xi, which is obtained via a linear transformation of xi shared across all input steps. the decoder network also maintains its latent memory states {deci}ni=1 where deci ∈ rd and, at each step i, uses a pointing mechanism to produce a distribution over the next city to visit in the tour. once the next city is selected, it is passed as the input to the next decoder step. the input of the first decoder step (denoted by 〈g〉 in figure 2) is a d-dimensional vector treated as a trainable parameter of our neural network.
our attention function, formally defined in appendix a.1, takes as input a query vector q = deci ∈ rd and a set of reference vectors ref = {enc1, . . . , enck} where enci ∈ rd, and predicts a distribution a(ref, q) over the set of k references. this probability distribution represents the degree to which the model is pointing to reference ri upon seeing query q.
vinyals  (2015a) also suggest including some additional computation steps, named glimpses, to aggregate the contributions of different parts of the input sequence, very much like (bahdanau , 2015). we discuss this approach in details in appendix a.1. in our experiments, we find that utilizing one glimpse in the pointing mechanism yields performance gains at an insignificant cost latency.
algorithm 1 actor-critic training 1: procedure train(training set s, number of training steps t , batch size b) 2: initialize pointer network params θ 3: initialize critic network params θv 4: for t = 1 to t do 5: si ∼ sampleinput(s) for i ∈ {1, . . . , b} 6: πi ∼ samplesolution(pθ(.|si)) for i ∈ {1, . . . , b} 7: bi ← bθv (si) for i ∈ {1, . . . , b} 8: gθ ← 1b ∑b i=1(l(πi|si)− bi)∇θ log pθ(πi|si) : lv ← 1b ∑b i=1 ‖bi − l(πi)‖ 2 2 0: θ ← adam(θ, gθ) 11: θv ← adam(θv,∇θvlv) 12: end for 13: return θ 14: end procedurevinyals  (2015b) proposes training a pointer network using a supervised loss function comprising conditional log-likelihood, which factors into a cross entropy objective between the network’s output probabilities and the targets provided by a tsp solver. learning from examples in such a way is undesirable for np-hard problems because (1) the performance of the model is tied to the quality of the supervised labels, (2) getting high-quality labeled data is expensive and may be infeasible for new problem statements, (3) one cares about finding a competitive solution more than replicating the results of another algorithm.
by contrast, we believe reinforcement learning (rl) provides an appropriate paradigm for training neural networks for combinatorial optimization, especially because these problems have relatively simple reward mechanisms that could be even used at test time. we hence propose to use model-free policy-based reinforcement learning to optimize the parameters of a pointer network denoted θ. our training objective is the expected tour length which, given an input graph s, is defined as
j(θ | s) = eπ∼pθ(.|s) l(π | s) . (3) during training, our graphs are drawn from a distribution s, and the total training objective involves sampling from the distribution of graphs, i.e. j(θ) = es∼s j(θ | s) . we resort to policy gradient methods and stochastic gradient descent to optimize the parameters. the gradient of (3) is formulated using the well-known reinforce algorithm (williams, 1992):
∇θj(θ | s) = eπ∼pθ(.|s) [( l(π | s)− b(s) ) ∇θ log pθ(π | s) ] , (4)
where b(s) denotes a baseline function that does not depend on π and estimates the expected tour length to reduce the variance of the gradients.
by drawing b i.i.d. sample graphs s1, s2, . . . , sb ∼ s and sampling a single tour per graph, i.e. πi ∼ pθ(. | si), the gradient in (4) is approximated with monte carlo sampling as follows:
∇θj(θ) ≈ 1
b b∑ i=1 ( l(πi|si)− b(si) ) ∇θ log pθ(πi | si) . (5)
a simple and popular choice of the baseline b(s) is an exponential moving average of the rewards obtained by the network over time to account for the fact that the policy improves with training. while this choice of baseline proved sufficient to improve upon the christofides algorithm, it suffers from not being able to differentiate between different input graphs. in particular, the optimal tour π∗ for a difficult graph s may be still discouraged if l(π∗|s) > b because b is shared across all instances in the batch.
using a parametric baseline to estimate the expected tour length eπ∼pθ(.|s)l(π | s) typically improves learning. therefore, we introduce an auxiliary network, called a critic and parameterized
algorithm 2 active search 1: procedure activesearch(input s, θ, number of candidates k, b, α) 2: π ← randomsolution() 3: lπ ← l(π | s) 4: n← dk
b e : for t = 1 . . . n do 6: πi ∼ samplesolution(pθ(. | s)) for i ∈ {1, . . . , b} 7: j ← argmin(l(π1 | s) . . . l(πb | s)) 8: lj ← l(πj | s) 9: if lj < lπ then 0: π ← πj 11: lπ ← lj 12: end if 13: gθ ← 1b ∑b i=1(l(πi | s)− b)∇θ log pθ(πi | s) 14: θ ← adam(θ, gθ) 15: b← α× b+ (1− α)× ( 1
b ∑b i=1 bi) 6: end for 17: return π 18: end procedure
by θv , to learn the expected tour length found by our current policy pθ given an input sequence s. the critic is trained with stochastic gradient descent on a mean squared error objective between its predictions bθv (s) and the actual tour lengths sampled by the most recent policy. the additional objective is formulated as
l(θv) = 1
b b∑ i=1 ∥∥ bθv (si)− l(πi | si)∥∥22 . (6) critic’s architecture for tsp. we now explain how our critic maps an input sequence s into a baseline prediction bθv (s). our critic comprises three neural network modules: 1) an lstm encoder, 2) an lstm process block and 3) a 2-layer relu neural network decoder. its encoder has the same architecture as that of our pointer network’s encoder and encodes an input sequence s into a sequence of latent memory states and a hidden state h. the process block, similarly to (vinyals , 2015a), then performs p steps of computation over the hidden state h. each processing step updates this hidden state by glimpsing at the memory states as described in appendix a.1 and feeds the output of the glimpse function as input to the next processing step. at the end of the process block, the obtained hidden state is then decoded into a baseline prediction (i.e a single scalar) by two fully connected layers with respectively d and 1 unit(s).
our training algorithm, described in algorithm 1, is closely related to the asynchronous advantage actor-critic (a3c) proposed in (mnih , 2016), as the difference between the sampled tour lengths and the critic’s predictions is an unbiased estimate of the advantage function. we perform our updates asynchronously across multiple workers, but each worker also handles a mini-batch of graphs for better gradient estimates.as evaluating a tour length is inexpensive, our tsp agent can easily simulate a search procedure at inference time by considering multiple candidate solutions per graph and selecting the best. this inference process resembles how solvers search over a large set of feasible solutions. in this paper, we consider two search strategies detailed below, which we refer to as sampling and active search.
sampling. our first approach is simply to sample multiple candidate tours from our stochastic policy pθ(.|s) and select the shortest one. in contrast to heuristic solvers, we do not enforce our model to sample different tours during the process. however, we can control the diversity of the sampled tours with a temperature hyperparameter when sampling from our non-parametric softmax (see appendix a.2). this sampling process yields significant improvements over greedy decoding, which always selects the index with the largest probability. we also considered perturbing the pointing
mechanism with random noise and greedily decoding from the obtained modified policy, similarly to (cho, 2016), but this proves less effective than sampling in our experiments.
active search. rather than sampling with a fixed model and ignoring the reward information obtained from the sampled solutions, one can refine the parameters of the stochastic policy pθ during inference to minimize eπ∼pθ(.|s)l(π | s) on a single test input s. this approach proves especially competitive when starting from a trained model. remarkably, it also produces satisfying solutions when starting from an untrained model. we refer to these two approaches as rl pretraining-active search and active search because the model actively updates its parameters while searching for candidate solutions on a single test instance.
active search applies policy gradients similarly to algorithm 1 but draws monte carlo samples over candidate solutions π1 . . . πb ∼ pθ(·|s) for a single test input. it resorts to an exponential moving average baseline, rather than a critic, as there is no need to differentiate between inputs. our active search training algorithm is presented in algorithm 2. we note that while rl training does not require supervision, it still requires training data and hence generalization depends on the training data distribution. in contrast, active search is distribution independent. finally, since we encode a set of cities as a sequence, we randomly shuffle the input sequence before feeding it to our pointer network. this increases the stochasticity of the sampling procedure and leads to large improvements in active search.we conduct experiments to investigate the behavior of the proposed neural combinatorial optimization methods. we consider three benchmark tasks, euclidean tsp20, 50 and 100, for which we generate a test set of 1, 000 graphs. points are drawn uniformly at random in the unit square [0, 1]2.across all experiments, we use mini-batches of 128 sequences, lstm cells with 128 hidden units, and embed the two coordinates of each point in a 128-dimensional space. we train our models with the adam optimizer (kingma & ba, 2014) and use an initial learning rate of 10−3 for tsp20 and tsp50 and 10−4 for tsp100 that we decay every 5000 steps by a factor of 0.96. we initialize our parameters uniformly at random within [−0.08, 0.08] and clip the l2 norm of our gradients to 1.0. we use up to one attention glimpse. when searching, the mini-batches either consist of replications of the test sequence or its permutations. the baseline decay is set to α = 0.99 in active search. our model and training code in tensorflow (abadi , 2016) will be made availabe soon. table 1 summarizes the configurations and different search strategies used in the experiments. the variations of our method, experimental procedure and results are as follows.
supervised learning. in addition to the described baselines, we implement and train a pointer network with supervised learning, similarly to (vinyals , 2015b). while our supervised data consists of one million optimal tours, we find that our supervised learning results are not as good as those reported in by (vinyals , 2015b). we suspect that learning from optimal tours is harder for supervised pointer networks due to subtle features that the model cannot figure out only by looking at given supervised targets. we thus refer to the results in (vinyals , 2015b) for tsp20 and tsp50 and report our results on tsp100, all of which are suboptimal compared to other approaches.
rl pretraining. for the rl experiments, we generate training mini-batches of inputs on the fly and update the model parameters with the actor critic algorithm 1. we use a validation set of 10, 000 randomly generated instances for hyper-parameters tuning. our critic consists of an encoder network which has the same architecture as that of the policy network, but followed by 3 processing steps and 2 fully connected layers. we find that clipping the logits to [−10, 10] with a tanh(·) activation function, as described in appendix a.2, helps with exploration and yields marginal performance gains. the simplest search strategy using an rl pretrained model is greedy decoding, i.e. selecting the city with the largest probability at each decoding step. we also experiment with decoding greedily from a set of 16 pretrained models at inference time. for each graph, the tour found by each individual model is collected and the shortest tour is chosen. we refer to those approaches as rl pretraining-greedy and rl pretraining-greedy@16.
rl pretraining-sampling. for each test instance, we sample 1, 280, 000 candidate solutions from a pretrained model and keep track of the shortest tour. a grid search over the temperature hyperparameter found respective temperatures of 2.0, 2.2 and 1.5 to yield the best results for tsp20, tsp50 and tsp100. we refer to the tuned temperature hyperparameter as t ∗. since sampling does not require parameter udpates and is entirely parallelizable, we use a larger batch size for speed purposes.
rl pretraining-active search. for each test instance, we initialize the model parameters from a pretrained rl model and run active search for up to 10, 000 training steps with a batch size of 128, sampling a total of 1, 280, 000 candidate solutions. we set the learning rate to a hundredth of the initial learning rate the tsp agent was trained on (i.e. 10−5 for tsp20/tsp50 and 10−6 for tsp100).
active search. we allow the model to train much longer to account for the fact that it starts from scratch. for each test graph, we run active search for 100, 000 training steps on tsp20/tsp50 and 200, 000 training steps on tsp100.we compare our methods against 3 different baselines of increasing performance and complexity: 1) christofides, 2) the vehicle routing solver from or-tools (google, 2016) and 3) optimality. christofides solutions are obtained in polynomial time and guaranteed to be within a 1.5 ratio of optimality. or-tools improves over christofides’ solutions with simple local search operators, including 2-opt (johnson, 1990) and a version of the lin-kernighan heuristic (lin & kernighan, 1973), stopping when it reaches a local minimum. in order to escape poor local optima, ortools’ local search can also be run in conjunction with different metaheuristics, such as simulated annealing (kirkpatrick , 1983), tabu search (glover & laguna, 2013) or guided local search (voudouris & tsang, 1999). or-tools’ vehicle routing solver can tackle a superset of the tsp and operates at a higher level of generality than solvers that are highly specific to the tsp. while not state-of-the art for the tsp, it is a common choice for general routing problems and provides a reasonable baseline between the simplicity of the most basic local search operators and the sophistication of the strongest solvers. optimal solutions are obtained via concorde (applegate , 2006) and lk-h’s local search (helsgaun, 2012; 2000). while only concorde provably solves instances to optimality, we empirically find that lk-h also achieves optimal solutions on all of our test sets after 50 trials per graph (which is the default parameter setting).
we report the average tour lengths of our approaches on tsp20, tsp50, and tsp100 in table 2. notably, results demonstrate that training with rl significantly improves over supervised learning
(vinyals , 2015b). all our methods comfortably surpass christofides’ heuristic, including rl pretraining-greedy which also does not rely on search. table 3 compares the running times of our greedy methods to the aforementioned baselines, with our methods running on a single nvidia tesla k80 gpu, concorde and lk-h running on an intel xeon cpu e5-1650 v3 3.50ghz cpu and ortool on an intel haswell cpu. we find that both greedy approaches are time-efficient but still quite far from optimality.
searching at inference time proves crucial to get closer to optimality but comes at the expense of longer running times. fortunately, the search from rl pretraining-sampling and rl pretrainingactive search can be stopped early with a small performance tradeoff in terms of the final objective. this can be seen in table 4, where we show their performances and corresponding running times as a function of how many solutions they consider.
we also find that many of our rl pretraining methods outperform or-tools’ local search, including rl pretraining-greedy@16 which runs similarly fast. table 6 in appendix a.3 presents the performance of the metaheuristics as they consider more solutions and the corresponding running times. in our experiments, neural combinatorial proves superior than simulated annealing but is slightly less competitive that tabu search and much less so than guided local search.
we present a more detailed comparison of our methods in figure 3, where we sort the ratios to optimality of our different learning configurations. rl pretraining-sampling and rl pretrainingactive search are the most competitive neural combinatorial optimization methods and recover the optimal solution in a significant number of our test cases. we find that for small solution spaces, rl pretraining-sampling, with a finetuned softmax temperature, outperforms rl pretraining-active search with the latter sometimes orienting the search towards suboptimal regions of the solution space (see tsp50 results in table 4 and figure 3). furthermore, rl pretraining-sampling benefits from being fully parallelizable and runs faster than rl pretraining-active search. however, for larger solution spaces, rl-pretraining active search proves superior both when controlling for the number of sampled solutions or the running time. interestingly, active search - which starts from an untrained model - also produces competitive tours but requires a considerable amount of time (respectively 7 and 25 hours per instance of tsp50/tsp100). finally, we show randomly picked example tours found by our methods in figure 4 in appendix a.4.in this section, we discuss how to apply neural combinatorial optimization to other problems than the tsp. in neural combinatorial optimization, the model architecture is tied to the given combinatorial optimization problem. examples of useful networks include the pointer network, when the output is a permutation or a truncated permutation or a subset of the input, and the classical seq2seq model for other kinds of structured outputs. for combinatorial problems that require to assign labels to elements of the input, such as graph coloring, it is also possible to combine a pointer module and a softmax module to simultaneously point and assign at decoding time. given a model that encodes an instance of a given combinatorial optimization task and repeatedly branches into subtrees to construct a solution, the training procedures described in section 4 can then be applied by adapting the reward function depending on the optimization problem being considered.
additionally, one also needs to ensure the feasibility of the obtained solutions. for certain combinatorial problems, it is straightforward to know exactly which branches do not lead to any feasible solutions at decoding time. we can then simply manually assign them a zero probability when decoding, similarly to how we enforce our model to not point at the same city twice in our pointing mechanism (see appendix a.1). however, for many combinatorial problems, coming up with a feasible solution can be a challenge in itself. consider, for example, the travelling salesman problem with time windows, where the travelling salesman has the additional constraint of visiting each city during a specific time window. it might be that most branches being considered early in the tour do not lead to any solution that respects all time windows. in such cases, knowing exactly which branches are feasible requires searching their subtrees, a time-consuming process that is not much easier than directly searching for the optimal solution unless using problem-specific heuristics.
rather than explicitly constraining the model to only sample feasible solutions, one can also let the model learn to respect the problem’s constraints. a simple approach, to be verified experimentally in future work, consists in augmenting the objective function with a term that penalizes solutions for violating the problem’s constraints, similarly to penalty methods in constrained optimization. while this does not guarantee that the model consistently samples feasible solutions at inference time, this is not necessarily problematic as we can simply ignore infeasible solutions and resample from the model (for rl pretraining-sampling and rl-pretraining active search). it is also conceivable to combine both approaches by assigning zero probabilities to branches that are easily identifiable as infeasible while still penalizing infeasible solutions once they are entirely constructed.as an example of the flexibility of neural combinatorial optimization, we consider the knapsack problem, another intensively studied problem in computer science. given a set of n items i = 1...n, each with weight wi and value vi and a maximum weight capacity ofw , the 0-1 knapsack problem consists in maximizing the sum of the values of items present in the knapsack so that the sum of the
weights is less than or equal to the knapsack capacity:
max s⊆{1,2,...,n} ∑ i∈s vi
subject to ∑ i∈s wi ≤w (7)
with wi, vi and w taking real values, the problem is np-hard (kellerer , 2004). a naive heuristic is to take the items ordered by their weight-to-value ratios until they fill up the weight capacity. two simple heuristics are expknap, which employs branch-and-bound with linear programming bounds (pisinger, 1995), and minknap, which uses dynamic programming with enumerative bounds (pisinger, 1997). exact solutions can also be obtained by quantizing the weights to high precisions and then performing dynamic programming with pseudo-polynomial complexity (bertsimas & demir, 2002).
we apply the pointer network and encode each knapsack instance as a sequence of 2d vectors (wi, vi). at decoding time, the pointer network points to items to include in the knapsack and stops when the total weight of the items collected so far exceeds the weight capacity. we generate three datasets, knap50, knap100 and knap200, of a thousand instances with items’ weights and values drawn uniformly at random in [0, 1]. without loss of generality (since we can scale the items’ weights), we set the capacities to 12.5 for knap50 and 25 for knap100 and knap200. we present the performances of rl pretraining-greedy and active search (which we run for 5, 000 training steps) in table 5 and compare them to the following baselines: 1) random search (which we let sample as many feasible solutions seen by active search), 2) the greedy value-to-weight ratio heuristic, 3) minknap, 4) expknap, 5) or-tools’ knapsack solver (google, 2016) and 6) optimality (which we obtained by quantizing the weights to high precisions and using dynamic programming).this paper presents neural combinatorial optimization, a framework to tackle combinatorial optimization with reinforcement learning and neural networks. we focus on the traveling salesman problem (tsp) and present a set of results for each variation of the framework. experiments demonstrate that neural combinatorial optimization achieves close to optimal results on 2d euclidean graphs with up to 100 nodes. our results, while still far from the strongest solvers (especially those which are optimized for one problem), provide an interesting research avenue for using neural networks as a general tool for tackling combinatorial optimization problems.the authors would like to thank vincent furnon, mustafa ispir, lukasz kaiser, oriol vinyals, barret zoph, the google brain team and the anonymous iclr reviewers for insightful comments and discussion.a.1 pointing and attending
pointing mechanism: its computations are parameterized by two attention matrices wref ,wq ∈ rd×d and an attention vector v ∈ rd as follows:
ui = { v> · tanh (wref · ri +wq · q) if i 6= π(j) for all j < i −∞ otherwise for i = 1, 2, ..., k (8)
a(ref, q;wref ,wq, v) def = softmax(u). (9)
our pointer network, at decoder step j, then assigns the probability of visiting the next point π(j) of the tour as follows:
p(π(j)|π(< j), s) def= a(enc1:n, decj). (10)
setting the logits of cities that already appeared in the tour to −∞, as shown in equation 8, ensures that our model only points at cities that have yet to be visited and hence outputs valid tsp tours.
attending mechanism: specifically, our glimpse function g(ref, q) takes the same inputs as the attention function a and is parameterized by w gref ,w g q ∈ rd×d and vg ∈ rd. it performs the following computations:
p = a(ref, q;w gref ,w g q , v g) (11)
g(ref, q;w gref ,w g q , v g) def = k∑ i=1 ripi. (12)
the glimpse functiong essentially computes a linear combination of the reference vectors weighted by the attention probabilities. it can also be applied multiple times on the same reference set ref :
g0 def = q (13)
gl def = g(ref, gl−1;w g ref ,w g q , v g) (14)
finally, the ultimate gl vector is passed to the attention function a(ref, gl;wref ,wq, v) to produce the probabilities of the pointing mechanism. we observed empirically that glimpsing more than once with the same parameters made the model less likely to learn and barely improved the results.
a.2 improving exploration
softmax temperature: we modify equation 9 as follows:
a(ref, q, t ;wref ,wq, v) def = softmax(u/t ), (15)
where t is a temperature hyperparameter set to t = 1 during training. when t > 1, the distribution represented by a(ref, q) becomes less steep, hence preventing the model from being overconfident.
logit clipping: we modify equation 9 as follows:
a(ref, q;wref ,wq, v) def = softmax(c tanh(u)), (16)
wherec is a hyperparameter that controls the range of the logits and hence the entropy ofa(ref, q).
a.3 or tool’s metaheuristics baselines for tsp
a.4 sample tours
(5.934)
rl pretraining -greedy
(5.734)
rl pretraining -sampling
(5.688)
rl pretraining -active search
(5.827)
active search
(5.688)
optimal
rl pretraining -greedy
rl pretraining -sampling
rl pretraining -active search
active search
optimal",0
611.pdf.json,"what do consumers really want? – this is a question to which everyone wishes to have an answer. over the past decade, the unprecedented growth of web services and online commercial platforms such as amazon, netflix, and spotify, gives rise to a vast amount of business data, which contain valuable information about the customers. however, “data don’t speak for themselves”. to accurately predict what the customers want, one needs not only the data, but also an effective means to extract useful messages therefrom.
there has been extensive study on recommender systems. existing methods roughly fall into two categories, namely content-based filtering (pazzani & billsus, 2007) and collaborative filtering (mnih & salakhutdinov, 2008; hu , 2008; yu , 2009). the former focuses on extracting relevant features from the content, while the latter attempts to exploit the common interest among groups of users. in recent efforts, hybrid methods (agarwal & chen, 2009; van den oord , 2013) that combine both aspects have also been developed.
whereas remarkable progress has been made on this topic, the state of the art remains far from satisfactory. the key challenges lie in several aspects. first, there is a large semantic gap between the true cause of a matching and what we observe from the data. for example, what usually attracts a book consumer is the implied emotion that one has to feel between the lines instead of the occurrences of certain words. it is difficult for classical techniques to extract such deep meanings from the observations. second, the cold-start issue, namely making predictions for unseen items or users, has not been well addressed. many collaborative filtering methods rely on the factorization of the matching matrix. such methods implicitly assume that all the users and items are known in advance, and thus are difficult to be applied in real-world applications, especially online services.
the success of deep learning brings new inspiration to this task. in a number of areas, including image classification (krizhevsky , 2012), speech recognition (hinton , 2012), and natural language understanding (socher , 2011), deep learning techniques have substantially pushed forward the state of the art. the power of deep networks in capturing complex variations and bridging semantic gaps has been repeatedly shown in previous study. however, deep models were primarily used for classification or regression, e.g. translating images to sentences. how deep networks can be used to model cross-domain relations remains an open question.
in this work, we aim to explore deep neural networks for learning the matching relations across two domains, with our focus placed on the matching between items and users. specifically, we propose a new framework called collaborative deep embedding, which comprises a pair of dual networks, one for encoding items and the other for users. each network contains multiple embedding layers that are aligned with their dual counterparts of the other network. predictions can then be made by coupling these embeddings. note that unlike a conventional network, the dual networks are trained on two streams of data. in this paper, we devise an algorithm that can jointly train both networks using dual mini-batches. compared to previous methods, this method not only narrows the semantic gap through a deep modeling architecture, but also provides a natural way to generalize – new items and new users can be encoded by the trained networks, just like those present in the training stage.
on a number of real world tasks, the proposed method yields significant improvement over the current state-of-the-art. it is worth stressing that whereas our focus is on the matching between items and users, collaborative deep embedding is a generic methodology, which can be readily extended to model other kinds of cross-domain relations.existing methods for recommendation roughly fall into two categories: content-based methods (pazzani & billsus, 2007) and collaborative filtering (cf) (mnih & salakhutdinov, 2008; hu , 2008; yu , 2009). specifically, content-based methods rely primarily on feature representation of the content, in which recommendations are often made based on feature similarity (slaney , 2008). following this, there are also attempts to incorporate additional information, such as meta-data of users, to further improve the performance (mcfee , 2012). instead, collaborative filtering exploits the interaction between users and items. a common approach to cf is to derive latent factors of both users and items through matrix factorization, and measure the degree of matching by their inner products. previous study (ricci , 2011) showed that cf methods tend to have higher recommendation accuracy than content-based methods, as they directly target the recommendation task. however, practical use of cf is often limited by the cold start problem. it is difficult to recommend items without a sufficient amount of use history. issues like this motivated hybrid methods (agarwal & chen, 2009; van den oord , 2013) that combine both aspects of information, which have showed encouraging improvement. our exploration is also along this line.
despite the progress on both family of methods, the practical performance of state-of-the-art still leaves a lot to be desired. this, to a large extent, is due to the lack of capability of capturing complex variations in interaction patterns. recently, deep learning (bengio, 2009) emerges as an important technique in machine learning. in a number of successful stories (krizhevsky , 2012; hinton , 2012; socher , 2011), deep models have demonstrated remarkable representation power in capturing complex patterns. this power has been exploited by some recent work for recommendation. van den oord  (2013) applies deep learning for music recommendation. it uses the latent item vector learned by cf as ground truth to train a deep network for extracting content features, obtaining considerable performance gain. however the latent vectors for known users and items are not improved. wang & wang (2014) proposed an extension to this method, which concatenates both the cf features and the deep features, resulting in slight improvement.
wang & blei (2011) showed that cf and topic modeling, when combined, can benefit each other. inspired by this, wang  (2015) proposed collaborative deep learning (cdl), which incorporates cf and deep feature learning with a combined objective function. this work represents the latest advances in recommendation methods. yet, its performance is still limited by several issues, e.g. the difficulties in balancing diversified objectives and the lack of effective methods for user encoding. an important aspect that distinguishes our work from cdl and other previous methods is that it encodes both items and users through a pair of deep networks that are jointly trained, which substantially
enhance the representation power on both sides. moreover, the objective function of our learning framework directly targets the recommendation accuracy, which also leads to better performance.at the heart of a recommender system is matching model, namely, a model that can predict whether a given item matches the interest of a given user. generally, this can be formalized as below. suppose there are m users and n items, respectively indexed by i and j. items are usually associated with inherent features, e.g. the descriptions or contents. here, we use xj to denote the observed features of the j-th item. however, inherent information for users is generally very limited and often irrelevant. hence, in most cases, users are primarily characterized by their history, i.e. the items they have purchased or rated. specifically, the user history can be partly captured by a matching matrix r ∈ {0, 1}m×n, where r(i, j) = 1 indicates that the i-th user purchased the j-th item and gave a positive rating. note that r is often an incomplete reflection of the user interest – it is not uncommon that a user does not purchase or rate an item that he/she likes.to motivate our approach, we begin with a brief revisit of collaborative filtering (cf), which is widely adopted in practical recommender systems. the basic idea of cf is to derive vector representations for both users and items by factorizing the matching matrix r. a representative formulation in this family is the weighted matrix factorization (wmf) (hu , 2008), which adopts an objective function as below: ∑
i ∑ j cij(rij − uti vj)2 + λu ∑ i ‖ui‖22 + λv ∑ j ‖vj‖22. (1)
here, ui and vj denote the vector representations of the i-th user and the j-th item, cij the confidence coefficient of an observed entry, and λu, λv the regularization coefficients. underlying such methods lies a common assumption, namely, all users and items must be known a priori. as a result, they will face fundamental difficulties when handling new items and new users.
encoding networks. in this work, we aim to move beyond this limitation by exploring an alternative approach. instead of pursuing the embeddings of a given set of items and users, our approach jointly learns a pair of encoding networks, respectively for items and users. compared to cf, the key advantage of this approach is that it is generalizable by nature. when new items or new users come, their vector embeddings can be readily derived using the learned encoders.
generally, the items can be encoded based on their own inherent features, using, for example, an auto-encoder. the key question here, however, is how to encode users, which, as mentioned, have no inherent features. again, we revisit conventional cf methods such as wmf and find that in these methods, the user representations can be expressed as:
ui = argmin u ∑ j cij‖rij − uti vj‖2 + λu ∑ i ‖ui‖2 = ( vciv t + λui )−1 vri. (2)
here, v = [v1, . . . ,vn] is a matrix comprised of all item embeddings, each column for one; ri is the i-th row of r treated as a column vector, which represents the history of the i-th user; and ci = diag(ci1, . . . , cin) captures the confidence weights.
the analysis above reveals that ui is a linear transform of ri as ui = wuri, where the transform matrix wu depends on the item embeddings v. this motivates our idea of user encoding, that is, to use a deep neural network instead the linear transform above, as
ui = g(ri;wu), (3)
where g denotes a nonlinear transform based on a deep network with parameters wu. as we will show in our experiments, by drawing on the expressive power of deep neural networks, the proposed way of user encoding can substantially improve the prediction accuracy.
overall formulation. by coupling an item-network denoted by f(xj ;wv) and a user-network g as introduced above, we can predict the matching of any given pair of user and item based on the inner product of their embeddings, as 〈f(x;wv), g(r;wu)〉. the inputs to these networks include x, the inherent feature of the given item, and r, the history of the given user on a set of reference items. with both encoding networks, we formulate the learning objective as follows:
min wu,wv ∑ i ∑ j cij‖rij − 〈f(xj ;wv), g(ri;wu)〉‖2. (4)
here, x = [x1, . . . ,xn] denotes the input features of all reference items. this formulation differs from previous ones in two key aspects: (1) both users and items are encoded using deep neural networks. the learning objective above encourages the cooperation of both networks such that the coupling of both sides yield the highest accuracy. hence, the user-network parameters wu depends on the item embeddings v, and likewise for the item-network. (2) the learning task is to estimate the parameters of the encoding networks. once the encoding networks are learned, they encode users and items in a uniform way, no matter whether they are seen during training. in other words, new users and new items are no longer second-class citizens – they are encoded in exactly the same way as those in the training set.
comparison with cdl. the collaborative deep learning (cdl) recently proposed by wang  (2015) was another attempt to tackle the cold-start issue. this method leverages the item features by aligning the item encoder with the embeddings resulted from matrix factorization. in particular, the objective function is given as follows:∑ ij cij(rij−uti vj)2+λv ∑ j ‖vj−fe(x̃j ,θ)‖2+λn ∑ j ‖x̃j−fr(x̃j ,θ)‖2+λu ∑ i ‖ui‖2+r(θ). (5) here, a stacked denoising autoencoder (sdae) (vincent , 2010) with parameter θ is used to encode the items, based on {x̃j}, noisy versions of their features. compared to our formulation, cdl has several limitations: (1) the objective is to balance the sdae reconstruction error and the matching accuracy, which does not necessarily lead to improved recommendation. tuning this balance also turns out to be tricky. (2) only items are encoded, while the representations of the users are still obtained by matrix factorization. as a result, its expressive power in capturing user interest remains limited. (3) there are inconsistencies between known items and new ones – the embedding of known items is resulted from a tradeoff between the matching accuracy and the fidelity to sdae features, while the embedding of new items are purely based on sdae encoding.our model consists of two networks, namely the item-network f and the user-network g. we went through a progressive procedure in designing their architectures, obtaining three different designs, from basic design, multi-level design, to multi-level branching design. each new design was motivated by the observation of certain limitations in the previous version.
the basic design, as shown in figure 1 (a) adopts the multilayer perceptron as the basic architecture, using tanh as the nonlinear activation function between layers1. the top layer of the item-network produces a vector f(xj ;wv) for each item; while that of the user-network produces a dual vector g(ri;wu) for each user. during training, the loss layer takes their inner products and compares them with the ground-truth r(i, j).
each layer in these networks generates a vector representation. we observe that representations from different layers are complementary. representations from lower layers tend to be closer to the inputs and preserve more information; while those from higher layers focus on deeper semantics. the representations from these levels have their respective values, as different users tend to focus on different aspects of an item. following this intuition, we reach a multi-level design, as shown in figure 1 (b). in this design, dot products between dual embeddings at corresponding levels are aggregated to produce the final prediction.
there is an issue of the multi-level design – the output of each intermediate layer actually plays two roles. on one hand, it is the input to the next layer for further abstraction; on the other hand, it also serves as a facet to be matched with the other side. these two roles require different properties of the representations. particularly, for the former role, the representation needs to preserve more information for higher-level abstraction; while for the latter, those parts related to the current level of matching need to be emphasized. to address this issue, we design a multi-level branching architecture, as shown in figure 1 (c). in this design, a matching branch is introduced to transform the representation at each level to a form that is more suitable for matching. this can also be considered as learning an alternative metric to measure the matchness between the embeddings. as we will show in our experiments, this design can considerably improve the prediction accuracy.a distinctive aspect of our training algorithm is the use of dual mini-batches. specifically, in each iteration, bv items and bu users are selected. in addition to the item features and user histories, the corresponding part of the matching matrix r will also be loaded and fed to the network. here, the two batch sizes bv and bu can be different, and they should be chosen according to the sparsity of the matching matrix r, such that each dual mini-batch can cover both positive and zero ratings.
during the backward pass, the loss layer that compares the predictions with the ground-truth matchings will produce two sets of gradients, respectively for items and users. these gradients are then back-propagated along respective networks. note that when the multi-level designs (both with and without branching) are used, each intermediate layer will receive gradients from two sources – those from the upper layers and those from the dual network (via the dot-product layer). hence, the training of one network would impact that of the other.
the entire training procedure consists of two stages: pre-training and optimization. in the pre-training stage, we initialize the item-network with unsupervised training (vincent , 2010) and the usernetwork randomly. the unsupervised training of the item-network allows it to capture the feature statistics. then both networks will be jointly refined in a layer-by-layer fashion. particularly, we first tune the one-level networks, taking the dot products of their outputs as the predictions. subsequently, we stack the second layers on top and refine them in a similar way. empirically, we found that this layer-wise refinement scheme provides better initialization. in the optimization stage, we adopt the sgd algorithm with momentum and use the dual mini-batch scheme presented above. in this stage, the training is conducted in epochs. each epoch, through multiple iterations, traverses the whole matching matrix r without repetition. the order of choosing mini-batches is arbitrary and will be shuffled at the beginning of each epoch. additional tricks such as dropout and batch normalization are employed to further improve the performance. the choice of tanh as the activation function is based on empirical comparison.we tested our method on three real-world datasets with different kinds of items and matching relations: . citeulike, constructed by wang & blei (2011), provides a list of researchers and the papers that they interested. each paper comes with a text document that comprises both the title and the abstract. in total, it contains 5, 551 researchers (as users) and 16, 980 papers (as items) with 0.22% density. the task is to predict the papers that a researcher would like. . movielens+posters is constructed based on the movielens 20m dataset (harper & konstan, 2016), which provides about 20m user ratings on movies. for each movie, we collect a movie poster from tmdb and extract a visual feature therefrom using a convolutional neural network (szegedy , 2016) as the item feature. removing all those movies without posters and the users with fewer than 10 ratings, we obtain a dataset that contains 76, 531 users and 14, 101 items with 0.24% density. in this dataset, all 5 ratings are considered as positive matchings. . ciao is organized by tang  (2012) from a product review site, where each product comes with a series of reviews. the reviews for each product are concatenated to serve as the item content. we removed those items with less than 5 rated users and the users with less than 10 ratings. this results in a dataset with 4, 663 users and 12, 083 items with 0.25% density. all ratings with 40 or above (the rating ranges from 0 to 50) are regarded as positive matchings.the performance of a recommender system can be assessed from different perspective. in this paper, we follow wang & blei (2011) and perform the evaluation from the retrieval perspective. specifically, a fraction of rating entries are omitted in the training phase, and the algorithms being tested will be used to predict those entries. as pointed out by wang & blei (2011), as the ratings are implicit feedback (hu , 2008) – some positive matchings are not reflected in the ratings, recall is more suitable than precision in measuring the performance. in particular, we use recall@m averaged over all users as the performance metric. here, for a certain user, recall@m is defined as follows:
recall@m = the number of items a user likes in top m recommendations
the total number of items the user likes .
in our experiments, the value of m varies from 50 to 200.
following wang & blei (2011), we consider two tasks, in-matrix prediction and out-matrix prediction. specifically, we divide all users into two disjoint parts, known and unknown, by the ratio of 9 to 1. the in-matrix prediction task only considers known items. for this task, all rating entries are split into three disjoint sets: training, validation and testing, by the ratio 3 : 1 : 1. it is ensured that all items in the validation and testing sets have appeared in the training stage (just that part of their ratings were omitted). the out-matrix prediction task is to make predictions for the items that are completely unseen in the training phase. this task is to test the performance of generalization and the capability of handling the cold-start issue.we compared our method, which we refer to as dualnet with two representative methods in previous work: (1) weighted matrix factorization (wmf) (hu , 2008), a representative method for for collaborative filtering (cf), and (2) collaborative deep learning (cdl) (wang , 2015), a hybrid method that combines deep encoding of the items and cf, which represents the latest advances in recommendation techniques.
on each dataset, we chose the design parameters for each method via grid search. the parameter combinations that attain best performance on the validation set are used. for our dualnet method, we adopt a three-level branching configuration, where the embedding dimensions of each network, from bottom to top, are set to 200, 200, 50. for wmf, the latent dimension is set to 300 on cdl and 450 on other datasets. for cdl, the best performance is attained when the structure of sdae is configured to be (2000, 1000, 300), with drop out ratio 0.1. other design parameters of cdl are set as a = 1.0, b = 0.01, lu = 1, lv = 10, ln = 1000, lw = 0.0005.
note that on citeulike, there are two ways to split the data. one is the scheme in (wang , 2015), and the other is the scheme in (wang & blei, 2011), which is the one presented in the previous section. note that in the former scheme, a fixed number of ratings from each user are selected for training. this may result in some testing items being missed in the training set. to provide a complete comparison with prior work, we use both schemes in our experiments, which are respectively denoted as citeulike1 and citeulike2.
table 1 compares the performance of wml, cdl, and dualnet on all three datasets (four data splitting settings). from the results, we observed: (1) our proposed dualnet method outperforms both wml and cdl on all datasets. on certain data sets, the performance gains are substantial. for example, on movielens, we obtained average recalls at 44.95%, 59.15%, and 72.56% respectively when m = 50, 100, 200. comparing what cdl achieves (38.11%, 49, 73%, and 61.00%), the relative gains are around 18%. on other data sets, the gains are also considerable. (2) the performance gains vary significantly across different datasets, as they are closely related to the relevance of the item features. particularly, when the item features are pertinent to the user interest, we may see remarkable improvement when those features are incorporated; otherwise, the performance gains would be relatively smaller.we conducted additional experiments on citeulike to further study the proposed algorithm. in this study, we investigate the performance of out-matrix prediction, the impact of various modeling choices, e.g. multi-level branching, as well as the influence of training tactics.
out-matrix prediction. as mentioned, the out-matrix prediction task is to examine an algorithm’s capability of handling new items, i.e. those unseen in the training stage. for this task, we compared cdl and dualnet on the citeulike dataset. wml is not included here as it is not able to handle new items. table 2 shows the results. it can be clearly seen that dualnet outperforms cdl by a notable margin. for example, recall@50 increases from 32.18% to 47.51% – the relative gain is 47.6%, a very remarkable improvement. the strong generalization performance as demonstrated here is, to a large extent, ascribed to our basic formulation, where the encoding networks uniformly encode both known and new items.
multi-level branching. we compared three different designs presented in section 3: basic design, multi-level design, and multi-level branching design. from the results shown in table 3, we can observe limited improvement of the multi-level design over the basic one. more significant performance
gains are observed when the branching design is introduced. this shows that the branches contribute a lot to the overall performance.
noise injection. sometimes we noticed overfitting during training i.e. the validation performance gets worse while the training loss is decreasing. to tackle this issue, we inject noises to the inputs, i.e. setting a fraction of input entries to zeros. generally, we observed that noise injection has little effect for recall@m on in-matrix predictions when m < 30. however, it can considerably increase the recall for largem value or out-matrix predictions. particularly, on citeulike, it increases in-matrix recall@300 from 67.3% to 71.2%, and out-matrix recall@50 from 38.6% to 47.5%.
unsuccessful tactics. finally, we show some tactics that we have tried and found to be not working. (1) replacing the weighted euclidean loss with logistic loss would lead to substantial degradation of the performance (sometimes by up to 20%). also, when using logistic loss, we observed severe overfitting. rendle  (2009) proposed bayesian personalized recommendation (bpr) which directly targets on ranking. we tested this on citeulike with parameters tuned to obtain the optimal performance. our experimental results showed that its performance is similar to wmf. particularly, the recall@50, 100, 200 for bpr are respectively 39.11%, 49.16%, 59.96%, while those for wmf are 40.45%, 50.25%, 59.95%.
(2) motivated by the observation that positive ratings are sparse, we tried a scheme that ignores a fraction of dual mini-batches that correspond to all zero ratings, with an aim to speed up the training. whereas this can reduces the time needed to run an epoch, it takes significantly more epochs to reach the same level of performance. as a result, the overall runtime is even longer.this paper presented a new method for predicting the interactions between users and items, called collaborative deep embedding. this method uses dual networks to encode users and items respectively. the user-network and item-network are trained jointly, in a collaborative manner, based on two streams of data. we obtained considerable performance gains over the state-of-the-art consistently on three large datasets. the proposed method also demonstrated superior generalization performance (on out-matrix predictions). this improvement, from our perspective, is ascribed to three important reasons: (1) the expressive power of deep models for capturing the rich variations in user interests, (2) the collaborative training process that encourages closely coupled embeddings, and (3) an objective function that directly targets the prediction accuracy.
we consider this work as a significant step that brings the power of deep models to relational modeling. however, the space of deep relational modeling remains wide open – lots of questions remain yet to be answered. in future, we plan to investigate more sophisticated network architectures, and extend the proposed methodology to applications that involve more than two domains.",0
612.pdf.json,"there has been an increased interest in unsupervised learning of representations from video sequences (mathieu , 2016; srivastava , 2015; vondrick , 2016). a popular formulation of the task is to learn to predict a small number of future frames given the previous k frames; the motivation being that predicting future frames requires understanding how objects interact and what plausible sequences of motion are. these methods directly aim to predict pixel values, with either mse loss or adversarial loss.
in this paper, we take a different approach to the problem of next frame prediction. in particular, our model operates in the space of transformations between frames, directly modeling the source of variability. we exploit the assumption that the transformations of objects from frame to frame should be smooth, even when the pixel values are not. instead of predicting pixel values, we directly predict how objects transform. the key insight is that while there are many possible outputs, predicting one such transformation will yield motion that may not correspond to ground truth, yet will be realistic; see fig. 1. we therefore propose a transformation-based model that operates in the space of affine transforms. given the affine transforms of a few previous frames, the model learns to predict the local affine transforms that can be deterministically applied on the image patches of the previous frame to generate the next frame. the intuition is that estimation errors will lead to a slightly different yet plausible motion. note that this allows us to keep using the mse criterion, which is easy to optimize, as long as it is in transformation space. no blur in the pixel space will be introduced since the output of the transformation model is directly applied to the pixels, keeping sharp edges intact. refer to fig. 5 and our online material 1 for examples.
the other contribution of this work is the evaluation protocol. typically, generative models of video sequences are evaluated in terms of mse in pixel space (srivastava , 2015), which is not a good choice since this metric favors blurry predictions over other more realistic looking options that just happen to differ from the ground truth. instead, we propose to feed the generated frames to a video
∗work done as part of internship with fair 1see: http://joo.st/iclr/generationbenchmark
classifier trained on ground truth sequences. the idea is that the less the classifier’s performance is affected by the generates frames the more the model has preserved distinctive features and the more the generated sequences are plausible. regardless of whether they resemble the actual ground truth or not. this protocol treats the classifier as a black box to measure how well the generated sequences can serve as surrogate for the truth sequence for the classification task. in this paper we will validate our assumption that motion can be modelled by local affine transforms, after which we will compare our method with networks trained using adversarial training and simple regression on the output frame, using both this new evaluation protocol and by providing samples for qualitative inspection.
our experiments show that our simple and efficient model outperforms other baselines, including much more sophisticated models, on benchmarks on the ucf-101 data set (soomro , 2012). we also provide qualitative comparisons to the moving mnist digit data set (srivastava , 2015).early work on video modeling focused on predicting small patches (michalski , 2014; srivastava , 2015); unfortunately, these models have not shown to scale to the complexity of highresolution videos. also these models require a significant amount of parameters and computational power for even relatively simple data.
in ranzato  (2014), the authors circumvented this problem by quantizing the space of image patches. while they were able to predict a few high-resolution frames in the future, it seems dissatisfying to impose such a drastic assumption to simplify the prediction task.
mathieu  (2016) recently proposed to replace mse in pixel space with a mse on image gradients, leveraging prior domain knowledge, and further improved using a multi-scale architecture with adversarial training (goodfellow , 2014). while producing better results than earlier methods, the models used require a very large amount of computational power. we make an explicit comparison to this paper in the experiments section 3.
in oh  (2015), frames of a video game are predicted given an action (transformation) taken by the player. while the paper shows great results, the movement in a natural video cannot be described by a simple action and is therefore not widely applicable. finally, our work is also related to optical flow estimation (brox , 2004). instead of estimating the flow of pixels, here we estimate the flow of patches and separately predict how these patches transform in future frames.
prior work relating to the evaluation protocol can be found in yan  (2015). the authors generate images using a set of predefined attributes and later show that they can recover these using a pretrained neural network. our proposal extends this to videos, which is more complicated since both appearance and motion are needed for correct classification.the model we propose is based on three key assumptions: 1) just estimating object motion yields sequences that are plausible and relatively sharp, 2) global motion can be estimated by tiling highresolution video frames into patches and estimating motion “convolutionally” at the patch level, and 3) patches at the same spatial location over two consecutive time steps undergo a deformation which can be well described by an affine transformation.
the first assumption is at the core of the proposed method: by considering uncertainty in the space of transformations we produce sequences that may still look plausible. the other two assumptions state that a video sequence can be composed by patches undergoing affine transformations. we agree that these are simplistic assumptions, which ignore how object identity affects motion and do not account for out of plane rotations and more general forms of deformation. however, our qualitative and quantitative evaluation shows the efficacy of these assumptions to real video sequence as can be seen in section 3 and from visualizations in the supplementary material2.
our approach consists of three steps. first, we estimate affine transforms of every video sequence to build a training set for our model. second, we train a model that takes the past n affine transforms and predicts the next m affine transforms. finally, at test time, the model uses the predicted affine transforms to reconstruct pixel values of the generated sequence. we describe the details of each phase in the following sections.given a frame x and the subsequent frame y, the goal of the affine transform extractor is to learn mappings that can warp x into y. since different parts of the scene may undergo different transforms, we tile x into overlapping patches and infer a transformation for each patch. the estimation process couples the transformations at different spatial locations because we minimize the reconstruction error of the entire frame y, as opposed to treating each patch independently. see: http://joo.st/iclr/reconstructionsfromgroundtruth and http://joo.st/ iclr/generationbenchmark
let x and y have size dr ×dc. let image x be decomposed into a set of overlapping patches, each containing pixels from patches of size dr×dc with dr ≤ dr and dc ≤ dc. these patches are laid out on a regular grid with stride sr and sc pixels over rows and columns, respectively. therefore, every pixel participates in drsr dc sc
overlapping patches, not taking into account for the sake of simplicity border effects and non-integer divisions. we denote the whole set of overlapping patches by {xk}, where index k runs over the whole set of patches. similarly and using the same coordinate system, we denote by {yk} the set of overlapping patches of y. we assume that there is an affine mapping ak that maps xk to yk, for all values of k. ak is a 2 × 3 matrix of free parameters representing a generic affine transform (translation, rotation and scaling) between the coordinates of output and input frame. let ỹk be the transformed patches obtained when ak is applied to xk. since coordinates overlap between patches, we reconstruct y by averaging all predictions at the same location, yielding the estimate ỹ. the joint set of ak is then jointly determined by minimizing the mean squared reconstruction error between y and ỹ.
notice that our approach and aim differs from spatial transformer networks (jaderberg , 2015) since we perform this estimation off-line only for the input frames, computing one transform per patch.
in our experiments, we extracted 16 × 16 pixel patches from the input and we used stride 4 over rows and columns. the input patches are then matched at the output against smaller patches of size 8× 8 pixels, to account for objects moving in and out of the patch region.the affine transform predictor is used to predict the affine transforms between the last input frame and the next frame in the sequence. a schematic illustration of the system is shown in fig. 2. it receives as input the affine transforms between pairs of adjacent frames, as produced by the affine transform extractor described in the previous section. each transform is arranged in a grid of size 6 × n × n, where n is the number of patches in a row/column and 6 is the number of parameters of each affine transform. therefore, if four frames are used to initialize the model, the actual input consists of 18 maps of size n × n, which are the concatenation of at−2, at−1, at, where at is the collection of patch affine transforms between frame at time t− 1 and t. the model consists of a multi-layer convolutional network without any pooling. the network is the composition of convolutional layers with relu non-linearity, computing a component-wise thresholding as in v = max(0, u). we learn the parameters in the filters of the convolutional layers by minimizing the mean squared error between the output of the network and the target transforms.
notice that we do not add any regularization to the model. in particular, we rely on the convolutional structure of the model to smooth out predictions at nearby spatial locations.in the previous section, we described how to predict the set of affine transforms at the next time step. in practice, we would like to predict several time steps in the future.
a greedy approach would: a) train as described above to minimize the prediction error for the affine transforms at the next time step, and b) at test time, predict one step ahead and then re-circulate the model prediction back to the input to predict the affine transform two steps ahead, etc. unfortunately, errors may accumulate throughout this process because the model was never exposed to its own predictions at training time.
the approach we propose replicates the model over time, also during training as shown in fig. 3. if we wish to predict m steps in the future, we replicate the cnn m times and pass the output of the cnn at time step t as input to the same cnn at time step t + 1, as we do at test time. since predictions live in a continuous space, the whole system is differentiable and amenable to standard back-propagation of the error. since parameters of the cnn are shared across time, the overall system is equivalent to a peculiar recurrent neural network, where affine transforms play the role of recurrent states. the experiments in section 3 demonstrate that this method is more accurate and robust than the greedy approach.at test time, we wish to predict m frames in the future given the past n frames. after extracting the n − 1 affine transforms from the frames we condition upon, we replicate the model m times and feed its own prediction back to the input, as explained in the previous section.
once the affine transforms are predicted, we can reconstruct the actual pixel values. we use the last frame of the sequence and apply the first set of affine transforms to each patch in that frame. each pixel in the output frame is predicted multiple times, depending on the stride used. we average these predictions and reconstruct the whole frame. as required, we can repeat this process for as many frames as necessary, using the last reconstructed frame and the next affine transform.
in order to evaluate the generation, we propose to feed the generated frames to a trained classifier for a task of interest. for instance, we can condition the generation using frames taken from video clips which have been labeled with the corresponding action. the classifier has been trained on ground truth data but it is evaluated using frames fantasized by the generative model. the performance of the classifier on ground truth data is an upper bound on the performance of any generative model. this evaluation protocol does not penalize any generation that deviates from the ground truth, as standard mse would. it instead check that discriminative features and the overall semantics of the generated sequence is correct, which is ultimately what we are interested in.in this section, we validate the key assumptions made by our model and compare against state-ofthe-art generative models on two data sets. we strongly encourage the reader to watch the short video clips in the supplementary material to better understand the quality of our generations.
in section 2, we discussed the three key assumptions at the foundations of our model: 1) errors in the transformation space look still plausible, 2) a frame can be decomposed into patches, and 3) each patch motion is well modeled by an affine transform. the results in the supplementary material 3 validate assumption 2 and 3 qualitatively. every row shows a sequence from the ucf101 dataset (soomro , 2012). the column on the left shows the original video frames and the one on the right the reconstructions from the estimated affine transforms, as described in section 2.1. as you can see there is barely any noticeable difference between these video sequences, suggesting that video sequences can be very well represented as tiled affine transforms. for a quantitative comparison and for an assessment of how well the first assumption holds, please refer to section 3.2. see: http://joo.st/iclr/reconstructionsfromgroundtruth
in the next section, we will first report some results using the toy data set of “moving mnist digits” (srivastava , 2015). we then discuss generations of natural high-resolution videos using the ucf-101 dataset and compare to current state-of-the-art methods.for our first experiment, we used the dataset of moving mnist digits (srivastava , 2015) and perform qualitative analysis4. it consists of one or two mnist digits, placed at random locations and moving at constant speed inside a 64 × 64 frame. when a digit hits a boundary, it bounces, meaning that velocity in that direction is reversed. digits can occlude each other and bounce off walls, making the data set challenging.
using scripts provided by srivastava  (2015), we generated a fixed dataset of 128,000 sequences and used 80% for training, 10% for validation and 10% for testing. next, we estimated the affine transforms between every pair of adjacent frames to a total of 4 frames, and trained a small cnn in the space of affine transforms. the cnn has 3 convolutional layers and the following number of feature maps: 18, 32, 32, 6. all filters have size 3× 3. fig. 4 shows some representative test sequences and the model outputs. each subfigure corresponds to a sequence from the test set; the top row corresponds to the ground truth sequence while the bottom row shows the generations. the input to the cnn are three sets of affine transforms corresponding to the first four consecutive frames. the network predicts the next six sets of affine transforms from which we reconstruct the corresponding frames. these results should be compared to fig. 5 in srivastava  (2015). the generations in fig. 4 show that the model has potential to represent and generate video sequences, it learns to move digits in the right direction, to bounce them, and it handles multiple digits well except when occluion makes inputs too ambiguous. the model’s performance is analyzed quantitatively in the next section using high resolution natural videos.the ucf-101 dataset (soomro , 2012) is a collection of 13320 videos of 101 action categories. frames have size 240× 320 pixels. we train a cnn on patches of size 64× 64 pixels; the cnn has 6 convolutional layers and the following number of feature maps: 18, 128, 128, 128, 64, 32, 16, 6. all filters have size 3 × 3. the optimal number of filters has been found using cross-validation in order to minimize the estimation error of the affine transform parameters. unless otherwise stated, we condition generation on 4 ground truth frames and we predict the following 8 frames.
we evaluate several models5: a) a baseline which merely copies the last frame used for conditioning, b) a baseline method which estimates optical flow (brox , 2004) from two consecutive frames a quantitative analysis would be difficult for this data set because metrics reported in the literature like mse (srivastava , 2015) are not appropriate for measuring generation quality, and it would be difficult to use the metric we propose because we do not have labels at the sequence level and the design of a classifier is not trivial. unfortunately, we could not compare against the lstm-based method in srivastava  (2015) because it does not scale to high-resolution videos, but only to small patches.
and extrapolates flow in subsequent frames under the assumption of constant flow speed, c) an adversarially trained multi-scale cnn (mathieu , 2016) and several variants of our proposed approach.
qualitative comparisons can be seen in the fig. 5 and in the supplementary material6. the first column on the page shows the input, the second the ground truth, followed by results from our model, mathieu  (2016) and optical flow (brox , 2004). note especially the severe deformations in the last two columns, while our model keeps the frame recognizable. it produces fairly sharp reconstructions validating our first hypothesis that errors in the space of transformations still yield plausible reconstructions (see section 2). however it is also apparent that our approach underestimates movement, which follows directly from using the mse criterion. as discussed before, mse in pixel space leads to blurry results, however using mse in transformation space also has some drawbacks. in practice, the model will predict the average of several likely transformations, which could lead to an understimation of the true movement. see: http://joo.st/iclr/generationbenchmark
in order to quantify the generation quality we use the metric described in section 2.4. we use c3d network (tran , 2015) as the video action classifier: c3d uses both appearance and temporal information jointly, and is pre-trained with sports1m (karpathy , 2014) and fine tuned on ucf 101. due to the model constraints, we trained only two models, that takes 4 and 8 frames as input, respectively.
we evaluate the quality of generation using 4 (the first four predicted frames) and the whole set of 8 predicted frames, for the task of action classification. at test time, we generate frames from each model under consideration, and then use them as input to the corresponding c3d network.
table 1 shows the accuracy of our approach and several baselines. the best performance is achieved by using ground truth frames, a result comparable to methods recently appeared in the literature (karpathy , 2014; tran , 2015). we see that for ground truth frames, the number of frames (4 or 8) doesn’t make a difference. there is not much additional temporal or spatial signal provided by having greater than four frames. next, we evaluate how much we lose by representing frames as tiled affine transforms. as the second row shows there is negligible if any loss of accuracy when using frames reconstructed from the estimated affine transforms (using the method described in section 2.1), validating our assumptions at the beginning of section 2 on how video sequences can be represented. the next question is then whether these affine transforms are predictable at all. the last two rows of table 1 show that this is indeed the case, to some extent. the longer the sequence of generated frames the poorer the performance, since the generation task gets more and more difficult.
compared to other methods, our approach performs better than optical flow and even the more sophisticated multi-scale cnn proposed in mathieu  (2016) while being computationally cheaper. for instance, our method has less than half a million parameters and requires about 2g floating point operations to generate a frame at test time, while the multi-scale cnn of mathieu  (2016) has 25 times more parameters (not counting the discriminator used at training time) and it requires more than 100 times more floating point operations to generate a single frame.
finally, we investigate the robustness of the system to its hyper-parameters: a) choice of patch size, b) number of input frames, and c) number of predicted frames. the results reported in table 2 demonstrate that the model is overall pretty robust to these choices. using patch sizes that are too big makes reconstructions blocky but within each block motion is coherent. smaller patch sizes give more flexibility but make the prediction task harder as well. mapping into patches of size smaller than 16 × 16 seems a good choice. using only 2 input frames does not seem to provide enough context to the predictor, but anything above 3 works equally well. training for prediction of the next frame works well, but better results can be achieved by training to predict several frames in the future, overall when evaluating longer sequences.in this work, we proposed a new approach to generative modeling of video sequences. this model does not make any assumption about the spatio-temporal resolution of video sequences nor about object categories. the key insight of our approach is to model in the space of transformations as opposed to raw pixel space. a priori we lack a good metric to measure how well a frame is reconstructed under uncertainty due to objects motion in natural scenes. uncertainty about object motion and occlusions causes blurry generations when using mse in pixel space. instead, by operating in the space of transformations we aim at predicting how objects move, and estimation errors only yield a different, and possibly still plausible, motion. with this motivation we proposed a simple cnn operating in the space of affine transforms and we showed that it can generate sensible sequences up to about 4 frames. this model produces sequences that are both visually and quantitatively better than previously proposed approaches.
the second contribution of this work is the metric to compare generative models of video sequences. a good metric should not penalize a generative model for producing a sequence which is plausible but different from the ground truth. with this goal in mind and assuming we have at our disposal labeled sequences, we can first train a classifier using ground truth sequences. next, the classifier is fed with sequences produced by our generative model for evaluation. a good generative model should produce sequences that still retain discriminative features. in other words, plausibility of generation is assessed in terms of how well inherent information is preserved during generation as opposed to necessarily and merely reproducing the ground truth sequences.
the proposed model is relatively simple; straightforward extensions that could improve its prediction accuracy are the use of a multi-scale architecture and the addition of recurrent units. these would enable a better modeling of objects of different sizes moving at varying speeds and to better capture complex temporal dynamics (e.g., cyclical movements like walking). a larger extension would be the addition of an appearance model, which together with our explicit transformation model could lead to learning better feature representations for classification.
in our view, the proposed approach should be considered as a stronger baseline for future research into next frame prediction. even though our analysis shows improved performance and better looking generations, there are also obvious limitations. the first such limitation is the underestimation of transformations due to usage of the mse as a criterion. we consider two main avenues worth pursuing in this space. first, we consider modelling a distribution of transformations and sampling one from it. the challenge of this approach is to sample a consistent trajectory. one could model the distribution of an entire trajectory, but that is a complex optimization problem. a second option is to use adversarial training to force the model to pick a plausible action. this option does not guarantee that underestimation of movement will be avoided. this will depend on the discriminator model accepting this as a plausible option.
another limitation is that the current model does not factor out the “what” from the “where”, appearance from motion. the representation of two distinct objects subject to the same motion, as well as the representation of the same object subject to two different motion patterns are intrinsically different. instead, it would be more powerful to learn models that can discover such factorization and leverage it to produce more efficient and compact representations.authors thank camille couprie and michael mathieu for discussions and helping with evaluation of their models.",0
632.pdf.json,"there is a growing interest in incorporating external memory into neural networks. for example, memory networks (weston , 2014; sukhbaatar , 2015) are equipped with static memory slots that are content or location addressable. neural turing machines (graves , 2014) implement memory slots that can be read and written as in turing machines (turing, 1938) but through differentiable attention mechanism.
each memory slot in these models stores a vector corresponding to a continuous representation of the memory content. in order to recall a piece of information stored in memory, attention is typically employed. attention mechanism introduced by bahdanau  (2014) uses a network that outputs a discrete probability mass over memory items. a memory read can be implemented as a weighted sum of the memory vectors in which the weights are given by the attention network. reading out a single item can be realized as a special case in which the output of the attention network is peaked at the desired item. the attention network may depend on the current context as well as the memory item itself. the attention model is called location-based and content-based, if it depends on the location in the memory and the stored memory vector, respectively.
knowledge bases, such as wordnet and freebase, can also be stored in memory either through an explicit knowledge base embedding (bordes , 2011; nickel , 2011; socher , 2013) or through a feedforward network (bordes , 2015).
when we embed entities from a knowledge base in a continuous vector space, if the capacity of the embedding model is appropriately controlled, we expect semantically similar entities to be close to each other, which will allow the model to generalize to unseen facts. however the notion of proximity may strongly depend on the type of a relation. for example, benjamin franklin was an engineer but also a politician. we would need different metrics to capture his proximity to other engineers and politicians of his time.
in this paper, we propose a new attention model for content-based addressing. our model scores each item vitem in the memory by the (logarithm of) multivariate gaussian likelihood as follows:
score(vitem) = log φ(vitem|µcontext,σcontext)
= −1 2 (vitem − µcontext)σ −1 context(vitem − µcontext) + const. (1)
where context denotes all the variables that the attention depends on. for example, “american engineers in the 18th century” or “american politicians in the 18th century” would be two contexts that include benjamin franklin but the two attentions would have very different shapes.
compared to the (normalized) inner product used in previous work (sukhbaatar , 2015; graves , 2014) for content-based addressing, the gaussian model has the additional control of the spread of the attention over items in the memory. as we show in figure 1, we can view the conventional inner-product-based attention and the proposed gaussian attention as addressing by an affine energy function and a quadratic energy function, respectively. by making the addressing mechanism more complex, we may represent many entities in a relatively low dimensional embedding space. since knowledge bases are typically extremely sparse, it is more likely that we can afford to have a more complex attention model than a large embedding dimension.
we apply the proposed gaussian attention model to question answering based on knowledge bases. at the high-level, the goal of the task is to learn the mapping from a question about objects in the knowledge base in natural language to a probability distribution over the entities. we use the scoring function (1) for both embedding the entities as vectors, and extracting the conditions mentioned in the question and taking a conjunction of them to score each candidate answer to the question.
the ability to compactly represent a set of objects makes the gaussian attention model well suited for representing the uncertainty in a multiple-answer question (e.g., “who are the children of abraham lincoln?”). moreover, traversal over the knowledge graph (see guu , 2015) can be naturally handled by a series of gaussian convolutions, which generalizes the addition of vectors. in fact, we model each relation as a gaussian with mean and variance parameters. thus a traversal on a relation corresponds to a translation in the mean and addition of the variances.
the proposed question answering model is able to handle not only the case where the answer to a question is associated with an atomic fact, which is called simple q&a (bordes , 2015), but also questions that require composition of relations (path queries in guu  (2015)) and conjunction of queries. an example flow of how our model deals with a question “who plays forward for borussia dortmund?” is shown in figure 2 in section 3.
this paper is structured as follows. in section 2, we describe how the gaussian scoring function (1) can be used to embed the entities in a knowledge base into a continuous vector space. we call our model transgaussian because of its similarity to the transe model proposed by bordes  (2013). then in section 3, we describe our question answering model. in section 4, we carry out experiments on worldcup2014 dataset we collected. the dataset is relatively small but it allows us to evaluate not only simple questions but also path queries and conjunction of queries. the proposed transgaussian embedding with the question answering model achieves significantly higher accuracy than the vanilla transe embedding or transe trained with compositional relations guu  (2015) combined with the same question answering model.in this section, we describe the proposed transgaussian model based on the gaussian attention model (1). while it is possible to train a network that computes the embedding in a single pass (bordes , 2015) or over multiple passes (li , 2015), it is more efficient to offload the embedding as a separate step for question answering based on a large static knowledge base.let e be the set of entities and r be the set of relations. a knowledge base is a collection of triplets (s, r, o), where we call s ∈ e , r ∈ r, and o ∈ e , the subject, the relation, and the object of the triplet, respectively. each triplet encodes a fact. for example, (albert einstein,has profession,theoretical physicist). all the triplets given in a knowledge base are assumed to be true. however generally speaking a triplet may be true or false. thus knowledge base embedding aims at training a model that predict if a triplet is true or not given some parameterization of the entities and relations (bordes , 2011; 2013; nickel , 2011; socher , 2013; wang , 2014).
in this paper, we associate a vector vs ∈ rd with each entity s ∈ e , and we associate each relation r ∈ r with two parameters, δr ∈ rd and a positive definite symmetric matrix σr ∈ rd×d++ . given subject s and relation r, we can compute the score of an object o to be in triplet (s, r, o) using the gaussian attention model as (1) with
score(s, r, o) = log φ(vo|µcontext,σcontext), (2) where µcontext = vs + δr, σcontext = σr. note that if σr is fixed to the identity matrix, we are modeling the relation of subject vs and object vo as a translation δr, which is equivalent to the transe model (bordes , 2013). we allow the covariance σr to depend on the relation to handle one-to-many relations (e.g., profession has person relation) and capture the shape of the distribution of the set of objects that can be in the triplet. we call our model transgaussian because of its similarity to transe (bordes , 2013).
parameterization for computational efficiency, we will restrict the covariance matrix σr to be diagonal in this paper. furthermore, in order to ensure that σr is strictly positive definite, we employ the exponential linear unit (elu, clevert , 2015) and parameterize σr as follows:
σr = diag
( elu(mr,1)+1+
. . . elu(mr,d)+1+ ) where mr,j (j = 1, . . . , d) are the unconstrained parameters that are optimized during training and is a small positive value that ensure the positivity of the variance during numerical computation. the elu is defined as
elu(x) = { x, x ≥ 0, exp (x)− 1, x < 0.
ranking loss suppose we have a set of triplets t = {(si, ri, oi)}ni=1 from the knowledge base. let n (s, r) be the set of incorrect objects to be in the triplet (s, r, ·). our objective function uses the ranking loss to measure the margin between the scores of true answers and those of false answers and it can be written as follows:
min {ve:e∈e},
{δr,mr,:r∈r̄} 
n ∑ (s,r,o)∈t et′∼n (s,r) [ [µ− score(s, r, o) + score(s, r, t′)]+ ]
+ λ ∑ e∈e ‖ve‖22 + ∑ r∈r̄ ( ‖δr‖22 + ‖m r‖2f ) , (3) where, n = |t |, µ is the margin parameter and m r denotes the diagonal matrix with mr,j , j = 1, . . . , d on the diagonal; the function [·]+ is defined as [x]+ = max(0, x). here, we treat an inverse
relation as a separate relation and denote by r̄ = r∪r−1 the set of all the relations including both relations in r and their inverse relations; a relation r̃ is the inverse relation of r if (s, r̃, o) implies (o, r, s) and vice versa. moreover, et′∼n (s,r) denotes the expectation with respect to the uniform distribution over the set of incorrect objects, which we approximate with 10 random samples in the experiments. finally, the last terms are `2 regularization terms for the embedding parameters.guu  (2015) has recently shown that training transe with compositional relations can make it competitive to more complex models, although transe is much simpler compared to for example, neural tensor networks (ntn, socher  (2013)) and transh wang  (2014). here, a compositional relation is a relation that is composed as a series of relations in r, for example, grand father of can be composed as first applying the parent of relation and then the father of relation, which can be seen as a traversal over a path on the knowledge graph.
transgaussian model can naturally handle and propagate the uncertainty over such a chain of relations by convolving the gaussian distributions along the path. that is, the score of an entity o to be in the τ -step relation r1/r2/ · · · /rτ with subject s, which we denote by the triplet (s, r1/r2/ · · · /rτ , o), is given as
score(s, r1/r2/ · · · /rτ , o) = log φ(vo|µcontext,σcontext), (4) with µcontext = vs + ∑τ t=1 δrt , σcontext = ∑τ t=1 σrt , where the covariance associated with each relation is parameterized in the same way as in the previous subsection. training with compositional relations let p = {( si, ri1/ri2/ · · · /rili , oi )}n ′ i=1
be a set of randomly sampled paths from the knowledge graph. here relation rik in a path can be a relation in r or an inverse relation in r−1. with the scoring function (4), the generalized training objective for compositional relations can be written identically to (3) except for replacing t with t ∪ p and replacing n with n ′ = |t ∪ p|.given a set of question-answer pairs, in which the question is phrased in natural language and the answer is an entity in the knowledge base, our goal is to train a model that learns the mapping from the question to the correct entity. our question answering model consists of three steps, entity recognition, relation composition, and conjunction. we first identify a list of entities mentioned in the question (which is assumed to be provided by an oracle in this paper). if the question is “who plays forward for borussia dortmund?” then the list would be [forward, borussia dortmund]. the next step is to predict the path of relations on the knowledgegraph starting from each entity in the list extracted in the first step. in the above example, this will be (smooth versions of) /forward/position played by/ and /borussia dortmund/has player/ predicted as series of gaussian convolutions. in general, we can have multiple relations appearing in each path. finally, we take a product of all the gaussian attentions and renormalize it, which is equivalent to bayes’ rule with independent observations (paths) and a noninformative prior.we assume that there is an oracle that provides a list containing all the entities mentioned in the question, because (1) a domain specific entity recognizer can be developed efficiently (williams , 2015) and (2) generally entity recognition is a challenging task and it is beyond the scope of this paper to show whether there is any benefit in training our question answering model jointly with a entity recognizer. we assume that the number of extracted entities can be different for each question.we train a long short-term memory (lstm, hochreiter & schmidhuber, 1997) network that emits an output ht for each token in the input sequence. then we compute the attention over the hidden
states for each recognized entity e as
pt,e = softmax (f(ve,ht)) (t = 1, . . . , t ),
where ve is the vector associated with the entity e. we use a two-layer perceptron for f in our experiments, which can be written as follows:
f(ve,ht) = u > f relu (w f,vve +w f,hht + b1) + b2,
wherew f,v∈rl×d,w f,h∈rl×h , b1 ∈ rl, uf ∈ rl, b2 ∈ r are parameters. here relu(x)= max(0, x) is the rectified linear unit. finally, softmax denotes softmax over the t tokens.
next, we use the weights pt,e to compute the weighted sum over the hidden states ht as oe = ∑t
t=1 pt,eht. (5)
then we compute the weights αr,e over all the relations as αr,e = relu ( w>r oe ) (∀r ∈ r ∪ r−1). here the rectified linear unit is used to ensure the positivity of the weights. note however that the weights should not be normalized, because we may want to use the same relation more than once in the same path. making the weights positive also has the effect of making the attention sparse and interpretable because there is no cancellation.
for each extracted entity e, we view the extracted entity and the answer of the question to be the subject and the object in some triplet (e, p, o), respectively, where the path p is inferred from the question as the weights αr,e as we described above. accordingly, the score for each candidate answer o can be expressed using (1) as:
scoree(vo) = log φ(vo|µe,α,kb,σe,α,kb) (6) with µe,α,kb = ve + ∑ r∈r̄ αr,eδr, σe,α,kb = ∑ r∈r̄ α 2 r,eσr, where ve is the vector associated with entity e and r̄ = r∪r−1 denotes the set of relations including the inverse relations.let e(q) be the set of entities recognized in the question q. the final step of our model is to take the conjunction of the gaussian attentions derived in the previous step. this step is simply carried out by multiplying the gaussian attentions as follows:
score(vo|e(q),θ) = log ∏
e∈e(q)
φ(vo|µe,α,kb,σe,α,kb)
= −1 2 ∑ e∈e(q) ( vo − µe,α,kb )> σ−1e,α,kb(vo − µe,α,kb) + const., (7)
which is again a (logarithm of) gaussian scoring function, where µe,α,kb and σe,α,kb are the mean and the covariance of the gaussian attention given in (6). here θ denotes all the parameters of the question-answering model.suppose we have a knowledge base (e ,r, t ) and a trained transgaussian model( {ve}e∈e , {(δr,σr)}r∈r̄ ) , where r̄ is the set of all relations including the inverse relations. during training time, we assume the training set is a supervised question-answer pairs {(qi, e(qi), ai) : i = 1, 2, . . . ,m}. here, qi is a question formulated in natural language, e(qi) ⊂ e is a set of knowledge base entities that appears in the question, and ai ∈ e is the answer to the question. for example, on a knowledge base of soccer players, a valid training sample could be
(“who plays forward for borussia dortmund?”,[forward,borussia dortmund], marco reus).
note that the answer to a question is not necessarily unique and we allow ai to be any of the true answers in the knowledge base. during test time, our model is shown (qi, e(qi)) and the task is to find ai. we denote the set of answers to qi by a(qi).
to train our question-answering model, we minimize the objective function 
m m∑ i=1 ( e t′∼n (qi) [ [µ− score(vai |e(qi),θ) + score(vt′ |e(qi),θ)]+ ] + ν ∑ e∈e(qi) ∑ r∈r̄ |αr,e| ) + λ‖θ‖22
where et′∼n (qi) is expectation with respect to a uniform distribution over of all incorrect answers to qi, which we approximate with 10 random samples. we assume that the number of relations implied in a question is small compared to the total number of relations in the knowledge base. hence the coefficients αr,e computed for each question qi are regularized by their `1 norms.as a demonstration of the proposed framework, we perform question and answering on a dataset of soccer players. in this work, we consider two types of questions. a path query is a question that contains only one named entity from the knowledge base and its answer can be found from the knowledge graph by walking down a path consisting of a few relations. a conjunctive query is a question that contains more than one entities and the answer is given as the conjunction of all path queries starting from each entity. furthermore, we experimented on a knowledge base completion task with transgaussian embeddings to test its capability of generalization to unseen fact. since knowledge base completion is not the main focus of this work, we include the results in the appendix.we build a knowledge base of football players that participated in fifa world cup 2014 1. the original dataset consists of players’ information such as nationality, positions on the field and ages etc. we picked a few attributes and constructed 1127 entities and 6 atomic relations. the entities include 736 players, 297 professional soccer clubs, 51 countries, 39 numbers and 4 positions. and the six atomic relations are the original dataset can be found at https://datahub.io/dataset/fifa-world-cup-2014-all-players.
plays in club: player→ club, plays position: player→ position, is aged: player→ number, wears number 2: player→ number, plays for country: player→ country, is in country: club→ country,
where player, club, number, etc, denote the type of entities that can appear as the left or right argument for each relation. some relations share the same type as the right argument, e.g., plays for country and is in country.
given the entities and relations, we transformed the dataset into a set of 3977 triplets. a list of sample triplets can be found in the appendix. based on these triplets, we created two sets of question answering tasks which we call path query and conjunctive query respectively. the answer of every question is always an entity in the knowledge base and a question can involve one or two triplets. the questions are generated as follows.
path queries. among the paths on the knowledge graph, there are some natural composition of relations, e.g., plays in country (player → country) can be decomposed as the composition of plays in club (player→ club) and is in country (club→ country). in addition to the atomic relations, we manually picked a few meaningful compositions of relations and formed query templates, which takes the form “find e ∈ e , such that (s, p, e) is true”, where s is the subject and p can be an atomic relation or a path of relations. to formulate a set of path-based question-answer pairs, we manually created one or more question templates for every query template (see table 5) then, for a particular instantiation of a query template with subject and object entities, we randomly select a question template to generate a question given the subject; the object entity becomes the answer of the question. see table 6 for the list of composed relations, sample questions, and answers. note that all atomic relations in this dataset are many-to-one while these composed relations can be one-to-many or many-to-many as well.
conjunctive queries. to generate question-and-answer pairs of conjunctive queries, we first picked three pairs of relations and used them to create query templates of the form “find e ∈ e , such that both (s1, r1, e) and (s2, r2, e) are true.” (see table 5). for a pair of relations r1 and r2, we enumerated all pairs of entities s1, s2 that can be their subjects and formulated the corresponding query in natural language using question templates as in the same way as path queries. see table 7 for a list of sample questions and answers.
as a result, we created 8003 question-and-answer pairs of path queries and 2208 pairs of conjunctive queries which are partitioned into train / validation / test subsets. we refer to table 1 for more statistics about the dataset. templates for generating the questions are list in table 5.to perform question and answering under our proposed framework, we first train the transgaussian model on worldcup2014 dataset. in addition to the atomic triplets, we randomly sampled 50000 paths with length 1 or 2 from the knowledge graph and trained a transgaussian model compositionally as described in set 2.2. an inverse relation is treated as a separate relation. following the naming convention from guu  (2015), we denote this trained embedding by transgaussian (comp). we found that the learned embedding possess some interesting properties. some dimensions of the embedding space dedicate to represent a particular relation. players are clustered by their attributes when entities’ embeddings are projected to the corresponding lower dimensional subspaces. we elaborate and illustrate such properties in the appendix.
baseline methods we also trained a transgaussian model only on the atomic triplets and denote such a model by transgaussian (single). since no inverse relation was involved when transgaussian (single) was trained, to use this embedding in question answering tasks, we represent the inverse relations as follows: for each relation r with mean δr and variance σr, we model its inverse r−1 as a gaussian attention with mean −δr and variance equal to σr. we also trained transe models on worldcup2014 dataset by using the code released by the authors of guu  (2015). likewise, we use transe (single) to denote the model trained with atomic triplets only and use transe (comp) to denote the model trained with the union of triplets and paths. note that transe can be considered as a special case of transgaussian where the variance matrix is the identity and hence, the scoring formula eq. (7) is applicable to transe as well.
training configurations for all models, dimension of entity embeddings was set to 30. the hidden size of lstm was set to 80. word embeddings were trained jointly with the question answering model and dimension of word embedding was set to 40. we employed adam (kingma & ba, 2014) as the optimizer. all parameters were tuned on the validation set. under the same setting, we experimented with two cases: first, we trained models for path queries and conjunctive queries separately; furthermore, we trained a single model that addresses both types queries. we present the results of the latter case in the next subsection while the results of the former are included in the appendix.
evaluation metrics during test time, our model receives a question in natural language and a list of knowledge base entities contained in the question. then it predicts the mean and variance of a gaussian attention formulated in eq. (7) which is expected to capture the distribution of all positive answers. we rank all entities in the knowledge base by their scores under this gaussian attention. next, for each entity which is a correct answer, we check its rank relative to all incorrect answers and call this rank the filtered rank. for example, if a correct entity is ranked above all negative answers except for one, it has filtered rank two. we compute this rank for all true answers and report mean filtered rank and h@1 which is the percentage of true answers that have filtered rank 1.we present the results of joint learning in table 2. these results show that transgaussian works better than transe in general. in fact, transgaussian (comp) achieved the best performance in almost all aspects. most notably, it achieved the highest h@1 rates on challenging questions such as “where is the club that edin dzeko plays for?” (#11, composition of two relations) and “who are the defenders on german national team?” (#14, conjunction of two queries).
the same table shows that transgaussian benefits remarkably from compositional training. for example, compositional training improved transgaussian’s h@1 rate by near 60% in queries on players from a given countries (#8) and queries on players who play a particular position (#9). it also boosted transgaussian’s performance on all conjunctive quries (#13–#15) significantly.
to understand transgaussian (comp)’s weak performance on answering queries on the professional football club located in a given country (#10) and queries on professional football club that has players from a particular country (#12), we tested its capability of modeling the composed relation by feeding the correct relations and subjects during test time. it turns out that these two relations were not modeled well by transgaussian (comp) embedding, which limits its performance in question answering. (see table 8 in the appendix for quantitative evaluations.) the same limit was found in the other three embeddings as well.
note that all the models compared in table 2 uses the proposed gaussian attention model because transe is the special case of transgaussian where the variance is fixed to one. thus the main differences are whether the variance is learned and whether the embedding was trained compositionally. finally, we refer to table 9 and 10 in the appendix for experimental results of models trained on path and conjunctive queries separately.the work of vilnis & mccallum (2014) is similar to our gaussian attention model. they discuss many advantages of the gaussian embedding; for example, it is arguably a better way of handling asymmetric relations and entailment. however the work was presented in the word2vec (mikolov , 2013)-style word embedding setting and the gaussian embedding was used to capture the diversity in the meaning of a word. our gaussian attention model extends their work to a more general setting in which any memory item can be addressed through a concept represented as a gaussian distribution over the memory items.
bordes  (2014; 2015) proposed a question-answering model that embeds both questions and their answers to a common continuous vector space. their method in bordes  (2015) can combine multiple knowledge bases and even generalize to a knowledge base that was not used during training. however their method is limited to the simple question answering setting in which the answer of each question associated with a triplet in the knowledge base. in contrast, our method can handle both composition of relations and conjunction of conditions, which are both naturally enabled by the proposed gaussian attention model.
neelakantan  (2015a) proposed a method that combines relations to deal with compositional relations for knowledge base completion. their key technical contribution is to use recurrent neural networks (rnns) to encode a chain of relations. when we restrict ourselves to path queries, question answering can be seen as a sequence transduction task (graves, 2012; sutskever , 2014) in which the input is text and the output is a series of relations. if we use rnns as a decoder, our model would be able to handle non-commutative composition of relations, which the current weighted convolution cannot handle well. another interesting connection to our work is that they take the maximum of the inner-product scores (see also weston , 2013; neelakantan , 2015b), which are computed along multiple paths connecting a pair of entities. representing a set as a collection of vectors and taking the maximum over the inner-product scores is a natural way to represent a set of memory items. the gaussian attention model we propose in this paper, however, has the advantage of differentiability and composability.in this paper, we have proposed the gaussian attention model which can be used in a variety of contexts where we can assume that the distance between the memory items in the latent space is compatible with some notion of semantics. we have shown that the proposed gaussian scoring function can be used for knowledge base embedding achieving competitive accuracy. we have also shown that our embedding model can naturally propagate uncertainty when we compose relations together. our embedding model also benefits from compositional training proposed by guu  (2015). furthermore, we have demonstrated the power of the gaussian attention model in a challenging question answering problem which involves both composition of relations and conjunction of queries. future work includes experiments on natural question answering datasets and end-to-end training including the entity extractor.the authors would like to thank daniel tarlow, nate kushman, and kevin gimpel for valuable discussions.we trained our transgaussian model on triplets and paths from worldcup2014 dataset and illustrated the embeddings in fig 3 and 4. recall that we modeled every relation as a gaussian with diagonal covariance matrix. fig 3 shows the learned variance parameters of different relations. each row corresponds to the variances of one relation. columns are permuted to reveal the block structure. from this figure, we can see that every relation has a small variance in two or more dimensions. this implies that the coordinates of the embedding space are partitioned into semantically coherent clusters each of which represent a particular attribute of a player (or a football club). to verify this further, we picked the two coordinates in which a relation (e.g. plays position) has the least variance and projected the embedding of all valid subjects and objects (e.g. players and positions) of the relation to this 2 dimensional subspace. see fig. 4. the relation between the subjects and the objects are simply translation in the projection when the corresponding subspace is two dimensional (e.g., plays position relation in fig. 4 (a)). the same is true for other relations that requires larger dimension but it is more challenging to visualize in two dimensions. for relations that have a large number of unique objects, we only plotted for the eight objects with the most subjects for clarity of illustration.
furthermore, in order to elucidate whether we are limited by the capacity of the transgaussian embedding or the ability to decode question expressed in natural language, we evaluated the test question-answer pairs using the transgaussian embedding composed according to the ground-truth relations and entities. the results were evaluated with the same metrics as in sec. 4.3. this estimation is conducted for transe embeddings as well. see table 8 for the results. compared to table 2, the accuracy of transgaussian (comp) is higher on the atomic relations and path queries but lower on conjunctive queries. this is natural because when the query is simple there is not much room for the question-answering network to improve upon just combining the relations according to the ground truth relations, whereas when the query is complex the network could combine the embedding in a more creative way to overcome its limitation. in fact, the two queries (#10 and #12) that transgaussian (comp) did not perform well in table 2 pertain to a single relation is in country−1 (#10) and a composition of two relations plays for country−1 / plays in club (#12). the performance of the two queries were low even when the ground truth
relations were given, which indicates that the transgaussian embedding rather than the questionanswering network is the limiting factor.knowledge base completion has been a common task for testing knowledge base models on their ability of generalizing to unseen facts. here, we apply our transgaussian model to a knowledge completion task and show that it has competitive performance.
we tested on the subset of wordnet released by guu  (2015). the atomic triplets in this dataset was originally created by socher  (2013) and guu  (2015) added path queries that were randomly sampled from the knowledge graph. we build our transgaussian model by training on these triplets and paths and tested our model on the same link prediction task as done by socher  (2013); guu  (2015).
as done by guu  (2015), we trained transgaussian (single) with atomic triplets only and trained transgaussian (comp) with the union of atomic triplets and paths. we did not incorporate
word embedding in this task and each entity is assigned its individual vector. without getting parameters tuned too much, transgaussian (comp) obtained accuracy comparable to transe (comp). see table 11.",0
648.pdf.json,"deep neural networks have yielded dramatic performance gains in recent years on tasks such as object classification (krizhevsky , 2012), text classification (zhang , 2015) and machine translation (sutskever , 2014; bahdanau , 2015). these successes are heavily dependent on large training sets of manually annotated data. in many settings however, such large collections of labels may not be readily available, motivating the need for methods that can learn from data where labels are rare.
we propose a method for harnessing unlabeled image data based on image in-painting. a generative model is trained to generate pixels within a missing hole, based on the context provided by surrounding parts of the image. these in-painted images are then used in an adversarial setting (goodfellow , 2014) to train a large discriminator model whose task is to determine if the image was real (from the unlabeled training set) or fake (an in-painted image). the realistic looking fake examples provided by the generative model cause the discriminator to learn features that generalize to the related task of classifying objects. thus adversarial training for the in-painting task can be used to regularize large discriminative models during supervised training on a handful of labeled images.learning from context: the closest work to ours is the independently developed context-encoder approach of pathak  (2016). this introduces an encoder-decoder framework, shown in fig. 1(a), that is used to in-paint images where a patch has been randomly removed. after using this as a pre-training task, a classifier is added to the encoder and the model is fine-tuned using the labeled examples. although both approaches use the concept of in-painting, they differ in several important ways. first, the architectures are different (see fig. 1): in pathak  (2016), the features for the classifier are taken from the encoder, whereas ours come from the discriminator network. in practice this makes an important difference as we are able to directly train large models such as vgg (simonyan & zisserman, 2015) using adversarial loss alone. by contrast, pathak  (2016) report difficulties in training an alexnet encoder with this loss. this leads to the second difference, namely that on account of these issues, they instead employ an `2 loss when training models for classification and detection (however they do use a joint `2 and adversarial loss to achieve impressive in-painting results). finally, the unsupervised learning task differs between the two models. the context-encoder learns a feature representation suitable for in-painting whereas our model learns a feature representation suitable for differentiating real/fake in-paintings. notably, while we also use a neural network to generate the in-paintings, this model is only used as an adversary for the
discriminator, rather than as a feature extractor. in section 4, we compare the performance of our model to the context-encoder on the pascal dataset.
other forms of spatial context within images have recently been utilized for representation learning. doersch  (2015) propose training a cnn to predict the spatial location of one image patch relative to another. noroozi & favaro (2016) propose a model that learns by unscrambling image patches, essentially solving a jigsaw puzzle to learn visual representations. in the text domain, context has been successfully leveraged as an unsupervised criterion for training useful word and sentence level representations (collobert , 2011; mikolov , 2015; kiros , 2015).
deep unsupervised and semi-supervised learning: a popular method of utilizing unlabeled data is to layer-wise train a deep autoencoder or restricted botlzmann machine (hinton , 2006) and then fine tune with labels on a discriminative task. more recently, several autoencoding variants have been proposed for unsupervised and semi-supervised learning, such as the ladder network (rasmus , 2015), stacked what-where autoencoders (zhao , 2016) and variational autoencoders (kingma & welling, 2014; kingma , 2014).
dosovitskiy  (2014) achieved state-of-the-art results by training a cnn with a different class for each training example and introducing a set of transformations to provide multiple examples per class. the pseudo-label approach (lee, 2013) is a simple semi-supervised method that trains using the maximumly predicted class as a label when labels are unavailable. springenberg (2015) propose a categorical generative adversarial network (catgan) which can be used for unsupervised and semi-supervised learning. the discriminator in a catgan outputs a distribution over classes and is trained to minimize the predicted entropy for real data and maximize the predicted entropy for fake data. similar to our model, catgans use the feature space learned by the discriminator for the final supervised learning task. salimans  (2016) recently proposed a semi-supervised gan model in which the discriminator outputs a softmax over classes rather than a probability of real vs. fake. an additional ‘generated’ class is used as the target for generated samples. this method differs from our work in that it does not utilize context information and has only been applied to datasets of small resolution. however, the discriminator loss is similar to the one we propose and could be combined with our context-conditional approach.
more traditional semi-supervised methods include graph-based approaches (zhou , 2004; zhu, 2006) that show impressive performance when good image representations are available. however, the focus of our work is on learning such representations.
generative models of images: restricted boltzmann machines (salakhutdinov, 2015), de-noising autoencoders (vincent , 2008) and variational autoencoders (kingma & welling, 2014) optimize a maximum likelihood criterion and thus learn decoders that map from latent space to image space. more recently, generative adversarial networks (goodfellow , 2014) and generative moment matching networks (li , 2015; dziugaite , 2015) have been proposed. these methods ignore data likelihoods and instead directly train a generative model to produce realistic samples. several extensions to the generative adversarial network framework have been proposed to scale the approach to larger images (denton , 2015; radford , 2016; salimans , 2016). our work draws on the insights of radford  (2016) regarding adversarial training practices and architecture for the generator network, as well as the notion that the discriminator can produce useful features for classification tasks.
other models used recurrent approaches to generate images (gregor , 2015; theis & bethge, 2015; mansimov , 2016; van den oord , 2016). dosovitskiy  (2015) trained a cnn to generate objects with different shapes, viewpoints and color. sohl-dickstein  (2015) propose a generative model based on a reverse diffusion process. while our model does involve image generation, it differs from these approaches in that the main focus is on learning a good representation for classification tasks.
predictive generative models of videos aim to extrapolate from current frames to future ones and in doing so learn a feature representation that is useful for other tasks. in this vein, ranzato  (2014) used an `2-loss in pixel-space. mathieu  (2015) combined an adversarial loss with `2, giving models that generate crisper images. while our model is also predictive, it only considers interpolation within an image, rather than extrapolation in time.we present a semi-supervised learning framework built on generative adversarial networks (gans) of goodfellow  (2014). we first review the generative adversarial network framework and then introduce context conditional generative adversarial networks (cc-gans). finally, we show how combining a classification objective and a cc-gan objective provides a unified framework for semi-supervised learning.the generative adversarial network approach (goodfellow , 2014) is a framework for training generative models, which we briefly review. it consists of two networks pitted against one another in a two player game: a generative model, g, is trained to synthesize images resembling the data distribution and a discriminative model, d, is trained to distinguish between samples drawn from g and images drawn from the training data.
more formally, let x = {x1, ...,xn} be a dataset of images of dimensionality d. let d denote a discriminative function that takes as input an image x ∈ rd and outputs a scalar representing the probability of input x being a real sample. let g denote the generative function that takes as input a random vector z ∈ rz sampled from a prior noise distribution pnoise and outputs a synthesized image x̃ = g(z) ∈ rd. ideally, d(x) = 1 when x ∈ x and d(x) = 0 when x was generated from g. the gan objective is given by:
min g max d ex∼x [logd(x)] + ez∼pnoise(z)[log(1−d(g(z)))] (1)
the conditional generative adversarial network (mirza & osindero, 2014) is an extension of the gan in which bothd andg receive an additional vector of information y as input. the conditional gan objective is given by:
min g max d ex,y∼x [logd(x,y)] + ez∼pnoise(z)[log(1−d(g(z,y),x))] (2)we propose context-conditional generative adversarial networks (cc-gans) which are conditional gans where the generator is trained to fill in a missing image patch and the generator and discriminator are conditioned on the surrounding pixels.
in particular, the generator g receives as input an image with a randomly masked out patch. the generator outputs an entire image. we fill in the missing patch from the generated output and then pass the completed image into d. we pass the completed image into d rather than the context and the patch as two separate inputs so as to prevent d from simply learning to identify discontinuities along the edge of the missing patch.
more formally, let m ∈ rd denote to a binary mask that will be used to drop out a specified portion of an image. the generator receives as input m x where denotes element-wise multiplication. the generator outputs xg = g(m x, z) ∈ rd and the in-painted image xi is given by:
xi = (1−m) xg +m x (3)
the cc-gan objective is given by:
min g max d
ex∼x [logd(x)] + ex∼x ,m∼m[log(1−d(xi))] (4)while the generator of the cc-gan outputs a full image, only a portion of it (corresponding to the missing hole) is seen by the discriminator. in the combined model, which we denote by cc-gan2, the fake examples for the discriminator include both the in-painted image xi and the full image xg produced by the generator (i.e. not just the missing patch). by combining the gan and cc-gan approaches, we introduce a wider array of negative examples to the discriminator. the cc-gan2 objective given by:
min g max d
ex∼x [logd(x)] (5)
+ ex∼x ,m∼m[log(1−d(xi))] (6) + ex∼x ,m∼m[log(1−d(xg))] (7)a common approach to semi-supervised learning is to combine a supervised and unsupervised objective during training. as a result unlabeled data can be leveraged to aid the supervised task.
intuitively, a gan discriminator must learn something about the structure of natural images in order to effectively distinguish real from generated images. recently, radford  (2016) showed that a gan discriminator learns a hierarchical image representation that is useful for object classification. such results suggest that combining an unsupervised gan objective with a supervised classification objective would produce a simple and effective semi-supervised learning method. this approach, denoted by ssl-gan, is illustrated in fig. 1(b). the discriminator network receives a gradient from the real/fake loss for every real and generated image. the discriminator also receives a gradient from the classification loss on the subset of (real) images for which labels are available.
generative adversarial networks have shown impressive performance on many diverse datasets. however, samples are most coherent when the set of images the network is trained on comes from a limited domain (eg. churches or faces). additionally, it is difficult to train gans on very large images. both these issues suggest semi-supervised learning with vanilla gans may not scale well to datasets of large diverse images. rather than determining if a full image is real or fake, context conditional gans address a different task: determining if a part of an image is real or fake given the surrounding context.
formally, let xl = {(x1, y1), ..., (xn, yn)} denote a dataset of labeled images. let dc(x) denote the output of the classifier head on the discriminator (see fig. 1(c) for details). then the semisupervised cc-gan objective is:
min g max d ex∼x [logd(x)] + ex∼x ,m∼m[log(1−d(xi))] + λcex,y∼xl [log(dc(y|x))] (8)
the hyperparameter λc balances the classification and adversarial losses. we only consider the ccgan in the semi-supervised setting and thus drop the ssl notation when referring to this model.the architecture of our generative model,g, is inspired by the generator architecture of the dcgan (radford , 2016). the model consists of a sequence of convolutional layers with subsampling (but no pooling) followed by a sequence of fractionally-strided convolutional layers. for the discriminator, d, we used the vgg-a network (simonyan & zisserman, 2015) without the fully connected layers (which we call the vgg-a’ architecture). details of the generator and discriminator are given
in fig. 2. the input to the generator is an image with a patch zeroed out. in preliminary experiments we also tried passing in a separate mask to the generator to make the missing area more explicit but found this did not effect performance.
even with the context conditioning it is difficult to generate large image patches that look realistic, making it problematic to scale our approach to high resolution images. to address this, we propose conditioning the generator on both the high resolution image with a missing patch and a low resolution version of the whole image (with no missing region). in this setting, the generators task becomes one of super-resolution on a portion of an image. however, the discriminator does not receive the low resolution image and thus is still faced with the same problem of determining if a given in-painting is viable or not. where indicated, we used this approach in our pascal voc 2007 experiments, with the original image being downsampled by a factor of 4. this provided enough information for the generator to fill in larger holes but not so much that it made the task trivial. this optional low resolution image is illustrated in fig. 2(left) with the dotted line.
we followed the training procedures of radford  (2016). we used the adam optimizer (kingma & ba, 2015) in all our experiments with learning rate of 0.0002, momentum term β1 of 0.5, and the remaining adam hyperparameters set to their default values. we set λc = 1 for all experiments.stl-10 is a dataset of 96×96 color images with a 1:100 ratio of labeled to unlabeled examples, making it an ideal fit for our semi-supervised learning framework. the training set consists of 5000 labeled images, mapped to 10 pre-defined folds of 1000 images each, and 100,000 unlabeled images. the labeled images belong to 10 classes and were extracted from the imagenet dataset and the unlabeled images come from a broader distribution of classes. we follow the standard testing protocol and train 10 different models on each of the 10 predefined folds of data. we then evaluate classification accuracy of each model on the test set and report the mean and standard deviation.
we trained our cc-gan and cc-gan2 models on 64×64 crops of the 96×96 image. the hole was 32×32 pixels and the location of the hole varied randomly (see fig. 3(top)). we trained for 100 epochs and then fine-tuned the discriminator on the 96x96 labeled images, stopping when training accuracy reached 100%. as shown in table 1, the cc-gan model performs comparably to current state of the art (dosovitskiy , 2014) and the cc-gan2 model improves upon it.
we also trained two baseline models in an attempt to tease apart the contributions of adversarial training and context conditional adversarial training. the first is a purely supervised training of the vgg-a’ model (the same architecture as the discriminator in the cc-gan framework). this was trained using a dropout of 0.5 on the final layer and weight decay of 0.001. the performance of this model is significantly worse than the cc-gan model.
we also trained a semi-supervised gan (ssl-gan, see fig. 1(b)) on stl-10. this consisted of the same discriminator as the cc-gan (vgg-a’ architecture) and generator from the dcgan model (radford , 2016). the training setup in this case is identical to the cc-gan model. the sslgan performs almost as well as the cc-gan, confirming our hypothesis that the gan objective is a useful unsupervised criterion.in order to compare against other methods that utilize spatial context we ran the cc-gan model on pascal voc 2007 dataset. this dataset consists of natural images coming from 20 classes. the dataset contains a large amount of variability with objects varying in size, pose, and position. the training and validation sets combined contain 5,011 images, and the test set contains 4,952 images. the standard measure of performance is mean average precision (map).
we trained each model on the combined training and validation set for ∼5000 epochs and evaluated on the test set once1. following pathak  (2016), we train using random cropping, and then evaluate using the average prediction from 10 random crops.
our best performing model was trained on images of resolution 128×128 with a hole size of 64×64 and a low resolution input of size 32×32. table 2 compares our cc-gan method to other feature learning approaches on the pascal test set. it outperforms them, beating the current state of the art (wang & gupta, 2015) by 3.8%. it is important to note that our feature extractor is the vgga’ model which is larger than the alexnet architecture (krizhevsky , 2012) used by other approaches in table 2. however, purely supervised training of the two models reveals that vgg-a’ hyperparameters were determined by initially training on the training sne and measuring performance on the validation set.
is less than 2% better than alexnet. furthermore, our model outperforms the supervised vgg-a’ baseline by a 7% margin (62.2% vs. 55.2%). this suggests that our gains stem from the cc-gan method rather than the use of a better architecture.
table 3 shows the effect of training on different resolutions. the cc-gan improves over the baseline cnn consistently regardless of image size. we found that conditioning on the low resolution image began to help when the hole size was largest (64×64). we hypothesize that the low resolution conditioning would be more important for larger images, potentially allowing the method to scale to larger image sizes than we explored in this work.we now show some sample in-paintings produced by our cc-gan generators. in our semisupervised learning experiments on stl-10 we remove a single fixed size hole from the image. the top row of fig. 3 shows in-paintings produced by this model. we can also explored different masking schemes as illustrated in the remaining rows of fig. 3 (however these did not improve classification results). in all cases we see that training the generator with the adversarial loss produces sharp semantically plausible in-painting results.
fig. 4 shows generated images and in-painted images from a model trained with the cc-gan2 criterion. the output of a cc-gan generator tends to be corrupted outside the patch used to inpaint the image (since gradients only flow back to the missing patch). however, in the cc-gan2 model, we see that both the in-painted image and the generated image are coherent and semantically consistent with the masked input image.
fig. 5 shows in-painted images from a generator trained on 128×128 pascal images. fig. 6 shows the effect of adding a low resolution (32×32) image as input to the generator. for comparison we also show the result of in-painting by filling in with a bi-linearly upsampled image. here we see the generator produces high-frequency structure rather than simply learning to copy the low resolution patch.we have presented a simple semi-supervised learning framework based on in-painting with an adversarial loss. the generator in our cc-gan model is capable of producing semantically meaningful
in-paintings and the discriminator performs comparable to or better than existing semi-supervised methods on two classification benchmarks.
since discrimination of real/fake in-paintings is more closely related to the target task of object classification than extracting a feature representation suitable for in-filling, it is not surprising that we are able to exceed the performance of pathak  (2016) on pascal classification. furthermore, since our model operates on images half the resolution as those used by other approaches (128×128 vs. 224×244), there is potential for further gains if improvements in the generator resolution can be made. our models and code are available at https://github.com/edenton/cc-gan.
acknowledgements: emily denton is supported by a google fellowship. rob fergus is grateful for the support of cifar.",0
670.pdf.json,"mt-lrp combines three ideas into a novel approach for task discovery and state representation learning: 1) extracting state representations for each task with robotic priors (jonschkowski & brock, 2015); 2) discovering discrete tasks and corresponding actions/policies in a rl context (stulp , 2014; höfer & brock, 2016); 3) using gated networks to implement a “mixture of experts” (jacobs , 1991; droniou , 2015).
state representation learning: learning from raw observations is considered a holy grail in reinforcement learning (rl). deep rl has had major success in this, using model-free (mnih , 2015) but also by combining model-free and model-based rl (levine , 2015). these approaches apply end-to-end learning to get from raw input to value functions and policies. a different approach is to explicitly learn state representations using unsupervised learning, e.g. using auto-encoders (lange , 2012). recently, watter  (2015) extended this idea to learn state representations jointly with dynamic models and apply optimal control to compute a policy. we use learning with robotic priors (jonschkowski & brock, 2015), a state representation learning method
that exploits information about temporal structure, actions, and rewards. we go beyond previous work by not only learning single state representations, but learning multiple state representations given raw data from multiple tasks.
options and parameterized skills: a common approach to factorizing a rl problem into subtasks are macro-actions, often called options (sutton , 1999; hengst, 2002). the main difference with our approach is that options are used to hierarchically decompose one high-level task into subtasks (and learn sub-policies for these subtasks), whereas we learn task-specific state representations for different high-level tasks. however, options bear resemblance on a technical level, since they are often implemented by a high-level “selection” policy that parametrizes low-level policies (daniel , 2012; kupcsik , 2013; stulp , 2014). continuous versions of options, referred to as parametrized skills, have been proposed, too (da silva , 2012; deisenroth , 2014; doshivelez & konidaris, 2016). however, in all the work above, the state representation is given. to the best of our knowledge, state representation learning has not yet been considered in the context of rl with options or parameterized skills.
gated networks for mixtures of experts and submanifold learning: gated networks are networks that contain gating connections, in which the outputs of at least two neurons are multiplied (sigaud , 2015). this allows a gating neuron g to prohibit (or limit) the flow of information from one neuron x to another neuron y, similar to how transistors function. an early example of gated networks is the mixture of experts approach (jacobs , 1991; jacobs & jordan, 1993; haruno , 2001), where separate networks in a modular neural network specialize in predicting subsets of training examples from a database. our contribution is to extend mixtures of experts by state representation learning (e.g. from raw images) and to the more difficult rl (rather than supervised learning) context. our gated network architecture is similar to the one proposed by droniou  (2015). their network simultaneously learns discrete classes jointly with continuous class variations (called submanifolds) in an unsupervised way, e.g., discrete digit classes and shape variations within each class. we use a similar architecture, but in a different way: rather than learning discrete classes, we learn discrete tasks; class-specific submanifolds correspond to task-specific state representations; and finally, we consider a rl rather than an unsupervised learning context.
as mentioned in the introduction, our work is orthogonal to multi-task learning (caruana, 1997) which has been extensively studied in recent reinforcement learning literature, too (parisotto , 2016). our approach can be trivially combined with multi-task learning by by prepending the gate and state extraction modules with a subnetwork that shares knowledge across tasks. another interesting multi-task approach is policy distillation (rusu , 2016). this method combines different policies for multiple tasks into a single network, which enables to share information between tasks and to learn a compact network that can even outperform the individual policies.we formulate mt-lrp in a reinforcement learning (rl) setting using a markov decision process (mdp) (s,a,t,r,γ): based on the current state s ∈ s, the agent chooses and executes an action a ∈ a, obtains a new state s′ ∈ s (according to the transition function t ) and collects a reward r ∈ r. the agent’s goal is to learn a policy π : s→ a that maximizes the expected return ie(∑∞t=0 γ trt), with rt being the reward collected at time t and 0 < γ ≤ 1 the discount factor. we consider an episodic setting with episodes of finite length, a continuous state space s and a discrete action space a.
in this work, we assume that the agent cannot directly observe the state s but only has access to observations o ∈ o, which are usually high-dimensional and contain task-irrelevant distractors. this requires us to extract the state from the observations by learning an observation-state-mapping ϕ : o→ s, and use the resulting state representation s to solve the rl problem (assuming that a markov state can be extracted from a single observation). to learn the state representation, we apply learning with robotic priors (jonschkowski & brock (2015), from now on referred to as lrp). this method learns ϕ from a set of temporally ordered experiences d = {(ot ,at ,rt)}dt=1 by optimizing the following loss:
lrp(d,ϕ) = ωtltemp.(d,ϕ)+ωplprop.(d,ϕ)+ωclcaus.(d,ϕ)+ωrlrep.(d,ϕ). (1)
this loss consists of four terms, each expressing a different prior about suitable state representations for robot rl. we optimize it using gradient descent, assuming ϕ to be differentiable. we now explain the four robotic prior loss terms in eq. (1).
temporal coherence enforces states to change gradually over time (wiskott & sejnowski, 2002): ltemp.(d,ϕ) = ie [ ‖∆st‖2 ] ,
where ∆st = st+1− st denotes the state change. (to increase readability we replace ϕ(o) by s.) proportionality expresses the prior that the same action should change the state by the same magnitude, irrespective of time and the location in the state space:
lprop.(d,ϕ) = ie [ (‖∆st2‖−‖∆st1‖) 2 ∣∣∣ at1 = at2].
causality enforces two states st1 ,st2 to be dissimilar if executing the same action in st1 generates a different reward than in st2 .
lcaus.(d,ϕ) = ie [ e−‖st2−st1‖ 2 ∣∣∣ at1 = at2 ,rt1+1 6= rt2+1].
repeatability requires actions to have repeatable effects by enforcing that the same action produces a similar state change in similar states:
lrep.(d, ϕ̂) = ie [ e−‖st2−st1‖ 2‖∆st2 −∆st1‖ 2 ∣∣∣ at1 = at2].
additionally, the method enforces simplicity by requiring s to be low-dimensional.
note that learning with robotic priors only makes use of the actions a, rewards r, and temporal information t during optimization, but not at test time for computing ϕ(o) = s. using a, r and t in this way is an instance of the learning with side information paradigm (jonschkowski , 2015).now consider a scenario in which an agent is learning multiple distinct tasks. for each task τ ∈ {1, . . . ,t}, the agent now requires a task-specific policy πτ : sτ → a. we approach the problem by learning a task-specific state representation ϕτ : o→ sτ for each policy, and a task detector χ which determines the task, given the current observation. we will consider a probabilistic task-detector χ : o→ [0,1]t that assigns a probability to each task being active. in order to solve the full multi-task rl problem, we must learn χ, {ϕτ}τ∈{1,...,t} and {πτ}τ∈{1,...,t}. we propose to address this problem by mt-lrp, a method that jointly learns χ and {ϕτ}τ∈{1,...,t} from raw observations, actions, and rewards. mt-lrp then uses the state representations {ϕτ} to learn task-specific policies {πτ}τ∈{1,...,t} (using standard rl methods), and switches between them using the task detector χ . to solve the joint learning problem, mt-lrp generalizes lrp (jonschkowski & brock, 2015) in the following regards: (i) we replace the linear observation-statemapping from the original method with a gated neural network, where the gates act as task detectors that switch between different task-specific observation-state-mappings; (ii) we extend the list of robotic priors by the prior of task coherence, which allows us to train multiple task-specific state representations without any specification (or labels) of tasks and states.we use a gated neural network architecture as shown schematically in fig. 2. the key idea is that both the task detector χ as well as the state representation ϕ are computed from raw inputs. however, the output of the task detector gates the output of the state representation. effectively, this means the output of χ(o) decides which task-specific state representation ϕτ is passed further to the policy, which is also gated by the output of χ(o).
formally, χ(o) = σ(χpre(o)) is composed of a function χpre with t -dimensional output and a softmax σ(z) = e z j
∑k ezk . the softmax ensures that χ computes a proper probability distribution over tasks.
the probabilities are then used to gate ϕ . to do this, we decompose ϕ into a pre-gating function
ϕpre that extracts features shared across all tasks (i.e. ”multi-task” in the sense of caruana (1997), unless set to the identity), and a t ×m×n gating tensor g that encodes the t (linear) observationstate mappings (m = dim(s) and n is the output dimension of ϕpre). the value of the state’s i-th dimension si computes as the expectation of the dot product of gating tensor and ϕpre(o) over the task probabilities χ(o):
si = ϕi(o) = t
∑ k=1 χk(o) 〈gk,i,:,ϕpre(o)〉. (2)to train the network, we extend the robotic prior loss lrp (eq. 1), by a task-coherence prior lτ :
l= lrp(d,ϕ)+ωτlτ(d,χ), (3)
where ωτ is a scalar weight balancing the influence of the additional loss term. task coherence is the assumption that a task only changes between training episodes, not within the same episode. it does not presuppose any knowledge about the number of tasks or the task presented in an episode, but it exploits the fact that task switching weakly correlates with training episodes. moreover, this assumption only needs to hold during training: since χ operates directly on the observation o, it can in principle switch the task at every point in time during execution. task-coherence applies directly to the output of the task detector, χ(o), and consists of two terms:
lcon+sepτ = lconτ +l sep τ . (4)
the first term enforces task consistency during an episode: lconτ = ie [ h(χ(ot1),χ(ot2)) ∣∣∣ episodet1 = episodet2], (5) where h denotes the cross-entropy h(p,q) = −∑x p(x) logq(x). it can be viewed as a measure of dissimilarity between probability distributions p and q. we use it to penalize χ if it assigns different task distributions to inputs ot1 , ot2 that belong to the same episode. note that task-consistency can be viewed as a temporal coherence prior on the task level (wiskott & sejnowski, 2002).
the second term expresses task separation and encourages χ to assign tasks to different episodes: lsepτ = ie [ e−h(χ(ot1 ),χ(ot2 )) ∣∣∣ episodet1 6= episodet2]. (6) this loss is complementary to task consistency, as it penalizes χ if it assigns similar task distributions to ot1 , ot2 from different episodes. note that l sep τ will in general not become zero. the reason is that the number of episodes usually exceeds the number of tasks, and therefore two observations from different episodes sometimes do belong to the same task. we will evaluate the contribution of each of the two terms to learning success in section 5.2.we evaluate mt-lrp in two scenarios. in the multi-task slot-car racing scenario (inspired by lange  (2012)), we apply mt-lrp to a linearly solvable problem, allowing us to easily inspect what and how mt-lrp learns. in slot-car racing, the agent controls one of multiple cars (figure 1), with the goal of traversing the circuit as fast as possible without leaving the track due to speeding in curves. however, the agent does not know a priori which car it controls, and only receives the raw visual signal as input. additionally, uncontrolled cars driving at random velocity, act as visual distractors. we turn this scenario into a multi-task problem in which the agent must learn to control each car, where controlling the different cars corresponds to separate tasks. we will now provide the technical details of our experimental set-up.the agent controls the velocity of one car (see fig. 1), receives a reward proportional to the car’s velocity, chosen from [0.01, 0.02, . . . , 0.1], and a negative reward of −10 if the car goes too fast
in curves. the velocity is subject to gaussian noise (zero mean, standard deviation 10%) of the commanded velocity. all cars move on independent lanes and do not influence each other. the agent observes the scenario by getting a downscaled 16x16 rgb top-down view (dimension n = 16×16×3 = 768) of the car circuit (fig. 1(b)). in our experiments, there are two or three cars on the track, and the agent controls a different one in every episode. to recognize the task, the agent must be able to extract a visual cue from the observation which correlates with the task. we study two types of visual cues: static visual cue: the arrangement of cars stays the same in all episodes and a static visual cue (a picture of the controlled car) in the top-left image corner indicates which car is currently controlled. dynamic visual cue: the agent always controls the same car (with a certain color), but in each task the car is located on a different lane (as in fig. 1(b)).
data collection and learning procedure: the agent collects 40 episodes per task, each episode consisting of 100 steps. to select an action in each step, the agent performs ε-greedy exploration by picking a random action with probability ε = 0.3 and the best action according to its current policy otherwise. the agent computes a policy after every τ episodes, by first learning the observation-state mapping ϕ (state representation) and then computing policies π1, . . . ,πτ (based on the outcomes of the learned χ and ϕ). to monitor the agent’s learning progress, we measure the average reward the agent attains on t test episodes, i.e. one test episode of length 100 per task (using the greedy policy), amounting to 8000 experiences in total. to collect sufficient statistics, the whole experiment is repeated 10 times. policy learning: we consider the model-free setting with continuous states s, discrete actions a and solve it using nearest-neighbor q-learning knn-td-rl (martı́n h , 2009) with k = 10. more recent approaches to model-free rl would be equally applicable (mnih , 2015). learning strategies and baselines: we compare five strategies. we run a) mt-lrp with 5 gate units (two/three more than necessary), state dimensionality m = 2 and using lcon+sepτ as taskcoherence prior. we compare mt-lrp to several state representation methods; for each method we evaluate different m and report only the best performing m: a) robotic priors without gated network, lrp (m = 4), b) principal components analysis (pca) on the observations (m = 20) and c) raw observations (m = 768). additionally, we evaluate d) a lower baseline in the form of a randomly moving agent and e) an upper baseline by applying rl on the known 2d-position of the slot car under control (m = 2). we use the same rl algorithm for all methods. to learn the state representations with robotic priors, we base our implementation on theano and lasagne, using the adam optimizer with learning rate 0.005, batch size 100, glorot’s weight initialization and ωt = 1,ωp = 5,ωc = 1,ωr = 5,ωτ = 10. moreover, we apply an l1 regularization of 0.001 on ϕ . additionally, we analyze the contribution of task coherence priors by applying mt-lrp to the full set of 8000 experiences a) without task-coherence, b) with task consistency lconτ only c) with task separation lconτ only) and d) without task consistency and separation l con+sep τ .we will now present the three main results of our experiments: (i) we show that mt-lrp enables the agent to extract better representations for rl; (ii) we provide insight in how the learner detects the task and encodes the state representations; and finally, (iii) we show the contribution of each of the task-coherence loss terms.
mt-lrp extracts better state representations for rl figure 3 shows the learning curves for rl based on state representations learned by the different methods in the two-slot-car scenario (static visual cue on the left, dynamic on the right). no method reaches the performance of the upper baseline, mainly due to aliasing errors resulting from the low image resolution.
the random baseline ranges around an average reward of −84.9 with standard error 0.72 and was omitted from the figure. the state representation learning baselines without robotic priors perform poorly because they are unable to identify the taskirrelevant distractions. mt-lrp gets very close to the performance of the upper baseline, especially for very low amounts of training data (d < 2500), whereas lrp does not even attain this level of performance for the full training set d = 8000 in the static task. the gap between mt-lrp and lrp increases even more if we add another car (figure 5) because lrp can only learn one state representation for all three tasks. including the three slot cars in this representation results in distractions for the rl method. however, in the dynamic-visual-cue scenario lrp-4 performs on par with mt-lrp. surprisingly, running lrp with only two dimensions suffices to achieve the performance of mt-lrp. we
will explain this phenomenon below. to conclude, mt-lrp allows to learn as good or better policies than the baselines in all slot-car scenarios.
mt-lrp detects all tasks and learns good state representations to gain more insight into what is learned, we analyze the state representations extracted by mt-lrp and lrp. figure 4 shows the state representation learned by mt-lrp for the static-visual-cue scenario. each point in the figure corresponds to one observation, markers indicate the task and colors the most active gate unit. we see that the first gate unit (blue) is always active for task 1 (circle), and the second gate unit for task 2. this shows that the task is detected with high accuracy. the task detector χ is also highly certain which is reflected in the fact that its entropy evaluated on the data is close to zero. moreover, the states reflect the circular structure of the slot car racing track. we thus conclude that mt-lrp has learned to identify the tasks and to represent the position of each car on the track.
the rl experiments raised the question why lrp manages to solve the dynamic, but not the static-visual-cue scenario as well as mt-lrp. we hypothesize that, for the dynamic cue, lrp is able to extract the position of the car on regardless of which lane it is in using a single linear mapping. figure 6 confirms this hypothesis: lrp filters for the car’s color (blue) along the track and assigns increasing weights to these pixels which results in the extraction of its position. it also assigns constant weights along the track in the red channel using the lane change of the two cars as an offset. this results in a mapping to two circles similar to fig. 4, where the state encodes both the position and the task. such a mapping can be expressed by a linear
function precisely because the features that are relevant for one task do not reappear in another task (e.g. a blue slot car in track 1 does not appear in the task where the blue car is in track 2).
however, there exists no equivalent linear mapping for the static-visual-cue variant of the slotcar problem, because cars that are relevant for one task are also present in every other task.
we can generalize from this insight as follows. a single linear observation-state-mapping is sufficient for multiple tasks if the state representation for every task can be extracted by a linear function using only features that stay constant for all other tasks. if this is the case, than there is no need for decoupling the extraction of task and state.
task-consistency is critical for learning performance to understand the influence of
the different task-coherence prior variants, we compared their performance in figure 7. we see that relying solely on the robotic priors gives poor results, mainly because the gate units are not used properly: more than one gate unit is activated per task (χ has high entropy). adding the taskseparation prior forces the network to use as many gates as possible (5 in our case), leading to bad state representations. interestingly, using task consistency only gives roughly the same result as using task consistency and task separation.
discussion the experiments showed that mt-lrp is able to solve the representation and reinforcement learning tasks better than the baselines. important questions for future work concern: the necessity and influence of the task-separation loss, in particular for short episode lengths and if the number of expected tasks exceeds the number of actual tasks; and transferring knowledge by adding a shared neural network layers before gating.we have presented mt-lrp, a method for multi-task state representation learning with robotic priors. the method learns in an unsupervised fashion, solely based on the robots own observations, actions, and rewards. our experiments confirmed that mt-lrp is effective in simultaneously identifying tasks and learning task-specific state representations. this capability is beneficial for scaling reinforcement learning to realistic scenarios that require dedicated skills for different tasks.we gratefully acknowledge the funding provided by the german research foundation (dfg, exploration challenge, br 2248/3-1), the alexander von humboldt foundation through an alexander von humboldt professorship (funded by the german federal ministry of education and research). additionally, antonin raffin was supported by an erasmus+ grant.",0
678.pdf.json,"machine intelligence has had some notable successes, however often in narrow domains which are sometimes of little practical use to humans – for instance games like chess (campbell , 2002) or go (silver , 2016). if we aimed to build a general ai that would be able to efficiently assist humans in a wide range of settings, we would want it to have a much larger set of skills – among them would be an ability to understand human language, to perform common-sense reasoning and to be able to generalize its abilities to new situations like humans do.
if we want to achieve this goal through machine learning, we need data to learn from. a lot of data if the task at hand is complex – which is the case for many useful tasks. one way to achieve wide applicability would be to provide training data for each specific task we would like the machine to perform. however it is unrealistic to obtain a sufficient amount of training data for some domains – it may for instance require expensive human annotation or all domains of application may be difficult to predict in advance – while the amount of training data in other domains is practically unlimited, (e.g. in language modelling or cloze-style question answering).
the way to bridge this gap – and to achieve the aforementioned adaptability – is transfer learning (pan & yang, 2010) and closely related semi-supervised learning (zhu & goldberg, 2009) which allow the system to acquire a set of skills on domains where data are abundant and then use these skills to succeed on previously unseen domains. despite how important generalization is for general ai, a lot of research keeps focusing on solving narrow tasks.
in this paper we would like to examine transfer of learnt skills and knowledge within the domain of text comprehension, a field that has lately attracted a lot of attention within the nlp community (hermann , 2015; hill , 2015; kobayashi , 2016; kadlec , 2016b; chen , 2016; sordoni , 2016; dhingra , 2016; trischler , 2016; weissenborn, 2016; cui , 2016b;a;
∗these authors contributed equally to this work.
li , 2016; shen , 2016). specifically, we would like to address the following research questions: . whether we could train models on natural-language tasks where data are abundant and transfer the learnt skills to tasks where in-domain training data may be difficult to obtain. we will first look into what reasoning abilities a model learns from two large-scale readingcomprehension datasets using artificial tasks, and then check whether it can transfer its skills to real world tasks. spoiler: both these transfers are very poor if we allow no training at all on the target task. . whether pre-training on large-scale datasets does help if we allow the model to train on a small sample of examples from the target tasks. here the results are much more positive. . finally we examine whether the benefits of pre-training are concentrated in any particular part of the model - namely the word-embedding part or the context encoder (the reasoning part). it turns out that pre-training is useful for both components.
although our results do not improve current state of the art in any of the studied tasks, they show a clear positive effect of large-dataset pre-training on the performance of our baseline machine-learning model. previous studies of transfer learning and semi-supervised learning in nlp focused on text classification (dai & le, 2015; mou , 2016) and various parsing tasks (collobert , 2011; hashimoto , 2016). to our knowledge this work is the first study of transfer learning in reading comprehension, and we hope it will stimulate further work in this important area.
we will first briefly introduce the datasets we will be using on the pre-training and target sides, then our baseline model and afterwards in turn describe the method and results of each of the three experiments.we have mentioned that for the model pre-training we would want to use a task where training data are abundant. an example of such task is context-dependent cloze-style-question answering since the training data for this task can be generated automatically from a suitable corpus. we will use two such pre-training datasets in our experiments: the booktest (bajgar , 2016) and the cnn/daily mail (cnn/dm) news dataset (hermann , 2015).
the task associated with both datasets is to answer a cloze-style question (i.e. fill in a blank in a sentence) the answer to which needs to be inferred from a context document provided with the question.in the booktest dataset, the context document is formed from 20 consecutive sentences from a book. the question is then formed by omitting a common noun or a named entity from the subsequent 21st sentence. among datasets of this kind, the booktest is among the largest with more than 14 million training examples coming from 3555 copyright-free books avalable thanks to project gutenberg.in the cnn/dm dataset the context document is formed from a news article while the cloze-style question is formed by removing a named entity from one of the short summary sentences which often appear at the top of the article.
to stop the model from using world knowledge from outside the context article (and hence truly test the comprehension of the article), all named entities were replaced by anonymous tags, which are further shuffled for each example. this may make the comprehension more difficult; however, since the answer is always one of the anonymized entities, it also reduces the number of possible answers making guessing easier.the first target dataset are the babi tasks (weston , 2016) – a set of artificial tasks each of which is designed to test a specific kind of reasoning. this toy dataset will allow us to observe what particular skills the model may be learning from each of the three training datasets.
for our experiments we will be using an architecture designed to select one word from the context document as the answer. hence we have selected tasks 1,2,3,4,5,11,12,13,14 and 16 which fulfill this requirement and added task 15 which required a slight modification. furthermore because both pre-training datasets are cloze-style we converted also the babi task questions into cloze style (e.g. ”where is john?” to ”john is in the xxxxx.”).
for the models pre-trained on cnn/dm we also anonymized the tasks in a way similar to the pre-training dataset - i.e. we replaced all names of characters and also all words that can appear as answers for the given task by anonymous tags in the style of cnn/dm. this gives even models that have not seen any training examples from the target domain a chance to answer the questions.
full details about these alterations can be found in appendix a.secondly, we will look on transfer to the squad dataset (rajpurkar , 2016); here the associated task may be already useful in the real world. although cloze-style questions have the huge advantage in the possibility of being automatically generated from a suitable corpus – the path taken by cnn/dm and the booktest – in practice humans would use a proper question, not its cloze-style substitute. this brings us to the need of transfer from the data-rich cloze-style training to the domain of proper questions where data are much scarcer due to the necessary human annotation.
the squad dataset is a great target dataset to use for this. as opposed to the babi tasks, the goal of this dataset is actually a problem whose solving would be useful to humans - answering natural questions based on an natural language encyclopedic knowledge base.
for our experiments we selected only a subset of the squad training and development examples where the answer is only a single word, since this is an inherent assumption of our machine learning model. this way we extracted 28,346 training examples out of the original 100,000 examples and 3,233 development examples out of 10,570.we perform our experiments using the attention sum reader (as reader) (kadlec , 2016b) model. the as reader is simple to implement while it achieves strong performance on several text comprehension tasks (kadlec , 2016b; bajgar , 2016; chu , 2016). since the as reader is a building block of many recent text-comprehension models (trischler , 2016; sordoni , 2016; dhingra , 2016; cui , 2016b;a; shen , 2016; munkhdalai & yu, 2016) it is a good representative of current research in this field.
a high level structure of the as reader is shown in figure 1. the words from the document and the question are first converted into vector embeddings using a look-up matrix. the document is then read by a bidirectional gated recurrent unit (gru) network (cho , 2014). a concatenation of the hidden states of the forward and backward grus at each word is then used as a contextual embedding of this word, intuitively representing the context in which the word is appearing. we can also understand it as representing the set of questions to which this word may be an answer.
similarly the question is read by a bidirectional gru but in this case only the final hidden states are concatenated to form the question embedding.
the attention over each word in the context is then calculated as the dot product of its contextual embedding with the question embedding. this attention is then normalized by the softmax function and summed across all occurrences of each answer candidate. the candidate with most accumulated attention is selected as the final answer.
for a more detailed description of the model including equations check kadlec  (2016b).now let us turn in more detail to the three kinds of experiments that we performed.in the first experiment we tested how a model trained on one of the large-scale pre-training datasets performs on the babi tasks without any opportunity to train on babi. since the booktest and cnn/dm tasks involve only cloze-style questions, we can’t expect a model trained on them to answer natural ?-style questions. hence we did not study the transfer to squad in this case, only the transfer to the (cloze-converted) babi tasks.first we tested how the as reader architecture (kadlec , 2016b) can handle the tasks if trained directly on the babi training data for each task. then we tested the degree of transfer from the booktest and cnn/dm data to the 11 selected babi tasks.
in the first part of the experiment we trained a separate instance of the as reader on the 10,000- example version of the babi training data for each of the 11 tasks (for more details see appendix b.1). on 8 of them the architecture was able to learn the task with accuracy at least 95% 1 (results for each task can be found in table 4 in appendix c). hence if given appropriate training the as reader is capable of the reasoning needed to solve most of the selected babi tasks. now when we know that the as reader is powerful enough to learn the target tasks we can turn to transfer from the two large-scale datasets.
the main part of this first experiment was then straightforward: we pre-trained multiple models on the booktest and cnn/dm datasets and then simply evaluated them on the test datasets of the 11 selected babi tasks.table 1 summarizes the results of this experiment. both the models trained on the booktest and those trained on the cnn/dm dataset perform quite poorly on babi and achieve much lower accuracy than it should be noted that there are several machine learning models that perform better than the as reader in the 10k weakly supervised setting, e.g. (sukhbaatar , 2015; xiong , 2016; graves , 2016), however they often need significant fine-tuning. on the other hand we trained plain as reader model without any modifications. hyperparameter and feature fine-tuning could probably further increase its performance on individual tasks however it goes directly against the idea of generality that is at the heart of this work. for comparison with state of the art we include results of dmn+ (xiong , 2016) in table 1 which had the best average performance over the original 20 tasks.
the models trained directly on each individual babi task. however there is some transfer between the tasks since the as reader trained on either the booktest or cnn/dm outperforms a random baseline2 and even an improved baseline which selects the most frequent word from the context that also appears as an answer in the training data for this task.
the results also show that the models trained on cnn/dm perform somewhat better on most tasks than the booktest models. this may be due to the fact that babi tasks generally require the model to summarize information from the context document, which is also what the cnn/dm dataset is testing. on the other hand, the booktest requires prediction of a possible continuation of a story, where the required kind of reasoning is much less clear but certainly different from pure summarization. another explanation for better performance of cnn/dm models might be that they solve slightly simpler task since the candidate answers were already pre-selected in the entity anonymization step.
readers interested in how the training-dataset size affects this kind of transfer can check (kadlec , 2016a) where we show that the target-task performance is a bit better if we use the large booktest as opposed to its smaller subset, the children’s book test (cbt) (hill , 2015).
conclusions from this experiment are that the skills learned from two large-scale datasets generalize surprisingly poorly to even simple toy tasks. this may make us ask whether most teams’ focus on solving narrow tasks is truly beneficial if the skills learnt on these tasks are hard to apply elsewhere. however it also brings us to our next experiment, where we try to provide some help to the struggling pre-trained models.after showing that the skills learnt from the booktest and cnn/dm datasets are by themselves insufficient for solving the toy tasks, the next natural question is whether they are useful if helped by training on a small sample of examples from the target task. we call this additional phase of training target adjustment. for this experiment we again use the babi tasks, however we also test transfer to a subset of the squad dataset, which is much closer to real-world natural-language question answering.
the results presented in this and the following section are based on training 3701 model instances.common to babi and squad datasets. in this experiment we started with a pre-trained model which we used in the previous experiment. however, after it finished training on one of the large pre-training datasets, we allowed it to train on a subset of training examples from the target dataset. we tried subsets of various sizes ranging from a single example to thousands. we tried training four different pre-trained models and also, for comparison, four randomly-initialized models with the same hyperparameters (see appendix b.2 for details). the experiment with each task-model couple was run on 4 different data samples of each size which were randomly drawn from the training dataset the random baseline selects randomly uniformly between all unique words contained in the context document.
of the task to account for variations between these random samples – which may be substantial given the small sample size.3
babi. for each of these models we observed the test accuracy at the best-validation epoch and compared this number between the randomly initialized and pre-trained models. validation was done using 100 examples which were set aside from the task’s original 10k training data.4 we perform the experiment with models pre-trained on the booktest and also on cnn/dm.
squad subset. in the squad experiment, we trained the model on a subset of the original training dataset where answers were only single words and its sub-subsets. we report the best-validation accuracy on a development set filtered in the same way. this experiment was performed only with the models pre-trained on booktest.the results of these experiments are summarized in figures 2 and 3. we are planning to release the split training datasets soon. 4the other models trained on the full 10k dataset usually use 1000 validation examples (sukhbaatar , 2015; xiong , 2016), however we wanted to focus on low data regime thus we used 10 times less examples.
babi. sub-figure 2a shows mean test accuracy of the models that achieved the best validation result for each single task. the results for both booktest and cnn/dm experiments confirm positive effect of pre-training compared to randomly initialized baseline. figure 3 shows performance on selected babi tasks where pre-training has clearly positive effect, such plot for each of the target tasks is provided in appendix c.2 (figure 4).
note that the cnn/dm models cannot be directly compared to booktest results due to entity anonymization that seems to simplify the task when the model is trained on smaller datasets.
since our evaluation methodology with different training set sizes is novel, we can compare our result only to memn2n (sukhbaatar , 2015) trained on a 1k dataset. memn2n is the only weakly supervised model that reports accuracy when trained on less than 10k examples. memn2n achieves average accuracy 93.2%5 on the eleven selected tasks. this is substantially better than both our random baseline (78.0%) and the booktest-pre-trained model (79.5%), however our model is not tuned in any way towards this particular task. one important conceptual difference is that the as reader processes the whole context as one sequence of words, whereas memn2n receives the context split into single sentences, which simplifies the task for the network.
squad subset. the results of squad experiment also confirm positive effect of pre-training, see sub-figure 2b, for now compare just lines showing performance of the fully pre-trained model and the randomly initialized model – the meaning of the remaining two lines shall become clear in the next section.
more detailed statistics about the results of this experiment can be found in appendix d.
we should note that performance of our model is not competitive with the state of the art models on this dataset. for instance the dcr model (yu , 2016) trained on our squad subset achieves validation accuracy 74.9% in this task which is better than our randomly initialized (35.4%) and pre-trained (51.6%) models6. however, the dcr model is designed specifically for the squad task, for instance it utilizes features that are not used by our model.since our previous experiment confirmed positive effect of pre-training if followed by target-domain adjustment, we wondered which part of the model contains the knowledge transferable to new domains. to examine this we performed the following experiment.our machine learning model, the as reader, consists of two main parts: the word-embedding look-up and the bidirectional grus used to encode the document and question (see figure 1). therefore a natural question was what the contribution of each of these parts is.
to test this we created two models out of each pre-trained model used in the previous experiment. the first model variant uses the pre-trained word embeddings from the original model while the gru encoders are randomly initialized. we say that this model has pre-trained embeddings. the second model variant uses the opposite setting where the word embeddings are randomly initialized while the encoders are taken form a pre-trained model. we call this pre-trained encoders.
babi. for this experiment we selected only a subset of tasks with training set of 100 examples where there was significant difference in accuracy between randomly-initialized and pre-trained models. for evaluation we use the same methodology as in the previous experiment, that is, we report accuracy of the best-validation model averaged over 4 training splits.
squad subset. we evaluated both model variants on all training sets from the previous squad experiment using the same methodology. memn2n trained on each single task with pe ls rn features, see (sukhbaatar , 2015) for details. 6we would like to thank yu  (2016) for training their system on our dataset.babi. table 2 shows improvement of pre-trained models over a randomly initialized baseline. in most cases (all except task 5) the fully pre-trained model achieved the best accuracy.
squad subset. the accuracies of the four model variants are plotted in figure 2b together with results of the previous squad experiment. the graph shows that both pre-trained embeddings and pre-trained encoders alone improve performance over the randomly initialized baseline, however the fully pre-trained model is always the best.
the overall result of this experiment is that both pre-training of the word embeddings and pre-training of the encoder parameters are important since the fully pre-trained model outperforms both partially pre-trained variants.our experiments show that transfer from two large cloze-style question-answering datasets to our two target tasks is suprisingly poor, if the models aren’t provided with any examples from the target domain. however we show that models that pre-trained models perform significantly better than a randomly initialized model if they are shown at least a few training examples from the target domain. the usefulness of pre-trained word embeddings is well known in the nlp community however we show that the power of our pre-trained model does not lie just in the embeddings. this suggests that once the text-comprehension community agrees on sufficiently versatile model, much larger parts of the model could start being reused than just the word-embeddings.
the generalization of skills from a training domain to new tasks is an important ingredient of any system we would want to call intelligent. this work is an early step to explore this direction.since our as reader architecture is designed to select a single word from the context document as an answer (the task of cbt and booktest), we selected 10 babi tasks that fulfill this requirement out of the original 20. these tasks are: 1. single supporting fact, 2. two supporting facts, 3. three supporting facts, 4. two argument relations, 5. three argument relations, 11. basic coreference, 12. conjunction, 13. compound coreference, 14. time reasoning and 16. basic induction.
task 15 needed a slight modification to satisfy this requirement: we converted the answers into plural (e.g. ”q: what is gertrude afraid of? a: wolf.” was converted into ”a: wolves” which also seems to be the more natural way to formulate the answer to such a question.).
also since cbt and booktest train the model for cloze-style question answering, we modify the original babi dataset by reformulating the questions into cloze-style. for example we translate a question ”where is john ?” to ”john is in the xxxxx .”
for the models pre-trained on cnn/dm we also replace two kinds of words by anonymized tags (e.g. ”@entity56”) in a style similar to the pre-training dataset. specifically we replace two (largely overlapping) categories of words: . proper names of story characters (e.g. john, sandra) 2. any word that can appear as an answer for the particular task (e.g. kitchen, garden if the
task is asking about locations).b.1 direct training on babi – method
here we give a more detailed description of the method we used to arrive to our results. we highlight only facts particular to this experiment. a more detailed general description of training the as reader is given in (kadlec , 2016b).
the results given for as reader trained on babi are each for a single model with 64 hidden units in each direction of the gru context encoder and embedding dimension 32 trained on the 10k training data provided with that particular task.
the results for as reader trained on the booktest and the cnn/dm are for a greedy ensemble consisting of 4 models whose predictions were simply averaged. the models and ensemble were all validated on the validation set corresponding to the training dataset. the performance on the babi tasks oscillated notably during training however the ensemble averaging does somewhat mitigate this to get more representative numbers.
b.2 hyperparameters for the target-adjustment experiments
table 3 lists hyperparameters of the pre-trained as reader instances used in our experiments with target adjustment.c.1 experiments without target adjustment
table 4 shows detailed results for the experiments on models which were just pre-trained on one of the pre-training datasets without any target-adjustment. it also shows several baselines and results of a state-of-the-art model.
c.2 target-adjustment experiments
c.2.1 results for all babi tasks
figure 4 shows the test accuracies of all models that we trained in the target-adjustment experiments as well as lines joining the accuracies of the best-validation models.
ta bl
e 4:
pe rf
or m
an ce
of th
e a
s r
ea de
r w
he n
tr ai
ne d
on th
e ba
bi 10
k, b
oo kt
es ta
nd c
n n
/d m
da ta
se ts
an d
th en
ev al
ua te
d on
ba bi
te st
da ta
. t
he d
yn am ic m em or y n et w or k (d m n +) is th e st at eof -t he -a rt m od el in a w ea kl y su pe rv is ed se tti ng on th e ba bi 10 k da ta se t. it s re su lts ar e ta ke n fr om (x io ng ., 20 16 ). m em n 2n (s uk hb aa ta re ta l., 20 15 )i s th e st at eof -t he -a rt m od el on th e 1k tr ai ni ng da ta se t; fo rc om pl et en es s w e al so in cl ud e its re su lts w ith th e 10 k tr ai ni ng .
m od
el :
r an
do m
r nd
ca nd
. m
em n 2n (s in gl e) (p e l s r
n )
m em
n 2n
(s in
gl e)
(p e
l s
lw r
n )
d m
n +
(s in
gl e)
a sr
ea de
r
a a
a a
a a a
a a a
te st
da ta
se t tr ai
n da
ta se
t no
t tr ai ne
d ba
bi 10
k ba
bi 1k
ba bi 10 k
ba bi 10 k
ba bi 10 k
b oo
kt es t 14
m d
m +c
n n . 2m  si
ng le
su pp
or tin
g fa
ct 7. 0 31
.2 0 0 0. 0 10 . 00 0 0. 0 10 . 00 7 .3  51
.5 0  tw
o su
pp or
tin g
fa ct
s 4. 0 26
.9 6 1 .7  99
.7 0 9 .7  91
.9 0 5 .8  28
.9 0  t
hr ee
su pp
or tin
g fa
ct s . 40 9 .1  59
.7 0 7 .9  98
.9 0 6 .0  22
.2 0 7 .4 0 4 tw oar gu m en tr el at io ns 10 .5 0 33 .5 8 97 .2 0 10 0. 00 10 0. 00 10 0. 00 50 .3 0 54 .9 0 5 t hr ee -a rg um en tr el at io ns 4. 40 21 .4 2 86 .9 0 99 .2 0 99 .5 0 99 .8 0 67 .6 0 68 .1 0 11 b as ic co re fe re nc e 6. 20 30 .4 2 99 .1 0 99 .9 0 10 0. 00 10 0. 00 33 .0 0 20 .8 0 12 c on ju nc tio n 6. 70 27 .2 5 99 .8 0 10 0. 00 10 0. 00 10 0. 00 30 .4 0 37 .7 0 13 c om po un d co re fe re nc e 5. 60 27 .7 3 99 .6 0 10 0. 00 10 0. 00 10 0. 00 33 .8 0 14 .0 0 14 ti m e re as on in g 5. 00 27 .8 2 98 .3 0 99 .9 0 99 .8 0 95 .0 0 27 .6 0 50 .5 0 15 b as ic de du ct io n 5. 20 37 .2 0 10 0. 00 10 0. 00 10 0. 00 96 .7 0 39 .9 0 17 .6 0 16 b as ic in du ct io n 7. 50 45 .6 5 98 .7 0 48 .2 0 54 .7 0 50 .3 0 15 .1 0 48 .0 0 ba bi m ea n (1 1 ta sk s) 6. 06 29 .8 5 93 .7 3 94 .9 8 95 .6 9 92 .7 0 34 .8 2 38 .1 3
c.2.2 average over all models trained on babi tasks
figure 5 plots mean accuracy of all models trained in our experiments. this suggests that pre-training helped all models, not only the top performing ones selected by validation as already shown in figure 2a.table 5 shows the mean accuracy across all models trained for each combination of task, pre-training dataset and target-adjustment dataset size. table 6 shows the corresponding standard deviations.
table 7 then shows the p-value that whether the expected accuracy of pre-trained models is greater than the expected accuracy of randomly initialized models. this shows that the pre-trained models are statistically significantly better for all target-adjustment set sizes on the squad dataset. on babi the booktest pre-trained models perform convincingly better especially for target-adjustment dataset sizes 100, 500 and 1000, with task 16 being the main exception to this because the as reader struggles to learn it in any setting. for the cnn+dm pre-training the results are not conclusive.
ta sk
pr et
ra in
in g
ta rg
et -a
dj us
tm en
ts et
si ze  1 0 10  50  10 0 50 0 10 0 0 8 17 4 sq ua d b oo kt es t 1. 01 e45 4. 07 e05 7. 40 e05 7. 82 e08 n a 5. 17 e08 n a 3. 93 e08 8. 2 e03 ta sk 1 b oo kt es t 3. 34 e83 1. 81 e03 1. 33 e01 2. 35 e19 9. 41 e04 1. 67 e02 1. 32 e01 n a n a ta sk 2 b oo kt es t 1. 24 e34 3. 86 e07 7. 29 e03 2. 59 e01 1. 39 e08 2. 63 e06 7. 54 e09 2. 04 e01 n a ta sk 3 b oo kt es t 9. 84 e55 1. 27 e05 7. 66 e03 1. 48 e03 3. 18 e04 2. 18 e03 2. 16 e04 1. 03 e01 n a ta sk 4 b oo kt es t 7. 25 e78 9. 50 e01 9. 71 e01 1. 04 e05 6. 38 e03 1. 70 e02 1. 81 e02 n a n a ta sk 5 b oo kt es t 6. 55 e11 5 9. 88 e22 8. 87 e19 5. 25 e05 3. 66 e03 8. 61 e02 5. 65 e03 n a n a ta sk 11 b oo kt es t 6. 78 e15 2 1. 00 e+ 00 9. 94 e01 4. 07 e09 2. 50 e04 2. 28 e02 6. 37 e02 n a n a ta sk 12 b oo kt es t 2. 27 e90 9. 10 e01 6. 46 e01 1. 89 e05 2. 78 e04 1. 43 e02 2. 36 e02 n a n a ta sk 13 b oo kt es t 5. 30 e91 9. 75 e01 9. 99 e01 2. 88 e02 2. 74 e02 1. 03 e01 7. 06 e02 n a n a ta sk 14 b oo kt es t 1. 97 e20 0 1. 01 e03 6. 79 e01 2. 22 e14 3. 40 e05 2. 93 e03 3. 66 e06 3. 97 e01 n a ta sk 15 b oo kt es t 3. 64 e09 4. 75 e01 4. 12 e01 6. 70 e01 1. 68 e03 3. 70 e03 1. 03 e05 4. 54 e01 n a ta sk 16 b oo kt es t 1. 81 e05 8. 28 e04 4. 38 e01 2. 72 e01 4. 89 e01 5. 71 e01 7. 40 e03 n a n a ta sk 1 c n n +d m 9. 43 e09 2. 99 e01 1. 11 e01 1. 05 e01 9. 54 e02 1. 45 e01 3. 97 e03 n a n a ta sk 2 c n n +d m 9. 38 e17 6. 93 e01 9. 02 e01 9. 15 e01 1. 05 e03 4. 20 e01 2. 64 e03 8. 49 e02 n a ta sk 3 c n n +d m 2. 42 e16 4. 95 e02 6. 30 e01 1. 75 e01 2. 13 e03 6. 59 e04 4. 68 e02 1. 24 e01 n a ta sk 4 c n n +d m 5. 84 e03 9. 70 e01 1. 37 e01 4. 83 e03 3. 33 e01 8. 84 e01 1. 08 e01 n a n a ta sk 5 c n n +d m 1. 17 e10 7. 00 e03 7. 93 e04 5. 20 e01 9. 70 e01 5. 66 e01 1. 83 e01 n a n a ta sk 11 c n n +d m 1. 00 e+ 00 9. 84 e01 9. 73 e01 2. 58 e01 7. 17 e01 1. 45 e01 6. 95 e01 n a n a ta sk 12 c n n +d m 1. 93 e14 9. 32 e01 9. 92 e01 2. 57 e02 4. 06 e01 6. 65 e02 2. 09 e01 n a n a ta sk 13 c n n +d m 8. 69 e02 9. 61 e01 9. 72 e01 9. 89 e01 6. 22 e01 9. 44 e01 2. 83 e01 n a n a ta sk 14 c n n +d m 2. 17 e12 6. 64 e02 1. 11 e01 2. 05 e02 3. 66 e02 4. 52 e01 9. 10 e01 8. 24 e01 n a ta sk 15 c n n +d m 1. 36 e52 5. 30 e03 3. 48 e02 7. 21 e02 8. 36 e01 3. 09 e01 8. 47 e01 9. 84 e01 n a ta sk 16 c n n +d m 6. 39 e35 4. 56 e02 9. 66 e01 5. 95 e01 7. 19 e01 4. 09 e02 2. 51 e02 2. 22 e03 n a
ta bl
e 7:
o nes id
ed pva lu
e w
he th
er th
e m
ea n
ac cu
ra cy
of pr
etr
ai ne
d m
od el
s is
gr ea
te rt
ha n
th e
ac cu
ra cy
of th
e ra
nd om
ly in
iti al
iz ed
on es
fo re
ac h
co m
bi na
tio n of ta sk pr etr ai ni ng da ta se t. pva lu es be lo w 0. 05 ar e m ar ke d in gr ee n.",0
687.pdf.json,"in this work we propose and evaluate a novel algorithm for pruning whole neurons from a trained neural network without any re-training and examine its performance compared to two simpler methods. we then analyze the kinds of errors made by our algorithm and use this as a stepping off point to launch an investigation into the fundamental nature of learning representations in neural networks. our results corroborate an insightful though largely forgotten observation by mozer & smolensky (1989a) concerning the nature of neural network learning. this observation is best summarized in a quotation from segee & carter (1991) on the notion of fault-tolerance in multilayer perceptron networks:
contrary to the belief widely held, multilayer networks are not inherently fault tolerant. in fact, the loss of a single weight is frequently sufficient to completely
disrupt a learned function approximation. furthermore, having a large number of weights does not seem to improve fault tolerance. [emphasis added]
essentially, mozer & smolensky (1989b) observed that during training neural networks do not distribute the learning representation evenly or equitably across hidden units. what actually happens is that a few, elite neurons learn an approximation of the input-output function, and the remaining units must learn a complex interdependence function which cancels out their respective influence on the network output. furthermore, assuming enough units exist to learn the function in question, increasing the number of parameters does not increase the richness or robustness of the learned approximation, but rather simply increases the likelihood of overfitting and the number of noisy parameters to be canceled during training. this is evinced by the fact that in many cases, multiple neurons can be removed from a network with no re-training and with negligible impact on the quality of the output approximation. in other words, there are few bipartisan units in a trained network. a unit is typically either part of the (possibly overfit) input-output function approximation, or it is part of an elaborate noise cancellation task force. assuming this is the case, most of the compute-time spent training a neural network is likely occupied by this arguably wasteful procedure of silencing superfluous parameters, and pruning can be viewed as a necessary procedure to “trim the fat.”
we observed copious evidence of this phenomenon in our experiments, and this is the motivation behind our decision to evaluate the pruning algorithms in this study on the simple criteria of their ability to trim neurons without any re-training. if we were to employ re-training as part of our evaluation criteria, we would arguably not be evaluating the quality of our algorithm’s pruning decisions per se but rather the ability of back-propagation trained networks to recover from faults caused by non-ideal pruning decisions, as suggested by the conclusions of segee & carter (1991) and mozer & smolensky (1989a). moreover, as fahlman & lebiere (1989) discuss, due to the “herd effect” and “moving target” phenomena in back-propagation learning, the remaining units in a network will simply shift course to account for whatever error signal is re-introduced as a result of a bad pruning decision or network fault. so long as there are enough critical parameters to learn the function in question, a network can typically recover faults with additional training. this limits the conclusions we can draw about the quality of our pruning criteria when we employ re-training.
in terms of removing units without re-training, what we discovered is that predicting the behavior of a network when a unit is to be pruned is very difficult, and most of the approximation techniques put forth in existing pruning algorithms do not fare well at all when compared to a brute-force search. to begin our discussion of how we arrived at our algorithm and set up our experiments, we review of the existing literature.pruning algorithms, as comprehensively surveyed by reed (1993), are a useful set of heuristics designed to identify and remove elements from a neural network which are either redundant or do not significantly contribute to the output of the network. this is motivated by the observed tendency of neural networks to overfit to the idiosyncrasies of their training data given too many trainable parameters or too few input patterns from which to generalize, as stated by chauvin (1990).
network architecture design and hyperparameter selection are inherently difficult tasks typically approached using a few well-known rules of thumb, e.g. various weight initialization procedures, choosing the width and number of layers, different activation functions, learning rates, momentum, etc. some of this “black art” appears unavoidable. for problems which cannot be solved using linear threshold units alone, baum & haussler (1989) demonstrate that there is no way to precisely determine the appropriate size of a neural network a priori given any random set of training instances. using too few neurons seems to inhibit learning, and so in practice it is common to attempt to overparameterize networks initially using a large number of hidden units and weights, and then prune or compress them afterwards if necessary. of course, as the old saying goes, there’s more than one way to skin a neural network.the generalization behavior of neural networks has been well studied, and apart from pruning algorithms many heuristics have been used to avoid overfitting, such as dropout (srivastava 
(2014)), maxout (goodfellow  (2013)), and cascade correlation (fahlman & lebiere (1989)), among others. of course, while cascade correlation specifically tries to construct of minimal networks, many techniques to improve network generalization do not explicitly attempt to reduce the total number of parameters or the memory footprint of a trained network per se.
model compression often has benefits with respect to generalization performance and the portability of neural networks to operate in memory-constrained or embedded environments. without explicitly removing parameters from the network, weight quantization allows for a reduction in the number of bytes used to represent each weight parameter, as investigated by balzer  (1991), dundar & rose (1994), and hoehfeld & fahlman (1992).
a recently proposed method for compressing recurrent neural networks (prabhavalkar  (2016)) uses the singular values of a trained weight matrix as basis vectors from which to derive a compressed hidden layer. øland & raj (2015) successfully implemented network compression through weight quantization with an encoding step while others such as han  (2016) have tried to expand on this by adding weight-pruning as a preceding step to quantization and encoding.
in summary, we can say that there are many different ways to improve network generalization by altering the training procedure, the objective error function, or by using compressed representations of the network parameters. but these are not, strictly speaking, examples of techniques to reduce the number of parameters in a network. for this we must employ some form of pruning criteria.if we wanted to continually shrink a neural network down to minimum size, the most straightforward brute-force way to do it is to individually switch each element off and measure the increase in total error on the training set. we then pick the element which has the least impact on the total error, and remove it. rinse and repeat. this is extremely computationally expensive, given a reasonably large neural network and training set. alternatively, we might accomplish this using any number of much faster off-the-shelf pruning algorithms, such as skeletonization (mozer & smolensky (1989a)), optimal brain damage (lecun  (1989)), or later variants such as optimal brain surgeon (hassibi & stork (1993)). in fact, we borrow much of our inspiration from these algorithms, with one major variation: instead of pruning individual weights, we prune entire neurons, thereby eliminating all of their incoming and outgoing weight parameters in one go, resulting in more memory saved, faster.
the algorithm developed for this paper is targeted at reducing the total number of neurons in a trained network, which is one way of reducing its computational memory footprint. this is often a desirable criteria to minimize in the case of resource-constrained or embedded devices, and also allows us to probe the limitations of pruning down to the very last essential network elements. in terms of generalization as well, we can measure the error of the network on the test set as each element is sequentially removed from the network. with an oracle pruning algorithm, what we expect to observe is that the output of the network remains stable as the first few superfluous neurons are removed, and as we start to bite into the more crucial members of the function approximation, the error should start to rise dramatically. in this paper, the brute-force approach described at the beginning of this section serves as a proxy for an oracle pruning algorithm.
one reason to choose to rank and prune individual neurons as opposed to weights is that there are far fewer elements to consider. furthermore, the removal of a single weight from a large network is a drop in the bucket in terms of reducing a network’s core memory footprint. if we want to reduce the size of a network as efficiently as possible, we argue that pruning neurons instead of weights is more efficient computationally as well as practically in terms of quickly reaching a hypothetical target reduction in memory consumption. this approach also offers downstream applications a realistic expectation of the minimal increase in error resulting from the removal of a specified percentage of neurons. such trade-offs are unavoidable, but performance impacts can be limited if a principled approach is used to find the best candidate neurons for removal.
it is well known that too many free parameters in a neural network can lead to overfitting. regardless of the number of weights used in a given network, as segee & carter (1991) assert, the representation of a learned function approximation is almost never evenly distributed over the hidden units, and thus the removal of any single hidden unit at random can actually result in a network fault. mozer & smolensky (1989b) argue that only a subset of the hidden units in a neural network actually
latch on to the invariant or generalizing properties of the training inputs, and the rest learn to either mutually cancel each other’s influence or begin overfitting to the noise in the data. we leverage this idea in the current work to rank all neurons in pre-trained networks based on their effective contributions to the overall performance. we then remove the unnecessary neurons to reduce the network’s footprint. through our experiments we not only concretely validate the theory put forth by mozer & smolensky (1989b) but we also successfully build on it to prune networks to 40 to 60 % of their original size without any major loss in performance.as discussed in section 1 our aim is to leverage the highly non-uniform distribution of the learning representation in pre-trained neural networks to eliminate redundant neurons, without focusing on individual weight parameters. taking this approach enables us to remove all the weights (incoming and outgoing) associated with a non-contributing neuron at once. we would like to note here that in an ideal scenario, based on the neuron interdependency theory put forward by mozer & smolensky (1989a), one would evaluate all possible combinations of neurons to remove (one at a time, two at a time, three at a time and so forth) to find the optimal subset of neurons to keep. this is computationally unacceptable, and so we will only focus on removing one neuron at a time and explore more “greedy” algorithms to do this in a more efficient manner.
the general approach taken to prune an optimally trained neural network here is to create a ranked list of all the neurons in the network based off of one of the 3 proposed ranking criteria: a brute force approximation, a linear approximation and a quadratic approximation of the neuron’s impact on the output of the network. we then test the effects of removing neurons on the accuracy and error of the network. all the algorithms and methods presented here are easily parallelizable as well.
one last thing to note here before moving forward is that the methods discussed in this section involve some non-trivial derivations which are beyond the scope of this paper. we are more focused on analyzing the implications of these methods on our understanding of neural network learning representations. however, a complete step-by-step derivation and proof of all the results presented is provided in the supplementary material as an appendix.this is perhaps the most naive yet the most accurate method for pruning the network. it is also the slowest and hence possibly unusable on large-scale neural networks with thousands of neurons. this method explicitly evaluates each neuron in the network. the idea is to manually check the effect of every single neuron on the output. this is done by running a forward propagation on the validation set k times (where k is the total number of neurons in the network), turning off exactly one neuron each time (keeping all other neurons active) and noting down the change in error. turning a neuron off can be achieved by simply setting its output to 0. this results in all the outgoing weights from that neuron being turned off. this change in error is then used to generate the ranked list.let us denote the total error from the optimally trained neural network for any given validation dataset by e. e can be seen as a function of o, where o is the output of any general neuron in the network. this error can be approximated at a particular neuron’s output (say ok) by using the 2nd order taylor series as,
ê(o) ≈ e(ok) + (o −ok) · ∂e
∂o ∣∣∣∣ ok + 0.5 · (o −ok)2 · ∂2e ∂o2 ∣∣∣∣ ok , (1)
when a neuron is pruned, its output o becomes 0.
replacing o by ok in equation 1 shows us that the error is approximated perfectly by equation 1 at ok. so:
∆ek = ê(0)− ê(ok) = −ok · ∂e
∂o ∣∣∣∣ ok + 0.5 ·o2k · ∂2e ∂o2 ∣∣∣∣ ok , (2)
where ∆ek is the change in the total error of the network when exactly one neuron (k) is turned off. most of the terms in this equation are fairly easy to compute, as we have ok already from the activations of the hidden units and we already compute ∂e∂o |ok for each training instance during backpropagation. the ∂ e ∂o2 |ok terms are a little more difficult to compute. this is derived in the
appendix and summarized in the sections below.we can use equation 2 to get the linear error approximation of the change in error due to the kth neuron being turned off and represent it as ∆e1k as follows:
∆e1k = −ok · ∂e
∂o ∣∣∣∣ ok
(3)
the derivative term above is the first-order gradient which represents the change in error with respect to the output a given neuron. this term can be collected during back-propagation. as we shall see further in this section, linear approximations are not reliable indicators of change in error but they provide us with an interesting basis for comparison with the other methods discussed in this paper.as above, we can use equation 2 to get the quadratic error approximation of the change in error due to the kth neuron being turned off and represent it as ∆e2k as follows:
∆e2k = −ok · ∂e
∂o ∣∣∣∣ ok + 0.5 ·o2k · ∂2e ∂o2 ∣∣∣∣ ok
(4)
the additional second-order gradient term appearing above represents the quadratic change in error with respect to the output of a given neuron. this term can be generated by performing backpropagation using second order derivatives. collecting these quadratic gradients involves some non-trivial mathematics, the entire step-by-step derivation procedure of which is provided in the supplementary material as an appendix.figure 1 shows a random error function plotted against the output of any given neuron. note that this figure is for illustration purposes only. the error function is minimized at a particular value of the neuron output as can be seen in the figure. the process of training a neural network is essentially the process of finding these minimizing output values for all the neurons in the network. pruning this particular neuron (which translates to getting a zero output from it will result in a change in the total overall error. this change in error is represented by distance between the original minimum error (shown by the dashed line) and the top red arrow. this neuron is clearly a bad candidate for removal since removing it will result in a huge error increase.
the straight red line in the figure represents the first-order approximation of the error using taylor series as described before while the parabola represents a second-order approximation. it can be clearly seen that the second-order approximation is a much better estimate of the change in error.
one thing to note here is that it is possible in some cases that there is some thresholding required when trying to approximate the error using the 2nd order taylor series expansion. these cases might arise when the parabolic approximation undergoes a steep slope change. to take into account such cases, mean and median thresholding were employed, where any change above a certain threshold was assigned a mean or median value respectively.
two pruning algorithms are proposed here. they are different in the way the neurons are ranked but both of them use ∆ek, the approximation of the change in error as the basis for the ranking. ∆ek can be calculated using the brute force method, or one of the two taylor series approximations discussed previously.
the first step in both the algorithms is to decide a stopping criterion. this can vary depending on the application but some intuitive stopping criteria can be: maximum number of neurons to remove, percentage scaling needed, maximum allowable accuracy drop etc.the complete algorithm is shown in algorithm 1. the idea here is to generate a single ranked list based on the values of ∆ek. this involves a single pass of second-order back-propagation (without weight updates) to collect the gradients for each neuron. the neurons from this rank-list (with the lowest values of ∆ek) are then pruned according to the stopping criterion decided. we note here that this algorithm is intentionally naive and is used for comparison only.
data: optimally trained network, training set result: a pruned network initialize and define stopping criterion ; perform forward propagation over the training set ; perform second-order back-propagation without updating weights and collect linear and quadratic
gradients ; rank the remaining neurons based on ∆ek; while stopping criterion is not met do
remove the last ranked neuron ; end
algorithm 1: single overall rankingin this greedy variation of the algorithm (algorithm 2), after each neuron removal, the remaining network undergoes a single forward and backward pass of second-order back-propagation (without weight updates) and the rank list is formed again. hence, each removal involves a new pass through
the network. this method is computationally more expensive but takes into account the dependencies the neurons might have on one another which would lead to a change in error contribution every time a dependent neuron is removed.
data: optimally trained network, training set result: a pruned network initialize and define stopping criterion ; while stopping criterion is not met do
perform forward propagation over the training set ; perform second-order back-propagation without updating weights and collect linear and
quadratic gradients ; rank the remaining neurons based on ∆ek ; remove the worst neuron based on the ranking ;
end algorithm 2: iterative re-rankingthis problem serves as a quick example to demonstrate many of the phenomena described in previous sections. we trained two networks to learn the cosine function, with one input and one output. this is a task which requires no more than 11 sigmoid neurons to solve entirely, and in this case we don’t care about overfitting because the cosine function has a precise definition. furthermore, the cosine function is a good toy example because it is a smooth continuous function and, as demonstrated by nielsen (2015), if we were to tinker directly with the weights and bias parameters of the network, we could allocate individual units within the network to be responsible for constrained ranges of inputs, similar to a basis spline function with many control points. this would distribute the learned function approximation evenly across all hidden units, and thus we have presented the network with a problem in which it could productively use as many hidden units as we give it. in this case, a pruning algorithm would observe a fairly consistent increase in error after the removal of each successive unit. in practice however, regardless of the number of experimental trials, this is not what happens. the network will always use 10-11 hidden units and leave the rest to cancel each other’s influence.
figure 2 shows two graphs. both graphs demonstrate the use of the iterative re-ranking algorithm and the comparative performance of the brute-force pruning method (in blue), the first order method (in green), and the second order method (in red). the graph on the left shows the performance of these algorithms starting from a network with two layers of 10 neurons (20 total), and the graph on the right shows a network with two layers of 50 neurons (100 total).
in the left graph, we see that the brute-force method shows a graceful degradation, and the error only begins to rise sharply after 50% of the total neurons have been removed. the error is basically constant up to that point. in the first and second order methods, we see evidence of poor decision making in the sense that both made mistakes early on, which disrupted the output function approximation. the first order method made a large error early on, though we see after a few more neurons were removed this error was corrected somewhat (though it only got worse from there). this is direct evidence of the lack of fault tolerance in a trained neural network. this phenomenon is even more starkly demonstrated in the second order method. after making a few poor neuron removal decisions in a row, the error signal rose sharply, and then went back to zero after the 6th neuron was removed. this is due to the fact that the neurons it chose to remove were trained to cancel each others’ influence within a localized part of the network. after the entire group was eliminated, the approximation returned to normal. this can only happen if the output function approximation is not evenly distributed over the hidden units in a trained network.
this phenomenon is even more starkly demonstrated in the graph on the right. here we see the first order method got “lucky” in the beginning and made decent decisions up to about the 40th removed neuron. the second order method had a small error in the beginning which it recovered from gracefully and proceeded to pass the 50 neuron point before finally beginning to unravel. the brute force method, in sharp contrast, shows little to no increase in error at all until 90% of the neurons in the network have been obliterated. clearly first and second order methods have some value in that they do not make completely arbitrary choices, but the brute force method is far better at this task.
this also demonstrates the sharp dualism in neuron roles within a trained network. these networks were trained to near-perfect precision and each pruning method was applied without any re-training of any kind. clearly, in the case of the brute force or oracle method, up to 90% of the network can be completely extirpated before the output approximation even begins to show any signs of degradation. this would be impossible if the learning representation were evenly or equitably distributed. note, for example, that the degradation point in both cases is approximately the same. this example is not a real-world application of course, but it brings into very clear focus the kind of phenomena we will discuss in the following sections.for all the results presented in this section, the mnist database of handwritten digits by lecun & cortes (2010) was used. it is worth noting that due to the time taken by the brute force algorithm we rather used a 5000 image subset of the mnist database in which we have normalized the pixel values between 0 and 1.0, and compressed the image sizes to 20x20 images rather than 28x28, so the starting test accuracy reported here appears higher than those reported by lecun  we do not believe that this affects the interpretation of the presented results because the basic learning problem does not change with a larger dataset or input dimension.the network architecture in this case consisted of 1 layer, 100 neurons, 10 outputs, logistic sigmoid activations, and a starting test accuracy of 0.998.we first present the results for a single-layer neural network in figure 3, using the single overall algorithm (algorithm 1) as proposed in section 3. (we again note that this algorithm is intentionally naive and is used for comparison only. its performance should be expected to be poor.) after training, each neuron is assigned its permanent ranking based on the three criteria discussed previously: a brute force “ground truth” ranking, and two approximations of this ranking using first and second order taylor estimations of the change in network output error resulting from the removal of each neuron.
an interesting observation here is that with only a single layer, no criteria for ranking the neurons in the network (brute force or the two taylor series variants) using algorithm 1 emerges superior, indicating that the 1st and 2nd order taylor series methods are actually reasonable approximations
of the brute force method under certain conditions. of course, this method is still quite bad in terms of the rate of degradation of the classification accuracy and in practice we would likely follow algorithm 2 which is takes into account mozer & smolensky (1989a)’s observations stated in the related work section. the purpose of the present investigation, however, is to demonstrate how much of a trained network can be theoretically removed without altering the network’s learned parameters in any way.in figure 4 we present our results using algorithm 2 (the iterative re-ranking algorithm) in which all remaining neurons are re-ranked after each successive neuron is switched off. we compute the same brute force rankings and taylor series approximations of error deltas over the remaining active neurons in the network after each pruning decision. this is intended to account for the effects of cancelling interactions between neurons.
there are 2 key observations here. using the brute force ranking criteria, almost 60% of the neurons in the network can be pruned away without any major loss in performance. the other noteworthy observation here is that the 2nd order taylor series approximation of the error performs consistently better than its 1st order version, in most situations, though figure 21 is a poignant counter-example.as explained in section 3, these graphs are a visualization of the error surface of the network output with respect to the neurons chosen for removal using each of the 3 ranking criteria, represented in
intervals of 10 neurons. in each graph, the error surface of the network output is displayed in log space (left) and in real space (right) with respect to each candidate neuron chosen for removal. we create these plots during the pruning exercise by picking a neuron to switch off, and then multiplying its output by a scalar gain value α which is adjusted from 0.0 to 10.0 with a step size of 0.001. when the value of α is 1.0, this represents the unperturbed neuron output learned during training. between 0.0 and 1.0, we are graphing the literal effect of turning the neuron off (α = 0), and when α > 1.0 we are simulating a boosting of the neuron’s influence in the network, i.e. inflating the value of its outgoing weight parameters.
we graph the effect of boosting the neuron’s output to demonstrate that for certain neurons in the network, even doubling, tripling, or quadrupling the scalar output of the neuron has no effect on the overall error of the network, indicating the remarkable degree to which the network has learned to ignore the value of certain parameters. in other cases, we can get a sense of the sensitivity of the network’s output to the value of a given neuron when the curve rises steeply after the red 1.0 line. this indicates that the learned value of the parameters emanating from a given neuron are relatively important, and this is why we should ideally see sharper upticks in the curves for the later-removed neurons in the network, that is, when the neurons crucial to the learning representation start to be picked off. some very interesting observations can be made in each of these graphs.
remember that lower is better in terms of the height of the curve and minimal (or negative) horizontal change between the vertical red line at 1.0 (neuron on, α = 1.0) and 0.0 (neuron off, α = 0.0) is indicative of a good candidate neuron to prune, i.e. there will be minimal effect on the network output when the neuron is removed.in figure ??, we notice how low to the floor and flat most of the curves are. it’s only until the 90th removed neuron that we see a higher curve with a more convex shape (clearly a more sensitive, influential piece of the network).it can be seen in figure 6 that most choices seem to have flat or negatively sloped curves, indicating that the first order approximation seems to be pretty good, but examining the brute force choices shows they could be better.the method in figure 7 looks similar to the brute force method choices, though clearly not as good (they’re more spread out). notice the difference in convexity between the 2nd and 1st order method
choices. it’s clear that the first order method is fitting a line and the 2nd order method is fitting a parabola in their approximation.the network architecture in this case consisted of 2 layers, 50 neurons per layer, 10 outputs, logistic sigmoid activations, and a starting test accuracy of 1.000.figure 8 shows the pruning results for algorithm 1 on a 2-layer network. the ranking procedure is identical to the one used to generate figure 3. (we again note that this algorithm is intentionally naive and is used for comparison only. its performance should be expected to be poor.)
unsurprisingly, a 2-layer network is harder to prune because a single overall ranking will never capture the interdependencies between neurons in different layers. it makes sense that this is worse
than the performance on the 1-layer network, even if this method is already known to be bad, and we’d likely never use it in practice.figure 9 shows the results from using algorithm 2 on a 2-layer network. we compute the same brute force rankings and taylor series approximations of error deltas over the remaining active neurons in the network after each pruning decision used to generate figure 4. again, this is intended to account for the effects of cancelling interactions between neurons.
it is clear that it becomes harder to remove neurons 1-by-1 with a deeper network (which makes sense because the neurons have more interdependencies in a deeper network), but we see an overall better performance with 2nd order method vs. 1st order, except for the first 20% of the neurons (but this doesn’t seem to make much difference for classification accuracy.)
perhaps a more important observation here is that even with a more complex network, it is possible to remove up to 40% of the neurons with no major loss in performance which is clearly illustrated by the brute force curve. this shows the clear potential of an ideal pruning technique and also shows how inconsistent 1st and 2nd order taylor series approximations of the error can be as ranking criteria.as seen in the case of a single layered network, these graphs are a visualization the error surface of the network output with respect to the neurons chosen for removal using each algorithm, represented in intervals of 10 neurons.in figure 10, it is clear why these neurons got chosen, their graphs clearly show little change when neuron is removed, are mostly near the floor, and show convex behaviour of error surface, which argues for the rationalization of using 2nd order methods to estimate difference in error when they are turned off.drawing a flat line at the point of each neurons intersection with the red vertical line (no change in gain) shows that the 1st derivative method is actually accurate for estimation of change in error in these cases, but still ultimately leads to poor decisions.clearly these neurons are not overtly poor candidates for removal (error doesn’t change much between 1.0 & zero-crossing left-hand-side), but could be better (as described above in the brute force criterion discussion).in our experiments thus far we have tacitly assumed that we start with a network which has learned an “optimal” representation of the training objective, i.e. it has been trained to the point where we accept its performance on the test set. here we explore what happens when we prune with a sub-optimal starting network.
if the assumptions of this paper regarding the nature of neural network learning are correct, we expect that two processes are essentially at work during back-propagation training. first, we expect that the neurons which directly participate in the fundamental learning representation (even if redundantly) work together to reduce error on the training data. second, we expect that neurons which do not directly participate in the learning representation work to cancel each other’s negative influence. furthermore, we expect that these two groups are essentially distinct, as evinced by the fact that multiple neurons can often be removed as a group with little to no effect on the network output. some non-trivial portion of the training time, then, is spent doing work which has nothing intrinsically to do with the learning representation and essentially functions as noise cancellation.
if this is the case, when we attempt to prune a network which has not fully canceled the noisy influence of extraneous or redundant units, we might expect to see the error actually improve after removing a few bad apples. this is in fact what we observe, as demonstrated in the following experiments.
for each experiment in this section we trained with the full mnist training set (lecun & cortes (2010)), uncompressed and without any data normalization. we trained three different networks to learn to distinguish a single handwritten digit from the rest of the data. the network architectures were each composed of 784 inputs, 1 hidden layer with 100 neurons, and 2 soft-max outputs; one to say yes, and the other to say no. these networks were trained to distinguish the digits 0, 1, and 2, and their respective starting accuracies were a sub-optimal 0.9757, 0.9881, and 0.9513. finally, we only consider the iterative re-ranking algorithm, as the single overall ranking algorithm is clearly nonviable.figure 13 shows the degradation in squared error after removing neurons from a network trained to distinguish the digit 0. what we observe is that the first and second order methods both fail in different ways, though clearly the second order method makes better decisions overall. the first order method explodes spectacularly in the first few iterations. the brute force method, in stark contrast, actually improves in the first few iterations, and remains essentially flat until around the 60% mark, at which point it begins to gradually increase and meet the other curves.
the behavior of the brute force method here demonstrates that the network was essentially working to cancel the effect of a few bad neurons when the training convergence criteria were met, i.e. the network was no longer able to make progress on the training set. after removing these neurons during pruning, the output improved. we can investigate this by looking at the error surface with respect to the neurons chosen for removal by each method in turn. below in figure 14 is the graph of the brute force method.
figure 14 shows an interesting phenomenon, which we will see in later experiments as well. the high blue curve corresponding to neuron 0 is negatively sloped in the beginning and clearly after removing this neuron, the output will improve. the rest of the curves, in correspondence with the squared error degradation curve above, are mostly flat and tightly layered together, indicating that they are good neurons to remove.
in figure 15 below, we observe a stark contrast to this. the curves corresponding to neurons 0 and 10 are mostly flat, and fairly lower than the rest, though clearly a mistake was made early on and the rest of the curves are clearly bad choices. in all of these cases however, we see that the curves are
easily approximated with a straight line and so the first order method may have been fairly accurate in its predictions, even though it still made poor decisions.
figure 15 is an example of how things can go south once a few bad mistakes are made at the outset. figure 16 shows a much better set of choices made by the second order method, though clearly not as good as the brute force method. the log-space plots make it a bit easier to see the difference between the brute force and second order methods in figures 14 and 16, respectively.examining figure 17, we see a much starker example of the previous phenomenon, in which the brute force method continues to improve the performance of the network after removing 80% of the neurons in the network. the first and second order methods fail early and proceed in fits and starts (clearly demonstrating evidence of interrelated groups of noise-canceling neurons), and never fully recover. it should be noted that it would be impossible to see curves like this if neural networks evenly distributed the learning representation evenly or equitably over their hidden units.
one of the most striking things about the blue curve in figure 17 is the fact that the network never drops below its starting error until it crosses the 80% mark, indicating that only 20% of the neurons in this network are actually essential to the learning the training objective. in this sense, we can only
wonder how much of the training time was spent winnowing the error out of the remaining 80% of the network.
in figures 18, 19 and 20 we can examine the choices made by the respective methods. the brute force method serves as our example of a near-optimal pruning regimen, and the rest are first and second order approximations of this. small differences, clearly, can lead to large effects on the network output as shown in figure 17.figure 21 is an interesting case because it shatters our confidence in the reliability of the second order method to make good pruning decisions, and further demonstrates the phenomenon of how much the error can improve if the right neurons are removed after training gets stuck. in this case, though still a poor performance overall, the first order method vastly outperforms the second order method.
figure 22 shows us a clear example of the first element to remove having a negative error slope, and improving the output as a result. the rest of the pruning decisions are reasonable. comparing with the blue curve in figure 21, we see the correspondence between the first pruning decision improving the output, and the remaining pruning decisions keeping the output fairly flat. clearly, however, there isn’t much room to get worse given our starting point with a sub-optimal network, and we see that the ending sum of squared errors is not much higher than the starting point. at the same time, we can still see the contrast in performance if we make optimal pruning decisions, and most of the neurons in this network were clearly doing nothing.
in figure 23, we see a mixed bag in which the decisions are clearly sub-optimal, though much better than figure 24, in which we can observe how a bad first decision essentially ruined the network for good. the jagged edges of the red curve in figure 21 correspond with the positive and negative
slopes of the cluster of bad pruning decisions in 24. once again, these are not necessarily bad decisions, but the starting point is already bad and this cannot be recovered without re-training the network.from the three examples above, we see that in each case, starting from a sub-optimal network, a brute force removal technique consistently improves performance for the first few pruning iterations, and the sum of squared errors does not degrade beyond the starting point until around 60-80% of the neurons have been removed. this is only possible if we have an essentially strict dichotomy between the roles of different neurons during training. if the network needs only 20-40% of the neurons it began with, the training process is essentially dominated by the task of canceling the residual noise of redundant neurons. furthermore, the network can get stuck in training with redundant units and distort the final output. this is strong evidence of our thesis that the learning representation is neither equitably nor evenly distributed and that most of the neurons which do not directly participate in the learning representation can be removed without any retraining.as can be seen from the experiments on mnist, even though the 2nd-order approximation criterion is consistently better than 1st-order, its performance is not nearly as good as brute force based ranking, especially beyond the first layer. what is interesting to note is that from some other experiments conducted on toy datasets (predicting whether a given point would lie inside a given shape on the cartesian plane), the performance of the 2nd-order method was found to be exceptionally good and produced results very close to the brute force method. the 1st-order method, as expected, performed poorly here as well. some of these results are illustrated in figure 25.in conclusion, we must first re-assert that we do not present this work as a bench-marking study of the algorithm we derived and tested. we have merely used this algorithm as a jumping off point to investigate the nature of learning representations in neural networks. what we discovered is that first and second order methods do not make particularly good pruning decisions, and can get hopelessly lost after making a bad pruning decision resulting in a network fault. furthermore, the brute-force algorithm does surprisingly well, despite being computationally expensive. this method does so well in fact, we argue that further investigation is warranted to make this algorithm computationally tractable, though we do not speculate on how that should be done here.
we also observed strong evidence for the hypotheses of mozer & smolensky (1989a) regarding the “dualist” nature of hidden units, i.e. that learning representations are divided between units which either participate in the output approximation or learn to cancel each others influence. this suggests that neural networks may in fact learn a minimal network implicitly, though we cannot say for sure that this is the case without further investigation. a necessary experiment to this end would be to compare the size of network constructed using cascade correlation (fahlman & lebiere (1989)) and compare it to the results described herein.
we have presented a novel algorithm for pruning whole neurons from a trained neural network using a second-order taylor series approximation of the change in error resulting from the removal a given neuron as a pruning criteria. we compared this method to a first order method and a bruteforce serial removal method which exhaustively found the next best single neuron to remove at each stage. our algorithm relies on a combination of assumptions similar to the ones made by mozer & smolensky (1989a) and lecun  (1989) in the formulation of the skeletonization and optimal brain damage algorithms.
first, we assumed that the error function with respect to each individual neuron can be approximated with a straight line or more precisely with a parabola. second, for second derivative terms we consider only the diagonal elements of the hessian matrix, i.e. we assume that each neuron-weight connection can be treated independently of the other elements in the network. third, we assumed that pruning could be done in a serial fashion in which we find the single least productive element in the network, remove it, and move on. we found that all of these assumptions are deeply flawed in the sense that the true relevance of a neuron can only be partially approximated by a first or second order method, and only at certain stages of the pruning process.
for most problems, these methods can usually remove between 10-30% of the neurons in a trained network, but beyond this point their reliability breaks down. for certain problems, none of the described methods seem to perform very well, though for obvious reasons the brute-force method always exhibits the best results. the reason for this is that the error function with respect to each hidden unit is more complex than a simple second-order taylor series can approximate. furthermore, we have not directly taken into account the interdependence of elements within a network, though the work of hassibi & stork (1993) could provide some guidance in this regard. this is another critical issue to investigate in the future.
re-training may help in this regard. we freely admit that our algorithm does not use re-training to recover from errors made in pruning decisions. we argue that evaluating a network pruning algorithm using re-training does not allow us to make fair comparisons between the kinds of decisions made by these algorithms. neural networks are very good at recovering from the removal of individual elements with re-training and so this compensates for sub-optimal pruning criteria.
we have observed that pruning whole neurons from an optimally trained network without major loss in performance is not only possible but also enables compressing networks to 40-70% of their original size, which is of great importance in constrained memory environments like embedded devices. we cite the results of our experiments using the brute force criterion as evidence of this conclusion. however expensive, it would be extremely easy to parallelize this method, or potentially approximate it using a subset of the training data to decide which neurons to prune. this avoids the problem of trying to approximate the importance of a unit and potentially making a mistake.
it would also be interesting to see how these methods perform on deeper networks and on some other popular and real world datasets. in our case, on the mnist dataset, we observed that it was more difficult to prune neurons from a deeper network than from one with a single layer. we should expect
this trend to continue as networks get deeper and deeper, which also calls into further question the reliability of the described first and second order methods. we did investigate the order in which neurons were plucked from each layer of the networks and we found that the brute force method primarily removes neurons from the deepest layer of the network first, but there was no obvious pattern in layer preference for the other two methods.
our experiments using the visualization of error surfaces and pruning decisions concretely establish the fact that not all neurons in a network contribute to its performance in the same way, and the observed complexity of these functions demonstrates limitations of the approximations we used.
finally, we encourage the readers of this work to take these results into consideration when making decisions as to which methods to use to improve network generalization or compress their models. it should be remembered that various heuristics may perform well in practice for reasons which are in fact orthogonal to the accepted justifications given by their proponents.",0
691.pdf.json,"controlling artificial agents using only raw high-dimensional input data such as image or sound is a difficult and important task in the field of reinforcement learning (rl). recent breakthroughs in the field allow its utilization in real-world applications such as autonomous driving (shalev-shwartz , 2016), navigation (bischoff , 2013) and more. agent interaction with the real world is usually either expensive or not feasible, as the real world is far too complex for the agent to perceive. therefore in practice the interaction is simulated by a virtual environment which receives feedback on a decision made by the algorithm. traditionally, games were used as a rl environment, dating back to chess (campbell , 2002), checkers (schaeffer , 1992), backgammon (tesauro, 1995) and the more recent go (silver , 2016). modern games often present problems and tasks which are highly correlated with real-world problems. for example, an agent that masters a racing game, by observing a simulated driver’s view screen as input, may be usefull for the development of an autonomous driver. for high-dimensional input, the leading benchmark is the arcade learning environment (ale) (bellemare , 2013) which provides a common interface to dozens of atari 2600 games, each presents a different challenge. ale provides an extensive benchmarking platform, allowing a controlled experiment setup for algorithm evaluation and comparison. the main challenge posed by ale is to successfully play as many atari 2600 games as possible (i.e., achieving a score higher than an expert human player) without providing the algorithm any game-specific information (i.e., using the same input available to a human - the game screen and score). a key work to tackle this problem is the deep q-networks algorithm (mnih , 2015), which made a breakthrough in the field of deep reinforcement learning by achieving human level performance on 29 out of 49 games. in this work we present a new environment — the retro learning environment (rle). rle sets new challenges by providing a unified interface for atari 2600 games as well as more advanced gaming consoles. as a start we focused on the super nintendo entertainment
system (snes). out of the five snes games we tested using state-of-the-art algorithms, only one was able to outperform an expert human player. as an additional feature, rle supports research of multi-agent reinforcement learning (marl) tasks (buşoniu , 2010). we utilize this feature by training and evaluating the agents against each other, rather than against a pre-configured in-game ai. we conducted several experiments with this new feature and discovered that agents tend to learn how to overcome their current opponent rather than generalize the game being played. however, if an agent is trained against an ensemble of different opponents, its robustness increases. the main contributions of the paper are as follows:
• introducing a novel rl environment with significant challenges and an easy agent evaluation technique (enabling agents to compete against each other) which could lead to new and more advanced rl algorithms.
• a new method to train an agent by enabling it to train against several opponents, making the final policy more robust.
• encapsulating several different challenges to a single rl environment.the arcade learning environment is a software framework designed for the development of rl algorithms, by playing atari 2600 games. the interface provided by ale allows the algorithms to select an action and receive the atari screen and a reward in every step. the action is the equivalent to a human’s joystick button combination and the reward is the difference between the scores at time stamp t and t− 1. the diversity of games for atari provides a solid benchmark since different games have significantly different goals. atari 2600 has over 500 games, currently over 70 of them are implemented in ale and are commonly used for algorithm comparison.infinite mario (togelius , 2009) is a remake of the classic super mario game in which levels are randomly generated. on these levels the mario ai competition was held. during the competition, several algorithms were trained on infinite mario and their performances were measured in terms of the number of stages completed. as opposed to ale, training is not based on the raw screen data but rather on an indication of mario’s (the player’s) location and objects in its surrounding. this environment no longer poses a challenge for state of the art algorithms. its main shortcoming lie in the fact that it provides only a single game to be learnt. additionally, the environment provides hand-crafted features, extracted directly from the simulator, to the algorithm. this allowed the use of planning algorithms that highly outperform any learning based algorithm.the openai gym (brockman , 2016) is an open source platform with the purpose of creating an interface between rl environments and algorithms for evaluation and comparison purposes. openai gym is currently very popular due to the large number of environments supported by it. for example ale, go, mouintaincar and vizdoom (zhu , 2016), an environment for the learning of the 3d first-person-shooter game ”doom”. openai gym’s recent appearance and wide usage indicates the growing interest and research done in the field of rl.universe (universe, 2016) is a platform within the openai framework in which rl algorithms can train on over a thousand games. universe includes very advanced games such as gta v, portal as well as other tasks (e.g. browser tasks). unlike rle, universe doesn’t run the games locally and requires a vnc interface to a server that runs the games. this leads to a lower frame rate and thus longer training times.malmo (johnson , 2016) is an artificial intelligence experimentation platform of the famous game ”minecraft”. although malmo consists of only a single game, it presents numerous challenges since the ”minecraft” game can be configured differently each time. the input to the rl algorithms include specific features indicating the ”state” of the game and the current reward.deepmind lab (dee) is a first-person 3d platform environment which allows training rl algorithms on several different challenges: static/random map navigation, collect fruit (a form of reward) and a laser-tag challenge where the objective is to tag the opponents controlled by the in-game ai. in lab the agent observations are the game screen (with an additional depth channel) and the velocity of the character. lab supports four games (one game - four different modes).in our work, we used several variant of the deep q-network algorithm (dqn) (mnih , 2015), an rl algorithm whose goal is to find an optimal policy (i.e., given a current state, choose action that maximize the final score). the state of the game is simply the game screen, and the action is a combination of joystick buttons that the game responds to (i.e., moving ,jumping). dqn learns through trial and error while trying to estimate the ”q-function”, which predicts the cumulative discounted reward at the end of the episode given the current state and action while following a policy π. the q-function is represented using a convolution neural network that receives the screen as input and predicts the best possible action at it’s output. the q-function weights θ are updated according to:
θt+1(st, at) = θt + α(rt+1 + γmax a
(qt(st+1, a; θ ′ t))−qt(st, at; θt))∇θqt(st, at; θt), (1)
where st, st+1 are the current and next states, at is the action chosen, α is the step size, γ is the discounting factor rt+1 is the reward received by applying at at st. θ′ represents the previous weights of the network that are updated periodically. other than dqn, we examined two leading algorithms on the rle: double deep q-learning (d-dqn) (van hasselt , 2015), a dqn based algorithm with a modified network update rule. dueling double dqn (wang , 2015), a modification of d-dqn’s architecture in which the q-function is modeled using a state (screen) dependent estimator and an action dependent estimator.the super nintendo entertainment system (snes) is a home video game console developed by nintendo and released in 1990. a total of 783 games were released, among them, the iconic super mario world, donkey kong country and the legend of zelda. table (1) presents a comparison between atari 2600, sega genesis and snes game consoles, from which it is clear that snes and genesis games are far more complex.to allow easier integration with current platforms and algorithms, we based our environment on the ale, with the aim of maintaining as much of its interface as possible. while the ale is highly coupled with the atari emulator, stella1, rle takes a different approach and separates the learning environment from the emulator. this was achieved by incorporating an interface named libretro (libretro site), that allows communication between front-end programs to game-console emulators. currently, libretro supports over 15 game consoles, each containing hundreds of games, at an estimated total of over 7,000 games that can potentially be supported using this interface. examples of supported game consoles include nintendo entertainment system, game boy, n64, sega genesis, http://stella.sourceforge.net/
saturn, dreamcast and sony playstation. we chose to focus on the snes game console implemented using the snes9x2 as it’s games present interesting, yet plausible to overcome challenges. additionally, we utilized the genesis-plus-gx3 emulator, which supports several sega consoles: genesis/mega drive, master system, game gear and sg-1000.rle is fully available as open source software for use under gnu’s general public license4. the environment is implemented in c++ with an interface to algorithms in c++, python and lua. adding a new game to the environment is a relatively simple process.rle provides a unified interface to all games in its supported consoles, acting as an rl-wrapper to the libretro interface. initialization of the environment is done by providing a game (rom file) and a gaming-console (denoted by ’core’). upon initialization, the first state is the initial frame of the game, skipping all menu selection screens. the cores are provided with the rle and installed together with the environment. actions have a bit-wise representation where each controller button is represented by a one-hot vector. therefore a combination of several buttons is possible using the bit-wise or operator. the number of valid buttons combinations is larger than 700, therefore only the meaningful combinations are provided. the environments observation is the game screen, provided as a 3d array of 32 bit per pixel with dimensions which vary depending on the game. the reward can be defined differently per game, usually we set it to be the score difference between two consecutive frames. by setting different configuration to the environment, it is possible to alter in-game properties such as difficulty (i.e easy, medium, hard), its characters, levels, etc.integrating snes and genesis with rle presents new challenges to the field of rl where visual information in the form of an image is the only state available to the agent. obviously, snes games are significantly more complex and unpredictable than atari games. for example in sports games, such as nba, while the player (agent) controls a single player, all the other nine players’ behavior is determined by pre-programmed agents, each exhibiting random behavior. in addition, many snes games exhibit delayed rewards in the course of their play (i.e., reward for an actions is given many time steps after it was performed). similarly, in some of the snes games, an agent can obtain a reward that is indirectly related to the imposed task. for example, in platform games, such as super mario, reward is received for collecting coins and defeating enemies, while the goal of the challenge is to reach the end of the level which requires to move to keep moving to the right. moreover, upon completing a level, a score bonus is given according to the time required for its completion. therefore collecting coins or defeating enemies is not necessarily preferable if it consumes too much time. analysis of such games is presented in section 4.2. moreover, unlike atari that consists of http://www.snes9x.com/ 3https://github.com/ekeeke/genesis-plus-gx 4https://github.com.adavbh12/retro-learning-environment
eight directions and one action button, snes has eight-directions pad and six actions buttons. since combinations of buttons are allowed, and required at times, the actual actions space may be larger than 700, compared to the maximum of 18 actions in atari. furthermore, the background in snes is very rich, filled with details which may move locally or across the screen, effectively acting as non-stationary noise since it provided little to no information regarding the state itself. finally, we note that snes utilized the first 3d games. in the game wolfenstein, the player must navigate a maze from a first-person perspective, while dodging and attacking enemies. the snes offers plenty of other 3d games such as flight and racing games which exhibit similar challenges. these games are much more realistic, thus inferring from snes games to ”real world” tasks, as in the case of self driving cars, might be more beneficial. a visual comparison of two games, atari and snes, is presented in figure (1).the evaluation methodology that we used for benchmarking the different algorithms is the popular method proposed by (mnih , 2015). each examined algorithm is trained until either it reached convergence or 100 epochs (each epoch corresponds to 50,000 actions), thereafter it is evaluated by performing 30 episodes of every game. each episode ends either by reaching a terminal state or after 5 minutes. the results are averaged per game and compared to the average result of a human player. for each game the human player was given two hours for training, and his performances were evaluated over 20 episodes. as the various algorithms don’t use the game audio in the learning process, the audio was muted for both the agent and the human. from both, humans and agents
score, a random agent score (an agent performing actions randomly) was subtracted to assure that learning indeed occurred. it is important to note that dqn’s -greedy approach (select a random action with a small probability ) is present during testing thus assuring that the same sequence of actions isn’t repeated. while the screen dimensions in snes are larger than those of atari, in our experiments we maintained the same pre-processing of dqn (i.e., downscaling the image to 84x84 pixels and converting to gray-scale). we argue that downscaling the image size doesn’t affect a human’s ability to play the game, therefore suitable for rl algorithms as well. to handle the large action space, we limited the algorithm’s actions to the minimal button combinations which provide unique behavior. for example, on many games the r and l action buttons don’t have any use therefore their use and combinations were omitted.a thorough comparison of the four different agents’ performances on snes games can be seen in figure (). the full results can be found in table (3). only in the game mortal kombat a trained agent was able to surpass a expert human player performance as opposed to atari games where the same algorithms have surpassed a human player on the vast majority of the games.
one example is wolfenstein game, a 3d first-person shooter game, requires solving 3d vision tasks, navigating in a maze and detecting object. as evident from figure (2), all agents produce poor results indicating a lack of the required properties. by using -greedy approach the agents weren’t able to explore enough states (or even other rooms in our case). the algorithm’s final policy appeared as a random walk in a 3d space. exploration based on visited states such as presented in bellemare  (2016) might help addressing this issue. an interesting case is gradius iii, a side-scrolling, flight-shooter game. while the trained agent was able to master the technical aspects of the game, which includes shooting incoming enemies and dodging their projectiles, it’s final score is still far from a human’s. this is due to a hidden game mechanism in the form of ”power-ups”, which can be accumulated, and significantly increase the players abilities. the more power-ups collected without being use — the larger their final impact will be. while this game-mechanism is evident to a human, the agent acts myopically and uses the power-up straight away5.as part of the environment and algorithm evaluation process, we investigated two case studies. first is a game on which dqn had failed to achieve a better-than-random score, and second is a game on which the training duration was significantly longer than that of other games.
in the first case study, we used a 2d back-view racing game ”f-zero”. in this game, one is required to complete four laps of the track while avoiding other race cars. the reward, as defined by the score of the game, is only received upon completing a lap. this is an extreme case of a reward delay. a lap may last as long as 30 seconds, which span over 450 states (actions) before reward is received. since dqn’s exploration is a simple -greedy approach, it was not able to produce a useful strategy. we approached this issue using reward shaping, essentially a modification of the reward to be a function of the reward and the observation, rather than the reward alone. here, we define the reward to be the sum of the score and the agent’s speed (a metric displayed on the screen of the game). indeed when the reward was defined as such, the agents learned to finish the race in first place within a short training period.
the second case study is the famous game of super mario. in this game the agent, mario, is required to reach the right-hand side of the screen, while avoiding enemies and collecting coins. we found this case interesting as it involves several challenges at once: dynamic background that can change drastically within a level, sparse and delayed rewards and multiple tasks (such as avoiding enemies and pits, advancing rightwards and collecting coins). to our surprise, dqn was able to reach the end of the level without any reward shaping, this was possible since the agent receives rewards for events (collecting coins, stomping on enemies etc.) that tend to appear to the right of the player, causing the agent to prefer moving right. however, the training time required for convergence was significantly longer than other games. we defined the reward as the sum of the in-game reward and a bonus granted according the the player’s position, making moving right preferable. this reward a video demonstration can be found at https://youtu.be.ul9xlmveeu
proved useful, as training time required for convergence decreased significantly. the two games above can be seen in figure (3).
figure (4) illustrates the agent’s average value function . though both were able complete the stage trained upon, the convergence rate with reward shaping is significantly quicker due to the immediate realization of the agent to move rightwards.in this section we describe our experiments with rle’s multi-agent capabilities. we consider the case where the number of agents, n = 2 and the goals of the agents are opposite, as in r1 = −r2. this scheme is known as fully competitive (buşoniu , 2010). we used the simple singleagent rl approach (as described by buşoniu  (2010) section 5.4.1) which is to apply to single agent approach to the multi-agent case. this approach was proved useful in crites and barto (1996) and matarić (1997). more elaborate schemes are possible such as the minimax-q algorithm (littman, 1994), (littman, 2001). these may be explored in future works. we conducted three experiments on this setup: the first use was to train two different agents against the in-game ai, as done in previous sections, and evaluate their performance by letting them compete against each other. here, rather than achieving the highest score, the goal was to win a tournament which consist of 50 rounds, as common in human-player competitions. the second experiment was to initially train two agents against the in-game ai, and resume the training while competing against each other. in this case, we evaluated the agent by playing again against the in-game ai, separately. finally, in our last experiment we try to boost the agent capabilities by alternated it’s opponents, switching between the in-game ai and other trained agents.we chose the game mortal kombat, a two character side viewed fighting game (a screenshot of the game can be seen in figure (1), as a testbed for the above, as it exhibits favorable properties: both players share the same screen, the agent’s optimal policy is heavily dependent on the rival’s behavior, unlike racing games for example. in order to evaluate two agents fairly, both were trained using the same characters maintaining the identity of rival and agent. furthermore, to remove the impact of the starting positions of both agents on their performances, the starting positions were initialized randomly.
in the first experiment we evaluated all combinations of dqn against d-dqn and dueling d-dqn. each agent was trained against the in-game ai until convergence. then 50 matches were performed between the two agents. dqn lost 28 out of 50 games against dueling d-dqn and 33 against d-dqn. d-dqn lost 26 time to dueling d-dqn. this win balance isn’t far from the random case, since the algorithms converged into a policy in which movement towards the opponent is not
required rather than generalize the game. therefore, in many episodes, little interaction between the two agents occur, leading to a semi-random outcome.
in our second experiment, we continued the training process of a the d-dqn network by letting it compete against the dueling d-dqn network. we evaluated the re-trained network by playing 30 episodes against the in-game ai. after training, d-dqn was able to win 28 out of 30 games, yet when faced again against the in-game ai its performance deteriorated drastically (from an average of 17000 to an average of -22000). this demonstrated a form of catastrophic forgetting (goodfellow , 2013) even though the agents played the same game.
in our third experiment, we trained a dueling d-dqn agent against three different rivals: the ingame ai, a trained dqn agent and a trained dueling-dqn agent, in an alternating manner, such that in each episode a different rival was playing as the opponent with the intention of preventing the agent from learning a policy suitable for just one opponent. the new agent was able to achieve a score of 162,966 (compared to the ”normal” dueling d-dqn which achieved 169,633). as a new and objective measure of generalization, we’ve configured the in-game ai difficulty to be ”very hard” (as opposed to the default ”medium” difficulty). in this metric the alternating version achieved 83,400 compared to -33,266 of the dueling d-dqn which was trained in default setting. thus, proving that the agent learned to generalize to other policies which weren’t observed while training.as demonstrated, rle presents numerous challenges that have yet to be answered. in addition to being able to learn all available games, the task of learning games in which reward delay is extreme, such as f-zero without reward shaping, remains an unsolved challenge. additionally, some games, such as super mario, feature several stages that differ in background and the levels structure. the task of generalizing platform games, as in learning on one stage and being tested on the other, is another unexplored challenge. likewise surpassing human performance remains a challenge since current state-of-the-art algorithms still struggling with the many snes games.we introduced a rich environment for evaluating and developing reinforcement learning algorithms which presents significant challenges to current state-of-the-art algorithms. in comparison to other environments rle provides a large amount of games with access to both the screen and the ingame state. the modular implementation we chose allows extensions of the environment with new consoles and games, thus ensuring the relevance of the environment to rl algorithms for years to come (see table (2)). we’ve encountered several games in which the learning process is highly dependent on the reward definition. this issue can be addressed and explored in rle as reward definition can be done easily. the challenges presented in the rle consist of: 3d interpretation, delayed reward, noisy background, stochastic ai behavior and more. although some algorithms were able to play successfully on part of the games, to fully overcome these challenges, an agent must incorporate both technique and strategy. therefore, we believe, that the rle is a great platform for future rl research.the authors are grateful to the signal and image processing lab (sipl) staff for their support, alfred agrell and the libretro community for their support and marc g. bellemare for his valuable inputs.",0
697.pdf.json,"in this paper, we consider the problem of embedding words into a low-dimensional space in order to measure the semantic similarity between them. as an example, how to find whether the word “table” is semantically more similar to the word “stool” than to the word “sky”? that is achieved by constructing a low-dimensional vector representation for each word and measuring similarity between the words as the similarity between the corresponding vectors.
one of the most popular word embedding models by mikolov  (2013) is a discriminative neural network that optimizes skip-gram negative sampling (sgns) objective (see equation 3). it aims at predicting whether two words can be found close to each other within a text. as shown in section 2, the process of word embeddings training using sgns can be divided into two general steps with clear objectives:
step 1. search for a low-rank matrix x that provides a good sgns objective value; step 2. search for a good low-rank representation x = wc⊤ in terms of linguistic metrics,
where w is a matrix of word embeddings and c is a matrix of so-called context embeddings.
unfortunately, most previous approaches mixed these two steps into a single one, what entails a not completely correct formulation of the optimization problem. for example, popular approaches to train embeddings (including the original “word2vec” implementation) do not take into account that the objective from step 1 depends only on the product x = wc⊤: instead of straightforward computing of the derivative w.r.t. x , these methods are explicitly based on the derivatives w.r.t. w and c, what complicates the optimization procedure. moreover, such approaches do not take into account that parametrization wc⊤ of matrix x is non-unique and step 2 is required. indeed, for any invertible matrix s, we have x = w1c⊤1 = w1ss −1c⊤1 = w2c ⊤ 2 , therefore, solutions w1c1 and w2c2 are equally good in terms of the sgns objective but entail different cosine similarities between embeddings and, as a result, different performance in terms of linguistic metrics (see section 4.2 for details).
a successful attempt to follow the above described steps, which outperforms the original sgns optimization approach in terms of various linguistic tasks, was proposed by levy & goldberg (2014). in order to obtain a low-rank matrix x on step 1, the method reduces the dimensionality of shifted positive pointwise mutual information (sppmi) matrix via singular value decomposition (svd). on step 2, it computes embeddings w and c via a simple formula that depends on the factors obtained by svd. however, this method has one important limitation: svd provides a solution to a surrogate optimization problem, which has no direct relation to the sgns objective. in fact, svd minimizes the mean squared error (mse) between x and sppmi matrix, what does not lead to minimization of sgns objective in general (see section 6.1 and section 4.2 in levy & goldberg (2014) for details).
these issues bring us to the main idea of our paper: while keeping the low-rank matrix search setup on step 1, optimize the original sgns objective directly. this leads to an optimization problem over matrixx with the low-rank constraint, which is often (mishra  (2014)) solved by applying riemannian optimization framework (udriste (1994)). in our paper, we use the projector-splitting algorithm (lubich & oseledets (2014)), which is easy to implement and has low computational complexity. of course, step 2 may be improved as well, but we regard this as a direction of future work.
as a result, our approach achieves the significant improvement in terms of sgns optimization on step 1 and, moreover, the improvement on step 1 entails the improvement on step 2 in terms of linguistic metrics. that is why, the proposed two-step decomposition of the problem makes sense, what, most importantly, opens the way to applying even more advanced approaches based on it (e.g., more advanced riemannian optimization techniques for step 1 or a more sophisticated treatment of step 2).
to summarize, the main contributions of our paper are:
• we reformulated the problem of sgns word embedding learning as a two-step procedure with clear objectives;
• for step 1, we developed an algorithm based on riemannian optimization framework that optimizes sgns objective over low-rank matrix x directly;
• our algorithm outperforms state-of-the-art competitors in terms of sgns objective and the semantic similarity linguistic metric (levy & goldberg (2014); mikolov  (2013); schnabel  (2015)).in this paper, we consider the skip-gram negative sampling (sgns) word embedding model (mikolov  (2013)), which is a probabilistic discriminative model. assume we have a text corpus given as a sequence of words w1, . . . , wn, where n may be larger than 1012 and wi ∈ vw belongs to a vocabulary of words vw . a context c ∈ vc of the word wi is a word from set {wi−l, ..., wi−1, wi+1, ..., wi+l} for some fixed window size l. letw, c ∈ rd be the word embeddings of word w and context c, respectively. assume they are specified by the following mappings:
w : vw → rd, c : vc → rd. the ultimate goal of sgns word embedding training is to fit good mappingsw and c. in the sgns model, the probability that pair (w, c) is observed in the corpus is modeled as a following function:
p ((w, c) ∈ d|w, c) = σ(⟨w, c⟩) = 1 1 + exp(−⟨w, c⟩) , (1)
where d is the multiset of all word-context pairs (w, c) observed in the corpus and ⟨x,y⟩ is the scalar product of vectors x and y. number d is a hyperparameter that adjusts the flexibility of the model. it usually takes values from tens to hundreds.
in order to collect a training set, we take all pairs (w, c) fromd as positive examples and k randomly generated pairs (w, c) as negative ones. let #(w, c) be the number of times the pair (w, c) appears
in d. thereby the number of times the word w and the context c appear in d can be computed as #(w) = ∑ c∈vc #(w, c) and #(c) = ∑ w∈vw #(w, c) accordingly. then negative examples are generated from the distribution defined by #(c) counters: pd(c) = #(c) |d| . in this way, we have a model maximizing the following logarithmic likelihood objective for each word pair (w, c):
#(w, c)(log σ(⟨w, c⟩) + k · ec′∼pd log σ(−⟨w, c′⟩)). (2) in order to maximize the objective over all observations for each pair (w, c), we arrive at the following sgns optimization problem over all possible mappingsw and c:
l = ∑
w∈vw ∑ c∈vc #(w, c)(log σ(⟨w, c⟩) + k · ec′∼pd log σ(−⟨w, c′⟩)) → maxw, . (3)
usually, this optimization is done via the stochastic gradient descent procedure that is performed during passing through the corpus (mikolov  (2013); rong (2014)).relying on the prospect proposed by levy & goldberg (2014), let us show that the optimization problem given by (3) can be considered as a problem of searching for a matrix that maximizes a certain objective function and has the rank-d constraint (step 1 in the scheme described in section 1).as shown by levy & goldberg (2014), the logarithmic likelihood (3) can be represented as the sum of lw,c(w, c) over all pairs (w, c), where lw,c(w, c) has the following form:
lw,c(w, c) =#(w, c) log σ(⟨w, c⟩) + k #(w)#(c)
|d| log σ(−⟨w, c⟩). (4)
a crucial observation is that this loss function depends only on the scalar product ⟨w, c⟩ but not on embeddings w and c separately:
lw,c(w, c) = fw,c(xw,c),
fw,c(xw,c) = aw,c log σ(xw,c) + bw,c log σ(−xw,c), where xw,c is the scalar product ⟨w, c⟩ and aw,c = #(w, c), bw,c = k#(w)#(c)|d| are constants.denote |vw | as n and |vc | as m. let w ∈ rn×d and c ∈ rm×d be matrices, where each row w ∈ rd of matrix w is the word embedding of the corresponding word w and each row c ∈ rd of matrix c is the context embedding of the corresponding context c. then the elements of the product of these matrices
x = wc⊤
are the scalar products xw,c of all pairs (w, c):
x = (xw,c), w ∈ vw , c ∈ vc . note that this matrix has rank d, becausex equals to the product of two matrices with sizes (n× d) and (d×m). now we can write sgns objective given by (3) as a function of x:
f (x) = ∑
w∈vw ∑ c∈vc fw,c(xw,c), f : rn×m → r. (5)
this arrives us at the following proposition:
proposition 1 sgns optimization problem given by (3) can be rewritten in the following constrained form:
maximize x∈rn×m f (x), subject to x ∈ md, (6)
wheremd is the manifold (udriste (1994)) of all matrices in rn×m with rank d: md = {x ∈ rn×m : rank(x) = d}.
the key idea of this paper is to solve the optimization problem given by (6) via the framework of riemannian optimization, which we introduce in section 3.
important to note that this prospect does not suppose the optimization over parameters w and c directly. this entails the optimization in the space with ((n + m − d) · d) degrees of freedom (mukherjee  (2015)) instead of ((n + m) · d), what simplifies the optimization process (see section 5 for the experimental results).oncex is found, we need to recoverw andc such thatx = wc⊤ (step 2 in the scheme described in section 1). this problem does not have a unique solution, since if (w,c) satisfy this equation, thenws−1 and cs⊤ satisfy it as well for any non-singular matrix s. moreover, different solutions may achieve different values of the linguistic metrics (see section 4.2 for details). while our paper focuses on step 1, we use, for step 2, a heuristic approach that was proposed by levy  (2015) and it shows good results in practice. we compute svd of x in the form x = uσv ⊤, where u and v have orthonormal columns, and σ is the diagonal matrix, and use
w = u √ σ, c = v √ σ
as matrices of embeddings.
a simple justification of this solution is the following: we need to map words into vectors in a way that similar words would have similar embeddings in terms of cosine similarities:
cos(w1,w2) = ⟨w1,w2⟩
∥w1∥ · ∥w2∥ .
it is reasonable to assume that two words are similar, if they share contexts. therefore, we can estimate the similarity of two words w1, w2 as s(w1, w2) = ∑ c∈vc xw1,c · xw2,c, what is the element of the matrix xx⊤ with indices (w1, w2). note that xx⊤ = uσv ⊤v σu⊤ = uς2u⊤. if we choose w = uς, we exactly obtain ⟨w1,w2⟩ = s(w1, w2), since ww⊤ = xx⊤ in this case. that is, the cosine similarity of the embeddingsw1,w2 coincides with the intuitive similarity s(w1, w2). however, scaling by √ σ instead of σ was shown by levy  (2015) to be a better solution in experiments.the main idea of riemannian optimization (udriste (1994)) is to consider (6) as a constrained optimization problem. assume we have an approximated solution xi on a current step of the optimization process, where i is the step number. in order to improve xi, the next step of the standard gradient ascent outputs xi + ∇f (xi), where ∇f (xi) is the gradient of objective f at the point xi. note that the gradient ∇f (xi) can be naturally considered as a matrix in rn×m. point xi + ∇f (xi) leaves the manifold md, because its rank is generally greater than d. that is why riemannian optimization methods map point xi + ∇f (xi) back to manifold md. the standard riemannian gradient method first projects the gradient step onto the tangent space at the current point xi and then retracts it back to the manifold:
xi+1 = r (ptm (xi +∇f (xi))),
where r is the retraction operator, and ptm is the projection onto the tangent space.in our paper, we use a much simpler version of such approach that retracts point xi + ∇f (xi) directly to the manifold, as illustrated on figure 1: xi+1 = r(xi +∇f (xi)).
under review as a conference paper at iclr 2017
fine-tuning word embeddings xxxxx xxxxx xxxxx xxxx xxxx xxxx xxx xxxxx xxxx xxxxx abstract blah-blah
keywords word embeddings, sgns, word2vec, glove . introduction sdfdsf . conclusions . related work mikolov main [?] levi main [?]
rfi
xi = uisiv t i
xi+1 = ui+1si+1v t i+1
retraction . conclusions
permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. to copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. woodstock ’97 el paso, texas usa copyright 20xx acm x-xxxxx-xx-x/xx/xx ...$15.00.
fine-tuning word embeddings xxxxx xxxxx xxxxx xxxx xxxx xxxx xxx xxxxx xxxx xxxxx abstract blah-blah keywords word embeddings, sgns, word2vec, glove . introduction sdfdsf . conclusions . related work mikolov main [?] levi main [?]
rfi
xi = uisiv t i
xi+1 = ui+1si+1v t i+1
retraction
md . conclusions
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. to copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. woodstock ’97 el paso, texas usa copyright 20xx acm x-xxxxx-xx-x/xx/xx ...$15.00.
fine-tuning word embeddings xxxxx xxxxx xxxxx xxxx xxxx xxxx xxx xxxxx xxxx xxxxx
abstract blah-blah
keywords word embeddings, sgns, word2vec, glove . introduction sdfdsf . conclusions . related work mikolov main [?] levi main [?]
rf (xi)
xi +rf (xi)
xi = uisiv t i
xi
xi+1
xi+1 = ui+1si+1v t i+1
retraction
md . conclusions
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. to copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. woodstock ’97 el paso, texas usa copyright 20xx acm x-xxxxx-xx-x/xx/xx ...$15.00.
fine-tuning word embeddings xxxxx xxxxx xxxxx xxx xxxx xxxx xxx xxxxx xxxx xxxxx abstract blah-blah
keywords word embeddings, sgns, word2vec, glovesdfdsf . conclusions . related work mikolov main [?] levi main [?]
rf (xi)
xi +rf (xi)
xi = uisiv t i
xi
xi+1
xi+1 = ui+1si+1v t i+1
retraction
md . conclusions
permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for profit or commercial advantage and that copies
bear this notice and the full citation on the first page. to copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. woodstock ’97 el paso, texas usa copyright 20xx acm x-xxxxx-xx-x/xx/xx ...$15.00.
fine-tuning word embeddings xxxxx xxxxx xxxxx xxxx xxxx xxxx xxx xxxxx xxxx xxxxx
abstract blah-blah
keywords word embeddings, sgns, word2vec, glove . introduction sdfdsf . conclusions . related work mikolov main [?] levi main [?]
rf (xi)
xi +rf (xi)
xi = uisiv t i
xi
xi+1
xi+1 = ui+1si+1v t i+1
retraction
md . conclusions
permission to make digital or hard copies of all or part of this work for personal or classro m us is r nted without f e provided tha copies are not made or distributed for profit or commercial advantage an that copies bear this notice and the full citation n the first page. to copy otherwise, to republish, to post on servers or to redistribute o lists, requires prior specific permission and/or a fee. woodstock ’97 el paso, texas usa copyright 20xx acm x-xxxxx-xx-x/xx/xx ...$15.00.
fine-tuning word embeddings xxxxx xx xxxxx xxxx xxxx xxxx xxx xxxxx xxxx xxxxx abstract blah-blah
keywords word embeddings, sgns, word2vec, glove . int oduction sdfdsf . conclusions . related work mikolov main [?] levi main [?]
rf (xi)
xi +rf (xi)
xi = uisiv t i
xi
xi+1
xi+1 = ui+1si+1v t i+1
retraction
md . conclusions
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. to copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. woodstock ’97 el paso, texas usa copyright 20xx acm x-xxxxx-xx-x/xx/xx ...$15.00.
figure 1: geometric interpretation of one step of projector-splitting optimization procedure: the gradient step an the retraction of the high-rank atr x xi + ∇f (xi) to the manifold of low-rank matrices md.
intuitively, retractor r finds rank-d matrix on t e manifold md tha is similar to high-rank matrixxi+∇f (xi) in terms o frobeniu orm. how can e do it? the most straightforward way to reduce the rank ofxi +∇f (xi) is to perform the svd, which keeps d largest singular values of it: : ui+1, si+1, v ⊤i+1 ← svd(xi +∇f (xi)), 2: xi+1 ← ui+1si+1v ⊤i+1.
(7)
however, it is computationally expensive. instead of this approach, we use the projector-splitting method (lubich & oseledets (2014)), which is a second-order retraction onto the manifold (for details, see the review by absil & oseledets (2015)). its practical implementation is also quite intuitive: instead of computing the full svd of xi +∇f (xi) according to the gradient projection method, we use just one step of the block power numerical method (bentbib & kanber (2015)) which computes the svd, what reduces the computational complexity.
let us keep the current point in the following factorized form: xi = uisiv ⊤ i , (8) where matrices ui ∈ rn×d and vi ∈ rm×d have d orthonormal columns and si ∈ rd×d. then we need to perform two qr-decompositions to retract point xi +∇f (xi) back to the manifold: : ui+1, si+1 ← qr ((xi +∇f (xi))vi) , 2: vi+1, s⊤i+1 ← qr ( (xi +∇f (xi))⊤ui+1 ) , : xi+1 ← ui+1si+1v ⊤i+1. in this way, we always keep the solution xi+1 = ui+1si+1v ⊤i+1 on the manifold md and in the form (8).
what is important, we only need to compute ∇f (xi), so the gradients with respect to u , s and v are never computed explicitly, thus avoiding the subtle case where s is close to singular (so-called singular (critical) point on the manifold). indeed, the gradient with respect to u (while keeping the orthogonality constraints) can be written (koch & lubich (2007)) as:
∂f ∂u = ∂f ∂x v s−1,
which means that the gradient will be large if s is close to singular. the projector-splitting scheme is free from this problem.in case of sgns objective given by (5), an element of gradient ∇f has the form:
(∇f (x))w,c = ∂fw,c(xw,c)
∂xw,c = #(w, c) · σ (−xw,c)− k
#(w)#(c)
|d| · σ (xw,c) .
to make the method more flexible in terms of convergence properties, we additionally use λ ∈ r, which is a step size parameter. in this case, retractor r returns xi + λ∇f (xi) instead of xi +∇f (xi) onto the manifold. the whole optimization procedure is summarized in algorithm 1.
algorithm 1 riemannian optimization for sgns require: dimentionality d, initializationw0 and c0, step size λ, gradient function∇f : rn×m →
rn×m, number of iterationsk ensure: factorw ∈ rn×d 1: x0 ← w0c⊤0 # get an initial point at the manifold 2: u0, s0, v ⊤0 ← svd(x0) # compute the first point satisfying the low-rank constraint 3: i ← 0 4: while i < k do 5: ui+1, si+1 ← qr ((xi + λ∇f (xi))vi) # perform one step of the block power method
with two qr-decompositions 6: vi+1, s⊤i+1 ← qr ( (xi + λ∇f (xi))⊤ui+1 ) 7: xi+1 ← ui+1si+1v ⊤i+1 # update the point at the manifold 8: i ← i+ 1 9: end while 10: u,σ, v ⊤ ← svd(xk) 11: w ← u √ σ # compute word embeddings 12: return wwe compare our method (“ro-sgns” in the tables) performance to two baselines: sgns embeddings optimized via stochastic gradient descent, implemented in the original “word2vec”, (“sgdsgns” in the tables) by mikolov  (2013) and embeddings obtained by svd over sppmi matrix (“svd-sppmi” in the tables) by levy & goldberg (2014). we have also experimented with the blockwise alternating optimization over factors w and c, but the results are almost the same to sgd results, that is why we do not to include them into the paper. the source code of our experiments is available online1.
the models were trained on english wikipedia “enwik9” corpus2, which was previously used in most papers on this topic. like in previous studies, we counted only the words which occur more than 200 times in the training corpus (levy & goldberg (2014); mikolov  (2013)). as a result, we obtained a vocabulary of 24292 unique tokens (set of words vw and set of contexts vc are equal). the size of the context window was set to 5 for all experiments, as it was done by levy & goldberg (2014); mikolov  (2013). we conduct two series of experiments: for dimensionality d = 100 and d = 200.
optimization step size is chosen to be small enough to avoid huge gradient values. however, thorough choice of λ does not result in a significant difference in performance (this parameter was tuned on the training data only, the exact values used in experiments are reported below).we evaluate word embeddings via the word similarity task. we use the following popular datasets for this purpose: “wordsim-353” (finkelstein  (2001); 3 datasets), “simlex-999” (hill  (2016)) and “men” (bruni  (2014)). original “wordsim-353” dataset is a mixture of the word pairs for both word similarity and word relatedness tasks. this dataset was split (agirre  (2009)) into two intersecting parts: “wordsim-sim” (“ws-sim” in the tables) and “wordsim-rel” (“ws-rel” in the tables) to separate the words from different tasks. in our experiments, we use both of them on a par with the full version of “wordsim-353” (“ws-full” in the tables). each dataset contains word pairs together with assessor-assigned similarity scores for each pair. as a quality measure, we use spearman’s correlation between these human ratings and cosine similarities for each pair. we call this quality metric linguistic in our paper. https://github.com.ewozz/riemannian_sgns 2enwik9 corpus can be found here: http://mattmahoney.net/dc/textdatafirst of all, we compare the value of sgns objective obtained by the methods. the comparison is demonstrated in table 1.
we see that sgd-sgns and svd-sppmi methods provide quite similar results, however, the proposed method obtains significantly better sgns values, what proves the feasibility of using riemannian optimization framework in sgns optimization problem. it is interesting to note that svdsppmi method, which does not optimize sgns objective directly, obtains better results than sgdsgns method, which aims at optimizing sgns. this fact additionally confirms the idea described in section 2.2.2 that the independent optimization over parameters w and c may decrease the performance.
however, the target performance measure of embedding models is the correlation between semantic similarity and human assessment (section 4.2). table 2 presents the comparison of the methods in terms of it. we see that our method outperforms the competitors on all datasets except for “men” dataset where it obtains slightly worse results. moreover, it is important that the higher dimension entails higher performance gain of our method in comparison to the competitors.
in order to understand how exactly our model improves or degrades the performance in comparison to the baseline, we found several words, whose neighbors in terms of cosine distance change significantly. table 3 demonstrates neighbors of words “five”, “he” and “main” in terms of our model and its nearest competitor according to the similarity task — svd-sppmi. these words were chosen as representative examples whose neighborhoods in terms of svd-sppmi and ro-sgns models are strikingly different. a neighbour of a source word is bold if we suppose that it has a similar semantic meaning to the source word. first of all, we notice that our model produces much better neighbors of the words describing digits or numbers (see word “five” as an example). the similar situation happens for many other words, e.g. in case of word “main” — the nearest neighbors contain 4 similar words in case of our model instead of 2 in case of svd-sppmi. the neighbourhood of word “he” contains less semantically similar words in case of our model. however, it filters out completely irrelevant words, such as “promptly” and “dumbledore”.
talking about the optimal number k of iterations in the optimization procedure and step size λ, we found that they depend on the particular value of dimensionality d. for d = 100, we have k = 25, λ ≈ 5 · 10−5, and for d = 200, we have k = 13, λ = 10−4. moreover, it is interesting that the best results were obtained when svd-sppmi embeddings were used as an initialization of riemannian optimization process.skip-gram negative sampling was introduced by mikolov  (2013). the “negative sampling” approach was thoroughly described by goldberg & levy (2014), and the learning method is explained by rong (2014). there are several open-source implementations of sgns neural network, which is widely known as “word2vec” 34.
as shown in section 2.2, skip-gram negative sampling optimization can be reformulated as a problem of searching for a low-rank matrix. in order to be able to use out-of-the-box svd for this task, levy & goldberg (2014) used the surrogate version of sgns as the objective function. there are two general assumptions made in their algorithm that distinguish it from the sgns optimization: . svd optimizes mean squared error (mse) objective instead of sgns loss function. . in order to avoid infinite elements in spmi matrix, it is transformed in ad-hoc manner (sppmi matrix) before applying svd.
this makes the objective not interpretable in terms of the original task (3). as mentioned by levy & goldberg (2014), sgns objective weighs different (w, c) pairs differently, unlike the svd, which works with the same weight for all pairs, what may entail the performance fall. the comprehensive explanation of the relation between sgns, sppmi, svd-over-sppmi methods is provided by keerthi  (2015). lai  (2015); levy  (2015) give a good overview of highly practical methods to improve these word embedding models.an introduction to optimization over riemannian manifolds can be found in the paper of udriste (1994). the overview of retractions of high rank matrices to low-rank manifolds is provided by absil & oseledets (2015). the projector-splitting algorithm was introduced by lubich & oseledets (2014), and also was mentioned by absil & oseledets (2015) as “lie-trotter retraction”.
riemannian optimization is succesfully applied to various data science problems: for example, matrix completion (vandereycken (2013)), large-scale recommender systems (tan  (2014)), and tensor completion (kressner  (2014)).in our paper, we proposed the general two-step scheme of training sgns word embedding model and introduced the algorithm that performs the search of a solution in the low-rank form via riemannian optimization framework. we also demonstrated the superiority of the proposed method, by providing the experimental comparison to the existing state-of-the-art approaches.
it seems to be an interesting direction of future work to apply more advanced optimization techniques to step 1 of the scheme proposed in section 1 and to explore the step 2 — obtaining embeddings with a given low-rank matrix. original google word2vec: https://code.google.com/archive/p/word2vec/ 4gensim word2vec: https://radimrehurek.com/gensim/models/word2vec.html",0
719.pdf.json,"infants are able to learn the binding between abstract concepts to the real world via their sensory input. for example, the abstract concept ball is binding to the visual representation of a rounded object and the auditory representation of the phonemes /b/ /a/ /l/. this scenario can be seen as the symbol grounding problem (harnad, 1990). moreover, infants are also able to learn the association between different sensory input signals while they are still learning the binding of the abstract concepts. several results have shown a correlation between object recognition (visual) and vocabulary acquisition (auditory) in infants (balaban & waxman, 1997; asano , 2015). one example of this correlation is the first words that infants have learned. in that case, the words are mainly nouns, which are visible concepts, such as, dad, mom, ball, dog, cat (gershkoff-stowe & smith, 2004). as a result, we can define the previous scenario in terms of a machine learning tasks. more formally, the task is defined by learning the association between two parallel streams of data that represent the same unknown class (or abstract concept). note that this task is different from the supervised association where the data has labels. first, the semantic concept is unknown in our scenario whereas it is known in the supervised case. second, both classifiers needs to agree on the same coding scheme for each sample pair during training. in contrast, the coding-scheme is already pre-defined before training in the supervised case. figure 1 shows an example of the difference between a supervised association task and our scenario.
usually, classifiers requires labeled data for training. however, the presented scenario needs an alternative training mechanism. one way is to train based on statistical distributions. casey (1986) proposed to solve the ocr problem using language statistics for inferring form images to characters. later on, knight  (2006) applied a similar idea to machine translation. recently, sutskever  (2015) defined the output distribution matching (odm) cost function for dual autoencoders and generative networks.
in this paper, we are proposing a novel model that is trained based on the association of two input samples of the same unknown class. the presented model has two parallel multilayer perceptrons (mlps) with an expectation-maximization (em) (dempster , 1977) training rule that matches the network output against a statistical distribution. also, both networks agree on the same classification because one network is used as target of the other network, and vice versa. our model has some
similarities with siamese networks proposed by chopra  (2005). they introduced their model for supervised face verification where training is based on constraints of pairs of faces. the constraints exploit the relation of two faces that may or may not be instances of the same person. however, there are some differences to our work. first, our training rule does not have pre-defined classes before training, whereas the siamese network requires labeled samples. second, our model only requires instances of the same unknown class, whereas the siamese network requires two types of input pairs: a) instances of the same person and b) instances of two different persons. our contributions in this paper are
• we define a novel training rule based on matching the output vectors of the presented model and a statistical distribution. note that the output vectors are used as symbolic features similar to the symbol grounding problem. furthermore, the proposed training rule is based on an em-approach and classified each sample based on generated pseudo-classes (section 2.1).
• we propose a novel architecture for learning the association in the classless scenario. moreover, the presented model uses two parallel mlps, which require to agree on the same class for each input sample. this association is motivated by the correlation between different sensory input signals in infants development. in more detail, one network is the target of the other network, and vice versa. also, note that our model is gradient-based and can be extended to deeper architectures (section 2.2).
• we evaluate our classless association task against two cases: totally supervised and totally unsupervised. in this manner, we can verify the range of our results in terms of supervised and unsupervised cases since our model is neither totally supervised nor totally unsupervised. we compare against a mlp trained with labels as the supervised scenario (upper bound) and two clustering algorithms (k-means and hierarchical agglomerative) as the unsupervised scenario (lower bound). first, our model reaches better results than the clustering. second, our model shows promising results with respect to the supervised scenario (sections 3 and 4).in this paper, we are interested in the classless association task in the following scenario: two input instances x(1) and x(2) belong to the same unknown class c, where x(1) ∈ x(1) and x(2) ∈ x(2) are two disjoint sets, and the goal is to learn the output classification of x(1) and x(2) is the same c(1) = c(2), where c(1) and c(2) ∈ c is the set of possible classes. with this in mind, we present a model that has two parallel multilayer perceptrons (mlps) that are trained with an em-approach that associates both networks in the following manner: one network uses the other network as a target, and vice versa. we explain how the output vectors of the network are matched to a statistical distribution in section 2.1 and the classless association learning is presented in section 2.2.one of our constraint is to train a mlp without classes. as a result, we use an alternative training rule based on matching the output vectors and a statistical distribution. for simplicity, we explain our training rule using a single mlp with one hidden layer, which is defined by
z = network(x;θ) (1)
where x ∈ rn is the input vector, θ encodes the parameters of the mlp, and z ∈ rc is the output vector. moreover, the output vectors (z1, . . . ,zm) of a mini-batch of size m are matched to a target distribution (e[z1, . . . ,zm] ∼ φ ∈ rc), e.g., uniform distribution. we have selected a uniform distribution because it is an ideal case to have a balanced dataset for any classifier. however, it is possible to extend to different distribution. we introduce a new parameter that is a weighting vector γ ∈ rc. the intuition behind it is to guide the network based on a set of generated pseudo-classes c. these pseudo-classes can be seen as cluster indexes that group similar elements. with this in mind, we also propose an em-training rule for learning the unknown class given a desired target distribution. we want to point out that the pseudo-classes are internal representations of the network that are independent of the labels.
the e-step obtains the current statistical distribution given the output vectors (z1, . . . ,zm) and the weighting vector (γ). in this case, an approximation of the distribution is obtained by the following equation
ẑ = 1
m m∑ i=1 power(zi,γ) (2)
where γ is the weighting vector, zi is the output vector of the network, m is the number of elements, and the function power1 is the element-wise power operation between the output vector and the weighting vector. we have used the power function because the output vectors (z1, . . . , zm) are quite similar between them at the initial state of the network, and the power function provides an initial boost for learning to separate the input samples in different pseudo-classes in the first iterations. moreover, we can retrieve the pseudo-classes by the maximum value of the following equation
c∗ = arg maxc power(zi,γ) (3)
where c∗ is the pseudo-class, which are used in the m-step for updating the mlp weights. also, note that the pseudo-classes are not updated in an online manner. instead, the pseudo-classes are updated after a certain number of iterations. the reason is the network requires a number of iterations to learn the common features.
the m-step updates the weighting vector γ given the current distribution ẑ. also, the mlp parameters (θ) are updated given the current classification given by the pseudo-classes. the cost function is the variance between the distribution and the desired statistical distribution, which is defined by
cost = (ẑ − φ)2 (4) 1we decide to use power function instead of zγi in order to simplify the index notation
where ẑ is the current statistical distribution of the output vectors, and φ is a vector that represent the desired statistical distribution, e.g. uniform distribution. then, the weighting vector is updated via gradient descent
γ = γ − α ∗ ∇γcost (5)
where α is the learning rate and ∇γcost is the derivative w.r.t γ. also, the mlp weights are updated via the generated pseudo-classes, which are used as targets in the backpropagation step.
in summary, we propose an em-training rule for matching the network output vectors and a desired target statistical distribution. the e-step generates pseudo-classes and finds an approximation of the current statistical distribution of the output vectors. the m-step updates the mlp parameters and the weighting vector. with this in mind, we adapt the mentioned training rule for the classless association task. figure 2 summarizes the presented em training rule and its components.our second constraint is to classify both input samples as the same class and different from the other classes. note that the pseudo-class (equation 3) is used as identification for each input sample and it is not related to the semantic concept or labels. the presented classless association model is trained based on a statistical constraint. formally, the input is represented by the pair x(1) ∈ rn1 and x(2) ∈ rn2 where x(1) and x(2) are two different instances of the same unknown label. the classless association model has two parallel multilayer perceptron mlp (1) and mlp (2) with training rule that follows an em-approach (cf. section 2.1). moreover, input samples are divided into several mini-batches of size m.
initially, all input samples have random pseudo-classes c(1)i and c (2) i . the pseudo-classes have the same desired statistical distribution φ. also, the weighting vectors γ(1) and γ(2) are initialized to one. then each input element from the mini-batch is propagated forward to each mlp. afterwards, an estimation of the statistical distribution for each mlp (ẑ(1) and ẑ(2)) is obtained. furthermore, a new set of pseudo-classes (c(1)1 , . . . , c (1) m and c (2) 1 , . . . , c (2) m ) is obtained for each network. note that this first part can be seen as an e-step from section 2.1. we want to point out that the pseudo-classes are updated only after a number of iterations.
the second part of our association training updates the mlp parameters and the weighting vector (γ(1) and γ(2)). in this step, one network (mlp (1)) uses pseudo-classes (c(2)1 , . . . , c (2) m ) obtained from the other network (mlp (2)), and vice versa. in addition, the weighting vector is updated
between the output approximation (ẑ(1) and ẑ(2)) and the desired target distribution (φ). figure 3 shows an overview of the presented model.in this paper, we are interested in a simplified scenario inspired by the symbol grounding problem and the association learning between sensory input signal in infants. we evaluated our model in four classless datasets that are generated from mnist (lecun & cortes, 2010). the procedure of generating classless datasets from labeled datasets have been already applied in (sutskever , 2015; hsu & kira, 2015). each dataset has two disjoint sets input 1 and input 2. the first dataset (mnist) has two different instances of the same digit. the second dataset (rotated-90 mnist) has two different instances of the same digit, and all input samples in input 2 are rotated 90 degrees. the third dataset (inverted mnist ) follows a similar procedures as the second dataset, but the transformation of the elements in input 2 is the invert function instead of rotation. the last dataset (random rotated mnist) is more challenging because all elements in input 2 are randomly rotated between 0 and 2π. all datasets have a uniform distribution between the digits and the dataset size is 21,000 samples for training and 4,000 samples for validation and testing.
the following parameters turned out being optimal on the validation set. for the first three datasets, each internal mlp relies on two fully connected layers of 200 and 100 neurons respectively. the learning rate for the mlps was set to start at 1.0 and was continuously decaying by half after every 1,000 iterations. we set the initial weighting vector to 1.0 and updated after every 1,000 iterations as well. moreover, the best parameters for the fourth dataset were the same formlp (1) and different for mlp (2), which has two fully connected layers of 400 and 150 neurons respectively and the learning rate stars at 1.2. the target distribution φ is uniform for all datasets. the decay of the learning rate (equation 5) for the weighting vector was given by 1/(100+epoch)0.3, where epoch was the number of training iterations so far. the mini-batch size m is 5,250 sample pairs (corresponding to 25% of the training set) and the mean of the derivatives for each mini-batch is used for the back-propagation step of mlps. note that the mini-batch is quite big comparing with common setups. we infer from this parameter that the model requires a sample size big enough for estimating the uniform distribution and also needs to learn slower than traditional approaches. our model was implemented in torch.
mlp(1) mlp (2) association matrix (%) purity (%) 0.9 10.9 __________initial state
epoch 1,000  1 2 3 4 5 6 7 8 9 mlp (2)  1 2 3 4 5 6 7 8 9 m lp (1 ) 0.7 0.6 2.4 0.4 3.0 2.2 1.0 1.4 1.2 0.6      0 2 4 6 8 0 4.8 22.6
epoch 3,000  1 2 3 4 5 6 7 8 9 mlp (2)  1 2 3 4 5 6 7 8 9 m lp (1 ) 0.1 1.7 2.8 0.0 5.7 8.9 0.3 10.0 8.1 0.1      0 2 4 6 8 0 4.4 65.8
epoch 49,000  1 2 3 4 5 6 7 8 9 mlp (2)  1 2 3 4 5 6 7 8 9 m lp (1 ) 9.8 8.9 9.4 9.0 9.6 9.6 9.7 9.6 9.6 9.0      0 2 4 6 8 0 5.5 95.6
figure 4: example of the presented model during classless training. in this example, there are ten pseudo-classes represented by each row of mlp (1) and mlp (2). note that the output classification are randomly selected (not cherry picking). initially, the pseudo-classes are assigned randomly to all input pair samples, which holds a uniform distribution (first row). then, the classless association model slowly start learning the features and grouping similar input samples. afterwards, the output classification of both mlps slowly agrees during training, and the association matrix shows the relation between the occurrences of the pseudo-classes.
to determine the baseline of our classless constraint, we compared our model against two cases: totally supervised and totally unsupervised. in the supervised case, we used the same mlp parameters and training for a fair comparison. in the unsupervised scenario, we used k-means and agglomerative clustering to each set (input 1 and input 2) independently. the clustering algorithm implementation are provided by scikit-learn (pedregosa , 2011).in this work, we have generated ten different folds for each dataset and report the average results. we introduce the association accuracy for measuring association, and it is defined by the following equation
association accuracy = 1
n n∑ i=1 1(c (1) i = c (2) i ) (6)
where the indicator function is one if c(1)i = c (2) i , zero otherwise; c (1) i and c (2) i are the pseudo-classes for mlp (1) and mlp (2), respectively, and n is the number of elements. in addition, we also reported the purity of each set (input 1 and input 2). purity is defined by
purity(ω, c) = 1 n k∑ i=1 maxj |ci ∩ gtj | (7)
where ω = {gt1, gt2, . . . , gtj} is the set of ground-truth labels and c = {c1, c2, . . . , ck} is the set of pseudo-classes in our model or the set of cluster indexes of k-means or hierarchical agglomerative clustering, and n is the number of elements.
table 1 shows the association accuracy between our model and the supervised association task and the purity between our model and two clustering algorithms. first, the supervised association task performances better that the presented model. this was expected because our task is more complex in relation to the supervised scenario. however, we can infer from our results that the presented model has a good performance in terms of the classless scenario and supervised method. second, our model not only learns the association between input samples but also finds similar elements covered under the same pseudo-class. also, we evaluate the purity of our model and found that the performance of our model reaches better results than both clustering methods for each set (input 1 and input 2).
figure 4 illustrates an example of the proposed learning rule. the first two columns (mlp (1) and mlp (2)) are the output classification (equation 3) and each row represents a pseudo-class. we have randomly selected 15 output samples for each mlp (not cherry picking). initially, the pseudo classes are random selected for each mlp. as a result, the output classification of both networks does not show any visible discriminant element and the initial purity is close to random choice (first row). after 1,000 epochs, the networks start learning some features in order to discriminate the input samples. some groups of digits are grouped together after 3,000 epochs. for example, the first row of mlp (2) shows several digits zero, whereas mlp (1) has not yet agree on the same digit for that pseudo-class. in contrast, both mlps have almost agree on digit one at the fifth row. finally, the association is learned using only the statistical distribution of the input samples and each digit is represented by each pseudo-class.
best results
worst results
mlp (1) mlp (2) association matrix (%)  1 2 3 4 5 6 7 8 9 mlp (2)  1 2 3 4 5 6 7 8 9 m lp (1 ) 9.7 8.9 9.0 8.7 9.7 9.0 9.2 9.1 9.4 8.5      0 2 4 6 8 0
purity (%)  1 2 3 4 5 6 7 8 9 mlp (2)  1 2 3 4 5 6 7 8 9 m lp (1 ) 9.7 7.9 5.1 4.5 0.0 5.1 9.2 0.0 10.3 12.8      0 2 4 6 8 0 5.9 95.2 2.9 59.4
figure 5: example of the best and worst results among all folds and datasets. it can be observed our model is able to learn to discriminate each digit (first row). however, the presented model has a limitation that two or more digits are assigned to the same pseudo-class (last row of mlp (1) and mlp (2)).
figure 5 shows the best and worst results of our model in two cases. the first row is the best result from mnist dataset. each row of mlp (1) and mlp (2) represent a pseudo-class, and it can be observed that all digits are grouped together. in addition, the association matrix shows a distribution per digit close to the desired uniform distribution, and the purity of each input is close to the supervised scenario. in contrast, the second row is our worst result from random rotated mnist dataset. in this example, we can observe that some digits are recognized by the same pseudo-class, for example, digit one and seven (first two rows). however, there two or more digits that are recognized by the samepseudo-class. for example, the last row shows that nine and four are merged. our model is still able to reach better results than the unsupervised scenario.in this paper, we have shown the feasibility to train a model that has two parallel mlps under the following scenario: pairs of input samples that represent the same unknown classes. this scenario was motivated by the symbol grounding problem and association learning between sensory input signal in infants development. we proposed a model based on gradients for solving the classless association. our model has an em-training that matches the network output against a statistical distribution and uses one network as a target of the other network, and vice versa. our model reaches better performance than k-means and hierarchical agglomerative clustering. in addition, we compare the presented model against a supervised method. we find that the presented model with respect to the supervised method reaches good results because of two extra conditions in the unsupervised association: unlabeled data and agree on the same pseudo-class. we want to point out that our model was evaluated in an optimal case where the input samples are uniform distributed and the number of classes is known. however, we will explore the performance of our model if the number of classes and the statistical distrubtion are unknown. one way is to change the number of pseudo-classes. this can be seen as changing the number of clusters k in k-means. with this in mind, we are planning to do more exhaustive analysis of the learning behavior with deeper architectures. moreover, we will work on how a small set of labeled classes affects the performance of our model (similar to semi-supervised learning). furthermore, we are interested in replicating our findings in more complex scenarios, such as, multimodal datasets like tvgraz (khan , 2009) or wikipedia featured articles (rasiwasia , 2010). finally, our work can be applied to more classless scenarios where the data can be extracted simultaneously from different input sources at the same time. also, transformation functions can be applied to input samples for creating the association without classes.we would like to thank damian borth, christian schulze, jörn hees, tushar karayil, and philipp blandfort for helpful discussions.",0
739.pdf.json,"polynomial feature expansion has long been used in statistics to approximate nonlinear functions gergonne (1974); smith (1918). the compressed sparse row (csr) matrix format is a widelyused data structure to hold design matrices for statistics and machine learning applications. however, polynomial expansions are typically not performed directly on sparse csr matrices, nor on any sparse matrix format for that matter, without intermediate densification steps. this densification not only adds extra overhead, but wastefully computes combinations of features that have a product of zero, which are then discarded during conversion into a sparse format.
we provide an algorithm that allows csr matrices to be the input of a polynomial feature expansion without any densification. the algorithm leverages the csr format to only compute products of features that result in nonzero values. this exploits the sparsity of the data to achieve an improved time complexity of o(dkdk) on each vector of the matrix where k is the degree of the expansion, d is the dimensionality, and d is the density. the standard algorithm has time complexity o(dk). since 0 ≤ d ≤ 1, our algorithm is a significant improvement. while the algorithm we describe uses csr matrices, it could be modified to operate on other sparse formats.matrices are denoted by uppercase bold letters thus: a. the ithe row of a is written ai. all vectors are written in bold, and a, with no subscript, is a vector.
a compressed sparse row (csr) matrix representation of an r-row matrix a consists of three vectors: c, d, and p and a single number: the number of columns of a. the vectors c and d contain the same number of elements, and hold the column indices and data values, respectively, of all nonzero elements of a. the vector p has r entries. the values in p index both c and d. the ith entry pi of p tells where the data describing nonzero columns of ai are within the other two vectors: cpi:pi+1 contain the column indices of those entries; dpi:pi+1 contain the entries themselves. since only nonzero elements of each row are held, the overall number of columns of a must also be stored, since it cannot be derived from the other data.
scalars, vectors, and matrices are often referenced with the superscript k. this is not to be interpreted as an exponent, but to indicate that it is the analogous aspect of that which procedes it, but in its polynomial expansion form. for example, c2 is the vector that holds columns for nonzero values in a’s quadratic feature expansion csr representation.
for simplicity in the presentation, we work with polynomial expansions of degree 2, but continue to use the exponent k to show how the ideas apply in the general case. ∗now at google †the authors contributed equally important and fundamental aspects of this work.
we do provide an algorithm for third degree expansions, and derive the big-o time complexity of the general case.
we have also developed an algorithm for second and third degree interaction features (combinations without repetition), which can be found in the implementation.in this section, we present a strawman algorithm for computing polynomial feature expansions on dense matrices. we then modify the algorithm slightly to operate on a csr matrix, in order to expose its infeasibility in that context. we then show how the algorithm would be feasible with an added component, which we then derive in the following section.a natural way to calculate polynomial features for a matrix a is to walk down its rows and, for each row, take products of all k-combinations of elements. to determine in which column of aki products of elements in ai belong, a simple counter can be set to zero for each row of a and incremented efter each polynomial feature is generated. this counter gives the column of aki into which each expansion feature belongs.
second order (k = 2) dense polynomial expansion algorithm(a) 1 n = row count of a 2 d = column count of a 3 ak = empty n × ( d 2 ) matrix 4 for i = 0 to n − 1 5 cp = 0 6 for j1 = 0 to d − 1 7 for j2 = j1 to d − 1 8 akicp = aij1 ·aij2 9 cp = cp + 1now consider how this algorithm might be modified to accept a csr matrix. instead of walking directly down rows of a, we will walk down sections of c and d partitioned by p, and instead of inserting polynomial features into ak, we will insert column numbers into ck and data elements into dk.
incomplete second order (k = 2) csr polynomial expansion algorithm(a) 1 n = row count of a 2 pk = vector of size n + 1 3 pk0 = 0 4 nnzk = 0 5 for i = 0 to n − 1 6 istart = pi 7 istop = pi+1 8 ci = cistart:istop 9 nnzki = (|ci| 2
) 10 nnzk = nnzk + nnzki 11 pki+1 = p k i + nnz k i
// build up the elements of pk, ck, and dk 2 pk = vector of size n + 1 13 ck = vector of size nnzk 14 dk = vector of size nnzk 15 n = 0 16 for i = 0 to n − 1 17 istart = pi 18 istop = pi+1 19 ci = cistart:istop 20 di = distart:istop 21 for c1 = 0 to |ci| − 1 22 for c2 = c1 to |ci| − 1 23 dkn = dc0 · dc1 24 ckn =? 25 n = n+ 1
the crux of the problem is at line 24. given the arbitrary columns involved in a polynomial feature of ai, we need to determine the corresponding column of aki . we cannot simply reset a counter for each row as we did in the dense algorithm, because only columns corresponding to nonzero values are stored. any time a column that would have held a zero value is implicitly skipped, the counter would err.
to develop a general algorithm, we require a mapping from columns of a to a column of ak. if there are d columns of a and ( d k ) columns of ak, this can be accomplished by a bijective mapping of the following form:
(j0, j1, . . . , jk−1) pj0j1...ik−1 ∈ {0, 1, . . . , ( d
k
) − 1} (1)
such that 0 ≤ j0 ≤ j1 ≤ · · · ≤ jk−1 < d where (j0, j1, . . . , jk−1) are elements of c and pj0j1...ik−1 is an element of ck.within this section, i, j, and k denote column indices. for the second degree case, we seek a map from matrix indices (i, j) (with 0 ≤ i < j < d ) to numbers f(i, j) with 0 ≤ f(i, j) < d(d−1)2 , one that follows the pattern indicated by x 0 1 3x x 2 4x x x 5
x x x x  (2) where the entry in row i, column j, displays the value f(i, j). we let t2(n) = 12n(n + 1) be the nth triangular number; then in equation 2, column j (for j > 0) contains entries with t2(j − 1) ≤
e < t2(j); the entry in the ith row is just i + t2(j − 1). thus we have f(i, j) = i + t2(j − 1) = 1 2 (2i + j  − j). for instance, in column j = 2 in our example (the third column), the entry in row i = 1 is i+ t2(j − 1) = 1 + 1 = 2. with one-based indexing in both the domain and codomain, the formula above becomes f1(i, j) = 1 2 (2i+ j  − 3j + 2). for polynomial features, we seek a similar map g, one that also handles the case i = j. in this case, a similar analysis yields g(i, j) = i+ t2(j) = 12 (2i+ j 2 + j + 1).
to handle three-way interactions, we need to map triples of indices in a 3-index array to a flat list, and similarly for higher-order interactions. for this, we’ll need the tetrahedral numbers t3(n) =∑n
i=1 t2(n) = 1 6 (n 3 + 3n2 + 2n).
for three indices, i, j, k, with 0 ≤ i < j < k < d, we have a similar recurrence. calling the mapping h, we have
h(i, j, k) = i+ t2(j − 1) + t3(k − 2); (3) if we define t1(i) = i, then this has the very regular form
h(i, j, k) = t1(i) + t2(j − 1) + t3(k − 2); (4) and from this the generalization to higher dimensions is straightforward. the formulas for “higher triangular numbers”, i.e., those defined by
tk(n) = n∑ i=1 tk−1(n) (5)
for k > 1 can be determined inductively.
the explicit formula for 3-way interactions, with zero-based indexing, is
h(i, j, k) = 1 + (i− 1) + (j − 1)j 2 + (6)
(k − 2)3 + 3(k − 2)2 + 2(k − 2) 6 . (7)with the mapping from columns of a to a column of ak, we can now write the final form of the innermost loop of the algorithm from 3.2. let the mapping for k = 2 be denoted h2. then the innermost loop becomes:
for c2 = c1 to |ci| − 1 j0 = cc0 j1 = cc1 cp = h (j0, j1) dkn = dc0 · dc1 ckn = cp n = n+ 1
the algorithm can be generalized to higher degrees by simply adding more nested loops, using higher order mappings, modifying the output dimensionality, and adjusting the counting of nonzero polynomial features in line 9.calculating k-degree polynomial features via our method for a vector of dimensionality d and density d requires ( dd k ) (with repetition) products. the complexity of the algorithm, for fixed k
dd, is therefore
o
(( dd + k − 1
k
)) = o ( (dd + k − 1)! k!(dd − 1)! ) (8)
= o
( (dd + k − 1)(dd + k − 2) . . . (dd)
k!
) (9)
= o ((dd + k − 1)(dd + k − 2) . . . (dd)) for k dd (10) = o ( dkdk ) (11)to demonstrate how our algorithm scales with the density of a matrix, we compare it to the traditional polynomial expansion algorithm in the popular machine library scikit-learn pedregosa  (2011) in the task of generating second degree polynomial expansions. matrices of size 100× 5000 were randomly generated with densities of 0.2, 0.4, 0.6, 0.8, and 1.0. thirty matrices of each density were randomly generated, and the mean times (gray) of each algorithm were plotted. the red or blue width around the mean marks the third standard deviation from the mean. the time to densify the input to the standard algorithm was not counted.
the standard algorithm’s runtime stays constant no matter the density of the matrix. this is because it does not avoid products that result in zero, but simply multiplies all second order combinations of features. our algorithm scales quadratically with respect to the density. if the task were third degree expansions rather than second, the plot would show cubic scaling.
the fact that our algorithm is approximately 6.5 times faster than the scikit-learn algorithm on 100× 5000 matrices that are entirely dense is likely a language implementation difference. what matters is that the time of our algorithm increases quadratically with respect to the density in accordance with the big-o analysis.we have developed an algorithm for performing polynomial feature expansions on csr matrices that scales polynomially with respect to the density of the matrix. the areas within machine learning that this work touches are not en vogue, but they are workhorses of industry, and every improvement in core representations has an impact across a broad range of applications.",0
745.pdf.json,"stochastic gradient descent (sgd) is an effective method for many regression and classification tasks. it is a simple algorithm with few hyper-parameters and its convergence rates are well understood both theoretically and empirically. however, its performance scalability is severely limited by its inherently sequential computation. sgd iteratively processes its input dataset where the computation at each iteration depends on the model parameters learned from the previous iteration.
current approaches for parallelizing sgd do not honor this inter-step dependence across threads. each thread learns a local model independently and combine these models in ways that can break sequential behavior. for instance, threads in hogwild! recht  (2011) racily update a shared global model without holding any locks. in parameter-server li  (2014a), each thread (or machine) periodically sends its model deltas to a server that applies them to a global model. in allreduce agarwal  (2014), threads periodically reach a barrier where they compute a weightedaverage of the local models. although these asynchronous parallel approaches reach the optimal solution eventually, they can produce a model that is potentially different from what a sequential sgd would have produced after processing a certain number of examples. our experiments indicate that this makes their convergence rate slower than sequential sgd in terms of total number of examples studied. our experiments show that all these algorithms either do not scale or their accuracy on the same number of examples falls short of a sequential baseline.
to address this problem, this paper presents symsgd, a parallel sgd algorithm that seeks to retain its sequential semantics. the key idea is for each thread to generate a sound combiner that allows the local models to be combined into a model that is the same as the sequential model. this paper describes a method for generating sound combiners for a class of sgd algorithms in which the inter-step dependence is linear in the model parameters. this class includes linear regression, linear regression with l2 regularization, and polynomial regression. while logistic regression is not in this class, our experiments show that linear regression performs equally well in classification tasks as logistic regression for the datasets studied in this paper. also, this approach works even if the sgd
computation is non-linear on the input examples and other parameters such as the learning rate; only the dependence on model parameters has to be linear.
generating sound combiners can be expensive. symsgd uses random projection techniques to reduce this overhead but still retaining sequential semantics in expectation. we call this approach probabilistically sound combiners. even though symsgd is expected to produce the same answer as the sequential sgd, controlling the variance introduced by the random projection requires care — a large variance can result in reduced accuracy. this paper describes the factors that affect this variance and explores the ensuing design trade-offs.
the resulting algorithm is fast, scales well on multiple cores, and achieves the same accuracy as sequential sgd on sparse and dense datasets. when compared to our optimized sequential baseline, symsgd achieves a speedup of 3.5× to 13× on 16 cores, with the algorithm performing better for denser datasets. moreover, the cost of computing combiners can be efficiently amortized in a multiclass regression as a single combiner is sufficient for all of the classes. finally, symsgd (like allreduce) is deterministic, producing the same result for a given dataset, configuration, and random seed. determinism greatly simplifies the task of debugging and optimizing learning.stochastic gradient descent (sgd) is a robust method for finding the parameters of a model that minimize a given error function. figure 1 shows an example of a (convex) error function over two dimensions x and y reaching the minimum at parameter w∗. sgd starts from some, not necessarily optimal, parameter wg (as shown in figure 1), and repeatedly modifies w by taking a step along the gradient of the error function for a randomly selected example at the currentw. the magnitude of the step is called the learning rate and is usually denoted by α. the gradient computed from one example is not necessarily the true gradient at w. nevertheless, sgd enjoys robust convergence behavior by moving along the “right” direction over a large number of steps. this is shown pictorially in figure 1, where sgd processes examples in dataset d1 to reach w1 from wg . subsequently, sgd starts from w1 and processes a different set d2 to reach wh. there is a clear dependence between the processing ofd1 and the processing ofd2 — the latter starts from w1, which is only determined after processing d1. our goal is to parallelize sgd despite this dependence.
state of the art parallelization techniques such as hogwild! and allreduce approach this problem by processing d1 and d2 starting from the same model wg (let us assume that there only two processors for now), and respectively reaching w1 and w2. then, they combine their local models into a global model, but do so in an ad-hoc manner. for instance, allreduce computes a weighted average of w1 and w2, where the per-feature weights are chosen so as to prefer the processor that has larger update for that feature. this weighted average is depicted pictorially as wa. similarly, in hogwild!, the two processors race to update the global model with their respective local model without any locking. (hogwild! performs this udpate after every example, thus the size of d1 and d2 is 1.) both approaches do not necessarily reach wh, the model that a sequential sgd would have reached on d1 and d2. while sgd is algorithmically robust to errors, such ad-hoc combinations can result in slower convergence or poor performance, as we demonstrate in section 4.
sound combiner: the goal of this paper is to soundly combine local models. looking at figure 1, a sound combiner combines local models w1 and w2, respectively generated from datasets d1 and d2, into a global model wh that is guaranteed to be the same as the model achieved by the sequential
sgd processing d1 and then d2. in effect, a sound combiner allows us to parallelize the sequential computation without changing its semantics.
if we look at the second processor, it starts its computation at wg , while in a sequential execution it would have started at w1, the output of the first processor. to obtain sequential semantics, we need to “adjust” its computation from wg to w1. to do so, the second processor performs its computation starting fromwg +∆w, where ∆w is an unknown symbolic vector. this allows the second processor to both compute a local model (resulting from the concrete part) and a sound combiner (resulting from the symbolic part) that accounts for changes in the initial state. once both processors are done learning, second processor finds wh by setting ∆w to w1 − wg where w1 is computed by the first processor. this parallelization approach of sgd can be extended to multiple processors where all processor produce a local model and a combiner (except for the first processor) and the local models are combined sequentially using the combiners.
when the update to the model parameters is linear in a sgd computation, then the dependence on the unknown ∆w can be concisely represented by a combiner matrix, as formally described in section 3. many interesting machine learning algorithms, such as linear regression, linear regression with l2 regularization, and polynomial regression already have linear update to the model parameters (but not necessarily linear on the input example).
probabilistically sound combiner: the main problem with generating a sound combiner is that the combiner matrix has as many rows and columns as the total number of features. thus, it can be effectively generated only for datasets with modest number of features. most interesting machine learning problems involve learning over tens of thousands to billions of features, for which maintaining a combiner matrix is clearly not feasible.
we solve this problem through dimensionality reduction. johnson-lindenstrauss (jl) lemma johnson & lindenstrauss (1984) allows us to project a set of vectors from a high-dimensional space to a random low-dimensional space while preserving distances. we use this property to reduce the size of the combiner matrix without losing the fidelity of the computation — our parallel algorithm produces the same result as the sequential sgd in expectation.
of course, a randomized sgd algorithm that generates the exact result in expectation is only useful if the resulting variance is small enough to maintain accuracy and the rate of convergence. we observe that for the variance to be small, the combiner matrix should have small singular values. interestingly, the combiner matrix resulting from sgd is dominated by the diagonal entries as the learning rate has to be small for effective learning. we use this property to perform the jl projection only after subtracting the identity matrix. also, other factors that control the singular values are the learning rate, number of processors, and the frequency of combining local models. this paper explores this design space and demonstrates the feasibility of efficient parallelization of sgd that retains the convergence properties of sequential sgd while enjoying parallel scalability.consider a training dataset (xn×f , yn×1), where f is the number of features, n is the number of examples in the dataset, the ith row of matrix x , xi, represents the features of the ith example, and yi is the dependent value (or label) of that example. a linear model seeks to find a
w∗ = arg min w∈rf n∑ i=0 q(xi · w, yi)
that minimizes an error function q. for linear regression, q(xi · w, yi) = (xi · w − yi)2. when (xi, yi) is evident from the context, we will simply refer to the error function as qi(w).
sgd iteratively finds w∗ by updating the current model w with a gradient of qr(w) for a randomly selected example r. for the linear regression error function above, this amounts to the update
wi = wi−1 − α∇qr(wi−1) = wi−1 − α(xr · wi−1 − yr)xtr (1) here, α is the learning rate that determines the magnitude of the update along the gradient. as it is clear from this equation, wi is dependent on wi−1 which creates a loop-carried dependence and consequently makes parallelization of sgd across iterations using naı̈ve approaches impossible.
the complexity of sgd for each iteration is as follows. assume thatxr has z non-zeros. therefore, the computation in equation 1 requires o(z) amount of time for the inner product computation, xr ·wi−1, and the sameo(z) amount of time for scalar-vector multiplication, α(xr ·wi−1−yr)xtr . if the updates to the weight vector happen in-place meaning thatwi andwi−1 share the same memory location, the computation in equation 1 takes o(z) amount of time.this section explains a new approach to parallelize the sgd algorithm despite its loop-carried dependence. as shown in figure 1, the basic idea is to start each processor (except the first) on a concrete model w along with a symbolic unknown ∆w that captures the fact that the starting model can change based on the output of the previous processor. if the dependence on ∆w is linear during an sgd update, which is indeed the case for linear regression, then the symbolic dependence on ∆w on the final output can be captured by an appropriate matrix ma→b that is a function of the input examples xa, . . . , xb processed (ya, . . . , yb do not affect this matrix). specifically, as lemma a.1 in the appendix shows, this combiner matrix is given by
ma→b = a∏ i=b (i − αxti ·xi) (2)
in effect, the combiner matrix above is the symbolic representation of how a ∆w change in the input will affect the output of a processor. ma→b is referred by m when the inputs are not evident.
the parallel sgd algorithm works as follows (see figure 1). in the learning phase, each processor i starting from w0, computes both a local model li and a combiner matrix mi. in a subsequent reduction phase, each processor in turn computes its true output using
wi = li +mi · (wi−1 − w0) (3) lemma a.1 ensures that this combination of local models will produce the same output as what these processors would have generated had they run sequentially. we call such combiners sound.
one can compute a sound model combiner for other sgd algorithms provided the loop-carried dependence on w is linear. in other words, there should exist a matrix ai and vector bi in iteration i such that wi = ai · wi−1 + bi. note that ai and bi can be nonlinear in terms of input datasets.the combiner matrixm generate above can be quite large and expensive to compute. the sequential sgd algorithm maintains and updates the weight vector w, and thus requires o(f) space and time, where f is the number of features. in contrast, m is a f × f matrix and consequently, the space and time complexity of parallel sgd is o(f2). in practice, this would mean that we would need o(f) processors to see constant speedups, an infeasible proposition particularly for datasets that can have thousands if not millions of features.
symsgd resolves this issue by projecting m into a smaller space while maintaining its fidelity. this projection is inspired by the johnson-lindenstrauss (jl) lemma johnson & lindenstrauss (1984) and follows the treatment of achlioptas achlioptas (2001). lemma 3.1. 1 let a be a random f × k matrix with
aij = dij/ √ k
where aij is the element of a at the ith row and jth column and dij is independently sampled from a random distribution d with ie[d] = 0 and var[d] = 1. then
ie[a ·at ] = if×f
the matrix a from lemma 3.1 projects from rf → rk where k can be much smaller than f . this allows us to approximate equation 3 as
wi ≈ li +mi ·a ·at (wi−1 − w0) (4) 1see proof in appendix a.2.
lemma 3.1 guarantees that the approximation above is unbiased.
ie[li +mi ·a ·at (wi−1 − w0)] = li +mi · ie[a ·at ](wi−1 − w0) = wi
this allows an efficient algorithm that only computes the projected version of the combiner matrix while still producing the same answer as the sequential algorithm in expectation. we call such combiners probabilistically sound.
algorithm 1: symsgd learning a local model and a model combiner. 1 <vector,matrix,matrix> symsgd( 2 float α, vector: w0, x1..xn, 3 scalar: y1..yn) { 4 vector w = w0; 5 matrix a = 1√
k random(d,f,k);  matrix ma = a; 7 for i in (1..n) { 8 w = w - α(xi·w - yi)xit; 9 ma = ma - α xi·(xitma); } 0 return <w,ma,a>; }
algorithm 2: symsgd combining local models using model combiners. 1 vector symsgdcombine(vector w0, 2 vector w, vector l, 3 matrix ma, matrix a) { 4 parallel { 5 matrix na = ma - a; 6 w = l+w-w0+na·at(w-w0); 7 } 8 return w; }
algorithm 1 shows the resulting symbolic sgd learner. the random function in line 5 returns a f × k matrix with elements chosen independently from the random distribution d according to lemma 3.1. when compared to the sequential sgd, the additional work is the computation of ma in line 9. it is important to note that this algorithm maintains the invariant that ma = m · a at every step. this projection incurs a space and time overhead of o(z × k) where z is the number of non-zeros in xi. this overhead is acceptable for small k and infact in our experiments in section 4, k is between 7 to 15 across all benchmarks. most of the overhead for such a small k is hidden by utilizing simd hardware within a processor (symsgd with one thread is only half as slow as the sequential sgd as discussed in section 4.1). after learning a local model and a probabilistically sound combiner in each processor, algorithm 2 combines the resulting local model using the combiners, but additionally employs the optimizations discussed in section 3.3.
note that the correctness and performance of symsgd do not depend on the sparsity of a dataset and as section 4 demonstrates, it works for very sparse and completely dense datasets. also, note that x1, . . . ,xn may contain a subset of size f’ of all f features. our implementation of algorithm 1 takes advantage of this property and allocates and initializes a for only the observed features. this optimization is omitted from the pseudo code in algorithm 1 for the sake of simplicity.while the dimensionality reduction discussed above is expected to produce the right answer, this is useful only if the variance of the approximation is acceptably small. computing the variance is involved and is discussed in the associated technical report symsgdtr. but we discuss the main result that motivates the rest of the paper.
consider the approximation ofm ·∆w with v = m ·a ·at ·∆w. let c(v) be the covariance matrix of v. the trace of the covariance matrix tr(c(v)) is the sum of the variance of individual elements of v. let λi(m) by the ith eigenvalue of m and σi(m) = √ λi(mtm) the ith singular value of m . let σmax(m) be the maximum singular value of m . then the following holds symsgdtr:
‖∆w‖22 k ∑ i σ2i (m) ≤ tr(c(v)) ≤ ‖∆w‖22 k ( ∑ i σ2i (m) + σ 2 max(m))
the covariance is small if k, the dimension of the projected space, is large. but increasing k proportionally increases the overhead of the parallel algorithm. similarly, covariance is small if the projection happens on small ∆w. looking at equation 4, this means that wi−1 should be as close to w0 as possible, implying that processors should communicate frequently enough such that their
models are roughly in sync. finally, the singular values of m should be as small as possible. the next section describes a crucial optimization that achieves this.
taking identity off: expanding equation 2, we see that the combiner matrices are of the form
i − αr1 + α2r2 − α3r3 + · · ·
where ri matrices are formed from the sum of products of xj · xtj matrices. since α is a small number, this sum is dominated by i . in fact, for a combiner matrix m generated from n examples, m − i has at most n non-zero singular values symsgdtr. we use these observation to lower the variance of dimensionality reduction by projecting matrix n = m − i instead of m . appendix a.3 empirically shows the impact of this optimization. rewriting equations 3 and 4, we have
wi = li + (ni + i) · (wi−1 − w0) = li + wi−1 − w0 +ni · (wi−1 − w0) ≈ li + wi−1 − w0 +ni ·a ·at · (wi−1 − w0) (5)
lemma 3.1 guarantees that the approximation above is unbiased. algorithm 2 shows the pseudo code for the resulting probabilistically sound combination of local models. the function symsgdcombine is called iteratively to combine the model of the first processor with the local models of the rest. note that each model combination is executed in parallel (line 4) by parallelizing the underlying linear algebra operations.
an important factor in controlling the singular values of n is the frequency of model combinations which is a tunable parameter in symsgd. as it is shown in appendix a.3, the fewer the number of examples learned, the smaller the singular values of n and the less variance (error) in equation 5.
implementation for the implementation of symsgd function, matrix m and weight vector w are stored next to each other. this enables better utilization of vector units in the processor and improves the performance of our approach significantly. also, most of datasets are sparse and therefore, sgd and symsgd only copy the observed features from w0 to their learning model w. moreover, for the implementation of matrix a, we used achlioptas (2001) theorem to minimize the overhead of creating a. in this approach, each element of a is independently chosen from { 13 ,− 1 3 , 0} with probability { 16 , 1 6 , 2 3}, respectively.all experiments described in this section were performed on an intel xeon e5-2630 v3 machine clocked at 2.4 ghz with 256 gb of ram. the machine has two sockets with 8 cores each, allowing us to study the scalability of the algorithms across sockets. we disabled hyper-threading and turbo boost. we also explicitly pinned threads to cores in a compact way which means that thread i + 1 was placed as close as possible to thread i. the machine runs windows 10. all of our implementations were compiled with intel c/c++ compiler 16.0 and relied heavily on openmp primitives for parallelization and mkl for efficient linear algebra computations. and, finally, to measure runtime, we use the average of five independent runs on an otherwise idle machine.
there are several algorithms and implementations that we used for our comparison: vowpal wabbit langford  (2007), a widely used public library, baseline, a fast sequential implementation, hw-paper, the implementation from recht  (2011), hw-release, an updated version, hogwild, which runs baseline in multiple threads without any synchronization, and allreduce, the implementation from agarwal  (2014). each of these algorithms have different parameters and settings and we slightly modified to ensure a fair comparison; see appendix a.4 for more details.
when studying the scalability of a parallel algorithm, it is important to compare the algorithms against an efficient baseline bailey (1991); mcsherry  (2015). otherwise, it is empirically not possible to differentiate between the scalability achieved from the parallelization of the inefficiencies and the scalability inherent in the algorithm. we spent a significant effort to implement a well-tuned sequential algorithm which we call baseline in our comparisons. baseline is between 1.97 to 7.62 (3.64 on average) times faster than vowpal wabbit and it is used for all speedup graphs in this paper.
datasets table 1 describes the datasets used for evaluation. the number of features, training instances, test instances, classes and the sparsity of each dataset is shown in table 1. we used vowpal
wabbit with the configurations discussed in appendix a.4 to measure the maximum accuracies that can be achieved using linear and logistic regression and the result is presented in columns 8 and 9 of table 1. in the case of aloi dataset, even after 500 passes (the default for our evaluation was 100 passes) the accuracies did not saturate to the maximum possible and we reported that both linear and logistic achieved at least 80% accuracy. the last two columns show the maximum speedup of symsgd and hogwild! over the baseline.
parameters hyper-parameters searching is essential for performance and accuracy. the learning rate, α, for each dataset was selected by searching for a constant value among {.5, .05, .005, . . . } where baseline reached close to maximum accuracy for each benchmark. the parameters for the projection size, k, and the frequency of model combination were searched to pick the best performing configuration. the parameters for allreduce were similarly searched.figure 2 shows the accuracy and speedup measurements on three benchmarks: rcv1.binary, a sparse binary dataset, rcv1.multiclass, a sparse multiclass dataset, and epsilon, a dense binary dataset. the results for the other six benchmarks are presented in appendix a.5.
sparse binary, rcv1.binary: figure 2a compares the scalability of all the algorithms studied in this paper. hw-paper is around six times slower than hw-release. while this could potentially be a result of us running hw-release on a ubuntu vm, our primary aim of this comparison was to ensure that hogwild is a competitive implementation of hogwild!. thus, we remove hw-paper and hw-release in our subsequent comparisons.
symsgd is half as slow as the baseline on one thread as it performs lot more computation, but scales to a 3.5× speedup to 16 cores. note, this represents a roughly 7× strong-scaling speedup with respect to its own performance on one thread. analysis of the hardware performance counters shows the current limit to symsgd’s scalability arises from load-imbalance across barrier synchronization, which provides an opportunity for future improvement.
figure 2d shows the accuracy as a function of the number of examples processed by different algorithms. symsgd “stutters” at the beginning, but it too matches the accuracy of baseline. the initial stuttering happens because the magnitude of the local models on each processor are large during the first set of examples. this directly affect the variance of the combiner matrix approximation. however, as more examples are given to symsgd, the magnitude of the local models are smaller and thus symsgd better matches the baseline accuracy. one way to avoid this stuttering is to combine models more frequently (lower variance) or running single threaded for the first few iterations.
hogwild does approach sequential accuracy, however, it does so at the cost of scalablity (i.e., see figure 2a (a)). likewise, allreduce scales slightly better but does so at the cost of accuracy.
sparse multiclass, rcv1.multiclass: figure 2b shows the scalability on rcv1.multiclass. since this is a multiclass dataset, symsgd is competitive with the baseline on one thread as it is able to amortize the combiner matrix computation across all of the classes (m is the same across different classes). thus, it enjoys much better scalability of 7× when compared to rcv1.binary. hogwild scales similar to symsgd up-to 8 threads but suffers when 16 threads across multiple sockets are used. figure 2e shows that symsgd meets the sequential accuracy after an initial stutter. allreduce suffers from accuracy.
dense binary, epsilon: figure 2c in appendix a.5 shows that symsgd achieves a 7× speedup over the baseline on 16 cores. this represents a 14× strong scaling speedup over symsgd on one thread. as hogwild! is not designed for dense workloads, its speedup suffers when 16 cores across multiple sockets are used. this shows that symsgd scales to both sparse and dense datasets. similarly, allreduce suffers from accuracy.most schemes for parallelizing sgd learn local models independently and communicate to update the global model. the algorithms differ in how and how often the update is performed. these choices determine the applicability of the algorithm to shared-memory or distributed systems.
to the best of our knowledge, our approach is the only one that retain the semantics of the sequential sgd algorithm. while some prior work provides theoretical analysis of the convergence rates that justify a specific parallelization, convergence properties of symsgd simply follow from the sequential sgd algorithm. on the other hand, symsgd is currently restricted to class of sgd computations where the inter-step dependence is linear in the model parameters.
given a tight coupling of the processing units, langford  langford  (2009) suggest on a round-robin scheme to update the global model allowing for some staleness. however, as the sgd computation per example is usually much smaller when compared to the locking overhead, hogwild! recht  (2011) improves on this approach to perform the update in a “racy” manner. while hogwild! is theoretically proven to achieve good convergence rates provided the dataset is sparse enough and the processors update the global model fast enough, our experiments show that the generated cache-coherence traffic limits its scalability particularly across multiple sockets. moreover, as hogwild! does not update the model atomically, it potentially loses correlation among more frequent features resulting in loss of accuracy. lastly, unlike symsgd, which works for both sparse and dense datasets, hogwild! is expclitly designed for sparse data. recently, sallinen  (2016) proposed applying lock-free hogwild! approach to mini-batch. however, mini-batch converges slower than sgd and also they did not study multi-socket scaling.
zinkevich  zinkevich  (2010) propose a mapreduce-friendly framework for sgd. the basic idea is for each machine/thread to run a sequential sgd on its local data. at the end, the global model is obtained by averaging these local models. alekh  agarwal  (2014) extend this approach by using mpi allreduce operation. additionally, they use the adagrad duchi  (2011) approach for the learning rates at each node and use weighted averaging to combine local models
with processors that processed a feature more frequently having a larger weight. our experiments on our datasets and implementation shows that it does not achieve the sequential accuracy.
several distributed frameworks for machine learning are based on parameter server li  (2014b;a) where clients perform local learning and periodically send the changes to a central parameter server that applies the changes. for additional parallelism, the models themselves can be split across multiple servers and clients only contact a subset of the servers to perform their updates.with terabytes of memory available on multicore machines today, our current implementation has the capability of learning from large datasets without incurring the communication overheads of a distributed system. that said, we believe the ideas in this paper apply to distributed sgd algorithms and how to pursue in future work.
many machine learning sgd algorithms require a nonlinear dependence on the parameter models. while symsgd does not directly apply to such algorithms, it is an interesting open problem to devise linear approximations (say using taylor expansion) to these problems and subsequently parallelize with probabilistically sound combiners. this is an interesting study for future work.a.1 combiner matrix
lemma a.1. if the sgd algorithm for linear regression processes examples (xa, ya), (xa+1, ya+1), . . . , (xb, yb) starting from model ws to obtain wb, then its outcome starting on model ws + ∆w is given by wb + ma→b · ∆w where the combiner matrix ma→b is given by
ma→b = a∏ i=b (i − αxti ·xi)
proof. the proof follows from a simple induction. starting from ws, let the models computed by sgd after processing (xa, ya), (xa+1, ya+1), . . . , (xb, yb) respectively be wa, wa+1, . . . wb. consider the base case of processing of (xa, ya). starting from ws + ∆w, sgd computes the model w′a using equation 1 (reminder: wi = wi−1 − α(xi · wi−1 − yi)xti ):
w′a = ws + ∆w − α(xa · (ws + ∆w)− ya)xta = ws + ∆w − α(xa · ws − ya)xta − α(xa ·∆w)xta = ws − α(xa · ws − ya)xta + ∆w − α(xa ·∆w)xta = wa + ∆w − α(xa ·∆w)xta (6) = wa + ∆w − αxta (xa ·∆w) (7) = wa + ∆w − α(xta ·xa) ·∆w (8) = wa + (i − αxta ·xa) ·∆w
step 6 uses equation 1, step 7 uses the fact that xa ·∆w is a scalar (allowing it to be rearranged), and step 8 follows from associativity property of matrix multiplication.
the induction is very similar and follows from replacing ∆w with ma→i−1∆w and the property that
ma→i = (i − αxti ·xi) ·ma→i−1
a.2 proof of lemma 3.1 proof. let’s call b = a · at . then bij , the element of b at row i and column j, is ∑
s aisajs. therefore, ie[bij ] = ∑k s=1 ie[aisajs] = ( 1√ k )2 ∑k s=1 ie[disdjs] = 1 k ∑k s=1 ie[disdjs]. for i 6= j, ie[bij ] = 1 k ∑k s=1 ie[dis]ie[djs] because dij are chosen independently. since ie[d] = 0 and dis, djs ∈ d, ie[dis] = ie[djs] = 0 and consequently, ie[bij ] = 0. for i = j, ie[bii] = 1 k ∑ s ie[disdis] = 1 k ∑ s ie[d 2 is]. since ie[d ] = 1 and dis ∈ d, ie[d2is] = 1. as a result, ie[bii] = 1 k ∑k s=1 ie[d 2 is] = 1 k ∑k s=1 1 = 1.
a.3 empirical evaluating singular values of m
figure 3 empirically demonstrates the benefit of taking identity off. this figure plots the singular values of m for the rcv1.binary dataset (described in section 4) after processing 64, 128, 192, 256 examples for two different learning rates. as it can be seen, the singular values are close to 1. however, the singular values of n = m − i are roughly the same as those of m minus 1 and consequently, are small. finally, the smaller α, the closer the singular values of m are to 1 and the singular values of n are to 0. also, note that the singular values of m decrease as the numbers of examples increase and therefore, the singular values of n increase. as a result, the more frequent the models are combined, the less variance (and error) is introduced into equation 5.
a.4 algorithm details and settings
this section provides details of all algorithms we used in this paper. each algorithm required slight modification to ensure fair comparison.
vowpal wabbit: vowpal wabbit langford  (2007) is one of the widely used public libraries for machine learning algorithms. we used this application as a baseline for accuracy of different datasets and as a comparison of logistic and linear regression and also an independent validation of the learners without any of our implementation bias. vowpal wabbit applies accuracy-improving optimizations such as adaptive and individual learning steps or per feature normalize updates. while all of these optimizations are applicable to symsgd, we avoided them since the focus of this paper is the running time performance of our learner. the non-default flags that we used are: --sgd, --power t 0, --holdout off, --oaa nc for multiclass datasets where nc is the number of classes, --loss function func where func is squared or logistic. for learning rate, we searched for α, the learning rate, in the set of {.1, .5, .01, .05, .001, .005, . . . } and used --learning rate α. we went through dataset 100 times for each dataset (--passes 100) and saved the learned model after each pass (--save per pass). at the end, for linear and logistic regressions, we reported the maximum accuracies achieved among different passes and different learning rates.
baseline: baseline uses a mixture of mkl intel and manually vectorized implementations of linear algebra primitives in order to deliver the fastest performance. baseline processes up-to 3.20 billion features per second at 6.4 gflops.
hogwild!: hogwild! recht  (2011) is a lock-free approach to parallelize sgd where multiple thread apply equation 1 simultaneously. although this approach may have race condition
when two threads process instances with a shared feature but the authors discuss that this does not hurt the accuracy significantly for sparse datasets. there are multiple implementations of this approach that we studied and evaluated in this section. below is a description of each:
• hw-paper: this is the implementation used to report the measurements in recht  (2011) which is publicly available hogwild. this code implements svm algorithm. therefore, we modified the update rule to linear regression. the modified code was compiled and run on our windows machine described above using an ubuntu vm since the code is configured for linux systems.
• hw-release: this is an optimized implementation that the authors built after the hogwild! paper recht  (2011) was published. similar to hw-paper, we changed the update rule accordingly and executed it on the vm.
• hogwild: we implemented this version which runs baseline by multiple threads without any synchronizations. this code runs natively on windows and enjoys all the optimizations applied to our baseline such as call to mkl library and manual vectorization of linear algebra primitives.
allreduce: allreduce agarwal  (2014) is an approach where each thread makes a copy from the global model and applies the sgd update rule to the local model for certain number of instances. along with the local model, another vector g is computed which indicates the confidence in an update for the weight of a feature in the local model. after the learning phase, the local weight vectors are averaged based on the confidence vectors from each thread. we implemented this approach similarly using mkl calls and manual vectorization.
a.5 speeups on remaining benchmarks",0
749.pdf.json,"many recent articles discuss new architectures for neural networking, especially regarding residual networks (he  (2015; 2016); larsson  (2016); zhang  (2016); huang  (2016b)). although the literature covers a wide range of network architectures, we take a high-level view of the architectures as the basis for discovering universal principles of the design of network architecture. we discuss 14 original design patterns that could benefit inexperienced practitioners who seek to incorporate deep learning in various new applications. this paper addresses the current lack of guidance on design, a deficiency that may prompt the novice to rely on standard architecture, e.g., alexnet, regardless of the architecture’s suitability to the application at hand.
this abundance of research is also an opportunity to determine which elements provide benefits in what specific contexts. we ask: do universal principles of deep network design exist? can these principles be mined from the collective knowledge on deep learning? which architectural choices work best in any given context? which architectures or parts of architectures seem elegant?
design patterns were first described by christopher alexander (alexander (1979)) in regards to the architectures of buildings and towns. alexander wrote of a timeless quality in architecture that “lives” and this quality is enabled by building based on universal principles. the basis of design patterns is that they resolve a conflict of forces in a given context and lead to an equilibrium analogous to the ecological balance in nature. design patterns are both highly specific, making them clear to follow, and flexible so they can be adapted to different environments and situations. inspired by alexander’s work, the “gang of four” (gamma  (1995)) applied the concept of design patterns to the architecture of object-oriented software. this classic computer science book describes 23 patterns that resolve issues prevalent in software design, such as “requirements always change”. we were inspired by these previous works on architectures to articulate possible design patterns for convolutional neural network (cnn) architectures.
design patterns provide universal guiding principles, and here we take the first steps to defining network design patterns. overall, it is an enormous task to define design principles for all neural networks and all applications, so we limit this paper to cnns and their canonical application of image classification. however, we recognize that architectures must depend upon the application by defining our first design pattern; design pattern 1: architectural structure follows the application
(we leave the details of this pattern to future work). in addition, these principles allowed us to discover some gaps in the existing research and to articulate novel networks (i.e, fractal of fractalnets, stagewise boosting and taylor series networks) and units (i.e., freeze-drop-path). we hope the rules of thumb articulated here are valuable for both the experienced and novice practitioners and that our preliminary work serves as a stepping stone for others to discover and share additional deep learning design patterns.to the best of our knowledge, there has been little written recently to provide guidance and understanding on appropriate architectural choices1. the book ”neural networks: tricks of the trade” (orr & müller, 2003) contains recommendations for network models but without reference to the vast amount of research in the past few years. perhaps the closest to our work is szegedy  (2015b) where those authors describe a few design principles based on their experiences.
much research has studied neural network architectures, but we are unaware of a recent survey of the field. unfortunately, we cannot do justice to this entire body of work, so we focus on recent innovations in convolutional neural networks architectures and, in particular, on residual networks (he , 2015) and its recent family of variants. we start with network in networks (lin , 2013), which describes a hierarchical network with a small network design repeatedly embedded in the overall architecture. szegedy  (2015a) incorporated this idea into their inception architecture. later, these authors proposed modifications to the original inception design (szegedy , 2015b). a similar concept was contained in the multi-scale convolution architecture (liao & carneiro, 2015). in the meantime, batch normalization (ioffe & szegedy, 2015) was presented as a unit within the network that makes training faster and easier.
before the introduction of residual networks, a few papers suggested skip connections. skip connections were proposed by raiko  (2012). highway networks (srivastava , 2015) use a gating mechanism to decide whether to combine the input with the layer’s output and showed how these networks allowed the training of very deep networks. the dropin technique (smith , 2015; 2016) also trains very deep networks by allowing a layer’s input to skip the layer. the concept of stochastic depth via a drop-path method was introduced by huang  (2016b).
residual networks were introduced by he  (2015), where the authors describe their network that won the 2015 imagenet challenge. they were able to extend the depth of a network from tens to hundreds of layers and in doing so, improve the network’s performance. the authors followed up with another paper (he , 2016) where they investigate why identity mappings help and report results for a network with more than a thousand layers. the research community took notice of this architecture and many modifications to the original design were soon proposed.
the inception-v4 paper (szegedy , 2016) describes the impact of residual connections on their inception architecture and compared these results with the results from an updated inception design. the resnet in resnet paper (targ , 2016) suggests a duel stream architecture. veit  (2016) provided an understanding of residual networks as an ensemble of relatively shallow networks. these authors illustrated how these residual connections allow the input to follow an exponential number of paths through the architecture. at the same time, the fractalnet paper (larsson , 2016) demonstrated training deep networks with a symmetrically repeating architectural pattern. as described later, we found the symmetry introduced in their paper intriguing. in a similar vein, convolutional neural fabrics (saxena & verbeek, 2016) introduces a three dimensional network, where the usual depth through the network is the first dimension.
wide residual networks (zagoruyko & komodakis, 2016) demonstrate that simultaneously increasing both depth and width leads to improved performance. in swapout (singh , 2016), each layer can be dropped, skipped, used normally, or combined with a residual. deeply fused nets (wang , 2016) proposes networks with multiple paths. in the weighted residual networks paper (shen & zeng, 2016), the authors recommend a weighting factor for the output from the convolutional layers, which gradually introduces the trainable layers. convolutional residual memory networks (moniz & pal, 2016) proposes an architecture that combines a convolutional residual network with after submission we became aware of an online book being written on deep learning design patterns at http://www.deeplearningpatterns.com
an lstm memory mechanism. for residual of residual networks (zhang , 2016), the authors propose adding a hierarchy of skip connections where the input can skip a layer, a module, or any number of modules. densenets (huang , 2016a) introduces a network where each module is densely connected; that is, the output from a layer is input to all of the other layers in the module. in the multi-residual paper (abdi & nahavandi, 2016), the authors propose expanding a residual block width-wise to contain multiple convolutional paths. our appendix a describes the close relationship between many of these residual network variants.we reviewed the literature specifically to extract commonalities and reduce their designs down to fundamental elements that might be considered design patterns. it seemed clear to us that in reviewing the literature some design choices are elegant while others are less so. in particular, the patterns described in this paper are the following: . architectural structure follows the application . proliferate paths . strive for simplicity . increase symmetry . pyramid shape . over-train . cover the problem space . incremental feature construction . normalize layer inputs 0. input transition 1. available resources guide layer widths 2. summation joining 3. down-sampling transition 4. maxout for competitionseveral researchers have pointed out that the winners of the imagenet challenge (russakovsky , 2015) have successively used deeper networks (as seen in, krizhevsky  (2012), szegedy  (2015a), simonyan & zisserman (2014), he  (2015)). it is also apparent to us from the imagenet challenge that multiplying the number of paths through the network is a recent trend that is illustrated in the progression from alexnet to inception to resnets. for example, veit  (2016) show that resnets can be considered to be an exponential ensemble of networks with different lengths. design pattern 2: proliferate paths is based on the idea that resnets can be an exponential ensemble of networks with different lengths. one proliferates paths by including a multiplicity of branches in the architecture. recent examples include fractalnet (larsson  2016), xception (chollet 2016), and decision forest convolutional networks (ioannou  2016).
scientists have embraced simplicity/parsimony for centuries. simplicity was exemplified in the paper ”striving for simplicity” (springenberg  2014) by achieving state-of-the-art results with fewer types of units. design pattern 3: strive for simplicity suggests using fewer types of units and keeping the network as simple as possible. we also noted a special degree of elegance in the fractalnet (larsson  2016) design, which we attributed to the symmetry of its structure. design pattern 4: increase symmetry is derived from the fact that architectural symmetry is typically considered a sign of beauty and quality. in addition to its symmetry, fractalnets also adheres to the proliferate paths design pattern so we used it as the baseline of our experiments in section 4.
an essential element of design patterns is the examination of trade-offs in an effort to understand the relevant forces. one fundamental trade-off is the maximization of representational power versus
elimination of redundant and non-discriminating information. it is universal in all convolutional neural networks that the activations are downsampled and the number of channels increased from the input to the final layer, which is exemplified in deep pyramidal residual networks (han  (2016)). design pattern 5: pyramid shape says there should be an overall smooth downsampling combined with an increase in the number of channels throughout the architecture.
another trade-off in deep learning is training accuracy versus the ability of the network to generalize to non-seen cases. the ability to generalize is an important virtue of deep neural networks. regularization is commonly used to improve generalization, which includes methods such as dropout (srivastava  2014a) and drop-path (huang  2016b). as noted by srivastava  2014b, dropout improves generalization by injecting noise in the architecture. we believe regularization techniques and prudent noise injection during training improves generalization (srivastava  2014b, gulcehre  2016). design pattern 6: over-train includes any training method where the network is trained on a harder problem than necessary to improve generalization performance of inference. design pattern 7: cover the problem space with the training data is another way to improve generalization (e.g., ratner  2016, hu  2016, wong  2016, johnson-roberson  2016). related to regularization methods, cover the problem space includes the use of noise (rasmus  2015, krause  2015, pezeshki  2015), synthetic data, and data augmentation, such as random cropping, flipping, and varying brightness, contrast, and the like.a common thread throughout many of the more successful architectures is to make each layer’s “job” easier. use of very deep networks is an example because any single layer only needs to incrementally modify the input, and this partially explains the success of residual networks, since in very deep networks, a layer’s output is likely similar to the input; hence adding the input to the layer’s output makes the layer’s job incremental. also, this concept is part of the motivation behind design pattern 2 but it extends beyond that. design pattern 8: incremental feature construction recommends using short skip lengths in resnets. a recent paper (alain & bengio (2016)) showed in an experiment that using an identity skip length of 64 in a network of depth 128 led to the first portion of the network not being trained.
design pattern 9: normalize layer inputs is another way to make a layer’s job easier. normalization of layer inputs has been shown to improve training and accuracy but the underlying reasons are not clear (ioffe & szegedy 2015, ba  2016, salimans & kingma 2016). the batch normalization paper (ioffe & szegedy 2015) attributes the benefits to handling internal covariate shift, while the authors of streaming normalization (liao  2016) express that it might be otherwise. we feel that normalization puts all the layer’s input samples on more equal footing (analogous to a units conversion scaling), which allows back-propagation to train more effectively.
some research, such as wide resnets (zagoruyko & komodakis 2016), has shown that increasing the number of channels improves performance but there are additional costs with extra channels. the input data for many of the benchmark datasets have 3 channels (i.e., rgb). design pattern 10: input transition is based on the common occurrence that the output from the first layer of a cnn significantly increases the number of channels from 3. a few examples of this increase in channels/outputs at the first layer for imagenet are alexnet (96 channels), inception (32), vgg (224), and resnets (64). intuitively it makes sense to increase the number of channels from 3 in the first layer as it allows the input data to be examined many ways but it is not clear how many outputs are best. here, the trade-off is that of cost versus accuracy. costs include the number of parameters in the network, which directly affects the computational and storage costs of training and inference. design pattern 11: available resources guide layer widths is based on balancing costs against an application’s requirements. choose the number of outputs of the first layer based on memory and computational resources and desired accuracy.when there are multiple branches, three methods have been used to combine the outputs; concatenation, summation (or mean), or maxout. it seems that different researchers have their favorites and there hasn’t been any motivation for using one in preference to another. in this section, we propose some rules for deciding how to combine branches.
summation is one of the most common ways of combining branches. design pattern 12: summation joining is where the joining is performed by summation/mean. summation is the preferred joining mechanism for residual networks because it allows each branch to compute corrective terms (i.e., residuals) rather than the entire approximation. the difference between summation and mean (i.e., fractal-join) is best understood by considering drop-path (huang  2016b). in a residual network where the input skip connection is always present, summation causes the layers to learn the residual (the difference from the input). on the other hand, in networks with several branches, where any branch can be dropped (e.g., fractalnet (larsson  (2016))), using the mean is preferable as it keeps the output smooth as branches are randomly dropped.
some researchers seem to prefer concatenation (e.g., szegedy  (2015a)). design pattern 13: down-sampling transition recommends using concatenation joining for increasing the number of outputs when pooling. that is, when down-sampling by pooling or using a stride greater than 1, a good way to combine branches is to concatenate the output channels, hence smoothly accomplishing both joining and an increase in the number of channels that typically accompanies down-sampling.
maxout has been used for competition, as in locally competitive networks (srivastava  2014b) and competitive multi-scale networks liao & carneiro (2015). design pattern 14: maxout for competition is based on maxout choosing only one of the activations, which is in contrast to summation or mean where the activations are “cooperating”; here, there is a “competition” with only one “winner”. for example, when each branch is composed of different sized kernels, maxout is useful for incorporating scale invariance in an analogous way to how max pooling enables translation invariance.in elucidating these fundamental design principles, we also discovered a few architectural innovations. in this section we will describe these innovations.
first, we recommended combining summation/mean, concatenation, and maxout joining mechanisms with differing roles within a single architecture, rather than the typical situation where only one is used throughout. next, design pattern 2: proliferate branches led us to modify the overall sequential pattern of modules in the fractalnet architecture. instead of lining up the modules for maximum depth, we arranged the modules in a fractal pattern as shown in 1b, which we named a fractal of fractalnet (fof) network, where we exchange depth for a greater number of paths.drop-path was introduced by huang  (2016b), which works by randomly removing branches during an iteration of training, as though that path doesn’t exist in the network. symmetry considerations led us to an opposite method that we named freeze-path. instead of removing a branch from the network during training, we freeze the weights, as though the learning rate was set to zero. a similar idea has been proposed for recurrent neural networks (krueger  2016).
the potential usefulness of combining drop-path and freeze-path, which we named freeze-drop-path, is best explained in the non-stochastic case. figure 1 shows an example of a fractal of fractalnet architecture. let’s say we start training only the leftmost branch in figure 1b and use drop-path on all of the other branches. this branch should train quickly since it has only a relatively few parameters compared to the entire network. next we freeze the weights in that branch and allow the next branch to the right to be active. if the leftmost branch is providing a good function approximation, the next branch works to produce a “small” corrective term. since the next branch contains more layers than the previous branch and the corrective term should be easier to approximate than the original function, the network should attain greater accuracy. one can continue this process from left to right to train the entire network. we used freeze-drop-path as the final/bottom join in the fof architecture in figure 1b and named this the stagewise boosting networks (sbn) because they are analogous to stagewise boosting (friedman  2001). the idea of boosting neural networks is not new (schwenk & bengio 2000) but this architecture is new. in appendix b we discuss the implementation we tested.taylor series expansions are classic and well known as a function approximation method, which is: f(x+ h) = f(x) + hf ′(x) + h2f ′′(x)/2 + ... (1)
since neural networks are also function approximators, it is a short leap from fofs and sbns to consider the branches of that network as terms in a taylor series expansion. hence, the taylor series implies squaring the second branch before the summation joining unit, analogous to the second order term in the expansion. similarly, the third branch would be cubed. we call this “taylor series networks” (tsn) and there is precedence for this idea in the literature with polynomial networks (livni  2014) and multiplication in networks (e.g. lin  2015. the implementation details of this tsn are discussed in the appendix.the experiments in this section are primarily to empirically validate the architectural innovations described above but not to fully test them. we leave a more complete evaluation to future work.
table 1 and figures 2 and 3 compare the final test accuracy results for cifar-10 and cifar-100 in a number of experiments. an accuracy value in table 1 is computed as the mean of the last 6 test
accuracies computed over the last 3,000 iterations (out of 100,000) of the training. the results from the original fractalnet (larsson  2016) are given in the first row of the table and we use this as our baseline. the first four rows of table 1 and figure 2 compare the test accuracy of the original fractalnet architectures to architectures with a few modifications advocated by design patterns. the first modification is to use concatenation instead of fractal-joins at all the downsampling locations in the networks. the results for both cifar-10 (2a) and cifar-100 (2b indicate that the results are equivalent when concatenation is used instead of fractal-joins at all the downsampling locations in the networks. the second experiment was to change the kernel sizes in the first module from 3x3 such that the left most column used a kernel size of 7x7, the second column 5x5, and the third used 3x3. the fractal-join for module one was replaced with maxout. the results in figure 2 are a bit worse, indicating that the more cooperative fractal-join (i.e., mean/summation) with 3x3 kernels has better performance than the competitive maxout with multiple scales. figure 2 also illustrates how an experiment replacing max pooling with average pooling throughout the architecture changes the training profile. for cifar-10, the training accuracy rises quickly, plateaus, then lags behind the original fractalnet but ends with a better final performance, which implies that average pooling might significantly reduce the length of the training (we plan to examine this in future work). this behavior provides some evidence that “cooperative” average pooling might be preferable to “competitive” max pooling.
table 1 and figure 3 compare the test accuracy results for the architectural innovations described in section 4.1. the fof architecture ends with a similar final test accuracy as fractalnet but the sbn and tsn architectures (which use freeze-drop-path) lag behind when the learning rate is dropped. however, it is clear from both figures 3a and 3b that the new architectures train more quickly than fractalnet. the fof network is best as it trains more quickly than fractalnet and achieves similar accuracy. the use of freeze-drop-path in sbn and tsn is questionable since the final performance lags behind fractalnet, but we are leaving the exploration for more suitable applications of these new architectures for future work.in this paper we describe convolutional neural network architectural design patterns that we discovered by studying the plethora of new architectures in recent deep learning papers. we hope these design patterns will be useful to both experienced practitioners looking to push the state-of-the-art and novice practitioners looking to apply deep learning to new applications. there exists a large expanse of potential follow up work (some of which we have indicated here as future work). our effort here is primarily focused on residual networks for classification but we hope this preliminary work will inspire others to follow up with new architectural design patterns for recurrent neural networks, deep reinforcement learning architectures, and beyond.the authors want to thank the numerous researchers upon whose work these design patterns are based and especially larsson  2016 for making their code publicly available. this work was supported by the us naval research laboratory base program.the architectures mentioned in section 2 commonly combine outputs from two or more layers using concatenation along the depth axis, element-wise summation, and element-wise average. we show here that the latter two are special cases of the former with weight-sharing enforced. likewise, we show that skip connections can be considered as introducing additional layers into a network that share parameters with existing layers. in this way, any of the residual network variants can be reformulated into a standard form where many of the variants are equivalent.
a filter has three dimensions: two spatial dimensions, along which convolution occurs, and a third dimension, depth. each input channel corresponds to a different depth for each filter of a layer. as a result, a filter can be considered to consist of “slices,” each of which is convolved over one input channel. the results of these convolutions are then added together, along with a bias, to produce a single output channel. the output channels of multiple filters are concatenated to produce the output of a single layer. when the outputs of several layers are concatenated, the behavior is similar to that of a single layer. however, instead of each filter having the same spatial dimensions, stride, and padding, each filter may have a different structure. as far as the function within a network, though, the two cases are the same. in fact, a standard layer, one where all filters have the same shape, can be considered a special case of concatenating outputs of multiple layer types.
if summation is used instead of concatenation, the network can be considered to perform concatenation but enforce weight-sharing in the following layer. the results of first summing several channels element-wise and then convolving a filter slice over the output yields the same result as convolving the slice over the channels and then performing an element-wise summation afterwards. therefore, enforcing weight-sharing such that the filter slices applied to the nth channel of all inputs share weight results in behavior identical to summation, but in a form similar to concatenation, which highlights the relationship between the two. when batch normalization (bn) (ioffe & szegedy 2015 is used, as is the current standard practice, performing an average is essentially identical to performing a summation, since bn scales the output. therefore, scaling the input by a constant (i.e., averaging instead of a summation) is rendered irrelevant. the details of architecture-specific manipulations of summations and averages is described further in section 3.2.1.
due to the ability to express depth-wise concatenation, element-wise sum, and element-wise mean as variants of each other, architectural features of recent works can be combined within a single network, regardless of choice of combining operation. however, this is not to say that concatenation has the most expressivity and is therefore strictly better than the others. summation allows networks to divide up the network’s task. also, there is a trade-off between the number of parameters and the expressivity of a layer; summation uses weight-sharing to significantly reduce the number of parameters within a layer at the expense of some amount of expressivity.
different architectures can further be expressed in a similar fashion through changes in the connections themselves. a densely connected series of layers can be “pruned” to resemble any desired architecture with skip connections through zeroing specific filter slices. this operation removes the dependency of the output on a specific input channel; if this is done for all channels from a given layer, the connection between the two layers is severed. likewise, densely connected layers can be turned into linearly connected layers while preserving the layer dependencies; a skip connection can be passed through the intermediate layers. a new filter can be introduced for each input channel passing through, where the filter performs the identity operation for the given input channel. all existing filters in the intermediate layers can have zeroed slices for this input so as to not introduce new dependencies. in this way, arbitrarily connected layers can be turned into a standard form.
we certainly do not recommend this representation for actual experimentation as it introduces fixed parameters. we merely describe it to illustrate the relationship between different architectures. this representation illustrates how skip connections effectively enforce specific weights in intermediate layers. though this restriction reduces expressivity, the number of stored weights is reduced, the number of computations performed is decreased, and the network might be more easily trainable.
b implementation details
our implementations are in caffe (jia  2014; downloaded october 9, 2016) using cuda 8.0. these experiments were run on a 64 node cluster with 8 nvidia titan black gpus, 128 gb memory, and dual intel xenon e5-2620 v2 cpus per node. we used the cifar10 and cifar-100 datasets (krizhevsky & hinton 2009 for our classification tests. these datasets consist of 60,000 32x32 colour images (50,000 for training and 10,000 for testing) in 10 or 100 classes, respectively. our caffe code and prototxt files are publicly available at https://github.com/iphysicist/cnndesignpatterns.
b.1 architectures
we started with the fractalnet implementation 2 as our baseline and it is described in larsson  2016. we used the three column module as shown in figure 1a. in some of our experiments, we replaced the fractal-join with concatenation at the downsampling locations. in other experiments, we modified the kernel sizes in module one and combined the branches with maxout. a fractalnet module is shown in figure 1a and the architecture consists of five sequential modules.
our fractal of fractalnet (fof) architecture uses the same module but has an overall fractal design as in figure 1b rather than the original sequential one. we limited our investigation to this one realization and left the study of other (possibly more complex) designs for future work. we followed the fractalnet implementation in regards to dropout where the dropout rate for a module were 0%, 10%, 20%, or 30%, depending on the depth of the module in the architecture. this choice for dropout rates were not found by experimentation and better values are possible. the local drop-path rate in the fractal-joins were fixed at 15%, which is identical to the fractalnet implementation.
freeze-drop-path introduces four new parameters. the first is whether the active branch is chosen stochastically or deterministically. if it is chosen stochastically, a random number is generated and the active branch is assigned based on which interval it falls in (intervals will be described shortly). if it is deterministically, a parameter is set by the user as to the number of iterations in one cycle through all the branches (we called this parameter num iter per cycle). in our caffe implementation of the freeze-drop-path unit, the bottom input specified first is assigned as branch 1, the next is branch 2, then branch 3, etc. the next parameter indicates the proportion of iterations each branch should be active relative to all the other branches. the first type of interval uses the square of the branch number (i.e., 1, 4, 9, 16, ...) to assign the interval length for that branch to be active, which gives the more update iterations to the higher numbered branches. the next type gives the same amount of iterations to each branch. our experiments showed that the first interval type works better (as we expected) and was used to obtained the results in section 4.2. in addition, our experiments showed that the stochastic option works better than the deterministic option (unexpected) and was used for section 4.2 results. https://github.com/gustavla/fractalnet/tree/master/caffe
the stagewise boosting network’s (sbn) architecture is the same as the fof architecture except that branches 2 and 3 are combined with a fractal-join and then combined with branch 1 in a freezedrop-path join. the reason for combining branches 2 and 3 came out of our first experiments; if branches 2 and 3 were separate, the performance deteriorated when branch 2 was frozen and branch 3 was active. in hindsight, this is due to the weights in the branch 2 path that are also in branch 3’s path being modified by the training of branch 3. the taylor series network has the same architecture as sbn with the addition of squaring the branch 2 and 3 combined activations before the freeze-drop-path join.
for all of our experiments, we trained for 400 epochs. since the training used 8 gpus and each gpu had a batchsize of 25, 400 epochs amounted to 100,000 iterations. we adopted the same learning rate as the fractalnet implementation, which started at 0.002 and dropped the learning rate by a factor of 10 at epochs 200, 300, and 350.",0
756.pdf.json,"many dimensionality reduction or manifold learning algorithms optimize for retaining the pairwise similarities, distances, or local neighborhoods of data points. classical scaling (cox & cox, 2000), kernel pca (schölkopf , 1998), isomap (tenenbaum , 2000), and lle (roweis & saul, 2000) achieve this by performing an eigendecomposition of some similarity matrix to obtain a low dimensional representation of the original data. however, this is computationally expensive if a lot of training examples are available. additionally, out-of-sample representations can only be created when the similarities to the original training examples can be computed (bengio , 2004).
for some methods such as t-sne (van der maaten & hinton, 2008), great effort was put into extending the algorithm to work with large datasets (van der maaten, 2013) or to provide an explicit mapping function which can be applied to new data points (van der maaten, 2009). current attempts at finding a more general solution to these issues are complex and require the development of specific cost functions and constraints when used in place of existing algorithms (bunte , 2012), which limits their applicability to new objectives.
in this paper we introduce a new neural network architecture, that we will denote as similarity encoder (simec), which is able to learn representations that can retain arbitrary pairwise relations present in the input space, even those obtained from unknown similarity functions such as human ratings. a simec can learn a linear or non-linear mapping function to project new data points into a lower dimensional embedding space. furthermore, it can take advantage of large datasets since the objective function is optimized iteratively using stochastic mini-batch gradient descent. we show on both image and text datasets that simecs can, on the one hand, recreate solutions found by traditional methods such as kpca or isomap, and, on the other hand, obtain meaningful embeddings from similarities based on human labels.
additionally, we propose the new context encoder (conec) model, a variation of similarity encoders for learning word embeddings, which extends word2vec (mikolov , 2013b) by using the local context of words as input to the neural network to create representations for out-of-vocabulary words and to distinguish between multiple meanings of words. this is shown to be advantageous, for example, if the word embeddings are used as features in a named entity recognition task as demonstrated on the conll 2003 challenge.we propose a novel dimensionality reduction framework termed similarity encoder (simec), which can be used to learn a linear or non-linear mapping function for computing low dimensional representations of data points such that the original pairwise similarities between the data points in the input space are preserved in the embedding space. for this, we borrow the “bottleneck” neural network (nn) architecture idea from autoencoders (tishby , 2000; hinton & salakhutdinov, 2006). autoencoders aim to transform the high dimensional data points into low dimensional embeddings such that most of the data’s variance is retained. their network architecture has two parts: the first part of the network maps the data points from the original feature space to the low dimensional embedding (at the bottleneck). the second part of the nn mirrors the first part and projects the embedding back to a high dimensional output. this output is then compared to the original input to compute the reconstruction error of the training samples, which is used in the backpropagation procedure to tune the network’s parameters. after the training is complete, i.e. the low dimensional embeddings encode enough information about the original input samples to allow for their reconstruction, the second part of the network is discarded and only the first part is used to project data points into the low dimensional embedding space. similarity encoders have a similar two fold architecture, where in the first part of the network, the data is mapped to a low dimensional embedding, and then in the second part (which is again only used during training), the embedding is transformed such that the error of the representation can be computed. however, since here the objective is to retain the (non-linear) pairwise similarities instead of the data’s variance, the second part of the nn does not mirror the first like it does in the autoencoder architecture.
the similarity encoder architecture (figure 1) uses as the first part of the network a flexible non-linear feed-forward neural network to map the high dimensional input data points xi ∈ rd to a low dimensional embedding yi ∈ rd (at the bottleneck). as we make no assumptions on the range of values the embedding can take, the last layer of the first part of the nn (i.e. the one resulting in the embedding) is always linear. for example, with two additional non-linear hidden layers, the embedding would be computed as
yi = σ1(σ0(xiw0)w1)w2,
where σ0 and σ1 denote your choice of non-linear activation functions (e.g. tanh, sigmoid, or relu), but there is no non-linearity applied after multiplying with w2. the second part of the network then
consists of a single additional layer with the weight matrix w−1 ∈ rd×n to project the embedding to the output, the approximated similarities s′ ∈ rn :
s′ = σ−1(yiw−1).
these approximated similarities are then compared to the target similarities (for one data point this is the corresponding row si ∈ rn of the similarity matrix s ∈ rn×n of the n training samples) and the computed error is used to tune the network’s parameters with backpropagation.
for the model to learn most efficiently, the exact form of the cost function to optimize as well as the type of non-linearity σ−1 applied when computing the network’s output should be chosen with respect to the type of target similarities that the model is supposed to preserve. in the experimental section of the paper we are considering two application scenarios of simecs: a) to obtain the same low dimensional embedding as found by spectral methods such as kpca, and b) to embed data points such that binary similarity relations obtained from human labels are preserved. in the first case (further discussed in the next section), we omit the non-linearity when computing the output of the network, i.e. s′ = yiw−1, since the target similarities, computed by some kernel function, are not necessarily constrained to lie in a specific interval. as the cost function to minimize we choose the mean squared error between the output (approximated similarities) and the original (target) similarities. a regularization term is added to encourage the weights of the last layer (w−1) to be orthogonal.1 the model’s objective function optimized during training is therefore:
min 1
n n∑ i=1 ‖si − s′‖22 + λ 1 d2 − d ∥∥w−1w>−1 − diag(w−1w>−1)∥∥1
where ‖ · ‖p denotes the respective p-norms for vectors and matrices and λ is a hyperparameter to control the strength of the regularization. in the second case, the target similarities are binary and it therefore makes sense to use a nonlinear activation function in the final layer when computing the output of the network to ensure the approximated similarities are between 0 and 1 as well:2
s′ = σ−1(yiw−1) with σ−1(z) = 1  + e−10(z−0.5) .
while the mean squared error between the target and approximated similarities would still be a natural choice of cost function to optimize, with the additional non-linearity in the output layer, learning might be slow due to small gradients and we therefore instead optimize the cross-entropy:
min − 1 n
∑ [si ln(s ′) + (1− si) ln(1− s′)] .
for a different application scenario, yet another setup might lead to the best results. when using simecs in practice, we recommend to first try the first setup, i.e. keeping the output layer linear and minimizing the mean squared error, as this often already gives quite good results.
after the training is completed, only the first part of the neural network, which maps the input to the embedding, is used to create the representations of new data points. depending on the complexity of the feed-forward nn, the mapping function learned by similarity encoders can be linear or non-linear, and because of the iterative optimization using stochastic mini-batch gradient descent, large amounts of data can be utilized to learn optimal representations.3kernel pca (kpca) is a popular non-linear dimensionality reduction algorithm, which performs the eigendecomposition of a kernel matrix to obtain low dimensional representations of the data points to get embeddings similar to those obtained by kpca, orthogonal weights in the last layer of the nn help as they correspond to the orthogonal eigenvectors of the kernel matrix found by kpca. this scaled and shifted sigmoid function maps values between 0 and 1 almost linearly while thresholding values outside this interval. to speed up the training procedure and limit memory requirements for large datasets, the columns of the similarity matrix can also be subsampled (yielding s ∈ rn×n), i.e. the number of target similarities (and the dimensionality of the output layer) is n < n , however all n training examples can still be used as input to train the network.
(schölkopf , 1998). however, if the kernel matrix is very large this becomes computationally very expensive. additionally, there are constraints on possible kernel functions (should be positive semi-definite) and new data points can only be embedded in the lower dimensional space if their kernel map (i.e. the similarities to the original training points) can be computed. as we show below, simec can optimize the same objective as kpca but addresses these shortcomings.
the general idea is that both kpca and simec embed the n data points in a feature space where the given target similarities can be approximated linearly (i.e. with the scalar product of the embedding vectors). when the error between the approximated (s′) and the target similarities (s) is computed as the mean squared error, kpca finds the optimal approximation by performing the eigendecomposition of the (centered) target similarity matrix, i.e.
s′ = y y >,
where y ∈ rn×d is the low dimensional embedding of the data based on the eigenvectors belonging to the d largest eigenvalues of s.
in addition to the embedding itself, it is often desired to have a parametrized mapping function, which can be used to project new (out-of-sample) data points into the embedding space. if the target similarity matrix is the linear kernel, i.e. s = xx> where x ∈ rn×d is the given input data, this can easily be accomplished with traditional pca. here, the covariance matrix of the centered input data, i.e. c = x>x is decomposed to obtain a matrix with parameters, w̃ ∈ rd×d, based on the eigenvectors belonging to the d largest eigenvalues of the covariance matrix. then the optimal embedding (i.e. the same solution obtained by linear kpca) can be computed as
y = xw̃.
this serves as a mapping function, with which new data points can be easily projected into the lower dimensional embedding space.
when using a similarity encoder to embed data in a low dimensional space where the linear similarities are preserved, the simec’s architecture would consist of a neural network with a single linear layer, i.e. the parameter matrix w0, to project the input data x to the embedding y = xw0, and another matrix w−1 ∈ rd×n used to approximate the similarities as s′ = yw−1. from these formulas one can immediately see the link between linear similarity encoders and pca / linear kpca: once the parameters of the neural network are tuned correctly, w0 would correspond to the mapping matrix w̃ found by pca and w−1 could be interpreted as y >, i.e. y would be the same eigenvector based embedding as found with linear kpca.
finding the corresponding function to map new data points into the embedding space is trivial for linear kpca, but this is not the case for other kernel functions. while it is still possible to find the optimal embedding with kpca for non-linear kernel functions, the mapping function remains unknown and new data points can only be projected into the embedding space if we can compute their kernel map, i.e. the similarities to the original training examples (bengio , 2004). some attempts were made to manually define an explicit mapping function to represent data points in the kernel feature space, however this only works for specific kernels and there exists no general solution (rahimi & recht, 2007). as neural networks are universal function approximators, with the right architecture similarity encoders could instead learn arbitrary mapping functions for unknown similarities to arrive at data driven kernel learning solutions.the properties of similarity encoders are summarized in the following. the objective of this dimensionality reduction approach is to retain pairwise similarities between data points in the embedding space. this is achieved by tuning the parameters of a neural network to obtain a linear or non-linear mapping (depending on the network’s architecture) from the high dimensional input to the low dimensional embedding. since the cost function is optimized using stochastic mini-batch gradient descent, we can take advantage of large datasets for training. the embedding for new test points can be easily computed with the explicit mapping function in the form of the tuned neural network. and since there is no need to compute the similarity of new test examples to the original training data for out-of-sample solutions (like with kpca), the target similarities can be generated by an unknown process such as human similarity judgments.in the following experiments we demonstrate that similarity encoders can, on the one hand, reach the same solution as kpca, and, on the other hand, generate meaningful embeddings from human labels. to illustrate that this is independent of the type of data, we present results obtained both on the well known mnist handwritten digits dataset as well as the 20 newsgroups text corpus. further details as well as the code to replicate these experiments and more is available online.4
we compare the embedding found with linear kpca to that created with a linear similarity encoder (consisting of one linear layer mapping the input to the embedding and a second linear layer to project the embedding to the output, i.e. computing the approximated similarities). additionally, we show that a non-linear simec can approximate the solution found with isomap (i.e. the eigendecomposition of the geodesic distance matrix). we found that for optimal results the kernel matrix used as the target similarity matrix for the simec should first be centered (as it is being done for kpca as well (müller , 2001)).
in a second step, we show that simecs can learn the mapping to a low dimensional embedding for arbitrary similarity functions and reliably create representations for new test samples without the need to compute their similarities to the original training examples, thereby going beyond the capabilities of kpca. for both datasets we illustrate this by using the class labels assigned to the samples by human annotators to create the target similarity matrix for the training fold of the data, i.e. s is 1 for data points belonging to the same class and 0 everywhere else. we compare the solutions found by simec architectures with a varying number of additional non-linear hidden layers in the first part of the network (while keeping the embedding layer linear as before) to show how a more complex network improves the ability to map the data into an embedding space in which the class-based similarities are retained.
mnist the mnist dataset contains 28× 28 pixel images depicting handwritten digits. for our experiments we randomly subsampled 10k images from all classes, of which 80% are assigned to the training fold and the remaining 20% to the test fold (in the following plots, data points belonging to the training set are displayed transparently while the test points are opaque). as shown in figure 2, the embeddings of the mnist dataset created with linear kpca and a linear similarity encoder, which uses as target similarities the linear kernel matrix, are almost identical (up to a rotation). the same holds true for the isomap embedding, which is well approximated by a non-linear simec with two hidden layers using the geodesic distances between the data points as targets (figure 8 in the appendix). when optimizing simecs to retain the class-based similarities (figure 3), additional
non-linear hidden layers in the feed-forward nn can improve the embedding by further separating data points belonging to different classes in tight clusters. as it can be seen, the test points (opaque) are nicely mapped into the same locations as the corresponding training points (transparent), i.e. the model learns to associate the input pixels with the class clusters only based on the imposed similarities between the training data points. https://github.com/cod3licious/simec/examples_simec.ipynb 0 newsgroups the 20 newsgroups dataset consists of around 18k newsgroup posts assigned to 20 different topics. we take a subset of seven categories and use the original train/test split (∼4.1k and ∼2.7k samples respectively) and remove metadata such as headers to avoid overfitting.5 all text documents are transformed into 46k dimensional tf-idf feature vectors, which are used as input to the simec and to compute the linear kernel matrix of the training fold. the embedding created with linear kpca is again well approximated by the solution found with a corresponding linear simec (figure 9 in the appendix). additionally, this serves as an example where traditional pca is not an option to obtain the corresponding mapping matrix for the linear kpca solution, as due to the high dimensionality of the input data and comparatively low number of samples, the empirical covariance matrix would be poorly estimated and too large to decompose into eigenvalues and -vectors. with the objective to retain the class-based similarities, a simec with a non-linear hidden layer clusters documents by their topics (figure 4).representation learning is very prominent in the field of natural language processing (nlp). for example, word embeddings learned by neural network language models were shown to improve the performance when used as features for supervised learning tasks such as named entity recognition (ner) (collobert , 2011; turian , 2010). the popular word2vec model (figure 5) learns meaningful word embeddings by considering only the words’ local contexts and thanks to its shallow architecture it can be trained very efficiently on large corpora. however, an important limiting factor of current word embedding models is that they only learn the representations for words from a fixed vocabulary. this means, if in a task we encounter a new word which was not present in the texts used for training, we can not create an embedding for this word without repeating the time consuming http://scikit-learn.org/stable/datasets/twenty_newsgroups.html
training procedure of the model.6 additionally, word2vec, like many other approaches, only learns a single representation for every word. however, it is often the case that a single word can have multiple meanings, e.g. “washington” is both the name of a us state as well as a former president. it is only the local context in which these words appear that lets humans resolve this ambiguity and identify the proper sense of the word in question. while attempts were made to improve this, they lack flexibility as they require a clustering of word contexts beforehand (huang , 2012), which still does not guarantee that all possible meanings of a word have been identified prior in the training documents. other approaches require additional labels such part-of-speech tags (trask , 2015) or other lexical resources like wordnet (rothe & schütze, 2015) to create word embeddings which distinguish between the different senses of a word.
as a further contribution of this paper we provide a link between the successful word2vec natural language model and similarity encoders and thereby propose a new model we call context encoder (conec), which can efficiently learn word embeddings from huge amounts of training data and additionally make use of local contexts to create representations for out-of-vocabulary words and help distinguish between multiple meanings of words. in practice these models are trained on such a large vocabulary that it is rare to encounter a word which does not have an embedding. however, there are still scenarios where this is the case, for example, it is unlikely that the term “w10281545” is encountered in a regular training corpus, but we might still want its embedding to represent a search query like “whirlpool w10281545 ice maker part”.
formally, word embeddings are d -dimensional vector representations learned for all n words in the vocabulary. word2vec is a shallow model with parameter matrices w0,w1 ∈ rn×d, which are tuned iteratively by scanning huge amounts of texts sentence by sentence (see figure 5). based on some context words the algorithm tries to predict the target word between them. mathematically this is realized by first computing the sum of the embeddings of the context words by selecting the appropriate rows from w0. this vector is then multiplied by several rows selected from w1: one of these rows corresponds to the target word, while the others correspond to k ‘noise’ words, selected at random (negative sampling). after applying a non-linear activation function, the backpropagation error is computed by comparing this output to a label vector t ∈ rk+1, which is 1 at the position of the target word and 0 for all k noise words. after the training of the model is complete, the word embedding for a target word is the corresponding row of w0.
the main principle utilized when learning word embeddings is that similar words appear in similar contexts (harris, 1954; melamud , 2015). therefore, in theory one could compute the similarities between all words by checking how many context words any two words generally have in common (possibly weighted somehow to reduce the influence of frequent words such as ‘the’ and ‘and’). however, such a word similarity matrix would be very large, as typically the vocabulary for which word embeddings are learned comprises several 10, 000 words, making it computationally too expensive to be used with similarity encoders. but this matrix would also be quite sparse, because many words in fact do not occur in similar contexts and most words only have a handful of synonyms which could be used in their place. therefore, we can view the negative sampling approach used for word2vec (mikolov , 2013b) as an approximation of the words’ context based similarities: while the similarity of a word to itself is 1, if for one word we select k random words out of the huge vocabulary, it is very unlikely that they are similar to the target word, i.e. we can approximate their similarities with 0. this is the main insight necessary for adapting similarity encoders to be used for learning (context sensitive) word embeddings.
figure 6 shows the architecture of the context encoder. for the training procedure we stick very closely to the optimization strategy used by word2vec: while parsing a document, we again select a target word and its context words. as input to the context encoder network, we use a vector xi of length n (i.e. the size of the vocabulary), which indicates the context words by non-zero values (either binary or e.g. giving lower weight to context words further away from the target word). this vector is then multiplied by a first matrix of weights w0 ∈ rn×d yielding a low dimensional embedding yi, comparable to the summed context embedding created as a first step when training the word2vec model. this embedding is then multiplied by a second matrix w1 ∈ rd×n to yield the output. instead of comparing this output vector to a whole row from a word similarity matrix (as we would with similarity encoders), only k + 1 entries are selected, namely those belonging to
the target word as well as k random and unrelated noise words. after applying a non-linearity we compare these entries s′ ∈ rk+1 to the binary target vector exactly as in the word2vec model and use error backpropagation to tune the parameters.
up to now, there are no real differences between the word2vec model and our context encoders, we have merely provided an intuitive interpretation of the training procedure and objective. the main deviation from the word2vec model lies in the computation of the word embedding for a target word after the training is complete. in the case of word2vec, the word embedding is simply the row of the tuned w0 matrix. however, when considering the idea behind the optimization procedure, we instead propose to compute a target word’s representation by multiplying w0 with the word’s average context vector. this is closer to what is being done in the training procedure and additionally it enables us to compute the embeddings for out-of-vocabulary words (assuming at least most of such a new word’s context words are in the vocabulary) as well as to place more emphasis on a word’s local context (which helps to identify the proper meaning of the word (melamud , 2015)) by creating a weighted sum between the word’s average global and local context vectors used as input to the conec.
with this new perspective on the model and optimization procedure, another advancement is feasible. since the context words are merely a sparse feature vector used as input to a neural network, there is no reason why this input vector should not contain other features about the target word as well. for example, the feature vector could be extended to contain information about the word’s case, part-of-speech (pos) tag, or other relevant details. while this would increase the dimensionality of the first weight matrix w0 to include the additional features when mapping the input to the word’s embedding, the training objective and therefore also w1 would remain unchanged. these additional features could be especially helpful if details about the words would otherwise get lost in preprocessing (e.g. by lowercasing) or to retain information about a word’s position in the sentence, which is ignored in a bow approach. these extended conecs are expected to create embeddings which distinguish even better between the words’ different senses by taking into account, for example, if the word is used as a noun or verb in the current context, similar to the sense2vec algorithm (trask , 2015). however, unlike sense2vec, not multiple embeddings per term are learned, instead the dimensionality of the input vector is increased to include the pos tag of the current word as a feature.the word embeddings learned with word2vec and context encoders are evaluated on a word analogy task (mikolov , 2013a) as well as the conll 2003 ner benchmark task (tjong , 2003). the word2vec model used is a continuous bow model trained with negative sampling as described above where k = 13, the embedding dimensionality d is 200 and we use a context window of 5. the word embeddings created by the context encoders are build directly on top of the word2vec model by multiplying the original embeddings (w0) with the respective context vectors. code to replicate the experiments can be found online.7 the results of the analogy task can be found in the appendix.8
named entity recognition the main advantage of context encoders is that they can use local context to create out-of-vocabulary (oov) embeddings and distinguish between the different senses of words. the effects of this are most prominent in a task such as named entity recognition (ner) where the local context of a word can make all the difference, e.g. to distinguish between the “chicago bears” (an organization) and the city of chicago (a location). to test this, we used the word embeddings as features in the conll 2003 ner benchmark task (tjong , 2003). the word2vec embeddings were trained on the documents used in the training part of the task.9 for the context encoders we experimented with different combinations of local and global context vectors. the global context vectors were computed on only the training documents as well, i.e. just as with https://github.com/cod3licious/conec 8as it was recently demonstrated that a good performance on intrinsic evaluation tasks such as word similarity or analogy tasks does not necessarily transfer to extrinsic evaluation measures when using the word embeddings as features (chiu , 2016; linzen, 2016), we consider the performance on the ner challenge as more relevant. since this is a very small corpus, we trained word2vec for 25 iterations on these documents (afterwards the performance on the development split stopped improving significantly) while usually the model is trained in a single pass through a much larger corpus.
the word2vec model, when applied to the test documents there are some words which don’t have a word embedding available as they did not occur in the training texts. the local context vectors on the other hand can be computed for all words occurring in the current document for which the model should identify the named entities. when combining these local context vectors with the global ones we always use the local context vector as is in case there is no global vector available and otherwise compute a weighted average between the two context vectors as wl · cvlocal + (1− wl) · cvglobal.10 the different word embeddings were used as features with a logistic regression classifier trained on the labels obtained from the training part of the task and the reported f1-scores were computed using the official evaluation script. please note that we are using this task to show the potential of conec word embeddings as features in a real world task and to illustrate their advantages over the regular word2vec embeddings and did not optimize for competitive performance on this ner challenge.
figure 7 shows the results achieved with various word embeddings on the training, development and test part of the conll task. as it can be seen there, taking into account the local context can yield large improvements, especially on the dev and test data. context encoders using only the global context vectors already perform better than word2vec. when using the local context vectors only where the global ones are not available (wl = 0) we can see a jump in the development and test performance, while of course the training performance stays the same as here we have global context vectors for all words. the best performances on all folds are achieved when averaging the global and local context vectors with around wl = 0.4 before multiplying them with the word2vec embeddings. this clearly shows that using conecs with local context vectors can be very beneficial as they let us compute word embeddings for out-of-vocabulary words as well as help distinguish between multiple meanings of words. 0the global context matrix is computed without taking the word itself into account (i.e. zero on the diagonal) to make the context vectors comparable to the local context vectors of oov words where we can’t count the target word either. both global and local context vectors are normalized by their respective maximum values, then multiplied with the length normalized word2vec embeddings and again renormalized to have unit length.representing intrinsically complex data is an ubiquitous challenge in data analysis. while kernel methods and manifold learning have made very successful contributions, their ability to scale is somewhat limited. neural autoencoders offer scalable nonlinear embeddings, but their objective is to minimize the reconstruction error of the input data which does not necessarily preserve important pairwise relations between data points. in this paper we have proposed simecs as a neural network framework which bridges this gap by optimizing the same objective as spectral methods, such as kpca, for creating similarity preserving embeddings while retaining the favorable properties of autoencoders.
similarity encoders are a novel method to learn similarity preserving embeddings and can be especially useful when it is computationally infeasible to perform the eigendecomposition of a kernel matrix, when the target similarities are obtained through an unknown process such as human similarity judgments, or when an explicit mapping function is required. to accomplish this, a feed-forward neural network is constructed to map the data into an embedding space where the original similarities can be approximated linearly.
as a second contribution we have defined context encoders, a practical extension of simecs, that can be readily used to enhance the word2vec model with further local context information and global word statistics. most importantly, conecs allow to easily create word embeddings for out-of-vocabulary words on the spot and distinguish between different meanings of a word based its local context.
finally, we have demonstrated the usefulness of simecs and conecs for practical tasks such as the visualization of data from different domains and to create meaningful word embedding features for a ner task, going beyond the capabilities of traditional methods.
future work will aim to further the theoretical understanding of simecs and conecs and explore other application scenarios where using this novel neural network architecture can be beneficial. as it is often the case with neural network models, determining the optimal architecture as well as other hyperparameter choices best suited for the task at hand can be difficult. while so far we mainly studied simecs based on fairly simple feed-forward networks, it appears promising to consider also deeper neural networks and possibly even more elaborate architectures, such as convolutional networks, for the initial mapping step to the embedding space, as in this manner hierarchical structures in complex data could be reflected. note furthermore that prior knowledge as well as more general error functions could be employed to tailor the embedding to the desired application target(s).we would like to thank antje relitz, christoph hartmann, ivana balažević, and other anonymous reviewers for their helpful comments on earlier versions of this manuscript. additionally, franziska horn acknowledges funding from the elsa-neumann scholarship from the tu berlin.",0
767.pdf.json,"while facing large scale of training data, stochastic learning such as stochastic gradient descent (sgd) is usually much faster than batch learning and often results in better models. an observation for sgd methods is that their performances are highly sensitive to the choice of learning rate lecun  (2012). clearly, setting a static learning rate for the whole training process is insufficient, since intuitively the learning rate should decrease when the model becomes more and more close to a (local) optimum as the training goes on over time maclaurin  (2015). although there are some empirical suggestions to guide how to adjust the learning rate over time in training, it is still a difficult task to find a good policy to adjust the learning rate, given that good policies are problem specific and depend on implementation details of a machine learning algorithm. one usually needs to try many times and adjust the learning rate manually to accumulate knowledge about the problem. however, human involvement often needs domain knowledge about the target problems, which is inefficient and difficult to scale up to different problems. thus, a natural question arises: can we automatically adjust the learning rate? this is exactly the focus of this work and we aim to automatically learn the learning rates for sgd based machine learning (ml) algorithms without human-designed rules or hand-crafted features.
by examining the current practice of learning rate control/adjustment, we have two observations. first, learning rate control is a sequential decision process. at the beginning, we set an initial learning rate. then at each step, we decide whether to change the learning rate and how to change it, based on the current model and loss, training data at hand, and maybe history of the training process. as suggested in orr & müller (2003), one well-principled method for estimating the ideal learning rate that is to decrease the learning rate when the weight vector oscillates, and increase it when the weight vector follows a relatively steady direction. second, although at each step some immediate reward (e.g., the loss decrement) can be obtained by taking actions, we care more about the performance of the final model found by the ml algorithm. consider two different learning rate
control policies: the first one leads to fast loss decrease at the beginning but gets saturated and stuck in a local minimum quickly, while the second one starts with slower loss decrease but results in much smaller final loss. obviously, the second policy is better. that is, we prefer long-term rewards over short-term rewards.
combining the two observations, it is easy to see that the problem of finding a good policy to control/adjust learning rate falls into the scope of reinforcement learning (rl) sutton & barto (1998), if one is familiar with rl. inspired by the recent success of rl for sequential decision problems, in this work, we leverage rl techniques and try to learn the learning rate for sgd based methods.
we propose an algorithm to learn the learning rate within the actor-critic framework sutton (1984); sutton  (1999); barto  (1983); silver  (2014) from rl. in particular, an actor network is trained to take an action that decides the learning rate for current step, and a critic network is trained to give feedbacks to the actor network about long-term performance and help the actor network to adjust itself so as to perform better in the future steps. the main contributions of this paper include:
• we propose an actor-critic algorithm to automatically learn the learning rate for ml algorithms.
• long-term rewards are exploited by the critic network in our algorithm to choose a better learning rate at each step.
• we propose to feed different training examples to the actor network and the critic network, which improve the generalization performance of the learnt ml model.
• a series of experiments validate the effectiveness of our proposed algorithm for learning rate control.our focus is to improve gradient based ml algorithm through automatic learning of learning rate. different approaches have been proposed to improve gradient methods, especially for deep neural networks.
since sgd solely rely on a given example (or a mini-batch of examples) to compare gradient, its model update at each step tends to be unstable and it takes many steps to converge. to solve this problem, momentum sgd jacobs (1988) is proposed to accelerate sgd by using recent gradients. rmsprop tieleman & hinton (2012) utilizes the magnitude of recent gradients to normalize the gradients. it always keeps a moving average over the root mean squared gradients, by which it divides the current gradient. adagrad duchi  (2011) adapts component-wise learning rates, and performs larger updates for infrequent and smaller updates for frequent parameters. adadelta zeiler (2012) extends adagrad by reducing its aggressive, monotonically decreasing learning rate. instead of accumulating all past squared gradients, adadelta restricts the window of accumulated past gradients to some fixed size. adam kingma & ba (2014) computes component-wise learning rates using the estimates of first and second moments of the gradients, which combines the advantages of adagrad and rmsprop.
senior  (2013); sutton (1992); darken & moody (1990) focus on predefining update rules to adjust learning rates during training. a limitation of these methods is that they have additional free parameters which need to be set manually. another recent work daniel  (2016) studies how to automatically select step sizes, but it still requires hand-tuned features. schaul  (2013) proposes a method to choose good learning rate for sgd, which relies on the square norm of the expectation of the gradient, and the expectation of the square norm of the gradient. the method is much more constrained than ours and several assumption should be met.since our proposed algorithm is based on rl techniques, here we give a very brief introduction to rl, which will ease the description of our algorithm in next section.
reinforcement learning sutton (1988) is concerned with how an agent acts in a stochastic environment by sequentially choosing actions over a sequence of time steps, in order to maximize a cumulative reward. in rl, a state st encodes the agents observation about the environment at a time step t, and a policy function π(st) determines how the agent behaves (e.g., which action to take) at state st. an action-value function (or, q function) qπ(st, at) is usually used to denote the cumulative reward of taking action at at state st and then following policy π afterwards.
many rl algorithms have been proposed sutton & barto (1998); watkins & dayan (1992), and many rl algorithms sutton (1984); sutton  (1999); barto  (1983); silver  (2014) can be described under the actor-critic framework. an actor-critic algorithm learns the policy function and the value function simultaneously and interactively. the policy structure is known as the actor, and is used to select actions; the estimated value function is known as the critic, and it criticizes the actions made by the actor.
recently, deep reinforcement learning, which uses deep neural networks to approximate/represent the policy function and/or the value function, have shown promise in various domains, including atari games mnih  (2015), go silver  (2016), machine translation bahdanau  (2016), image recognition xu  (2015), etc.in this section, we present an actor-critic algorithm that can automate the learning rate control for sgd based machine learning algorithms.
many machine learning tasks need to train a model with parameters ω by minimizing a loss function f defined over a set x of training examples:
ω∗ = arg min ω fω(x). (1)
a standard approach for the loss function minimization is gradient descent, which sequentially updates the parameters using gradients step by step:
ωt+1 = ωt − at∇f t, (2) where at is the learning rate at step t, and ∇f t is the local gradient of f at ωt. here one step can be the whole batch of all the training data, a mini batch of tens/hundreds of examples, or a random sample.
it is observed that the performance of sgd based methods is quite sensitive to the choice of at for non-convex loss function f . unfortunately, f is usually non-convex with respect to the parameters
w in many ml algorithms, especially for deep neural networks. we aim to learn a learning rate controller using rl techniques that can automatically control at.
figure 1 illustrates our automatic learning rate controller, which adopts the actor-critic framework in rl. the basic idea is that at each step, given the current model ωt and training sample x, an actor network is used to take an action (the learning rate at, and it will be used to update the model ωt), and a critic network is used to estimate the goodness of the action. the actor network will be updated using the estimated goodness of at, and the critic network will be updated by minimizing temporal difference (td) sutton & barto (1990) error. we describe the details of our algorithm in the following subsections.the actor network, which is called policy network in rl, plays the key role in our algorithm: it determines the learning rate control policy for the primary ml algorithm1 based on the current model, training data, and maybe historical information during the training process.
note that ωt could be of huge dimensions, e.g., one widely used image recognition model vggnet simonyan & zisserman (2014) has more than 140 million parameters. if the actor network takes all of those parameters as the inputs, its computational complexity would dominate the complexity of the primary algorithm, which is unfordable. therefore, we propose to use a function χ(·) to process and yield a compact vector st as the input of the actor network. following the practice in rl, we call χ(·) the state function, which takes ωt and the training data x as inputs:
st = χ(ωt, x). (3)
then the actor network πθ(·) parameterized by θ yields an action at:
πθ(s t) = at, (4)
where the action at ∈ r is a continuous value. when at is determined, we update the model of the primary algorithm by equation 2.
note that the actor network has its own parameters and we need to learn them to output a good action. to learn the actor network, we need to know how to evaluate the goodness of an actor network. the critic network exactly plays this role.recall that our goal is to find a good policy for learning rate control to ensure that a good model can be learnt eventually by the primary ml algorithm. for this purpose, the actor network needs to output a good action at at state st so that finally a low training loss f(·) can be achieved. in rl, the q function qπ(s, a) is often used to denote the long term reward of the state-action pair s, a while following the policy π to take future actions. in our problem, qπ(st, at) indicates the accumulative decrement of training loss starting from step t. we define the immediate reward at step t as the one step loss decrement:
rt = f t − f t+1. (5)
the accumulative value rtπ of policy π at step t is the total discounted reward from step t:
rtπ = σ t k=tγ k−tr(sk, ak),
where γ ∈ (0, 1] is the discount factor. considering that both the states and actions are uncountable in our problem, the critic network uses a parametric function qϕ(s, a) with parameters ϕ to approximate the q value function qπ(s, a). here we have two learning algorithms. we call the one with learning rate to adjust as the primary ml algorithm, and the other one which optimizes the learning rate of the primary one as the secondary ml algorithm.the critic network has its own parameters ϕ, which is updated at each step using td learning. more precisely, the critic is trained by minimizing the square error between the estimation qϕ(st, at) and the target yt:
yt = rt + γqϕ(s t+1, at+1). (6)
the td error is defined as:
δt = yt −qϕ(st, at) = rt + γqϕ(s t+1, πθ(s t+1))−qϕ(st, at)
(7)
the weight update rule follows the on-policy deterministic actor-critic algorithm. the gradients of critic network are:
∇ϕ = δt∇ϕqϕ(st, at), (8)
the policy parameters θ of the actor network is updated by ensuring that it can output the action with the largest q value at state st, i.e., a∗ = arg maxaqϕ(st, a). mathematically,
∇θ = ∇θπθ(st+1)∇aqϕ(st+1, at+1)|a=πθ(s). (9)
algorithm 1 actor-critic algorithm for learning rate learning require: training steps t ; training set x; loss function f ; state function χ; discount factor: γ ; ensure: model parameters w, policy parameters θ of the actor network, and value parameters ϕ of
the critic network; 1: initial parameters ω0, θ0, ϕ0; 2: for t = 0, ..., t do 3: sample xi ∈ x, i ∈ 1, ..., n . 4: extract state vector: sti = χ(ω
t, xi). 5: //actor network selects an action. 6: computes learning rate ati = πθ(s t i). 7: //update model parameters ω. 8: compute∇f t(xi). 9: update ω: ωt+1 = ωt − ati∇f t(xi). 0: //update critic network by minimizing square error between estimation and label. 11: rt = f t(xi)− f t+1(xi) 12: extract state vector: st+1i = χ(ω t+1, xi) 13: compute qϕ(st+1i , πθ(s t+1 i )), qϕ(s t i, a t i) 14: compute δt according to equation 7: δt = rt + γqϕ(s t+1 i , πθ(s t+1 i ))−qϕ(sti, ati) 15: update ϕ using the following gradients according to equation 8 : ∇ϕ = δt∇ϕqϕ(sti, ati) 16: // update actor network 17: sample xj ∈ x, j ∈ 1, ..., n, j 6= i. 18: extract state vector: st+1j = χ(ω
t+1, xj). 19: compute at+1j = πθ(s t+1 j ). 20: update θ from equation 9: ∇θ = ∇θπθ(st+1j )∇aqϕ(s t+1 j , a t+1 j )|a=πθ(s) 21: end for 22: return ω, θ, ϕ;the overall algorithm is shown in algorithm 1. in each step, we sample an example (line 3), extract the current state vector (line 4), compute the learning rate using the actor network (line 6), update the model (lines 8-9), compute td error (lines 11-14), update the critic network (line 15), and sample another example (line 17) to update the actor network (line 18-20). we would like to make some discussions about the algorithm.
first, in the current algorithm, for simplicity, we consider using only one example for model update. it is easy to generalize to a mini batch of random examples.
second, one may notice that we use one example (e.g., xi) for model and the critic network update, but a different example (e.g., xj) for the actor network update. doing so we can avoid that the algorithm will overfit on some (too) hard examples and can improve the generalization performance of the algorithm on the test set. consider a hard example2 in a classification task. since such an example is difficult to be classified correctly, intuitively its gradient will be large and the learning rate given by the actor network at this step will also be large. in other words, this hard example will greatly change the model, while itself is not a good representative of its category and the learning algorithm should not pay much attention to it. if we feed the same example to both the actor network and the critic network, both of them will encourage the model to change a lot to fit the example, consequently resulting in oscillation of the training, as shown in our experiments. by feeding different examples to the actor and critic networks, it is very likely the critic network will find that the gradient direction of the example fed into the actor network is inconsistent with its own training example and thus criticize the large learning rate suggested by the actor network. more precisely, the update of ω is based on xi and the learning rate suggested by the actor network, while the training target of the actor network is to maximize the output of the critic network on xj . if there is big gradient disagreement between xi and xj , the update of ω, which is affected by actor’s decision, would cause the critic’s output on xj to be small. to compensate this effect, the actor network is forced to predict a small learning rate for a too hard xi in this situation.we conducted a set of experiments to test the performance of our learning rate learning algorithm and compared with several baseline methods. we report the experimental results in this section.we tested our method on two widely used image classification datasets: mnist lecun  (1998) and cifar-10 krizhevsky & hinton (2009). convolutional neural networks (cnns) are the standard model for image classification tasks in recent years, and thus the primary ml algorithm adopted the cnn model in all our experiments.
we specified our actor-critic algorithm in experiments as follows. given that stochastic mini-batch training is a common practice in deep learning, the actor-critic algorithm also operated on minibatches, i.e., each step is a mini batch in our experiments. we defined the state st = χ(ωt, xi) as the average loss of learning model ωt on the input min-batch xi. we specified the actor network as a two-layer long short-term memory (lstm) network with 20 units in each layer, considering that a good learning rate for step t depends on and correlates with the learning rates at previous steps while lstm is well suited to model sequences with long-distance dependence. we used the absolute value activation function for the output layer of the lstm to ensure a positive learning rate. the lstm was unrolled for 20 steps during training. we specified the critic network as a simple neural network with one hidden layer and 10 hidden units. we use adam with the default setting in tensorflow optimizer toolbox abadi  (2015) to train the actor and critic networks in all the experiments.
we compared our method with several mainstream sgd algorithms, including sgd, adam kingma & ba (2014), adagrad duchi  (2011) and rmsprop tieleman & hinton (2012). for each of these algorithms and each dataset, we tried the following learning rates 10−4, 10−3, ..., 100. we report the best performance of these algorithms over those learning rates. if an algorithm needs some other parameters to set, such as decay coefficients for adam, we used the default setting in tensorflow optimizer toolbox. for each benchmark and our proposed method, five independent runs are averaged and reported in all of the following experiments.mnist is a dataset for handwritten digit classification task. each example in the dataset is a 28×28 black and white image containing a digit in {0, 1, · · · , 9}. the cnn model used in the primary for example, an example may has an incorrect label because of the limited quality of labelers.
ml algorithm is consist of two convolutional layers, each followed by a pooling layer, and finally a fully connected layer. the first convolutional layer filters each input image using 32 kernels of size 5 × 5. the max-pooling layer following the first convolutional layer is performed over 2 × 2 pixel windows, with stride 2. the second convolutional layer takes the outputs of the first max-pooling layer as inputs and filters them with 64 kernels of size 5 × 5. the max-pooling layer following the second convolutional layer is performed over 2 × 2 pixel windows, with stride 2. the outputs of second max pooling layer are fed to a fully connected layer with 512 neurons. dropout was conducted on the fully connect layer with a dropout rate of 0.5. relu activation functions are used in the cnn model. there are 60,000 training images and 10,000 test images in this dataset. we scaled the pixel values to the [0,1] range before inputting to all the algorithms. each mini batch contains 50 randomly sampled images.
figure 2 shows the results of our actor-critic algorithm for learning rate learning and the baseline methods, including the curves of training loss, test loss, and test accuracy. the final accuracies of these methods are summarized in table 1. we have the following observations.
• in terms of training loss, our algorithm has similar convergence speed to the baseline methods. one may expect that our algorithm should have significantly faster convergence speed considering that our algorithm learns both the learning rate and the cnn model while the baselines only learn the cnn model and choose the learning rates per some predefined rules. however, this is not correct. as discussed in section 3.4, we carefully design the algorithm and feed different samples to the actor network and critic network. doing so we can focus more on generalization performance than training loss: as shown in figure 4, our algorithm achieves the best test accuracy. 0-2 10-1 100 101
epoch .010 .015 .020 .025 .030 .035 .040 .045 .050 .055
le a rn
in g r
a te
cifar-10
figure 5: the learning rate learned by actor network for cifar-10.
• our algorithm achieves the lowest error rate on mnist. although the improvement looks small, we would like to point out that given that the accuracy of cnn is already close to 100%, it is a very difficult task to further improve accuracy, not to mention that we only changed learning rate policy without changing the cnn model.cifar-10 is a dataset consisting of 60000 natural 32 × 32 rgb images in 10 classes: 50,000 imagesfor training and 10,000 for test. we used a cnn with 2 convolutional layers (each followed by max-pooling layer) and 2 fully connected layers for this task. there is a max pooling layer which performed over 2× 2 pixel windows, with stride 2 after each convolutional layer. all convolutional layers filter the input with 64 kernels of size 5× 5. the outputs of the second pooling layer are fed to a fully connected layer with 384 neurons. the last fully connected layer has 192 neurons. before inputting an image to the cnn, we subtracted the per-pixel mean computed over the training set from each image.
figure 3 shows the results of all the algorithms on cifar-10, including the curves of training loss, the test loss and test accuracy. table 2 shows the final test accuracy. we get similar observations as mnist: our algorithm achieves similar convergence speed in terms of training loss and slightly better test accuracy than baselines. figure 5 shows the learning rate learned by our method on cifar-10. to further understand the generalization performance of our algorithm, we ran all the
algorithms on two subsets of training data on cifar-10: one with only 20% training data the curves of training loss and test loss are shown in figure 4. as can be seen from the figure, those baseline methods are easy to overfit and their test loss increases after 5000 steps (mini batches). in contrast, our algorithm is relatively robust and can prevent overfitting to some extent.
as we explained in section 3.4, feeding different examples to the actor and critic networks is important to guarantee generalization ability. here we conducted another experiment to verify our intuitive explanation. figure 6 shows the results of two different implementations of our actor-critic algorithm on cifar-10. in the first implementation, we fed the sample examples to the two networks, i.e., xi = xj in the algorithm, and in the second implementation, the input xj of the critic network is different from the input xi of the actor network. it is easy to see from the figure that setting xi = xj tends to oscillate during training and leads to poor test performance. thus, we need to feed different training data to the actor network and the critic network to ensure the performance of the algorithm.we also compare our method with “vsgd” from previous by work schaul  (2013), which can automatically adjust learning rates to minimize the expected error. this method tries to compute learning rate at each update by optimizing the expected loss after the next update according to the square norm of the expectation of the gradient, and the expectation of the square norm of the gradient. note that our method learns to predict a learning rate at each time step by utilizing the long term reward predicted by a critic network.
for a fair comparison, we followed the experiments settings of schaul  (2013), which designed three different network architectures for mnist task to measure the performance. the first one is denoted by ‘m0’ which is simple softmax regression (i.e. a network with no hidden layer). the second one (‘m1’) is a fully connected multi-layer perceptron, with a single hidden layer. the third one (denoted ‘m2’) is a deep, fully connected multi-layer perceptron with two hidden layers. the vsgd has three variants in their paper. we referred to the results reported in their paper and compared our method with all of three variants of their algorithm (vsgd-l, vsgd-b, vsgd-g). the learning rates of sgd are decreased according to a human designed schedule, and the hyperparameters of sgd, adam, adagrad, rmsprop are carefully determined by their lowest test error among a set of hyper-parameters. all hyper-parameters can be found in schaul  (2013).
the experimental results are reported in table 3. it shows that our proposed method performs better than vsgd and other baseline methods, and is stable across different network architectures.in this work, we have studied how to automatically learn learning rates for gradient based machine learning methods and proposed an actor-critic algorithm, inspired by the recent success of reinforcement learning. the experiments on two image classification datasets have shown that our method (1) has comparable convergence speed with expert-designed optimizer while achieving better test accuracy, and (2) can successfully adjust learning rate for different datasets and cnn model structures.
for the future work, we will explore the following directions. in this work, we have applied our algorithm to control the learning rates of sgd. we will apply to other variants of sgd methods. we have focused on learning a learning rate for all the model parameters. we will study how to learn an individual learning rate for each parameter. we have considered learning learning rates using rl techniques. we will consider learning other hyperparameters such as step-dependent dropout rates for deep neural networks.a method of automatically controlling learning rate is proposed in the main body of the paper. the learning rate controller adjusts itself during training to control the learning rate. here, we propose an improved version that can leverage experiences from several repeated training runs to learn a fixed learning rate controller. empirically, this algorithm can achieve better performance than the previous one. given that it requires more time for training the learning rate controller, this method is more suitable for training offline models.
in this algorithm, during every training run, we fix the actor network and compute the weighted sum of the gradients of its parameter θ. the parameter is updated after each run (modified from equation 9):
∇θ = σtt=1h(t)∇θπθ(st+1)∇aqϕ(st+1, at+1)|a=πθ(s). (10)
h(t) is weighted function which is used to amplify the feedback signal from the initial training stage. it is defined as h(t) = 1/t in our experiments. an error rate of 0.48% was achieved with 5 repeated training runs in mnist experiment (the same setting as table 1), and in cifar-10 experiment (the same setting as table 2), 80.23% accuracy was achieved with 10 training runs. this method showed better performance in both experiments.",0
773.pdf.json,"biclustering is widely-used in statistics (a. kasim & talloen, 2016), and recently it also became popular in the machine learning community (o´ connor & feizi, 2014; lee , 2015; kolar , 2011), e.g., for analyzing large dyadic data given in matrix form, where one dimension are the samples and the other the features. a matrix entry is a feature value for the according sample. a bicluster is a pair of a sample set and a feature set for which the samples are similar to each other on the features and vice versa. biclustering simultaneously clusters rows and columns of a matrix. in particular, it clusters row elements that are similar to each other on a subset of column elements. in contrast to standard clustering, the samples of a bicluster are only similar to each other on a subset of features. furthermore, a sample may belong to different biclusters or to no bicluster at all. thus, biclusters can overlap in both dimensions. for example, in drug design biclusters are compounds which activate the same gene module and thereby indicate a side effect. in this example different chemical compounds are added to a cell line and the gene expression is measured (verbist , 2015). if multiple pathways are active in a sample, it belongs to different biclusters and may
have different side effects. in e-commerce often matrices of costumers times products are available, where an entry indicates whether a customer bought the product or not. biclusters are costumers which buy the same subset of products. in a collaboration with the internet retailer zalando the biclusters revealed outfits which were created by customers which selected certain clothes for a particular outfit.
fabia (factor analysis for bicluster acquisition, (hochreiter , 2010)) evolved into one of the most successful biclustering methods. a detailed comparison has shown fabia’s superiority over existing biclustering methods both on simulated data and real-world gene expression data (hochreiter , 2010). in particular fabia outperformed non-negative matrix factorization with sparseness constraints and state-of-the-art biclustering methods. it has been applied to genomics, where it identified in gene expression data task-relevant biological modules (xiong , 2014). in the large drug design project qstar, fabia was used to extract biclusters from a data matrix that contains bioactivity measurements across compounds (verbist , 2015). due to its successes, fabia has become part of the standard microarray data processing pipeline at the pharmaceutical company janssen pharmaceuticals. fabia has been applied to genetics, where it has been used to identify dna regions that are identical by descent in different individuals. these individuals inherited an ibd region from a common ancestor (hochreiter, 2013; povysil & hochreiter, 2014). fabia is a generative model that enforces sparse codes (hochreiter , 2010) and, thereby, detects biclusters. sparseness of code units and parameters is essential for fabia to find biclusters, since only few samples and few features belong to a bicluster. each fabia bicluster is represented by two membership vectors: one for the samples and one for the features. these membership vectors are both sparse since only few samples and only few features belong to the bicluster.
however, fabia has shortcomings, too. a disadvantage of fabia is that it is only feasible with about 20 code units (the biclusters) because of the high computational complexity which depends cubically on the number of biclusters, i.e. the code units. if less code units were used, only the large and common input structures would be detected, thereby, occluding the small and rare ones. another shortcoming of fabia is that units are insufficiently decorrelated and, therefore, multiple units may encode the same event or part of it. a third shortcoming of fabia is that the membership vectors do not have exact zero entries, that is the membership is continuous and a threshold have to be determined. this threshold is difficult to adjust. a forth shortcoming is that biclusters can have large positive but also large negative members of samples (that is positive or negative code values). in this case it is not clear whether the positive pattern or the negative pattern has been recognized.
rectified factor networks (rfns; (clevert , 2015)) rfns overcome the shortcomings of fabia. the first shortcoming of only few code units is avoided by extending fabia to thousands of code units. rfns introduce rectified units to fabia’s posterior distribution and, thereby, allow for fast computations on gpus. they are the first methods which apply rectification to the posterior distribution of factor analysis and matrix factorization, though rectification it is well established in deep learning by rectified linear units (relus). rfns transfer the methods for rectification from the neural network field to latent variable models. addressing the second shortcoming of fabia, rfns achieve decorrelation by increasing the sparsity of the code units using dropout from field of deep learning. rfns also address the third fabia shortcoming, since the rectified posterior means yield exact zero values. therefore, memberships to biclusters are readily obtained by values that are not zero. since rfns only have non-negative code units, the problem of separating the negative from the positive pattern disappears.we propose to use the recently introduced rectified factor networks (rfns; (clevert , 2015)) for biclustering to overcome the drawbacks of the fabia model. the factor analysis model and the construction of a bicluster matrix are depicted in fig. 1. rfns efficiently construct very sparse, nonlinear, high-dimensional representations of the input. rfn models identify rare and small events in the input, have a low interference between code units, have a small reconstruction error, and explain the data covariance structure.
rfn learning is a generalized alternating minimization algorithm derived from the posterior regularization method which enforces non-negative and normalized posterior means. these posterior means are the code of the input data. the rfn code can be computed very efficiently. for nongaussian priors, the computation of the posterior mean of a new input requires either to numerically solve an integral or to iteratively update variational parameters. in contrast, for gaussian priors the posterior mean is the product between the input and a matrix that is independent of the input. rfns use a rectified gaussian posterior, therefore, they have the speed of gaussian posteriors but lead to sparse codes via rectification. rfns are implemented on gpus.
the rfn model is a factor analysis model
v = wh + ✏ , (1)
which extracts the covariance structure of the data. the prior h ⇠ n (0, i) of the hidden units (factors) h 2 rl and the noise ✏ ⇠ n (0, ) of visible units (observations) v 2 rm are independent. the model parameters are the weight (factor loading) matrix w 2 rm⇥l and the noise covariance matrix 2 rm⇥m. rfn models are selected via the posterior regularization method (ganchev , 2010). for data {v} = {v1, . . . ,vn}, it maximizes the objective f :
f = 1 n
nx
i=1
log p(vi) 1
n
nx
i=1
dkl(q(hi | vi) k p(hi | vi)), (2)
where dkl is the kullback-leibler distance. maximizing f achieves two goals simultaneously: (1) extracting desired structures and information from the data as imposed by the generative model and (2) ensuring sparse codes via q from the set of rectified gaussians.
for gaussian posterior distributions, and mean-centered data {v} = {v1, . . . ,vn}, the posterior p(hi | vi) is gaussian with mean vector (µp)i and covariance matrix ⌃p:
(µp)i = i + w t 1w 1 w t 1 vi , ⌃p = i + w t 1w 1 . (3)
for rectified gaussian posterior distributions, ⌃p remains as in the gaussian case, but minimizing the second dkl of eq. (2) leads to constrained optimization problem (see clevert  (2015))
min
µi 
n
nx
i=1
(µi (µp)i)t ⌃ 1p (µi (µp)i)
s.t. 8i : µi 0 , 8j : 1
n
nx
i=1
µ2ij = 1 , (4)
where “ ” is component-wise. in the e-step of the generalized alternating minimization algorithm (ganchev , 2010), which is used for rfn model selection, we only perform a step of the gradient projection algorithm (bertsekas, 1976; kelley, 1999), in particular a step of the projected newton method for solving eq. (4) (clevert , 2015). therefore, rfn model selection is extremely efficient but still guarantees the correct solution.for a rfn model, each code unit represents a bicluster, where samples, for which the code unit is active, belong to the bicluster. on the other hand features that activates the code unit belong to the bicluster, too. the vector of activations of a unit across all samples is the sample membership vector. the weight vector which activates the unit is the feature membership vector. the un-constraint posterior mean vector is computed by multiplying the input with a matrix according to eq. (3). the constraint posterior of a code unit is obtained by multiplying the input by a vector and subsequently rectifying and normalizing the code unit (clevert , 2015).
to keep feature membership vector sparse, we introduce a laplace prior on the parameters. therefore only few features contribute to activating a code unit, that is, only few features belong to a bicluster. sparse weights wi are achieved by a component-wise independent laplace prior for the weights:
p(wi) = ⇣ p 2
⌘n ny
k=1
e p 2 |wki| (5)
the weight update for rfn (laplace prior on the weights) is
w = w + ⌘ u s 1 w
↵ sign(w ) . (6)
whereby the sparseness of the weight matrix can be controlled by the hyper-parameter ↵ and u and s are defined as u = 1n pn i=1 viµ t i and s = 1 n pn i=1 µiµ t i +⌃, respectively. in order to enforce more sparseness of the sample membership vectors, we introduce dropout of code units. dropout means that during training some code units are set to zero at the same time as they get rectified. dropout avoids co-adaptation of code units and reduces correlation of code units — a problem of fabia which is solved.
rfn biclustering does not require a threshold for determining sample memberships to a bicluster since rectification sets code units to zero. further crosstalk between biclusters via mixing up negative and positive memberships is avoided, therefore spurious biclusters do less often appear.in this section, we will present numerical results on multiple synthetic and real data sets to verify the performance of our rfn biclustering algorithm, and compare it with various other biclustering methods.to assess the performance of rectified factor networks (rfns) as unsupervised biclustering methods, we compare the following 14 biclustering methods:
(1) rfn: rectified factor networks (clevert , 2015), (2) fabia: factor analysis with laplace prior on the hidden units (hochreiter , 2010; hochreiter, 2013), (3) fabias: factor analysis with sparseness projection (hochreiter , 2010), (4) mfsc: matrix factorization with sparseness constraints (hoyer, 2004), (5) plaid: plaid model (lazzeroni & owen, 2002; t. chekouo & raffelsberger, 2015), (6) isa: iterative signature algorithm (ihmels , 2004), (7) opsm: orderpreserving sub-matrices (ben-dor , 2003), (8) samba: statistical-algorithmic method for bicluster analysis (tanay , 2002), (9) xmotif: conserved motifs (murali & kasif, 2003), (10) bimax: divide-and-conquer algorithm (prelic , 2006), (11) cc: cheng-church -biclusters
(cheng & church, 2000), (12) plaid t: improved plaid model (turner , 2003), (13) floc: flexible overlapped biclustering, a generalization of cc (yang , 2005), and (14) spec: spectral biclustering (kluger , 2003).
for a fair comparison, the parameters of the methods were optimized on auxiliary toy data sets. if more than one setting was close to the optimum, all near optimal parameter settings were tested. in the following, these variants are denoted as method variant (e.g. plaid ss). for rfn we used the following parameter setting: 13 hidden units, a dropout rate of 0.1, 500 iterations with a learning rate of 0.1, and set the parameter ↵ (controlling the sparseness on the weights) to 0.01.in the following subsections, we describe the data generation process and results for synthetically generated data according to either a multiplicative or additive model structure.we assumed n = 1000 genes and l = 100 samples and implanted p = 10 multiplicative biclusters. the bicluster datasets with p biclusters are generated by following model:
x = px
i=1
i z t i + ⌥ , (7)
where ⌥ 2 rn⇥l is additive noise; i 2 rn and zi 2 rl are the bicluster membership vectors for the i-th bicluster. the i’s are generated by (i) randomly choosing the number n i of genes in bicluster i from {10, . . . , 210}, (ii) choosing n i genes randomly from {1, . . . , 1000}, (iii) setting i components not in bicluster i to n (0, 0.22) random values, and (iv) setting i components that are in bicluster i to n (±3, 1) random values, where the sign is chosen randomly for each gene. the zi’s are generated by (i) randomly choosing the number nzi of samples in bicluster i from {5, . . . , 25}, (ii) choosing nzi samples randomly from {1, . . . , 100}, (iii) setting zi components not in bicluster i to n (0, 0.22) random values, and (iv) setting zi components that are in bicluster i to n (2, 1) random values. finally, we draw the ⌥ entries (additive noise on all entries) according to n (0, 32) and compute the data x according to eq. (7). using these settings, noisy biclusters of random sizes between 10⇥5 and 210⇥25 (genes⇥samples) are generated. in all experiments, rows (genes) were standardized to mean 0 and variance 1.in this experiment we generated biclustering data where biclusters stem from an additive two-way anova model:
x = px
i=1
✓i ( i zti ) + ⌥ , ✓ikj = µi + ↵ik + ij , (8)
where is the element-wise product of matrices and both i and zi are binary indicator vectors which indicate the rows and columns belonging to bicluster i. the i-th bicluster is described by an anova model with mean µi, k-th row effect ↵ik (first factor of the anova model), and jth column effect ij (second factor of the anova model). the anova model does not have interaction effects. while the anova model is described for the whole data matrix, only the effects on rows and columns belonging to the bicluster are used in data generation. noise and bicluster sizes are generated as in previous subsection 3.2.1.
data was generated for three different signal-to-noise ratios which are determined by distribution from which µi is chosen: a1 (low signal) n (0, 22), a2 (moderate signal) n (±2, 0.52), and a3 (high signal) n (±4, 0.52), where the sign of the mean is randomly chosen. the row effects ↵ki are chosen from n (0.5, 0.22) and the column effects ij are chosen from n (1, 0.52).for method evaluation, we use the previously introduced biclustering consensus score for two sets of biclusters (hochreiter , 2010), which is computed as follows:
step (3) penalizes different numbers of biclusters in the sets. the highest consensus score is 1 and only obtained for identical sets of biclusters.
table 1 shows the biclustering results for these data sets. rfn significantly outperformed all other methods (t-test and mcnemar test of correct elements in biclusters).in this experiment, we test the biclustering methods on gene expression data sets, where the biclusters are gene modules. the genes that are in a particular gene module belong to the according bicluster and samples for which the gene module is activated belong to the bicluster. we consider three gene expression data sets which have been provided by the broad institute and were previously clustered by hoshida  (2007) using additional data sets. our goal was to study how well biclustering methods are able to recover these clusters without any additional information. (a) the “breast cancer” data set (van’t veer , 2002) was aimed at a predictive gene signature for the outcome of a breast cancer therapy. we removed the outlier array s54 which leads to a data set with 97 samples and 1213 genes. in hoshida  (2007), three biologically meaningful subclasses were found that should be re-identified. (b) the “multiple tissue types” data set (su , 2002) are gene expression profiles from human cancer samples from diverse tissues and cell lines. the data set contains 102 samples with 5565 genes. biclustering should be able to re-identify the tissue types. (c) the “diffuse large-b-cell lymphoma (dlbcl)” data set (rosenwald , 2002) was aimed at predicting the survival after chemotherapy. it contains 180 samples and 661 genes. the three classes found by hoshida  (2007) should be re-identified.
for methods assuming a fixed number of biclusters, we chose five biclusters — slightly higher than the number of known clusters to avoid biases towards prior knowledge about the number of actual clusters. besides the number of hidden units (biclusters) we used the same parameters as described in sec. 3.1. the performance was assessed by comparing known classes of samples in the data sets with the sample sets identified by biclustering using the consensus score defined in subsection 3.2.3 — here the score is evaluated for sample clusters instead of biclusters. the biclustering results are summarized in table 2. rfn biclustering yielded in two out of three datasets significantly better results than all other methods and was on second place for the third dataset (significantly according to a mcnemar test of correct samples in clusters).in this experiment, we used rfn for detecting dna segments that are identical by descent (ibd). a dna segment is ibd in two or more individuals, if they have inherited it from a common ancestor, that is, the segment has the same ancestral origin in these individuals. biclustering is well-suited to detect such ibd segments in a genotype matrix (hochreiter, 2013; povysil & hochreiter, 2014), which has individuals as row elements and genomic structural variations (snvs) as column elements. entries in the genotype matrix usually count how often the minor allele of a particular snv is present in a particular individual. individuals that share an ibd segment are similar to each other because they also share minor alleles of snvs (tagsnvs) within the ibd segment. individuals that share an ibd segment represent a bicluster.
for our ibd-analysis we used the next generation sequencing data from the 1000 genomes phase 3. this data set consists of low-coverage whole genome sequences from 2,504 individuals of the main continental population groups (africans (afr), asians (asn), europeans (eur), and admixed americans (amr)). individuals that showed cryptic first degree relatedness to others were removed, so that the final data set consisted of 2,493 individuals. furthermore, we also included archaic human and human ancestor genomes, in order to gain insights into the genetic relationships between humans, neandertals and denisovans. the common ancestor genome was reconstructed from human, chimpanzee, gorilla, orang-utan, macaque, and marmoset genomes. rfn ibd detection is based on low frequency and rare variants, therefore we removed common and private variants prior to the analysis. afterwards, all chromosomes were divided into intervals of 10,000 variants with adjacent intervals overlapping by 5,000 variants
in the data of the 1000 genomes project, we found ibd-based indications of interbreeding between ancestors of humans and other ancient hominins within africa (see fig. 2 as an example of an ibd segment that matches the neandertal genome).we have introduced rectified factor networks (rfns) for biclustering and benchmarked it with 13 other biclustering methods on artificial and real-world data sets.
on 400 benchmark data sets with artificially implanted biclusters, rfn significantly outperformed all other biclustering competitors including fabia. on three gene expression data sets with previously verified ground-truth, rfn biclustering yielded twice significantly better results than all other methods and was once the second best performing method. on data of the 1000 genomes project, rfn could identify ibd segments which support the hypothesis that interbreeding between ancestors of humans and other ancient hominins already have taken place in africa.
rfn biclustering is geared to large data sets, sparse coding, many coding units, and distinct membership assignment. thereby rfn biclustering overcomes the shortcomings of fabia and has the potential to become the new state of the art biclustering algorithm.
acknowledgment. we thank the nvidia corporation for supporting this research with several titan x gpus.",0
778.pdf.json,"there have been extensive studies on accelerating and compressing deep neural networks, e.g., on an fft-based method (mathieu , 2014), re-parameterization of a weight matrix (yang , 2015), pruning network connection (han , 2015; 2016), and hardware-specific optimization (vanhoucke , 2011). in the following paragraphs, we only review previous studies that are intimately connected to ours.
it was pointed out by denil  (2013) that network weights have a significant redundancy. motivated by this fact, researchers have been involved in a series of studies on matrix/tensor factorization (jaderberg , 2014; zhang , 2015). in these studies, a weight matrix (or tensor) was factorized by minimizing an approximation error of original weights or activations. jaderberg  (2014) exploited 1-d separable filter decomposition to accelerate feed-forward propagation. zhang  (2015) proposed low-rank approximation based on generalized svd to compress an entire deep network. taking into account the lessons learned from these best practices, we also exploit the redundancy of the weights.
there is an another series of studies, integer decomposition (hare , 2012; yuji , 2014; ambai & sato, 2014), which involved accelerating test-time speed of a classifier by using fast logical operations. although their contributions are limited to a shallow architecture such as a linear svm, they achieved a noticeable acceleration. in these approaches, a real-valued weight vector is approximated by a weighted sum of a few binary or ternary basis vectors. to use fast logical operations, they extracted binary features from an image. hare  (2012) and yuji  (2014) exploited binary basis vectors, and ambai & sato (2014) investigated a case of ternary basis to improve approximation quality.
in a manner of speaking, our method is a unified framework of matrix/tensor factorization and integer decomposition reviewed in the above and inherits both their advantages. while the weight matrix is factorized to exploit low-rank characteristics, the basis matrix is restricted to take only three integer values, {−1, 0,+1}. in contrast to recent binary weighted networks such as xnor-net (rastegari , 2016) which quantizes both activations and weights during backpropagation, it is not necessary for our method to change training algorithms at all. we can benefit from recent sophisticated training techniques, e.g. batch normalization (ioffe & szegedy, 2015), in combination with our method. furthermore, our method does not need (iterative) end-to-end retraining which is needed for several previous studies such as network pruning (han , 2015; 2016) and distillation (hinton , 2014).in this section, we introduce our compression model and discuss time and space complexity. we consider a convolutional layer with a filter size of wx × wy × c, where wx and wy are the spacial size and c is a number of input channels. if wx = wy = 1, we can regard this layer as a fully connected layer. this three dimensional volume is reshaped to form a di dimensional vector where di = wx×wy×c. the filter weights and biases can be formulated by w ∈ rdi×do and b ∈ rdo , where do is a number of output channels. let x ∈ rdi denote an activation vector obtained by
vectorizing the corresponding three dimensional volume. in test-time, we need to compute w>x+b followed by a non-linear activation function.
in our compressed network, w is decomposed into two matrices before test-time as follows:
w ≈mwcw, (1)
where mw ∈ {−1, 0,+1}di×kw is a ternary basis matrix, cw ∈ rkw×do is a co-efficient matrix, and kw is the number of basis vectors, respectively. since mw only takes the three values, it consumes only 2 bits per element. setting a sufficiently small value to kw further reduces total memory consumption. from the viewpoint of approximation quality, it should be noted that a large number of elements in w takes close to zero values. to fit them well enough, a zero value must be included in the basis. the ternary basis satisfies this characteristic. in practice, the ternary basis gives better approximation than the binary basis, as we discuss in section 3.
the activation vector x is also factored to the following form:
x ≈mxcx + bx1, (2)
where mx ∈ {−1,+1}di×kx is a binary basis matrix, cx ∈ rkx is a real-valued co-efficient vector, bx ∈ r is a bias, and kx is the number of basis vectors, respectively. since elements of x are often biased, e.g., activations from relu take non-negative values and have a non-zero mean, bx is added to this decomposition model. while cx and bx reflect a range of activation values, mx determines approximated activation values within the defined range. this factorization must be computed at test-time because the intermediate activations depend on an input to the first layer. however, in practice, factorizing x into mx, cx, and bx requires an iterative optimization, which is very slow. since a scale of activation values within a layer is almost similar regardless of x, we pre-computed canonical cx and bx in advance and only optimized mx at test-time. as we discuss in section 4, an optimal mx under fixed cx and bx can be selected using a lookup table resulting in fast factorization.
substituting eqs.(1) and (2) into w>x+ b, approximated response values are obtained as follows:
w>x+ b ≈ (mwcw)>(mxcx + bx1) + b = c>wm > wmxcx + bxc > wm > w1+ b. (3)
a new bias bxc>wm > w1+ b in eq.(3) is pre-computable in advance, because cw,mw, and bx are fixed at test-time. it should be noted that m>wmx is a multiplication of the ternary and binary matrix, which is efficiently computable using three logical operations: xor, and, and bit count, as previously investigated (ambai & sato, 2014). after computing m>wmx, the two co-efficient components, cx and cw, are multiplied from the right and left in this order. since cx and cw are much smaller than w, the total number of floating point computations is drastically reduced.
the time and space complexity are summarized in tables 1 and 2. as can be seen from table 1, most of the floating operations are replaced with logical operations. in this table, b means the bit width of a variable used in the logical operations, e.g., b = 64 if a type of unsigned long long is used in c/c++ language. table 2 suggests that if kw is sufficiently smaller than di and do, the total size of mw and cw is reduced compared to the original parameterization.
algorithm 1 decompose w into mw and cw require: w, kw ensure: factorized components mw and cw. : r←w 2: for i← 1 to kw do 3: initialize m(i)w by three random values {−1, 0,+1}. 4: minimize ||r−m(i)w c(i)w ||2f by repeating the following two steps until convergence. 5: [step 1] c(i)w ←m(i)>w r/m(i)>w m(i)w 6: [step 2] mij ← arg min
α∈{−1,0,+1} ||rj − αc(i)w ||22, for j = 1, · · · , di : r← r−m(i)w c(i)w 8: end forto factorize w, we need to solve the following optimization problem.
jw = min mw,cw
||w −mwcw||2f . (4)
however, the ternary constraint makes this optimization very difficult. therefore, we take an iterative approach that repeats rank-one approximation one by one, as shown in algorithm 1. let m (i) w ∈ {−1, 0,+1}di×1 denote an i-th column vector of mw and c(i)w ∈ r1×do denote an i-th row vector of cw. instead of directly minimizing eq. (4), we iteratively solve the following rank-one approximation,
j (i)w = min m(i)w ,c(i)w ||r−m(i)w c(i)w ||2f , (5)
where r is a residual matrix initialized by w. we applied alternating optimization to obtain m(i)w and c(i)w . if m (i) w is fixed, c (i) w can be updated using a least squares method, as shown in line 5 of algorithm 1. if c(i)w is fixed, mij , the j-th element of m (i) w , can be independently updated by exhaustively verifying three choices {−1, 0,+1} for each j = 1, · · · , di , as shown in line 6 of algorithm 1, where rj is a j-th row vector of r. after the alternating optimization is converged, r is updated by subtracting m(i)w c (i) w and passed to the next (i+ 1)-th iteration. comparison of binary constraints with ternary constraints can be seen in appendix a.binary decomposition for a given activation vector x can be performed by minimizing
jx(mx, cx, bx;x) = ||x− (mxcx + bx1)||22. (6)
in contrast to the case of decomposing w, a number of basis vectors kx can be set to a very small value (from 2 to 4 in practice) because x is not a matrix but a vector. this characteristic enables an exhaustive search for updating mx. algorithm 2 is an alternating optimization with respect to mx, cx, and bx. by fixing mx, we can apply a least squares method to update cx and bx (in lines 3-4 of algorithm 2). if cx and bx are fixed, m (j) x , the j-th row vector of mx, is independent of any other m (j′) x , j′ 6= j. we separately solve di sub-problems formulated as follows:
m(j)x = arg min β∈{−1,+1}1×kx (xj − (βcx + bx))2, j = 1, · · · , di , (7)
where xj is a j-th element of x. since kx is sufficiently small, 2kx possible solutions can be exhaustively verified (in line 5 of algorithm 2).
our method makes this decomposition faster by pre-computing canonical cx and bx from training data and only optimizing mx at test-time using lookup table. this compromise is reasonable because of the following two reasons: (1) scale of activation values is similar regardless of vector elements
algorithm 2 decompose x into mx, cx, and bx require: x, kx ensure: factorized components mx, cx, and bx. : initialize mx by three random values {−1,+1}. 2: minimize ||x− (mxcx + bx1)||22 by repeating the following two steps until convergence. 3: [step 1] update cx and bx using a least squares method. 4: cx ← (m>xmx)−1m > x (x− bx1), bx ← 1>(x−mxcx)/di 5: [step 2] update m(j)x for each j = 1, · · ·di by an exhaustive search that minimizes eq.(7).
within a layer, and (2) cx and bx reflect a scale of approximated activation values. knowing these properties, cx and bx are obtained by minimizing jx(m̂x, cx, bx; x̂) ,where x̂ is constructed as follows. first, nt different activation vectors t ∈ {xi}nti=1 are collected from randomly chosen nt training data. second, n elements are randomly sampled from xi. the sampled nnt elements are concatenated to form a vector x̂ ∈ rnnt . we use cx and bx as constants at test-time, and discard m̂x.
at test-time, we only need to solve the optimization of eq. (7) for each xj . this can be regarded as the nearest neighbour search in one-dimensional space. we call βcx + bx a prototype. there are 2kx possible prototypes because β takes 2kx possible combinations. the nearest prototype to xj and an optimal solution m(j)x can be efficiently found using a lookup table as follows.
preparing lookup table: we define l bins that evenly divide one-dimensional space in a range from the smallest to largest prototype. let x̂l denote a representative value of the l-th bin. this is located at the center of the bin. for each x̂l, we solve eq. (7) and assign the solution to the bin.
activation encoding: at test-time, xj is quantized into l-levels. in other words, xj is transformed to an index of the lookup table. let pmax and pmin denote the largest and smallest prototype, respectively. we transform xj as follows:
q = (l− 1)(xj − pmin)/(pmax − pmin) + 1, (8) l̂ = min(max(bq + 1/2c, 1), l). (9)
the range from pmin to pmax is linearly mapped to the range from 1 to l by eq. (8). the term q is rounded and truncated from 1 to l by the max and min function in eq. (9). if l is sufficiently large, the solution assigned to the l̂-th bin can be regarded as a nearly optimal solution because the difference between xj and the center of the bin x̂l̂ becomes very small. we found that l = 4096 is sufficient. the time complexity of this encoding is o(di).we tested our method on three different convolutional neural networks: cnn for handwritten digits (lecun , 1998), vgg-16 for imagenet classification (simonyan & zisserman, 2015), and vggface for large-scale face recognition (parkhi , 2015). to compute memory compression rate, a size of w and a total size of mw and cw were compared. to obtain a fair evaluation of computation time, a test-time code of forward propagation was implemented without using any parallelization scheme, e.g., multi-threading or simd, and was used for both compressed and uncompressed networks. the computation time includes both binary activation encoding and calculation of eq. (3). we used an intel core i7-5500u 2.40-ghz processor.mnist is a database of handwritten digits which consists of 60000 training and 10000 test sets of 28× 28 gray-scale images with ground-truth labels from 0 to 9. we trained our cnn by using an example code in matconvnet 1.0-beta18 (vedaldi & lenc, 2015). our architecture is similar to lenet-5 (lecun , 1998) but has a different number of input and output channels. each layer’s configuration is shown below:
(conv5-20)(maxpool)(conv5-64)(maxpool)(fc1024-640)(relu)(fc640-10)(softmax), (10)
where the parameters of a convolutional layer are denoted as (conv<receptive field size>-<number of output channels>), and parameters of a fully connected layer are denoted as (fc<number of input channels>-<number of output channels>). the (maxpool) is 2×2 subsampling without overlapping. the error rate of this network is 0.86%.
we applied our method to the first fully connected layer (fc1024-640) and set n = 10 andnt = 1000 to learn cx and bx from randomly chosen nnt activations. the cases of kx = 1, 2, 3, 4 and kw = do, do/2, do/5 were tested. this means that kw was set to 640, 320, and 128.
figures 2(a) and (b) show the relationships among the increases in error rates, memory compression rates, and acceleration rates. it was observed that error rates basically improved along with increasing kx and saturated at kx = 4. it is interesting that kx = 2, only 2 bits per element for encoding an activation x, still achieved good performance. while the smaller kw achieved better compression and acceleration rate, error rates rapidly increased when kw = do/5. one of the well balanced parameters was (kx, kw) = (4, do/2) which resulted in 1.95× faster processing and a 34.4% memory compression rate in exchange of a 0.19% increase in the error rate.a dataset of ilsvrc2012 (russakovsky , 2015) consists of 1.2 million training, 50,000 validation, and 100,000 test sets. each image represents one of 1000 object categories. in this experiment, we used a network model of vgg-16 (model d in (simonyan & zisserman, 2015)) that consists of 13 convolutional layers and 3 fully connected layers followed by a softmax layer. the architecture is shown below:
(input) · · · (fc25088-4096)(relu)(fc4096-4096)(relu)(fc4096-1000)(softmax), (11) where layers before the first fully connected layer are omitted.
first, all three fully connected layers were compressed with our algorithm. we set n = 10 and nt = 1000 to learn cx and bx from randomly chosen nnt activations. the cases of kx = 2, 3, 4 and kw = do/2, do/4, do/8, do/16 were tested. the case of kx = 1 was omitted because this setting resulted in a very high error rate. note that each of the fully connected layers has different do. the kw was independently set for each layer according to its do. the top-5 error rates were evaluated on the validation dataset. the top-5 error rate of the original network is 13.4%.
the three lines with circles in figure 3 show these results. it should be noted that much higher acceleration rates and smaller compression rates with small loss of accuracies were achieved than the case of the network for mnist. interestingly, the case of kw = do/4 still performed well due to the low-rank characteristics of weights in the vgg-16 network.
although the error rates rapidly increased when kw took much smaller values, we found that this could be improved by tuning kw of the third layer. more specifically, we additionally tested the
following cases. while kw was set to do/2, do/4, do/8, and do/16 for the first and second layers, kw was fixed to do for the third layer. the kx was set to 4. this is plotted with a red line in figure 3. in this way, the memory compression rate and acceleration rate noticeably improved. setting appropriate parameters for each layer is important to improve the total performance. table 3 shows the details of the best balanced case in which 15× faster processing and 5.2% compression rate were achieved in exchange of a 1.43% increase in error rate.
next, we also tested to compress convolutional layers. in this experiment, kw and kx were set to do and 4. this setting accelerates each of the layers averagely 2.5 times faster. table 4 shows positions of compressed layers, top-5 errors, and acceleration rates of the entire network. although kw and kx must be larger than those of fully connected layers to avoid error propagation, it is still beneficial for entire acceleration. in summary, while compressing fully connected layers is beneficial for reducing memory, compressing convolutional layers is beneficial for reducing entire computation time.the vgg-face (parkhi , 2015) is a model for extracting a face descriptor. it consists of a similar structure to vgg-16. the difference is that vgg-face has only two fully connected layers, as shown below. (input) · · · (fc25088-4096)(relu)(fc4096-4096). (12) this network outputs a 4096-dimensional descriptor. we can verify whether two face images are identical, by evaluating the euclidean distance of two l2-normalized descriptors extracted from
them. in our experiment, we did not apply a descriptor embedding technique based on triplet loss minimization (parkhi , 2015). following the evaluation protocol introduced in a previous paper (parkhi , 2015), we used labeled faces in the wild dataset (lfw) (huang , 2007), which includes 13,233 face images with 5,749 identities. the lfw defines 1200 positive and 1200 negative pairs for testing. we used the 2400 test pairs to compute roc curve and equal error rate (eer). the eer is defined as an error rate at the roc operating point where the false positive and false negative rates are equal. the eer of the original network is 3.8%.
first, the two fully connected layers were compressed using our algorithm. we set n = 10 and nt = 1000 to learn cx and bx from randomly chosen nnt activations. we tested the cases of kx = 1, 2, 3, 4, and kw = do/2, do/4, do/8, do/16. figure 4 reveals an interesting fact that even the fastest and smallest network configuration, kx = 1 and kw = do/16, had less impact on the eer, in contrast to the previous imagenet classification task in which the recognition results were corrupted when kx = 1. this indicates that the 4096-dimensional feature space is well preserved regardless of such coarse discretization of both weights and activations.
next, we also tested to compress convolutional layers. in this experiment, kw and kx were set to do and 4 which are the the same setting used in table 4. table 5 shows positions of compressed layers and eers. the acceleration rates were almost the same as the results shown in table 4. this is because architecture of vgg-face is the same as vgg-16 and we used the same parameter for kw and kx. interestingly, compressing multiple layers from 2nd to 10th still preserves the original eer. as can be seen from this table, our method works very well depending on a certain kind of machine learning task.we proposed a network compression model that consists of two components: ternary matrix decomposition and binary activation encoding. our experiments revealed that the proposed compression model is available not only for multi-class recognition but also for feature embedding. since our approach is post-processing for a pre-trained model, it is promising that recent networks designed for semantic segmentation, describing images, stereo matching, depth estimation, and much more can also be compressed with our method. for future work, we plan to improve approximation error further by investigating the discrete optimization algorithm.figure 5 illustrates the reconstruction errors of a 4096×1000 weight matrix of the last fully connected layer in vgg-16 model (simonyan & zisserman, 2015). we tested both the binary and ternary constraints on mw for comparison. the reconstruction error jw monotonically decreased along with an increase in kw. it was clear that the ternary basis provided better reconstruction than the binary basis.",0
